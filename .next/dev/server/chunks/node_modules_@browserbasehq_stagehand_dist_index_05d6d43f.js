module.exports = [
"[project]/node_modules/@browserbasehq/stagehand/dist/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude)=>{
    var target = {};
    for(var prop in source)if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)){
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];
    }
    return target;
};
var __esm = (fn, res)=>function __init() {
        return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
    };
var __commonJS = (cb, mod)=>function __require() {
        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {
            exports: {}
        }).exports, mod), mod.exports;
    };
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var __async = (__this, __arguments, generator)=>{
    return new Promise((resolve2, reject)=>{
        var fulfilled = (value)=>{
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        };
        var rejected = (value)=>{
            try {
                step(generator.throw(value));
            } catch (e) {
                reject(e);
            }
        };
        var step = (x)=>x.done ? resolve2(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
        step((generator = generator.apply(__this, __arguments)).next());
    });
};
// lib/version.ts
var STAGEHAND_VERSION;
var init_version = __esm({
    "lib/version.ts" () {
        STAGEHAND_VERSION = "3.0.3";
    }
});
// lib/v3/types/public/sdkErrors.ts
var StagehandError, StagehandDefaultError, StagehandEnvironmentError, MissingEnvironmentVariableError, UnsupportedModelError, UnsupportedModelProviderError, UnsupportedAISDKModelProviderError, InvalidAISDKModelFormatError, StagehandNotInitializedError, BrowserbaseSessionNotFoundError, CaptchaTimeoutError, MissingLLMConfigurationError, HandlerNotInitializedError, StagehandInvalidArgumentError, StagehandElementNotFoundError, AgentScreenshotProviderError, StagehandMissingArgumentError, CreateChatCompletionResponseError, StagehandEvalError, StagehandDomProcessError, StagehandClickError, LLMResponseError, StagehandIframeError, ContentFrameNotFoundError, XPathResolutionError, ExperimentalApiConflictError, ExperimentalNotConfiguredError, CuaModelRequiredError, ZodSchemaValidationError, StagehandInitError, MCPConnectionError, StagehandShadowRootMissingError, StagehandShadowSegmentEmptyError, StagehandShadowSegmentNotFoundError, ElementNotVisibleError, ResponseBodyError, ResponseParseError, TimeoutError, PageNotFoundError, ConnectionTimeoutError;
var init_sdkErrors = __esm({
    "lib/v3/types/public/sdkErrors.ts" () {
        init_version();
        StagehandError = class extends Error {
            constructor(message){
                super(message);
                this.name = this.constructor.name;
            }
        };
        StagehandDefaultError = class extends StagehandError {
            constructor(error){
                if (error instanceof Error || error instanceof StagehandError) {
                    super(`
Hey! We're sorry you ran into an error. 
Stagehand version: ${STAGEHAND_VERSION} 
If you need help, please open a Github issue or reach out to us on Slack: https://stagehand.dev/slack

Full error:
${error.message}`);
                }
            }
        };
        StagehandEnvironmentError = class extends StagehandError {
            constructor(currentEnvironment, requiredEnvironment, feature){
                super(`You seem to be setting the current environment to ${currentEnvironment}.Ensure the environment is set to ${requiredEnvironment} if you want to use ${feature}.`);
            }
        };
        MissingEnvironmentVariableError = class extends StagehandError {
            constructor(missingEnvironmentVariable, feature){
                super(`${missingEnvironmentVariable} is required to use ${feature}.Please set ${missingEnvironmentVariable} in your environment.`);
            }
        };
        UnsupportedModelError = class extends StagehandError {
            constructor(supportedModels, feature){
                super(feature ? `${feature} requires one of the following models: ${supportedModels}` : `please use one of the supported models: ${supportedModels}`);
            }
        };
        UnsupportedModelProviderError = class extends StagehandError {
            constructor(supportedProviders, feature){
                super(feature ? `${feature} requires one of the following model providers: ${supportedProviders}` : `please use one of the supported model providers: ${supportedProviders}`);
            }
        };
        UnsupportedAISDKModelProviderError = class extends StagehandError {
            constructor(provider, supportedProviders){
                super(`${provider} is not currently supported for aiSDK. please use one of the supported model providers: ${supportedProviders}`);
            }
        };
        InvalidAISDKModelFormatError = class extends StagehandError {
            constructor(modelName){
                super(`${modelName} does not follow correct format for specifying aiSDK models. Please define your model as 'provider/model-name'. For example: \`model: 'openai/gpt-4o-mini'\``);
            }
        };
        StagehandNotInitializedError = class extends StagehandError {
            constructor(prop){
                super(`You seem to be calling \`${prop}\` on a page in an uninitialized \`Stagehand\` object. Ensure you are running \`await stagehand.init()\` on the Stagehand object before referencing the \`page\` object.`);
            }
        };
        BrowserbaseSessionNotFoundError = class extends StagehandError {
            constructor(){
                super("No Browserbase session ID found");
            }
        };
        CaptchaTimeoutError = class extends StagehandError {
            constructor(){
                super("Captcha timeout");
            }
        };
        MissingLLMConfigurationError = class extends StagehandError {
            constructor(){
                super("No LLM API key or LLM Client configured. An LLM API key or a custom LLM Client is required to use act, extract, or observe.");
            }
        };
        HandlerNotInitializedError = class extends StagehandError {
            constructor(handlerType){
                super(`${handlerType} handler not initialized`);
            }
        };
        StagehandInvalidArgumentError = class extends StagehandError {
            constructor(message){
                super(`InvalidArgumentError: ${message}`);
            }
        };
        StagehandElementNotFoundError = class extends StagehandError {
            constructor(xpaths){
                super(`Could not find an element for the given xPath(s): ${xpaths}`);
            }
        };
        AgentScreenshotProviderError = class extends StagehandError {
            constructor(message){
                super(`ScreenshotProviderError: ${message}`);
            }
        };
        StagehandMissingArgumentError = class extends StagehandError {
            constructor(message){
                super(`MissingArgumentError: ${message}`);
            }
        };
        CreateChatCompletionResponseError = class extends StagehandError {
            constructor(message){
                super(`CreateChatCompletionResponseError: ${message}`);
            }
        };
        StagehandEvalError = class extends StagehandError {
            constructor(message){
                super(`StagehandEvalError: ${message}`);
            }
        };
        StagehandDomProcessError = class extends StagehandError {
            constructor(message){
                super(`Error Processing Dom: ${message}`);
            }
        };
        StagehandClickError = class extends StagehandError {
            constructor(message, selector){
                super(`Error Clicking Element with selector: ${selector} Reason: ${message}`);
            }
        };
        LLMResponseError = class extends StagehandError {
            constructor(primitive, message){
                super(`${primitive} LLM response error: ${message}`);
            }
        };
        StagehandIframeError = class extends StagehandError {
            constructor(frameUrl, message){
                super(`Unable to resolve frameId for iframe with URL: ${frameUrl} Full error: ${message}`);
            }
        };
        ContentFrameNotFoundError = class extends StagehandError {
            constructor(selector){
                super(`Unable to obtain a content frame for selector: ${selector}`);
            }
        };
        XPathResolutionError = class extends StagehandError {
            constructor(xpath){
                super(`XPath "${xpath}" does not resolve in the current page or frames`);
            }
        };
        ExperimentalApiConflictError = class extends StagehandError {
            constructor(){
                super("`experimental` mode cannot be used together with the Stagehand API. To use experimental features, set experimental: true, and useApi: false in the stagehand constructor. To use the Stagehand API, set experimental: false and useApi: true in the stagehand constructor. ");
            }
        };
        ExperimentalNotConfiguredError = class extends StagehandError {
            constructor(featureName){
                super(`Feature "${featureName}" is an experimental feature, and cannot be configured when useAPI: true. 
    Please set experimental: true and useAPI: false in the stagehand constructor to use this feature. 
    If you wish to use the Stagehand API, please ensure ${featureName} is not defined in your function call, 
    and set experimental: false, useAPI: true in the Stagehand constructor. `);
            }
        };
        CuaModelRequiredError = class extends StagehandError {
            constructor(availableModels){
                super(`To use the computer use agent (CUA), please provide a CUA model in the agent constructor or stagehand config. Try one of our supported CUA models: ${availableModels.join(", ")}`);
            }
        };
        ZodSchemaValidationError = class extends Error {
            constructor(received, issues){
                super(`Zod schema validation failed

\u2014 Received \u2014
${JSON.stringify(received, null, 2)}

\u2014 Issues \u2014
${JSON.stringify(issues, null, 2)}`);
                this.received = received;
                this.issues = issues;
                this.name = "ZodSchemaValidationError";
            }
        };
        StagehandInitError = class extends StagehandError {
            constructor(message){
                super(message);
            }
        };
        MCPConnectionError = class extends StagehandError {
            constructor(serverUrl, originalError){
                const errorMessage = originalError instanceof Error ? originalError.message : String(originalError);
                super(`Failed to connect to MCP server at "${serverUrl}". ${errorMessage}. Please verify the server URL is correct and the server is running.`);
                this.serverUrl = serverUrl;
                this.originalError = originalError;
            }
        };
        StagehandShadowRootMissingError = class extends StagehandError {
            constructor(detail){
                super(`No shadow root present on the resolved host` + (detail ? `: ${detail}` : ""));
            }
        };
        StagehandShadowSegmentEmptyError = class extends StagehandError {
            constructor(){
                super(`Empty selector segment after shadow-DOM hop ("//")`);
            }
        };
        StagehandShadowSegmentNotFoundError = class extends StagehandError {
            constructor(segment, hint){
                super(`Shadow segment '${segment}' matched no element inside shadow root` + (hint ? ` ${hint}` : ""));
            }
        };
        ElementNotVisibleError = class extends StagehandError {
            constructor(selector){
                super(`Element not visible (no box model): ${selector}`);
            }
        };
        ResponseBodyError = class extends StagehandError {
            constructor(message){
                super(`Failed to retrieve response body: ${message}`);
            }
        };
        ResponseParseError = class extends StagehandError {
            constructor(message){
                super(`Failed to parse response: ${message}`);
            }
        };
        TimeoutError = class extends StagehandError {
            constructor(operation, timeoutMs){
                super(`${operation} timed out after ${timeoutMs}ms`);
            }
        };
        PageNotFoundError = class extends StagehandError {
            constructor(identifier){
                super(`No Page found for ${identifier}`);
            }
        };
        ConnectionTimeoutError = class extends StagehandError {
            constructor(message){
                super(`Connection timeout: ${message}`);
            }
        };
    }
});
// lib/v3/logger.ts
function bindInstanceLogger(instanceId, logger) {
    instanceLoggers.set(instanceId, logger);
}
function unbindInstanceLogger(instanceId) {
    instanceLoggers.delete(instanceId);
}
function withInstanceLogContext(instanceId, fn) {
    return logContext.run(instanceId, fn);
}
function v3Logger(line) {
    var _a, _b, _c;
    const id = logContext.getStore();
    if (id) {
        const fn = instanceLoggers.get(id);
        if (fn) {
            const enriched = __spreadProps(__spreadValues({}, line), {
                auxiliary: __spreadValues({}, line.auxiliary || {})
            });
            try {
                fn(enriched);
                return;
            } catch (e) {}
        }
    }
    const ts = (_a = line.timestamp) != null ? _a : /* @__PURE__ */ new Date().toISOString();
    const lvl = (_b = line.level) != null ? _b : 1;
    const levelStr = lvl === 0 ? "ERROR" : lvl === 2 ? "DEBUG" : "INFO";
    let output = `[${ts}] ${levelStr}: ${line.message}`;
    if (line.auxiliary) {
        for (const [key, { value, type }] of Object.entries(line.auxiliary)){
            let formattedValue = value;
            if (type === "object") {
                try {
                    formattedValue = JSON.stringify(JSON.parse(value), null, 2).split("\n").map((line2, i)=>i === 0 ? line2 : `    ${line2}`).join("\n");
                } catch (e) {
                    formattedValue = value;
                }
            }
            output += `
    ${key}: ${formattedValue}`;
        }
    }
    if (lvl === 0) {
        console.error(output);
    } else if (lvl === 2) {
        ((_c = console.debug) != null ? _c : console.log)(output);
    } else {
        console.log(output);
    }
}
var import_node_async_hooks, logContext, instanceLoggers;
var init_logger = __esm({
    "lib/v3/logger.ts" () {
        import_node_async_hooks = __turbopack_context__.r("[externals]/async_hooks [external] (async_hooks, cjs)");
        logContext = new import_node_async_hooks.AsyncLocalStorage();
        instanceLoggers = /* @__PURE__ */ new Map();
    }
});
// lib/v3/understudy/executionContextRegistry.ts
var ExecutionContextRegistry, executionContexts;
var init_executionContextRegistry = __esm({
    "lib/v3/understudy/executionContextRegistry.ts" () {
        ExecutionContextRegistry = class {
            constructor(){
                this.byFrame = /* @__PURE__ */ new WeakMap();
                this.byExec = /* @__PURE__ */ new WeakMap();
            }
            /** Wire listeners for this session. Call BEFORE Runtime.enable. */ attachSession(session) {
                const onCreated = (evt)=>{
                    var _a;
                    const aux = (_a = evt.context.auxData) != null ? _a : {};
                    if (aux.isDefault === true && typeof aux.frameId === "string") {
                        this.register(session, aux.frameId, evt.context.id);
                    }
                };
                const onDestroyed = (evt)=>{
                    const rev = this.byExec.get(session);
                    const fwd = this.byFrame.get(session);
                    if (!rev || !fwd) return;
                    const frameId = rev.get(evt.executionContextId);
                    if (!frameId) return;
                    rev.delete(evt.executionContextId);
                    if (fwd.get(frameId) === evt.executionContextId) fwd.delete(frameId);
                };
                const onCleared = ()=>{
                    this.byFrame.delete(session);
                    this.byExec.delete(session);
                };
                session.on("Runtime.executionContextCreated", onCreated);
                session.on("Runtime.executionContextDestroyed", onDestroyed);
                session.on("Runtime.executionContextsCleared", onCleared);
            }
            getMainWorld(session, frameId) {
                var _a, _b;
                return (_b = (_a = this.byFrame.get(session)) == null ? void 0 : _a.get(frameId)) != null ? _b : null;
            }
            waitForMainWorld(session, frameId, timeoutMs = 800) {
                return __async(this, null, function*() {
                    const cached = this.getMainWorld(session, frameId);
                    if (cached) return cached;
                    yield session.send("Runtime.enable").catch(()=>{});
                    const after = this.getMainWorld(session, frameId);
                    if (after) return after;
                    return yield new Promise((resolve2, reject)=>{
                        let done = false;
                        const onCreated = (evt)=>{
                            var _a;
                            const aux = (_a = evt.context.auxData) != null ? _a : {};
                            if (aux.isDefault === true && aux.frameId === frameId) {
                                this.register(session, frameId, evt.context.id);
                                if (!done) {
                                    done = true;
                                    clearTimeout(timer);
                                    session.off("Runtime.executionContextCreated", onCreated);
                                    resolve2(evt.context.id);
                                }
                            }
                        };
                        const timer = setTimeout(()=>{
                            if (!done) {
                                done = true;
                                session.off("Runtime.executionContextCreated", onCreated);
                                reject(new Error(`main world not ready for frame ${frameId}`));
                            }
                        }, timeoutMs);
                        session.on("Runtime.executionContextCreated", onCreated);
                    });
                });
            }
            register(session, frameId, ctxId) {
                let fwd = this.byFrame.get(session);
                if (!fwd) {
                    fwd = /* @__PURE__ */ new Map();
                    this.byFrame.set(session, fwd);
                }
                let rev = this.byExec.get(session);
                if (!rev) {
                    rev = /* @__PURE__ */ new Map();
                    this.byExec.set(session, rev);
                }
                fwd.set(frameId, ctxId);
                rev.set(ctxId, frameId);
            }
        };
        executionContexts = new ExecutionContextRegistry();
    }
});
// lib/v3/understudy/a11y/snapshot.ts
function resolveXpathForLocation(page, x, y) {
    return __async(this, null, function*() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const tree = page.getFullFrameTree();
        const parentByFrame = /* @__PURE__ */ new Map();
        (function index(n, parent) {
            var _a2;
            parentByFrame.set(n.frame.id, parent);
            for (const c of (_a2 = n.childFrames) != null ? _a2 : [])index(c, n.frame.id);
        })(tree, null);
        const iframeChain = [];
        let curFrameId = page.mainFrameId();
        let curSession = page.getSessionForFrame(curFrameId);
        let curX = x;
        let curY = y;
        for(let depth = 0; depth < 8; depth++){
            try {
                yield curSession.send("DOM.enable").catch(()=>{});
                let sx = 0;
                let sy = 0;
                try {
                    yield curSession.send("Runtime.enable").catch(()=>{});
                    const ctxId = yield executionContexts.waitForMainWorld(curSession, curFrameId).catch(()=>{});
                    const evalParams = ctxId ? {
                        contextId: ctxId,
                        expression: scrollOffsetsExpr(),
                        returnByValue: true
                    } : {
                        expression: scrollOffsetsExpr(),
                        returnByValue: true
                    };
                    const { result } = yield curSession.send("Runtime.evaluate", evalParams);
                    sx = Number((_b = (_a = result == null ? void 0 : result.value) == null ? void 0 : _a.sx) != null ? _b : 0);
                    sy = Number((_d = (_c = result == null ? void 0 : result.value) == null ? void 0 : _c.sy) != null ? _d : 0);
                } catch (e) {}
                const xi = Math.max(0, Math.floor(curX + sx));
                const yi = Math.max(0, Math.floor(curY + sy));
                let res;
                try {
                    res = yield curSession.send("DOM.getNodeForLocation", {
                        x: xi,
                        y: yi,
                        includeUserAgentShadowDOM: false,
                        ignorePointerEventsNone: false
                    });
                } catch (e) {
                    return null;
                }
                const be = res == null ? void 0 : res.backendNodeId;
                const reportedFrameId = res == null ? void 0 : res.frameId;
                if (typeof be === "number" && reportedFrameId && reportedFrameId !== curFrameId) {
                    const abs = yield buildAbsoluteXPathFromChain(iframeChain, curSession, be);
                    return abs ? {
                        frameId: reportedFrameId,
                        backendNodeId: be,
                        absoluteXPath: abs
                    } : null;
                }
                if (typeof be !== "number") return null;
                let matchedChild;
                for (const fid of listChildrenOf(parentByFrame, curFrameId)){
                    try {
                        const { backendNodeId } = yield curSession.send("DOM.getFrameOwner", {
                            frameId: fid
                        });
                        if (backendNodeId === be) {
                            matchedChild = fid;
                            break;
                        }
                    } catch (e) {}
                }
                if (!matchedChild) {
                    const abs = yield buildAbsoluteXPathFromChain(iframeChain, curSession, be);
                    return abs ? {
                        frameId: curFrameId,
                        backendNodeId: be,
                        absoluteXPath: abs
                    } : null;
                }
                iframeChain.push({
                    parentFrameId: curFrameId,
                    parentSession: curSession,
                    iframeBackendNodeId: be
                });
                let left = 0;
                let top = 0;
                try {
                    const { object } = yield curSession.send("DOM.resolveNode", {
                        backendNodeId: be
                    });
                    const objectId = object == null ? void 0 : object.objectId;
                    if (objectId) {
                        const { result } = yield curSession.send("Runtime.callFunctionOn", {
                            objectId,
                            functionDeclaration: "function(){ const r=this.getBoundingClientRect(); return {left:r.left, top:r.top}; }",
                            returnByValue: true
                        });
                        left = Number((_f = (_e = result == null ? void 0 : result.value) == null ? void 0 : _e.left) != null ? _f : 0);
                        top = Number((_h = (_g = result == null ? void 0 : result.value) == null ? void 0 : _g.top) != null ? _h : 0);
                        yield curSession.send("Runtime.releaseObject", {
                            objectId
                        }).catch(()=>{});
                    }
                } catch (e) {}
                curX = Math.max(0, curX - left);
                curY = Math.max(0, curY - top);
                curFrameId = matchedChild;
                curSession = page.getSessionForFrame(curFrameId);
            } catch (e) {
                return null;
            }
        }
        return null;
    });
}
function computeActiveElementXpath(page) {
    return __async(this, null, function*() {
        var _a;
        const tree = page.getFullFrameTree();
        const parentByFrame = /* @__PURE__ */ new Map();
        (function index(n, parent) {
            var _a2;
            parentByFrame.set(n.frame.id, parent);
            for (const c of (_a2 = n.childFrames) != null ? _a2 : [])index(c, n.frame.id);
        })(tree, null);
        const frames = page.listAllFrameIds();
        let focusedFrameId = null;
        for (const fid of frames){
            const sess = page.getSessionForFrame(fid);
            try {
                yield sess.send("Runtime.enable").catch(()=>{});
                const ctxId = yield executionContexts.waitForMainWorld(sess, fid, 1e3).catch(()=>{});
                const evalParams = ctxId ? {
                    contextId: ctxId,
                    expression: "document.hasFocus()===true",
                    returnByValue: true
                } : {
                    expression: "document.hasFocus()===true",
                    returnByValue: true
                };
                const { result } = yield sess.send("Runtime.evaluate", evalParams);
                if ((result == null ? void 0 : result.value) === true) {
                    focusedFrameId = fid;
                    break;
                }
            } catch (e) {}
        }
        if (!focusedFrameId) focusedFrameId = page.mainFrameId();
        const focusedSession = page.getSessionForFrame(focusedFrameId);
        let objectId;
        try {
            yield focusedSession.send("Runtime.enable").catch(()=>{});
            const ctxId = yield executionContexts.waitForMainWorld(focusedSession, focusedFrameId, 1e3).catch(()=>{});
            const expr = `(() => {
      try {
        function deepActive(doc) {
          let el = doc.activeElement || null;
          while (el && el.shadowRoot && el.shadowRoot.activeElement) {
            el = el.shadowRoot.activeElement;
          }
          return el || null;
        }
        return deepActive(document);
      } catch { return null; }
    })()`;
            const evalParams = ctxId ? {
                contextId: ctxId,
                expression: expr,
                returnByValue: false
            } : {
                expression: expr,
                returnByValue: false
            };
            const { result } = yield focusedSession.send("Runtime.evaluate", evalParams);
            objectId = result == null ? void 0 : result.objectId;
        } catch (e) {
            objectId = void 0;
        }
        if (!objectId) return null;
        const leafXPath = yield (()=>__async(null, null, function*() {
                try {
                    const { result } = yield focusedSession.send("Runtime.callFunctionOn", {
                        objectId,
                        functionDeclaration: `function() {
            try {
              const node = this;
              function sibIndex(n) {
                let i = 1; const t = n.nodeType+':'+(n.nodeName||'').toLowerCase();
                for (let p = n.previousSibling; p; p = p.previousSibling) {
                  const key = p.nodeType+':'+(p.nodeName||'').toLowerCase();
                  if (key === t) i++;
                }
                return i;
              }
              function step(n) {
                if (!n) return '';
                if (n.nodeType === Node.DOCUMENT_NODE) return '';
                if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE) return '//';
                if (n.nodeType === Node.TEXT_NODE) return 'text()[' + sibIndex(n) + ']';
                if (n.nodeType === Node.COMMENT_NODE) return 'comment()[' + sibIndex(n) + ']';
                const tag = (n.nodeName||'').toLowerCase();
                const name = tag.includes(':') ? "*[name()='"+tag+"']" : tag;
                return name + '[' + sibIndex(n) + ']';
              }
              const parts = [];
              let cur = node;
              while (cur) {
                if (cur.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                  parts.push('//');
                  cur = (cur && cur.host) ? cur.host : null;
                  continue;
                }
                const s = step(cur);
                if (s) parts.push(s);
                cur = cur.parentNode;
              }
              parts.reverse();
              let out = '';
              for (const s of parts) {
                if (s === '//') out = out ? (out.endsWith('/') ? out + '/' : out + '//') : '//';
                else out = out ? (out.endsWith('/') ? out + s : out + '/' + s) : '/' + s;
              }
              return out || '/';
            } catch { return ''; }
          }`,
                        returnByValue: true
                    });
                    try {
                        yield focusedSession.send("Runtime.releaseObject", {
                            objectId
                        });
                    } catch (e) {}
                    const xp = (result == null ? void 0 : result.value) || "";
                    return typeof xp === "string" && xp ? xp : null;
                } catch (e) {
                    try {
                        yield focusedSession.send("Runtime.releaseObject", {
                            objectId
                        });
                    } catch (e2) {}
                    return null;
                }
            }))();
        if (!leafXPath) return null;
        let prefix = "";
        let cur = focusedFrameId;
        while(cur){
            const parent = (_a = parentByFrame.get(cur)) != null ? _a : null;
            if (!parent) break;
            const parentSess = page.getSessionForFrame(parent);
            try {
                const { backendNodeId } = yield parentSess.send("DOM.getFrameOwner", {
                    frameId: cur
                });
                if (typeof backendNodeId === "number") {
                    const xp = yield absoluteXPathForBackendNode(parentSess, backendNodeId);
                    if (xp) prefix = prefix ? prefixXPath(prefix, xp) : normalizeXPath(xp);
                }
            } catch (e) {}
            cur = parent;
        }
        return prefix ? prefixXPath(prefix, leafXPath) : normalizeXPath(leafXPath);
    });
}
function scrollOffsetsExpr() {
    return "({sx:(window.scrollX||window.pageXOffset||0),sy:(window.scrollY||window.pageYOffset||0)})";
}
function buildAbsoluteXPathFromChain(chain, leafSession, leafBackendNodeId) {
    return __async(this, null, function*() {
        let prefix = "";
        for (const step of chain){
            const xp = yield absoluteXPathForBackendNode(step.parentSession, step.iframeBackendNodeId);
            if (!xp) continue;
            prefix = prefix ? prefixXPath(prefix, xp) : normalizeXPath(xp);
        }
        const leaf = yield absoluteXPathForBackendNode(leafSession, leafBackendNodeId);
        if (!leaf) return prefix || "/";
        return prefix ? prefixXPath(prefix, leaf) : normalizeXPath(leaf);
    });
}
function absoluteXPathForBackendNode(session, backendNodeId) {
    return __async(this, null, function*() {
        try {
            const { object } = yield session.send("DOM.resolveNode", {
                backendNodeId
            });
            const objectId = object == null ? void 0 : object.objectId;
            if (!objectId) return null;
            const { result } = yield session.send("Runtime.callFunctionOn", {
                objectId,
                functionDeclaration: `function() {
          try {
            const node = this;
            function sibIndex(n) {
              let i = 1; const t = n.nodeType+':'+(n.nodeName||'').toLowerCase();
              for (let p = n.previousSibling; p; p = p.previousSibling) {
                const key = p.nodeType+':'+(p.nodeName||'').toLowerCase();
                if (key === t) i++;
              }
              return i;
            }
            function step(n) {
              if (!n) return '';
              if (n.nodeType === Node.DOCUMENT_NODE) return '';
              if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE) return '//'; // ShadowRoot hop
              if (n.nodeType === Node.TEXT_NODE) return 'text()[' + sibIndex(n) + ']';
              if (n.nodeType === Node.COMMENT_NODE) return 'comment()[' + sibIndex(n) + ']';
              const tag = (n.nodeName||'').toLowerCase();
              const name = tag.includes(':') ? "*[name()='"+tag+"']" : tag;
              return name + '[' + sibIndex(n) + ']';
            }
            const parts = [];
            let cur = node;
            while (cur) {
              // Insert a marker before stepping out of a ShadowRoot
              if (cur.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                parts.push('//');
                cur = (cur && cur.host) ? cur.host : null;
                continue;
              }
              const s = step(cur);
              if (s) parts.push(s);
              cur = cur.parentNode;
            }
            parts.reverse();
            let out = '';
            for (const s of parts) {
              if (s === '//') out = out ? (out.endsWith('/') ? out + '/' : out + '//') : '//';
              else out = out ? (out.endsWith('/') ? out + s : out + '/' + s) : '/' + s;
            }
            return out || '/';
          } catch { return ''; }
        }`,
                returnByValue: true
            });
            yield session.send("Runtime.releaseObject", {
                objectId
            }).catch(()=>{});
            return typeof (result == null ? void 0 : result.value) === "string" && result.value ? result.value : null;
        } catch (e) {
            return null;
        }
    });
}
function captureHybridSnapshot(page, options) {
    return __async(this, null, function*() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
        const pierce = (_a = options == null ? void 0 : options.pierceShadow) != null ? _a : true;
        const rootId = page.mainFrameId();
        const frameTree = page.asProtocolFrameTree(rootId);
        const parentByFrame = /* @__PURE__ */ new Map();
        (function index(n, parent) {
            var _a2;
            parentByFrame.set(n.frame.id, parent);
            for (const c of (_a2 = n.childFrames) != null ? _a2 : [])index(c, n.frame.id);
        })(frameTree, null);
        const frames = page.listAllFrameIds();
        const combinedXpathMap = {};
        const combinedUrlMap = {};
        const perFrameOutlines = [];
        const perFrameMaps = /* @__PURE__ */ new Map();
        const requestedFocus = (_b = options == null ? void 0 : options.focusSelector) == null ? void 0 : _b.trim();
        if (requestedFocus) {
            const logScopeFallback = ()=>{
                var _a2;
                v3Logger({
                    message: `Unable to narrow scope with selector. Falling back to using full DOM`,
                    level: 1,
                    auxiliary: {
                        arguments: {
                            value: `selector: ${(_a2 = options == null ? void 0 : options.focusSelector) == null ? void 0 : _a2.trim()}`,
                            type: "string"
                        }
                    }
                });
            };
            try {
                let targetFrameId;
                let tailSelector;
                let absPrefix2;
                const looksLikeXPath = /^xpath=/i.test(requestedFocus) || requestedFocus.startsWith("/");
                if (looksLikeXPath) {
                    const focus = normalizeXPath(requestedFocus);
                    const hit = yield resolveFocusFrameAndTail(page, focus, parentByFrame, rootId);
                    targetFrameId = hit.targetFrameId;
                    tailSelector = hit.tailXPath || void 0;
                    absPrefix2 = hit.absPrefix;
                } else {
                    const cssHit = yield resolveCssFocusFrameAndTail(page, requestedFocus, parentByFrame, rootId);
                    targetFrameId = cssHit.targetFrameId;
                    tailSelector = cssHit.tailSelector || void 0;
                    absPrefix2 = cssHit.absPrefix;
                }
                const owningSess = ownerSession(page, targetFrameId);
                const parentId = parentByFrame.get(targetFrameId);
                const sameSessionAsParent = !!parentId && ownerSession(page, parentId) === ownerSession(page, targetFrameId);
                const { tagNameMap, xpathMap, scrollableMap } = yield domMapsForSession(owningSess, targetFrameId, pierce, (fid, be)=>`${page.getOrdinal(fid)}-${be}`, /*attemptOwnerLookup=*/ sameSessionAsParent);
                const { outline, urlMap, scopeApplied } = yield a11yForFrame(owningSess, targetFrameId, {
                    focusSelector: tailSelector || void 0,
                    tagNameMap,
                    experimental: (_c = options == null ? void 0 : options.experimental) != null ? _c : false,
                    scrollableMap,
                    encode: (backendNodeId)=>`${page.getOrdinal(targetFrameId)}-${backendNodeId}`
                });
                const combinedXpathMap2 = {};
                const abs = absPrefix2 != null ? absPrefix2 : "";
                const isRoot = !abs || abs === "/";
                if (isRoot) {
                    Object.assign(combinedXpathMap2, xpathMap);
                } else {
                    for (const [encId, xp] of Object.entries(xpathMap)){
                        combinedXpathMap2[encId] = prefixXPath(abs, xp);
                    }
                }
                const combinedUrlMap2 = __spreadValues({}, urlMap);
                const snapshot = {
                    combinedTree: outline,
                    combinedXpathMap: combinedXpathMap2,
                    combinedUrlMap: combinedUrlMap2,
                    perFrame: [
                        {
                            frameId: targetFrameId,
                            outline,
                            xpathMap,
                            urlMap
                        }
                    ]
                };
                if (scopeApplied) {
                    return snapshot;
                }
                logScopeFallback();
            } catch (e) {
                logScopeFallback();
            }
        }
        function buildSessionDomIndex(session, pierce2) {
            return __async(this, null, function*() {
                var _a2, _b2;
                yield session.send("DOM.enable").catch(()=>{});
                const { root } = yield session.send("DOM.getDocument", {
                    depth: -1,
                    pierce: pierce2
                });
                const absByBe = /* @__PURE__ */ new Map();
                const tagByBe = /* @__PURE__ */ new Map();
                const scrollByBe = /* @__PURE__ */ new Map();
                const docRootOf = /* @__PURE__ */ new Map();
                const contentDocRootByIframe = /* @__PURE__ */ new Map();
                const rootBe = root.backendNodeId;
                const stack = [
                    {
                        node: root,
                        xp: "/",
                        docRootBe: rootBe
                    }
                ];
                while(stack.length){
                    const { node, xp, docRootBe } = stack.pop();
                    if (node.backendNodeId) {
                        absByBe.set(node.backendNodeId, xp || "/");
                        tagByBe.set(node.backendNodeId, String(node.nodeName).toLowerCase());
                        if ((node == null ? void 0 : node.isScrollable) === true) scrollByBe.set(node.backendNodeId, true);
                        docRootOf.set(node.backendNodeId, docRootBe);
                    }
                    const kids = (_a2 = node.children) != null ? _a2 : [];
                    if (kids.length) {
                        const segs = buildChildXPathSegments(kids);
                        for(let i = kids.length - 1; i >= 0; i--){
                            const child = kids[i];
                            const step = segs[i];
                            stack.push({
                                node: child,
                                xp: joinXPath(xp, step),
                                docRootBe
                            });
                        }
                    }
                    for (const sr of (_b2 = node.shadowRoots) != null ? _b2 : []){
                        stack.push({
                            node: sr,
                            xp: joinXPath(xp, "//"),
                            docRootBe
                        });
                    }
                    const cd = node.contentDocument;
                    if (cd && typeof cd.backendNodeId === "number") {
                        contentDocRootByIframe.set(node.backendNodeId, cd.backendNodeId);
                        stack.push({
                            node: cd,
                            xp,
                            docRootBe: cd.backendNodeId
                        });
                    }
                }
                return {
                    rootBackend: rootBe,
                    absByBe,
                    tagByBe,
                    scrollByBe,
                    docRootOf,
                    contentDocRootByIframe
                };
            });
        }
        function relativizeXPath(baseAbs, nodeAbs) {
            const base = normalizeXPath(baseAbs);
            const abs = normalizeXPath(nodeAbs);
            if (abs === base) return "/";
            if (abs.startsWith(base)) {
                const tail = abs.slice(base.length);
                if (!tail) return "/";
                return tail.startsWith("/") || tail.startsWith("//") ? tail : `/${tail}`;
            }
            if (base === "/") return abs;
            return abs;
        }
        const sessionToIndex = /* @__PURE__ */ new Map();
        const sessionById = /* @__PURE__ */ new Map();
        for (const frameId of frames){
            const sess = ownerSession(page, frameId);
            const sid = (_d = sess.id) != null ? _d : "root";
            if (!sessionById.has(sid)) sessionById.set(sid, sess);
        }
        for (const [sid, sess] of sessionById.entries()){
            const idx = yield buildSessionDomIndex(sess, pierce);
            sessionToIndex.set(sid, idx);
        }
        for (const frameId of frames){
            const sess = ownerSession(page, frameId);
            const sid = (_e = sess.id) != null ? _e : "root";
            let idx = sessionToIndex.get(sid);
            if (!idx) {
                idx = yield buildSessionDomIndex(sess, pierce);
                sessionToIndex.set(sid, idx);
            }
            const parentId = parentByFrame.get(frameId);
            const sameSessionAsParent = !!parentId && ownerSession(page, parentId) === sess;
            let docRootBe = idx.rootBackend;
            if (sameSessionAsParent) {
                try {
                    const { backendNodeId } = yield sess.send("DOM.getFrameOwner", {
                        frameId
                    });
                    if (typeof backendNodeId === "number") {
                        const cdBe = idx.contentDocRootByIframe.get(backendNodeId);
                        if (typeof cdBe === "number") docRootBe = cdBe;
                    }
                } catch (e) {}
            }
            const tagNameMap = {};
            const xpathMap = {};
            const scrollableMap = {};
            const enc = (be)=>`${page.getOrdinal(frameId)}-${be}`;
            const baseAbs = (_f = idx.absByBe.get(docRootBe)) != null ? _f : "/";
            for (const [be, nodeAbs] of idx.absByBe.entries()){
                const nodeDocRoot = idx.docRootOf.get(be);
                if (nodeDocRoot !== docRootBe) continue;
                const rel = relativizeXPath(baseAbs, nodeAbs);
                const key = enc(be);
                xpathMap[key] = rel;
                const tag = idx.tagByBe.get(be);
                if (tag) tagNameMap[key] = tag;
                if (idx.scrollByBe.get(be)) scrollableMap[key] = true;
            }
            const { outline, urlMap } = yield a11yForFrame(sess, frameId, {
                experimental: (_g = options == null ? void 0 : options.experimental) != null ? _g : false,
                tagNameMap,
                scrollableMap,
                encode: (backendNodeId)=>`${page.getOrdinal(frameId)}-${backendNodeId}`
            });
            perFrameOutlines.push({
                frameId,
                outline
            });
            perFrameMaps.set(frameId, {
                tagNameMap,
                xpathMap,
                scrollableMap,
                urlMap
            });
        }
        const absPrefix = /* @__PURE__ */ new Map();
        const iframeHostEncByChild = /* @__PURE__ */ new Map();
        absPrefix.set(rootId, "");
        const queue = [
            rootId
        ];
        while(queue.length){
            const parent = queue.shift();
            const parentAbs = absPrefix.get(parent);
            for (const child of frames){
                if (parentByFrame.get(child) !== parent) continue;
                queue.push(child);
                const parentSess = parentSession(page, parentByFrame, child);
                const ownerBackendNodeId = yield (()=>__async(null, null, function*() {
                        try {
                            const { backendNodeId } = yield parentSess.send("DOM.getFrameOwner", {
                                frameId: child
                            });
                            return backendNodeId;
                        } catch (e) {
                            return void 0;
                        }
                    }))();
                if (!ownerBackendNodeId) {
                    absPrefix.set(child, parentAbs);
                    continue;
                }
                const parentDom = perFrameMaps.get(parent);
                const iframeEnc = `${page.getOrdinal(parent)}-${ownerBackendNodeId}`;
                const iframeXPath = parentDom == null ? void 0 : parentDom.xpathMap[iframeEnc];
                const childAbs = iframeXPath ? prefixXPath(parentAbs || "/", iframeXPath) : parentAbs;
                absPrefix.set(child, childAbs);
                iframeHostEncByChild.set(child, iframeEnc);
            }
        }
        for (const frameId of frames){
            const maps = perFrameMaps.get(frameId);
            if (!maps) continue;
            const abs = (_h = absPrefix.get(frameId)) != null ? _h : "";
            const isRoot = abs === "" || abs === "/";
            if (isRoot) {
                Object.assign(combinedXpathMap, maps.xpathMap);
                Object.assign(combinedUrlMap, maps.urlMap);
                continue;
            }
            for (const [encId, xp] of Object.entries(maps.xpathMap)){
                combinedXpathMap[encId] = prefixXPath(abs, xp);
            }
            Object.assign(combinedUrlMap, maps.urlMap);
        }
        const idToTree = /* @__PURE__ */ new Map();
        for (const { frameId, outline } of perFrameOutlines){
            const parentEnc = iframeHostEncByChild.get(frameId);
            if (parentEnc) idToTree.set(parentEnc, outline);
        }
        const rootOutline = (_l = (_k = (_i = perFrameOutlines.find((o)=>o.frameId === rootId)) == null ? void 0 : _i.outline) != null ? _k : (_j = perFrameOutlines[0]) == null ? void 0 : _j.outline) != null ? _l : "";
        const combinedTree = injectSubtrees(rootOutline, idToTree);
        return {
            combinedTree,
            combinedXpathMap,
            combinedUrlMap,
            perFrame: perFrameOutlines.map(({ frameId, outline })=>{
                var _a2, _b2;
                const maps = perFrameMaps.get(frameId);
                return {
                    frameId,
                    outline,
                    xpathMap: (_a2 = maps == null ? void 0 : maps.xpathMap) != null ? _a2 : {},
                    urlMap: (_b2 = maps == null ? void 0 : maps.urlMap) != null ? _b2 : {}
                };
            })
        };
    });
}
function prefixXPath(parentAbs, child) {
    const p = parentAbs === "/" ? "" : parentAbs.replace(/\/$/, "");
    if (!child || child === "/") return p || "/";
    if (child.startsWith("//")) return p ? `${p}//${child.slice(2)}` : `//${child.slice(2)}`;
    const c = child.replace(/^\//, "");
    return p ? `${p}/${c}` : `/${c}`;
}
function normalizeXPath(x) {
    if (!x) return "";
    let s = x.trim().replace(/^xpath=/i, "");
    if (!s.startsWith("/")) s = "/" + s;
    if (s.length > 1 && s.endsWith("/")) s = s.slice(0, -1);
    return s;
}
function parseXPathToSteps(path7) {
    const s = path7.trim();
    let i = 0;
    const steps = [];
    while(i < s.length){
        let axis = "child";
        if (s.startsWith("//", i)) {
            axis = "desc";
            i += 2;
        } else if (s[i] === "/") {
            axis = "child";
            i += 1;
        }
        const start = i;
        while(i < s.length && s[i] !== "/")i++;
        const raw = s.slice(start, i).trim();
        if (!raw) continue;
        const name = raw.replace(/\[\d+\]\s*$/u, "").toLowerCase();
        steps.push({
            axis,
            raw,
            name
        });
    }
    return steps;
}
function buildXPathFromSteps(steps) {
    let out = "";
    for (const st of steps){
        out += st.axis === "desc" ? "//" : "/";
        out += st.raw;
    }
    return out || "/";
}
function resolveFocusFrameAndTail(page, absoluteXPath, parentByFrame, rootId) {
    return __async(this, null, function*() {
        const steps = parseXPathToSteps(absoluteXPath);
        let ctxFrameId = rootId;
        let buf = [];
        let absPrefix = "";
        const flushIntoChild = ()=>__async(null, null, function*() {
                if (!buf.length) return;
                const selectorForIframe = buildXPathFromSteps(buf);
                const parentSess = page.getSessionForFrame(ctxFrameId);
                const objectId = yield resolveObjectIdForXPath(parentSess, selectorForIframe, ctxFrameId);
                if (!objectId) throw new StagehandIframeError(selectorForIframe, "Failed to resolve iframe element by XPath");
                try {
                    yield parentSess.send("DOM.enable").catch(()=>{});
                    const desc = yield parentSess.send("DOM.describeNode", {
                        objectId
                    });
                    const iframeBackendNodeId = desc.node.backendNodeId;
                    let childFrameId;
                    for (const fid of listChildrenOf(parentByFrame, ctxFrameId)){
                        try {
                            const { backendNodeId } = yield parentSess.send("DOM.getFrameOwner", {
                                frameId: fid
                            });
                            if (backendNodeId === iframeBackendNodeId) {
                                childFrameId = fid;
                                break;
                            }
                        } catch (e) {}
                    }
                    if (!childFrameId) throw new StagehandIframeError(selectorForIframe, "Could not map iframe to child frameId");
                    absPrefix = prefixXPath(absPrefix || "/", selectorForIframe);
                    ctxFrameId = childFrameId;
                } finally{
                    yield parentSess.send("Runtime.releaseObject", {
                        objectId
                    }).catch(()=>{});
                }
                buf = [];
            });
        for (const st of steps){
            buf.push(st);
            if (IFRAME_STEP_RE.test(st.name)) {
                yield flushIntoChild();
            }
        }
        const tailXPath = buildXPathFromSteps(buf);
        return {
            targetFrameId: ctxFrameId,
            tailXPath,
            absPrefix
        };
    });
}
function resolveCssFocusFrameAndTail(page, rawSelector, parentByFrame, rootId) {
    return __async(this, null, function*() {
        var _a;
        const parts = rawSelector.split(">>").map((s)=>s.trim()).filter(Boolean);
        let ctxFrameId = rootId;
        const absPrefix = "";
        for(let i = 0; i < Math.max(0, parts.length - 1); i++){
            const parentSess = page.getSessionForFrame(ctxFrameId);
            const objectId = yield resolveObjectIdForCss(parentSess, parts[i], ctxFrameId);
            if (!objectId) throw new StagehandIframeError(parts[i], "Failed to resolve iframe via CSS hop");
            try {
                yield parentSess.send("DOM.enable").catch(()=>{});
                const desc = yield parentSess.send("DOM.describeNode", {
                    objectId
                });
                const iframeBackendNodeId = desc.node.backendNodeId;
                let childFrameId;
                for (const fid of listChildrenOf(parentByFrame, ctxFrameId)){
                    try {
                        const { backendNodeId } = yield parentSess.send("DOM.getFrameOwner", {
                            frameId: fid
                        });
                        if (backendNodeId === iframeBackendNodeId) {
                            childFrameId = fid;
                            break;
                        }
                    } catch (e) {}
                }
                if (!childFrameId) throw new StagehandIframeError(parts[i], "Could not map CSS iframe hop to child frameId");
                ctxFrameId = childFrameId;
            } finally{
                yield parentSess.send("Runtime.releaseObject", {
                    objectId
                }).catch(()=>{});
            }
        }
        const tailSelector = (_a = parts[parts.length - 1]) != null ? _a : "*";
        return {
            targetFrameId: ctxFrameId,
            tailSelector,
            absPrefix
        };
    });
}
function listChildrenOf(parentByFrame, parentId) {
    const out = [];
    for (const [fid, p] of parentByFrame.entries()){
        if (p === parentId) out.push(fid);
    }
    return out;
}
function domMapsForSession(session, frameId, pierce, encode = (fid, be)=>`${fid}-${be}`, attemptOwnerLookup = true) {
    return __async(this, null, function*() {
        var _a, _b;
        yield session.send("DOM.enable").catch(()=>{});
        const { root } = yield session.send("DOM.getDocument", {
            depth: -1,
            pierce
        });
        let startNode = root;
        if (attemptOwnerLookup) {
            try {
                const owner = yield session.send("DOM.getFrameOwner", {
                    frameId
                });
                const ownerBackendId = owner.backendNodeId;
                if (typeof ownerBackendId === "number") {
                    const ownerEl = findNodeByBackendId(root, ownerBackendId);
                    if (ownerEl == null ? void 0 : ownerEl.contentDocument) {
                        startNode = ownerEl.contentDocument;
                    }
                }
            } catch (e) {}
        }
        const tagNameMap = {};
        const xpathMap = {};
        const scrollableMap = {};
        const stack = [
            {
                node: startNode,
                xpath: ""
            }
        ];
        while(stack.length){
            const { node, xpath } = stack.pop();
            if (node.backendNodeId) {
                const encId = encode(frameId, node.backendNodeId);
                tagNameMap[encId] = String(node.nodeName).toLowerCase();
                xpathMap[encId] = xpath || "/";
                const isScrollable = (node == null ? void 0 : node.isScrollable) === true;
                if (isScrollable) scrollableMap[encId] = true;
            }
            const kids = (_a = node.children) != null ? _a : [];
            if (kids.length) {
                const segs = buildChildXPathSegments(kids);
                for(let i = kids.length - 1; i >= 0; i--){
                    const child = kids[i];
                    const step = segs[i];
                    stack.push({
                        node: child,
                        xpath: joinXPath(xpath, step)
                    });
                }
            }
            for (const sr of (_b = node.shadowRoots) != null ? _b : []){
                stack.push({
                    node: sr,
                    xpath: joinXPath(xpath, "//")
                });
            }
        }
        return {
            tagNameMap,
            xpathMap,
            scrollableMap
        };
    });
}
function buildChildXPathSegments(kids) {
    var _a;
    const segs = [];
    const ctr = {};
    for (const child of kids){
        const tag = String(child.nodeName).toLowerCase();
        const key = `${child.nodeType}:${tag}`;
        const idx = ctr[key] = ((_a = ctr[key]) != null ? _a : 0) + 1;
        if (child.nodeType === 3) {
            segs.push(`text()[${idx}]`);
        } else if (child.nodeType === 8) {
            segs.push(`comment()[${idx}]`);
        } else {
            segs.push(tag.includes(":") ? `*[name()='${tag}'][${idx}]` : `${tag}[${idx}]`);
        }
    }
    return segs;
}
function joinXPath(base, step) {
    if (step === "//") {
        if (!base || base === "/") return "//";
        return base.endsWith("/") ? `${base}/` : `${base}//`;
    }
    if (!base || base === "/") return step ? `/${step}` : "/";
    if (base.endsWith("//")) return `${base}${step}`;
    if (!step) return base;
    return `${base}/${step}`;
}
function a11yForFrame(session, frameId, opts) {
    return __async(this, null, function*() {
        var _a, _b;
        yield session.send("Accessibility.enable").catch(()=>{});
        yield session.send("Runtime.enable").catch(()=>{});
        yield session.send("DOM.enable").catch(()=>{});
        let nodes = [];
        try {
            const params = frameId ? {
                frameId
            } : {};
            ({ nodes } = yield session.send("Accessibility.getFullAXTree", params));
        } catch (e) {
            const msg = String((_b = (_a = e == null ? void 0 : e.message) != null ? _a : e) != null ? _b : "");
            const isFrameScopeError = msg.includes("Frame with the given") || msg.includes("does not belong to the target") || msg.includes("is not found");
            if (!isFrameScopeError || !frameId) throw e;
            ({ nodes } = yield session.send("Accessibility.getFullAXTree"));
        }
        const urlMap = {};
        for (const n of nodes){
            const be = n.backendDOMNodeId;
            if (typeof be !== "number") continue;
            const url = extractUrlFromAXNode(n);
            if (!url) continue;
            const enc = opts.encode(be);
            urlMap[enc] = url;
        }
        let scopeApplied = false;
        const nodesForOutline = yield (()=>__async(null, null, function*() {
                var _a2, _b2, _c;
                const sel = (_a2 = opts.focusSelector) == null ? void 0 : _a2.trim();
                if (!sel) return nodes;
                try {
                    const looksLikeXPath = /^xpath=/i.test(sel) || sel.startsWith("/");
                    const objectId = looksLikeXPath ? yield resolveObjectIdForXPath(session, sel, frameId) : yield resolveObjectIdForCss(session, sel, frameId);
                    if (!objectId) return nodes;
                    const desc = yield session.send("DOM.describeNode", {
                        objectId
                    });
                    const be = (_b2 = desc.node) == null ? void 0 : _b2.backendNodeId;
                    if (typeof be !== "number") return nodes;
                    const target = nodes.find((n)=>n.backendDOMNodeId === be);
                    if (!target) return nodes;
                    scopeApplied = true;
                    const keep = /* @__PURE__ */ new Set([
                        target.nodeId
                    ]);
                    const queue = [
                        target
                    ];
                    while(queue.length){
                        const cur = queue.shift();
                        for (const id of (_c = cur.childIds) != null ? _c : []){
                            if (keep.has(id)) continue;
                            keep.add(id);
                            const child = nodes.find((n)=>n.nodeId === id);
                            if (child) queue.push(child);
                        }
                    }
                    return nodes.filter((n)=>keep.has(n.nodeId)).map((n)=>n.nodeId === target.nodeId ? __spreadProps(__spreadValues({}, n), {
                            parentId: void 0
                        }) : n);
                } catch (e) {
                    return nodes;
                }
            }))();
        const decorated = decorateRoles(nodesForOutline, opts);
        const { tree } = yield buildHierarchicalTree(decorated, opts);
        const simplified = tree.map((n)=>formatTreeLine(n)).join("\n");
        return {
            outline: simplified.trimEnd(),
            urlMap,
            scopeApplied
        };
    });
}
function resolveObjectIdForXPath(session, xpath, frameId) {
    return __async(this, null, function*() {
        var _a;
        let contextId;
        try {
            if (frameId) {
                contextId = yield executionContexts.waitForMainWorld(session, frameId, 800).catch(()=>{
                    var _a2;
                    return (_a2 = executionContexts.getMainWorld(session, frameId)) != null ? _a2 : void 0;
                });
            }
        } catch (e) {
            contextId = void 0;
        }
        const expr = `(() => {
    const xp = ${JSON.stringify(xpath)};
    try {
      if (window.__stagehandV3__ && typeof window.__stagehandV3__.resolveSimpleXPath === 'function') {
        return window.__stagehandV3__.resolveSimpleXPath(xp);
      }
    } catch {}
    try {
      const res = document.evaluate(xp, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
      return res.singleNodeValue;
    } catch { return null; }
  })()`;
        const { result, exceptionDetails } = yield session.send("Runtime.evaluate", {
            expression: expr,
            returnByValue: false,
            contextId,
            awaitPromise: true
        });
        if (exceptionDetails) return null;
        return (_a = result == null ? void 0 : result.objectId) != null ? _a : null;
    });
}
function resolveObjectIdForCss(session, selector, frameId) {
    return __async(this, null, function*() {
        var _a;
        let contextId;
        try {
            if (frameId) {
                contextId = yield executionContexts.waitForMainWorld(session, frameId, 800).catch(()=>{
                    var _a2;
                    return (_a2 = executionContexts.getMainWorld(session, frameId)) != null ? _a2 : void 0;
                });
            }
        } catch (e) {
            contextId = void 0;
        }
        const expr = `(() => {
    const selector = ${JSON.stringify(selector)};
    function queryOpenDeep(root) {
      try {
        const hit = root.querySelector(selector);
        if (hit) return hit;
      } catch {}
      const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
      let n;
      while ((n = walker.nextNode())) {
        if (n.shadowRoot) {
          const found = queryOpenDeep(n.shadowRoot);
          if (found) return found;
        }
      }
      return null;
    }
    const backdoor = window.__stagehandV3__;
    if (backdoor && typeof backdoor.getClosedRoot === 'function') {
      function* roots() {
        yield document;
        const queue = [];
        try {
          const w = document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT);
          let e; while ((e = w.nextNode())) {
            if (e.shadowRoot) queue.push(e.shadowRoot);
            try { const closed = backdoor.getClosedRoot(e); if (closed) queue.push(closed); } catch {}
          }
        } catch {}
        while (queue.length) {
          const r = queue.shift();
          yield r;
          try {
            const w2 = document.createTreeWalker(r, NodeFilter.SHOW_ELEMENT);
            let e2; while ((e2 = w2.nextNode())) {
              if (e2.shadowRoot) queue.push(e2.shadowRoot);
              try { const closed2 = backdoor.getClosedRoot(e2); if (closed2) queue.push(closed2); } catch {}
            }
          } catch {}
        }
      }
      for (const r of roots()) {
        try { const hit = r.querySelector(selector); if (hit) return hit; } catch {}
      }
      return null;
    }
    return queryOpenDeep(document);
  })()`;
        const { result, exceptionDetails } = yield session.send("Runtime.evaluate", {
            expression: expr,
            returnByValue: false,
            contextId,
            awaitPromise: true
        });
        if (exceptionDetails) return null;
        return (_a = result == null ? void 0 : result.objectId) != null ? _a : null;
    });
}
function decorateRoles(nodes, opts) {
    const asRole = (n)=>{
        var _a, _b;
        return String((_b = (_a = n.role) == null ? void 0 : _a.value) != null ? _b : "");
    };
    return nodes.map((n)=>{
        var _a, _b, _c;
        let encodedId;
        if (typeof n.backendDOMNodeId === "number") {
            try {
                encodedId = opts.encode(n.backendDOMNodeId);
            } catch (e) {}
        }
        let role = asRole(n);
        const domIsScrollable = encodedId ? opts.scrollableMap[encodedId] === true : false;
        const tag = encodedId ? opts.tagNameMap[encodedId] : void 0;
        const isHtmlElement = tag === "html";
        if ((domIsScrollable || isHtmlElement) && tag !== "#document") {
            const tagLabel = tag && tag.startsWith("#") ? tag.slice(1) : tag;
            role = tagLabel ? `scrollable, ${tagLabel}` : `scrollable${role ? `, ${role}` : ""}`;
        }
        return {
            role,
            name: (_a = n.name) == null ? void 0 : _a.value,
            description: (_b = n.description) == null ? void 0 : _b.value,
            value: (_c = n.value) == null ? void 0 : _c.value,
            nodeId: n.nodeId,
            backendDOMNodeId: n.backendDOMNodeId,
            parentId: n.parentId,
            childIds: n.childIds,
            encodedId
        };
    });
}
function buildHierarchicalTree(nodes, opts) {
    return __async(this, null, function*() {
        var _a;
        const nodeMap = /* @__PURE__ */ new Map();
        for (const n of nodes){
            const keep = !!(n.name && n.name.trim()) || !!(n.childIds && n.childIds.length) || !isStructural(n.role);
            if (!keep) continue;
            nodeMap.set(n.nodeId, __spreadValues({}, n));
        }
        for (const n of nodes){
            if (!n.parentId) continue;
            const parent = nodeMap.get(n.parentId);
            const cur = nodeMap.get(n.nodeId);
            if (parent && cur) ((_a = parent.children) != null ? _a : parent.children = []).push(cur);
        }
        const roots = nodes.filter((n)=>!n.parentId && nodeMap.has(n.nodeId)).map((n)=>nodeMap.get(n.nodeId));
        const cleaned = (yield Promise.all(roots.map(pruneStructuralSafe))).filter(Boolean);
        return {
            tree: cleaned
        };
        //TURBOPACK unreachable
        ;
        function pruneStructuralSafe(node) {
            return __async(this, null, function*() {
                var _a2;
                if (+node.nodeId < 0) return null;
                const children = (_a2 = node.children) != null ? _a2 : [];
                if (!children.length) {
                    return isStructural(node.role) ? null : node;
                }
                const cleanedKids = (yield Promise.all(children.map(pruneStructuralSafe))).filter(Boolean);
                const prunedStatic = removeRedundantStaticTextChildren(node, cleanedKids);
                if (isStructural(node.role)) {
                    if (prunedStatic.length === 1) return prunedStatic[0];
                    if (prunedStatic.length === 0) return null;
                }
                let newRole = node.role;
                if ((newRole === "generic" || newRole === "none") && node.encodedId) {
                    const tagName = opts.tagNameMap[node.encodedId];
                    if (tagName) newRole = tagName;
                }
                if (newRole === "combobox" && node.encodedId) {
                    const tagName = opts.tagNameMap[node.encodedId];
                    if (tagName === "select") newRole = "select";
                }
                return __spreadProps(__spreadValues({}, node), {
                    role: newRole,
                    children: prunedStatic
                });
            });
        }
    });
}
function formatTreeLine(node, level = 0) {
    var _a, _b, _c;
    const indent = "  ".repeat(level);
    const labelId = (_a = node.encodedId) != null ? _a : node.nodeId;
    const label = `[${labelId}] ${node.role}${node.name ? `: ${cleanText(node.name)}` : ""}`;
    const kids = (_c = (_b = node.children) == null ? void 0 : _b.map((c)=>formatTreeLine(c, level + 1)).join("\n")) != null ? _c : "";
    return kids ? `${indent}${label}
${kids}` : `${indent}${label}`;
}
function isStructural(role) {
    const r = role == null ? void 0 : role.toLowerCase();
    return r === "generic" || r === "none" || r === "inlinetextbox";
}
function cleanText(input) {
    const PUA_START = 57344;
    const PUA_END = 63743;
    const NBSP = /* @__PURE__ */ new Set([
        160,
        8239,
        8199,
        65279
    ]);
    let out = "";
    let prevSpace = false;
    for(let i = 0; i < input.length; i++){
        const code = input.charCodeAt(i);
        if (code >= PUA_START && code <= PUA_END) continue;
        if (NBSP.has(code)) {
            if (!prevSpace) {
                out += " ";
                prevSpace = true;
            }
            continue;
        }
        out += input[i];
        prevSpace = input[i] === " ";
    }
    return out.trim();
}
function extractUrlFromAXNode(ax) {
    var _a, _b;
    const props = (_a = ax.properties) != null ? _a : [];
    const urlProp = props.find((p)=>p.name === "url");
    const value = (_b = urlProp == null ? void 0 : urlProp.value) == null ? void 0 : _b.value;
    return typeof value === "string" && value.trim() ? value.trim() : void 0;
}
function normaliseSpaces(s) {
    let out = "";
    let inWs = false;
    for(let i = 0; i < s.length; i++){
        const ch = s[i];
        const isWs = /\s/.test(ch);
        if (isWs) {
            if (!inWs) {
                out += " ";
                inWs = true;
            }
        } else {
            out += ch;
            inWs = false;
        }
    }
    return out;
}
function removeRedundantStaticTextChildren(parent, children) {
    if (!parent.name) return children;
    const parentNorm = normaliseSpaces(parent.name).trim();
    let combined = "";
    for (const c of children){
        if (c.role === "StaticText" && c.name) {
            combined += normaliseSpaces(c.name).trim();
        }
    }
    if (combined === parentNorm) {
        return children.filter((c)=>c.role !== "StaticText");
    }
    return children;
}
function findNodeByBackendId(root, backendNodeId) {
    const stack = [
        root
    ];
    while(stack.length){
        const n = stack.pop();
        if (n.backendNodeId === backendNodeId) return n;
        if (n.children) for (const c of n.children)stack.push(c);
        if (n.shadowRoots) for (const s of n.shadowRoots)stack.push(s);
    }
    return void 0;
}
function injectSubtrees(rootOutline, idToTree) {
    var _a, _b;
    const out = [];
    const visited = /* @__PURE__ */ new Set();
    const stack = [
        {
            lines: rootOutline.split("\n"),
            i: 0
        }
    ];
    while(stack.length){
        const top = stack[stack.length - 1];
        if (top.i >= top.lines.length) {
            stack.pop();
            continue;
        }
        const raw = top.lines[top.i++];
        out.push(raw);
        const indent = (_b = (_a = raw.match(/^(\s*)/)) == null ? void 0 : _a[1]) != null ? _b : "";
        const content = raw.slice(indent.length);
        const m = content.match(/^\[([^\]]+)]/);
        if (!m) continue;
        const encId = m[1];
        const childOutline = idToTree.get(encId);
        if (!childOutline || visited.has(encId)) continue;
        visited.add(encId);
        const fullyInjectedChild = injectSubtrees(childOutline, idToTree);
        out.push(indentBlock(fullyInjectedChild.trimEnd(), indent + "  "));
    }
    return out.join("\n");
}
function indentBlock(block, indent) {
    if (!block) return "";
    return block.split("\n").map((line)=>line.length ? indent + line : indent + line).join("\n");
}
function diffCombinedTrees(prevTree, nextTree) {
    const prevSet = new Set((prevTree || "").split("\n").map((l)=>l.trim()).filter((l)=>l.length > 0));
    const nextLines = (nextTree || "").split("\n");
    const added = [];
    for (const line of nextLines){
        const core = line.trim();
        if (!core) continue;
        if (!prevSet.has(core)) added.push(line);
    }
    if (added.length === 0) return "";
    let minIndent = Infinity;
    for (const l of added){
        if (!l.trim()) continue;
        const m = l.match(/^\s*/);
        const indentLen = m ? m[0].length : 0;
        if (indentLen < minIndent) minIndent = indentLen;
    }
    if (!isFinite(minIndent)) minIndent = 0;
    const out = added.map((l)=>l.length >= minIndent ? l.slice(minIndent) : l);
    return out.join("\n");
}
function ownerSession(page, frameId) {
    return page.getSessionForFrame(frameId);
}
function parentSession(page, parentByFrame, frameId) {
    var _a;
    const parentId = (_a = parentByFrame.get(frameId)) != null ? _a : null;
    if (!parentId) {
        return page.getSessionForFrame(frameId);
    }
    return page.getSessionForFrame(parentId);
}
var IFRAME_STEP_RE;
var init_snapshot = __esm({
    "lib/v3/understudy/a11y/snapshot.ts" () {
        init_executionContextRegistry();
        init_logger();
        init_sdkErrors();
        IFRAME_STEP_RE = /^iframe(?:\[\d+])?$/i;
    }
});
// lib/v3/dom/build/locatorScripts.generated.ts
var locatorScriptBootstrap, locatorScriptSources, locatorScriptGlobalRefs;
var init_locatorScripts_generated = __esm({
    "lib/v3/dom/build/locatorScripts.generated.ts" () {
        locatorScriptBootstrap = 'if (!globalThis.__stagehandLocatorScripts) { var __stagehandLocatorScriptsFactory=(()=>{var L=Object.defineProperty;var R=Object.getOwnPropertyDescriptor;var k=Object.getOwnPropertyNames;var H=Object.prototype.hasOwnProperty;var D=(t,e)=>{for(var c in e)L(t,c,{get:e[c],enumerable:!0})},A=(t,e,c,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of k(e))!H.call(t,o)&&o!==c&&L(t,o,{get:()=>e[o],enumerable:!(n=R(e,o))||n.enumerable});return t};var _=t=>A(L({},"__esModule",{value:!0}),t);var oe={};D(oe,{assignFilePayloadsToInputElement:()=>F,countCssMatchesPierce:()=>ee,countCssMatchesPrimary:()=>Z,countTextMatches:()=>te,countXPathMatchesMainWorld:()=>ne,dispatchDomClick:()=>W,ensureFileInputElement:()=>I,fillElementValue:()=>O,focusElement:()=>V,isElementChecked:()=>B,isElementVisible:()=>Y,prepareElementForTyping:()=>T,readElementInnerHTML:()=>U,readElementInnerText:()=>j,readElementInputValue:()=>$,readElementTextContent:()=>z,resolveCssSelector:()=>K,resolveCssSelectorPierce:()=>G,resolveTextSelector:()=>J,resolveXPathMainWorld:()=>Q,scrollElementToPercent:()=>q,selectElementOptions:()=>X});function I(){try{return(this.tagName?.toLowerCase()??"")!=="input"?!1:String(this.type??"").toLowerCase()==="file"}catch{return!1}}function F(t){try{let e=this;if(!e||e.tagName?.toLowerCase()!=="input"||(e.type??"").toLowerCase()!=="file")return!1;let c=(()=>{try{return new DataTransfer}catch{return null}})();if(!c)return!1;let n=Array.isArray(t)?t:[];for(let o of n){if(!o)continue;let y=o.name||"upload.bin",u=o.mimeType||"application/octet-stream",a=typeof o.lastModified=="number"?o.lastModified:Date.now(),l=window.atob(o.base64??""),i=new Uint8Array(l.length);for(let s=0;s<l.length;s+=1)i[s]=l.charCodeAt(s);let f=new Blob([i],{type:u}),h=new File([f],y,{type:u,lastModified:a});c.items.add(h)}return e.files=c.files,e.dispatchEvent(new Event("input",{bubbles:!0})),e.dispatchEvent(new Event("change",{bubbles:!0})),!0}catch{return!1}}function W(t){let e=t??{};try{let c=new MouseEvent("click",{bubbles:!!e.bubbles,cancelable:!!e.cancelable,composed:!!e.composed,detail:typeof e.detail=="number"?e.detail:1,view:this?.ownerDocument?.defaultView??window});this.dispatchEvent(c)}catch{try{this.click()}catch{}}}function q(t){let e=c=>{if(typeof c=="number"&&Number.isFinite(c))return c;let n=String(c??"").trim();if(!n)return 0;let o=parseFloat(n.replace("%",""));return Number.isNaN(o)||!Number.isFinite(o)?0:o};try{let c=Math.max(0,Math.min(e(t),100)),n=this,o=n.tagName?.toLowerCase()??"";if(o==="html"||o==="body"){let h=(n.ownerDocument?.scrollingElement||n.ownerDocument?.documentElement||n.ownerDocument?.body||document.scrollingElement||document.documentElement||document.body)?.scrollHeight??document.body.scrollHeight??0,s=n.ownerDocument?.defaultView?.innerHeight??window.innerHeight,g=Math.max(0,h-s)*(c/100);return n.ownerDocument?.defaultView?.scrollTo({top:g,left:n.ownerDocument?.defaultView?.scrollX??window.scrollX??0,behavior:"smooth"}),!0}let u=n.scrollHeight??0,a=n.clientHeight??0,i=Math.max(0,u-a)*(c/100);return n.scrollTo({top:i,left:n.scrollLeft??0,behavior:"smooth"}),!0}catch{return!1}}var v=new Set(["color","date","datetime-local","month","range","time","week"]),P=new Set(["","email","number","password","search","tel","text","url"]);function T(){try{let t=this;if(!t.isConnected)return!1;let e=t.ownerDocument||document,c=e.defaultView||window;try{typeof t.focus=="function"&&t.focus()}catch{}if(t instanceof c.HTMLInputElement||t instanceof c.HTMLTextAreaElement){try{if(typeof t.select=="function")return t.select(),!0}catch{}try{let n=(t.value??"").length;if(typeof t.setSelectionRange=="function")return t.setSelectionRange(0,n),!0}catch{}return!0}if(t.isContentEditable){let n=e.getSelection?.(),o=e.createRange?.();if(n&&o)try{o.selectNodeContents(t),n.removeAllRanges(),n.addRange(o)}catch{}return!0}return!1}catch{return!1}}function O(t){let e=this;if(!e.isConnected)return{status:"error",reason:"notconnected"};let n=(e.ownerDocument||document).defaultView||window,o=t??"";try{let y=u=>{let a;if(typeof n.InputEvent=="function")try{a=new n.InputEvent("input",{bubbles:!0,composed:!0,data:u,inputType:"insertText"})}catch{a=new n.Event("input",{bubbles:!0,composed:!0})}else a=new n.Event("input",{bubbles:!0,composed:!0});e.dispatchEvent(a);let l=new n.Event("change",{bubbles:!0});e.dispatchEvent(l)};if(e instanceof n.HTMLInputElement){let u=(e.type||"").toLowerCase();if(!P.has(u)&&!v.has(u))return{status:"error",reason:`unsupported-input-type:${u}`};let a=t;if(u==="number"){let l=t.trim();if(l!==""&&Number.isNaN(Number(l)))return{status:"error",reason:"invalid-number-value"};a=l}if(o=a,v.has(u)){let l=t.trim();o=l,T.call(e);let i=n.HTMLInputElement.prototype,h=Object.getOwnPropertyDescriptor(i,"value")?.set;return typeof h=="function"?h.call(e,l):e.value=l,e._valueTracker?.setValue?.(l),e.value!==l?{status:"error",reason:"malformed-value"}:(y(l),{status:"done"})}return T.call(e),{status:"needsinput",value:a}}return e instanceof n.HTMLTextAreaElement?(T.call(e),o=t,{status:"needsinput",value:t}):e instanceof n.HTMLSelectElement?{status:"error",reason:"unsupported-element"}:e.isContentEditable?(T.call(e),o=t,{status:"needsinput",value:t}):{status:"error",reason:"unsupported-element"}}catch(y){let u="exception";if(y&&typeof y=="object"){let a=y.message;typeof a=="string"&&a.trim().length>0&&(u=`exception:${a}`)}return{status:"needsinput",value:o,reason:u}}}function V(){try{typeof this.focus=="function"&&this.focus()}catch{}}function X(t){try{if(!(this instanceof HTMLSelectElement))return[];let e=Array.isArray(t)?t:[t],c=new Set(e.map(u=>String(u??"").trim())),n=u=>{let a=(u.label||u.textContent||"").trim(),l=String(u.value??"").trim();return c.has(a)||c.has(l)};if(this.multiple)for(let u of Array.from(this.options))u.selected=n(u);else{let u=!1;for(let a of Array.from(this.options))!u&&n(a)?(a.selected=!0,this.value=a.value,u=!0):a.selected=!1}let o=new Event("input",{bubbles:!0}),y=new Event("change",{bubbles:!0});return this.dispatchEvent(o),this.dispatchEvent(y),Array.from(this.selectedOptions).map(u=>u.value)}catch{return[]}}function Y(){try{let t=this;if(!t.isConnected)return!1;let e=t.ownerDocument?.defaultView?.getComputedStyle(t)??window.getComputedStyle(t);if(!e||e.display==="none"||e.visibility==="hidden")return!1;let c=parseFloat(e.opacity??"1");if(!Number.isFinite(c)||c===0)return!1;let n=t.getBoundingClientRect();return!(!n||Math.max(n.width,n.height)===0||t.getClientRects().length===0)}catch{return!1}}function B(){try{let t=this;if((t.tagName||"").toLowerCase()==="input"){let n=t.type?.toLowerCase()??"";if(n==="checkbox"||n==="radio")return!!t.checked}let c=t.getAttribute?.("aria-checked");return c!=null?c==="true":!1}catch{return!1}}function $(){try{let t=this,e=(t.tagName||"").toLowerCase();return e==="input"||e==="textarea"||e==="select"?String(t.value??""):t.isContentEditable?String(t.textContent??""):""}catch{return""}}function z(){try{return String(this.textContent??"")}catch{return""}}function U(){try{return String(this.innerHTML??"")}catch{return""}}function j(){try{let t=this,e=t.innerText;if(typeof e=="string"&&e.length>0)return e;let c=t.textContent;return typeof c=="string"?c:""}catch{return""}}var N=t=>{let e=Number(t??0);return!Number.isFinite(e)||e<0?0:Math.floor(e)},M=(t,e)=>{if(!t)return[];let c=new WeakSet,n=new Set,o=[],y=[document],u=a=>{if(!(!a||c.has(a)||o.length>=e)){c.add(a);try{let l=a.querySelectorAll(t);for(let i of l)if(!n.has(i)&&(n.add(i),o.push(i),o.length>=e))return}catch{}try{let i=(a instanceof Document?a:a.host?.ownerDocument??document).createTreeWalker(a,NodeFilter.SHOW_ELEMENT),f;for(;f=i.nextNode();){if(!(f instanceof Element))continue;let h=f.shadowRoot;h&&y.push(h)}}catch{}}};for(;y.length&&o.length<e;){let a=y.shift();a&&u(a)}return o};function K(t,e){let c=String(t??"").trim();if(!c)return null;let n=N(e);return M(c,n+1)[n]??null}function G(t,e){let c=String(t??"").trim();if(!c)return null;let n=N(e),o=window.__stagehandV3__;if(!o||typeof o.getClosedRoot!="function")return M(c,n+1)[n]??null;let y=h=>{try{return o.getClosedRoot(h)??null}catch{return null}},u=new WeakSet,a=new Set,l=[],i=[document],f=h=>{if(!(!h||u.has(h)||l.length>=n+1)){u.add(h);try{let s=h.querySelectorAll(c);for(let d of s)if(!a.has(d)&&(a.add(d),l.push(d),l.length>=n+1))return}catch{}try{let d=(h instanceof Document?h:h.host?.ownerDocument??document).createTreeWalker(h,NodeFilter.SHOW_ELEMENT),g;for(;g=d.nextNode();){if(!(g instanceof Element))continue;let w=g.shadowRoot;w&&i.push(w);let E=y(g);E&&i.push(E)}}catch{}}};for(;i.length&&l.length<n+1;){let h=i.shift();h&&f(h)}return l[n]??null}function J(t,e){let c=String(t??"");if(!c)return null;let n=c.toLowerCase(),o=N(e),y=new Set(["SCRIPT","STYLE","TEMPLATE","NOSCRIPT","HEAD","TITLE","LINK","META","HTML","BODY"]),u=r=>{if(!r)return!1;let p=r.tagName?.toUpperCase()??"";return y.has(p)},a=r=>{try{if(u(r))return"";let p=r.innerText;if(typeof p=="string"&&p.trim())return p.trim()}catch{}try{let p=r.textContent;if(typeof p=="string")return p.trim()}catch{}return""},l=r=>{let p=a(r);return!!p&&p.toLowerCase().includes(n)},i=window.__stagehandV3__,f=i&&typeof i.getClosedRoot=="function"?r=>{try{return i.getClosedRoot(r)??null}catch{return null}}:r=>null,h=new WeakSet,s=[],d=[],g=r=>{!r||h.has(r)||(h.add(r),s.push(r))},w=r=>{try{return(r instanceof Document?r:r?.ownerDocument??document).createTreeWalker(r,NodeFilter.SHOW_ELEMENT)}catch{return null}};for(g(document);s.length;){let r=s.shift();if(!r)continue;r instanceof Element&&l(r)&&d.push({element:r,tag:r.tagName??"",id:r.id??"",className:r.className??"",text:a(r)});let p=w(r);if(!p)continue;let x;for(;x=p.nextNode();){if(!(x instanceof Element))continue;l(x)&&d.push({element:x,tag:x.tagName??"",id:x.id??"",className:x.className??"",text:a(x)});let b=x.shadowRoot;b&&g(b);let S=f(x);S&&g(S)}}let E=[];for(let r of d){let p=r.element,x=!1;for(let b of d)if(r!==b)try{if(p.contains(b.element)){x=!0;break}}catch{}x||E.push(r)}return E[o]?.element??null}function Q(t,e){let c=String(t??"").trim();if(!c)return null;let n=N(e),o=window.__stagehandV3__;if(n===0){try{if(o&&typeof o.resolveSimpleXPath=="function"){let s=o.resolveSimpleXPath(c);if(s)return s}}catch{}try{return document.evaluate(c,document,null,XPathResult.FIRST_ORDERED_NODE_TYPE,null).singleNodeValue}catch{}}let u=(s=>{let d=String(s||"").trim();if(!d)return[];let g=d.replace(/^xpath=/i,""),w=[],E=0;for(;E<g.length;){let m="child";g.startsWith("//",E)?(m="desc",E+=2):g[E]==="/"&&(m="child",E+=1);let r=E;for(;E<g.length&&g[E]!=="/";)E+=1;let p=g.slice(r,E).trim();if(!p)continue;let x=p.match(/^(.*?)(\\[(\\d+)\\])?$/u),b=(x?.[1]??p).trim(),S=x?.[3]?Math.max(1,Number(x[3])):null,C=b===""?"*":b.toLowerCase();w.push({axis:m,tag:C,index:S})}return w})(c);if(!u.length)return null;let a=o&&typeof o.getClosedRoot=="function"?s=>{try{return o.getClosedRoot(s)??null}catch{return null}}:s=>null,l=s=>{let d=[];if(!s)return d;if(s instanceof Document)return s.documentElement&&d.push(s.documentElement),d;if(s instanceof ShadowRoot||s instanceof DocumentFragment)return d.push(...Array.from(s.children??[])),d;if(s instanceof Element){d.push(...Array.from(s.children??[]));let g=s.shadowRoot;g&&d.push(...Array.from(g.children??[]));let w=a(s);return w&&d.push(...Array.from(w.children??[])),d}return d},i=s=>{let d=[],g=new Set,w=[...l(s)];for(;w.length;){let E=w.shift();!E||g.has(E)||(g.add(E),d.push(E),w.push(...l(E)))}return d},f=[document];for(let s of u){let d=[],g=new Set;for(let w of f){if(!w)continue;let E=s.axis==="child"?l(w):i(w);if(!E.length)continue;let m=E.filter(r=>r instanceof Element?s.tag==="*"?!0:r.localName===s.tag:!1);if(s.index!=null){let r=s.index-1,p=r>=0&&r<m.length?m[r]:null;p&&!g.has(p)&&(g.add(p),d.push(p))}else for(let r of m)g.has(r)||(g.add(r),d.push(r))}if(!d.length)return null;f=d}return f[n]??null}function Z(t){let e=String(t??"").trim();if(!e)return 0;let c=new WeakSet,n=o=>{if(!o||c.has(o))return 0;c.add(o);let y=0;try{let u=o;typeof u.querySelectorAll=="function"&&(y+=u.querySelectorAll(e).length)}catch{}try{let a=(o instanceof Document?o:o?.ownerDocument??document).createTreeWalker(o,NodeFilter.SHOW_ELEMENT),l;for(;l=a.nextNode();)l instanceof Element&&l.shadowRoot&&(y+=n(l.shadowRoot))}catch{}return y};try{return n(document)}catch{try{return document.querySelectorAll(e).length}catch{return 0}}}function ee(t){let e=String(t??"").trim();if(!e)return 0;let c=window.__stagehandV3__;if(!c||typeof c.getClosedRoot!="function")try{return document.querySelectorAll(e).length}catch{return 0}let n=new WeakSet,o=[],y=l=>{!l||n.has(l)||(n.add(l),o.push(l))};y(document);let u=0,a=l=>{let i=l.shadowRoot;i&&y(i);try{let f=c.getClosedRoot(l);f&&y(f)}catch{}};for(;o.length;){let l=o.shift();if(l){try{let i=l;typeof i.querySelectorAll=="function"&&(u+=i.querySelectorAll(e).length)}catch{}try{let f=(l instanceof Document?l:l instanceof ShadowRoot?l.host?.ownerDocument??document:l.ownerDocument??document).createTreeWalker(l,NodeFilter.SHOW_ELEMENT),h;for(;h=f.nextNode();)h instanceof Element&&a(h)}catch{}}}return u}function te(t){let e=String(t??"");if(!e)return{count:0,sample:[],error:null};let c=e.toLowerCase(),n=new Set(["SCRIPT","STYLE","TEMPLATE","NOSCRIPT","HEAD","TITLE","LINK","META","HTML","BODY"]),o=m=>{if(!m)return!1;let r=m.tagName?.toUpperCase()??"";return n.has(r)},y=m=>{try{if(o(m))return"";let r=m.innerText;if(typeof r=="string"&&r.trim())return r.trim()}catch{}try{let r=m.textContent;if(typeof r=="string")return r.trim()}catch{}return""},u=m=>{let r=y(m);return!!r&&r.toLowerCase().includes(c)},a=window.__stagehandV3__,l=a&&typeof a.getClosedRoot=="function"?m=>{try{return a.getClosedRoot(m)??null}catch{return null}}:m=>null,i=new WeakSet,f=[],h=m=>{!m||i.has(m)||(i.add(m),f.push(m))},s=m=>{try{return(m instanceof Document?m:m?.ownerDocument??document).createTreeWalker(m,NodeFilter.SHOW_ELEMENT)}catch{return null}},d=[];for(h(document);f.length;){let m=f.shift();if(!m)continue;m instanceof Element&&u(m)&&d.push({element:m,tag:m.tagName??"",id:m.id??"",className:m.className??"",text:y(m)});let r=s(m);if(!r)continue;let p;for(;p=r.nextNode();){if(!(p instanceof Element))continue;u(p)&&d.push({element:p,tag:p.tagName??"",id:p.id??"",className:p.className??"",text:y(p)});let x=p.shadowRoot;x&&h(x);let b=l(p);b&&h(b)}}let g=[];for(let m of d){let r=m.element,p=!1;for(let x of d)if(m!==x)try{if(r.contains(x.element)){p=!0;break}}catch{}p||g.push(m)}let w=g.length,E=g.slice(0,5).map(m=>({tag:m.tag,id:m.id,class:m.className,text:m.text}));return{count:w,sample:E,error:null}}function ne(t){let e=String(t??"").trim();if(!e)return 0;let n=(i=>{let f=String(i||"").trim().replace(/^xpath=/i,"");if(!f)return[];let h=[],s=0;for(;s<f.length;){let d="child";f.startsWith("//",s)?(d="desc",s+=2):f[s]==="/"&&(d="child",s+=1);let g=s;for(;s<f.length&&f[s]!=="/";)s+=1;let w=f.slice(g,s).trim();if(!w)continue;let E=w.match(/^(.*?)(\\[(\\d+)\\])?$/u),m=(E?.[1]??w).trim(),r=E?.[3]?Math.max(1,Number(E[3])):null,p=m===""?"*":m.toLowerCase();h.push({axis:d,tag:p,index:r})}return h})(e);if(!n.length)return 0;let o=window.__stagehandV3__,y=o&&typeof o.getClosedRoot=="function"?i=>{try{return o.getClosedRoot(i)??null}catch{return null}}:i=>null,u=i=>{let f=[];if(!i)return f;if(i instanceof Document)return i.documentElement&&f.push(i.documentElement),f;if(i instanceof ShadowRoot||i instanceof DocumentFragment)return f.push(...Array.from(i.children??[])),f;if(i instanceof Element){f.push(...Array.from(i.children??[]));let h=i.shadowRoot;h&&f.push(...Array.from(h.children??[]));let s=y(i);return s&&f.push(...Array.from(s.children??[])),f}return f},a=i=>{let f=[],h=new Set,s=[...u(i)];for(;s.length;){let d=s.shift();!d||h.has(d)||(h.add(d),f.push(d),s.push(...u(d)))}return f},l=[document];for(let i of n){let f=[],h=new Set;for(let s of l){if(!s)continue;let d=i.axis==="child"?u(s):a(s);if(!d.length)continue;let g=d.filter(w=>w instanceof Element?i.tag==="*"?!0:w.localName===i.tag:!1);if(i.index!=null){let w=i.index-1,E=w>=0&&w<g.length?g[w]:null;E&&!h.has(E)&&(h.add(E),f.push(E))}else for(let w of g)h.has(w)||(h.add(w),f.push(w))}if(!f.length)return 0;l=f}return l.length}return _(oe);})();\n  globalThis.__stagehandLocatorScripts = __stagehandLocatorScriptsFactory;\n}';
        locatorScriptSources = {
            "assignFilePayloadsToInputElement": 'function k(t){try{let e=this;if(!e||e.tagName?.toLowerCase()!=="input"||(e.type??"").toLowerCase()!=="file")return!1;let i=(()=>{try{return new DataTransfer}catch{return null}})();if(!i)return!1;let n=Array.isArray(t)?t:[];for(let s of n){if(!s)continue;let y=s.name||"upload.bin",u=s.mimeType||"application/octet-stream",a=typeof s.lastModified=="number"?s.lastModified:Date.now(),l=window.atob(s.base64??""),c=new Uint8Array(l.length);for(let r=0;r<l.length;r+=1)c[r]=l.charCodeAt(r);let f=new Blob([c],{type:u}),h=new File([f],y,{type:u,lastModified:a});i.items.add(h)}return e.files=i.files,e.dispatchEvent(new Event("input",{bubbles:!0})),e.dispatchEvent(new Event("change",{bubbles:!0})),!0}catch{return!1}}',
            "countCssMatchesPierce": 'function K(t){let e=String(t??"").trim();if(!e)return 0;let i=window.__stagehandV3__;if(!i||typeof i.getClosedRoot!="function")try{return document.querySelectorAll(e).length}catch{return 0}let n=new WeakSet,s=[],y=l=>{!l||n.has(l)||(n.add(l),s.push(l))};y(document);let u=0,a=l=>{let c=l.shadowRoot;c&&y(c);try{let f=i.getClosedRoot(l);f&&y(f)}catch{}};for(;s.length;){let l=s.shift();if(l){try{let c=l;typeof c.querySelectorAll=="function"&&(u+=c.querySelectorAll(e).length)}catch{}try{let f=(l instanceof Document?l:l instanceof ShadowRoot?l.host?.ownerDocument??document:l.ownerDocument??document).createTreeWalker(l,NodeFilter.SHOW_ELEMENT),h;for(;h=f.nextNode();)h instanceof Element&&a(h)}catch{}}}return u}',
            "countCssMatchesPrimary": 'function j(t){let e=String(t??"").trim();if(!e)return 0;let i=new WeakSet,n=s=>{if(!s||i.has(s))return 0;i.add(s);let y=0;try{let u=s;typeof u.querySelectorAll=="function"&&(y+=u.querySelectorAll(e).length)}catch{}try{let a=(s instanceof Document?s:s?.ownerDocument??document).createTreeWalker(s,NodeFilter.SHOW_ELEMENT),l;for(;l=a.nextNode();)l instanceof Element&&l.shadowRoot&&(y+=n(l.shadowRoot))}catch{}return y};try{return n(document)}catch{try{return document.querySelectorAll(e).length}catch{return 0}}}',
            "countTextMatches": 'function G(t){let e=String(t??"");if(!e)return{count:0,sample:[],error:null};let i=e.toLowerCase(),n=new Set(["SCRIPT","STYLE","TEMPLATE","NOSCRIPT","HEAD","TITLE","LINK","META","HTML","BODY"]),s=m=>{if(!m)return!1;let o=m.tagName?.toUpperCase()??"";return n.has(o)},y=m=>{try{if(s(m))return"";let o=m.innerText;if(typeof o=="string"&&o.trim())return o.trim()}catch{}try{let o=m.textContent;if(typeof o=="string")return o.trim()}catch{}return""},u=m=>{let o=y(m);return!!o&&o.toLowerCase().includes(i)},a=window.__stagehandV3__,l=a&&typeof a.getClosedRoot=="function"?m=>{try{return a.getClosedRoot(m)??null}catch{return null}}:m=>null,c=new WeakSet,f=[],h=m=>{!m||c.has(m)||(c.add(m),f.push(m))},r=m=>{try{return(m instanceof Document?m:m?.ownerDocument??document).createTreeWalker(m,NodeFilter.SHOW_ELEMENT)}catch{return null}},d=[];for(h(document);f.length;){let m=f.shift();if(!m)continue;m instanceof Element&&u(m)&&d.push({element:m,tag:m.tagName??"",id:m.id??"",className:m.className??"",text:y(m)});let o=r(m);if(!o)continue;let p;for(;p=o.nextNode();){if(!(p instanceof Element))continue;u(p)&&d.push({element:p,tag:p.tagName??"",id:p.id??"",className:p.className??"",text:y(p)});let x=p.shadowRoot;x&&h(x);let b=l(p);b&&h(b)}}let g=[];for(let m of d){let o=m.element,p=!1;for(let x of d)if(m!==x)try{if(o.contains(x.element)){p=!0;break}}catch{}p||g.push(m)}let w=g.length,E=g.slice(0,5).map(m=>({tag:m.tag,id:m.id,class:m.className,text:m.text}));return{count:w,sample:E,error:null}}',
            "countXPathMatchesMainWorld": 'function J(t){let e=String(t??"").trim();if(!e)return 0;let n=(c=>{let f=String(c||"").trim().replace(/^xpath=/i,"");if(!f)return[];let h=[],r=0;for(;r<f.length;){let d="child";f.startsWith("//",r)?(d="desc",r+=2):f[r]==="/"&&(d="child",r+=1);let g=r;for(;r<f.length&&f[r]!=="/";)r+=1;let w=f.slice(g,r).trim();if(!w)continue;let E=w.match(/^(.*?)(\\[(\\d+)\\])?$/u),m=(E?.[1]??w).trim(),o=E?.[3]?Math.max(1,Number(E[3])):null,p=m===""?"*":m.toLowerCase();h.push({axis:d,tag:p,index:o})}return h})(e);if(!n.length)return 0;let s=window.__stagehandV3__,y=s&&typeof s.getClosedRoot=="function"?c=>{try{return s.getClosedRoot(c)??null}catch{return null}}:c=>null,u=c=>{let f=[];if(!c)return f;if(c instanceof Document)return c.documentElement&&f.push(c.documentElement),f;if(c instanceof ShadowRoot||c instanceof DocumentFragment)return f.push(...Array.from(c.children??[])),f;if(c instanceof Element){f.push(...Array.from(c.children??[]));let h=c.shadowRoot;h&&f.push(...Array.from(h.children??[]));let r=y(c);return r&&f.push(...Array.from(r.children??[])),f}return f},a=c=>{let f=[],h=new Set,r=[...u(c)];for(;r.length;){let d=r.shift();!d||h.has(d)||(h.add(d),f.push(d),r.push(...u(d)))}return f},l=[document];for(let c of n){let f=[],h=new Set;for(let r of l){if(!r)continue;let d=c.axis==="child"?u(r):a(r);if(!d.length)continue;let g=d.filter(w=>w instanceof Element?c.tag==="*"?!0:w.localName===c.tag:!1);if(c.index!=null){let w=c.index-1,E=w>=0&&w<g.length?g[w]:null;E&&!h.has(E)&&(h.add(E),f.push(E))}else for(let w of g)h.has(w)||(h.add(w),f.push(w))}if(!f.length)return 0;l=f}return l.length}',
            "dispatchDomClick": 'function H(t){let e=t??{};try{let i=new MouseEvent("click",{bubbles:!!e.bubbles,cancelable:!!e.cancelable,composed:!!e.composed,detail:typeof e.detail=="number"?e.detail:1,view:this?.ownerDocument?.defaultView??window});this.dispatchEvent(i)}catch{try{this.click()}catch{}}}',
            "ensureFileInputElement": 'function R(){try{return(this.tagName?.toLowerCase()??"")!=="input"?!1:String(this.type??"").toLowerCase()==="file"}catch{return!1}}',
            "fillElementValue": 'function A(t){let e=this;if(!e.isConnected)return{status:"error",reason:"notconnected"};let n=(e.ownerDocument||document).defaultView||window,s=t??"";try{let y=u=>{let a;if(typeof n.InputEvent=="function")try{a=new n.InputEvent("input",{bubbles:!0,composed:!0,data:u,inputType:"insertText"})}catch{a=new n.Event("input",{bubbles:!0,composed:!0})}else a=new n.Event("input",{bubbles:!0,composed:!0});e.dispatchEvent(a);let l=new n.Event("change",{bubbles:!0});e.dispatchEvent(l)};if(e instanceof n.HTMLInputElement){let u=(e.type||"").toLowerCase();if(!C.has(u)&&!L.has(u))return{status:"error",reason:`unsupported-input-type:${u}`};let a=t;if(u==="number"){let l=t.trim();if(l!==""&&Number.isNaN(Number(l)))return{status:"error",reason:"invalid-number-value"};a=l}if(s=a,L.has(u)){let l=t.trim();s=l,S.call(e);let c=n.HTMLInputElement.prototype,h=Object.getOwnPropertyDescriptor(c,"value")?.set;return typeof h=="function"?h.call(e,l):e.value=l,e._valueTracker?.setValue?.(l),e.value!==l?{status:"error",reason:"malformed-value"}:(y(l),{status:"done"})}return S.call(e),{status:"needsinput",value:a}}return e instanceof n.HTMLTextAreaElement?(S.call(e),s=t,{status:"needsinput",value:t}):e instanceof n.HTMLSelectElement?{status:"error",reason:"unsupported-element"}:e.isContentEditable?(S.call(e),s=t,{status:"needsinput",value:t}):{status:"error",reason:"unsupported-element"}}catch(y){let u="exception";if(y&&typeof y=="object"){let a=y.message;typeof a=="string"&&a.trim().length>0&&(u=`exception:${a}`)}return{status:"needsinput",value:s,reason:u}}}',
            "focusElement": 'function _(){try{typeof this.focus=="function"&&this.focus()}catch{}}',
            "isElementChecked": 'function W(){try{let t=this;if((t.tagName||"").toLowerCase()==="input"){let n=t.type?.toLowerCase()??"";if(n==="checkbox"||n==="radio")return!!t.checked}let i=t.getAttribute?.("aria-checked");return i!=null?i==="true":!1}catch{return!1}}',
            "isElementVisible": 'function F(){try{let t=this;if(!t.isConnected)return!1;let e=t.ownerDocument?.defaultView?.getComputedStyle(t)??window.getComputedStyle(t);if(!e||e.display==="none"||e.visibility==="hidden")return!1;let i=parseFloat(e.opacity??"1");if(!Number.isFinite(i)||i===0)return!1;let n=t.getBoundingClientRect();return!(!n||Math.max(n.width,n.height)===0||t.getClientRects().length===0)}catch{return!1}}',
            "prepareElementForTyping": 'function S(){try{let t=this;if(!t.isConnected)return!1;let e=t.ownerDocument||document,i=e.defaultView||window;try{typeof t.focus=="function"&&t.focus()}catch{}if(t instanceof i.HTMLInputElement||t instanceof i.HTMLTextAreaElement){try{if(typeof t.select=="function")return t.select(),!0}catch{}try{let n=(t.value??"").length;if(typeof t.setSelectionRange=="function")return t.setSelectionRange(0,n),!0}catch{}return!0}if(t.isContentEditable){let n=e.getSelection?.(),s=e.createRange?.();if(n&&s)try{s.selectNodeContents(t),n.removeAllRanges(),n.addRange(s)}catch{}return!0}return!1}catch{return!1}}',
            "readElementInnerHTML": 'function O(){try{return String(this.innerHTML??"")}catch{return""}}',
            "readElementInnerText": 'function V(){try{let t=this,e=t.innerText;if(typeof e=="string"&&e.length>0)return e;let i=t.textContent;return typeof i=="string"?i:""}catch{return""}}',
            "readElementInputValue": 'function q(){try{let t=this,e=(t.tagName||"").toLowerCase();return e==="input"||e==="textarea"||e==="select"?String(t.value??""):t.isContentEditable?String(t.textContent??""):""}catch{return""}}',
            "readElementTextContent": 'function P(){try{return String(this.textContent??"")}catch{return""}}',
            "resolveCssSelector": 'function Y(t,e){let i=String(t??"").trim();if(!i)return null;let n=N(e);return v(i,n+1)[n]??null}',
            "resolveCssSelectorPierce": 'function B(t,e){let i=String(t??"").trim();if(!i)return null;let n=N(e),s=window.__stagehandV3__;if(!s||typeof s.getClosedRoot!="function")return v(i,n+1)[n]??null;let y=h=>{try{return s.getClosedRoot(h)??null}catch{return null}},u=new WeakSet,a=new Set,l=[],c=[document],f=h=>{if(!(!h||u.has(h)||l.length>=n+1)){u.add(h);try{let r=h.querySelectorAll(i);for(let d of r)if(!a.has(d)&&(a.add(d),l.push(d),l.length>=n+1))return}catch{}try{let d=(h instanceof Document?h:h.host?.ownerDocument??document).createTreeWalker(h,NodeFilter.SHOW_ELEMENT),g;for(;g=d.nextNode();){if(!(g instanceof Element))continue;let w=g.shadowRoot;w&&c.push(w);let E=y(g);E&&c.push(E)}}catch{}}};for(;c.length&&l.length<n+1;){let h=c.shift();h&&f(h)}return l[n]??null}',
            "resolveTextSelector": 'function $(t,e){let i=String(t??"");if(!i)return null;let n=i.toLowerCase(),s=N(e),y=new Set(["SCRIPT","STYLE","TEMPLATE","NOSCRIPT","HEAD","TITLE","LINK","META","HTML","BODY"]),u=o=>{if(!o)return!1;let p=o.tagName?.toUpperCase()??"";return y.has(p)},a=o=>{try{if(u(o))return"";let p=o.innerText;if(typeof p=="string"&&p.trim())return p.trim()}catch{}try{let p=o.textContent;if(typeof p=="string")return p.trim()}catch{}return""},l=o=>{let p=a(o);return!!p&&p.toLowerCase().includes(n)},c=window.__stagehandV3__,f=c&&typeof c.getClosedRoot=="function"?o=>{try{return c.getClosedRoot(o)??null}catch{return null}}:o=>null,h=new WeakSet,r=[],d=[],g=o=>{!o||h.has(o)||(h.add(o),r.push(o))},w=o=>{try{return(o instanceof Document?o:o?.ownerDocument??document).createTreeWalker(o,NodeFilter.SHOW_ELEMENT)}catch{return null}};for(g(document);r.length;){let o=r.shift();if(!o)continue;o instanceof Element&&l(o)&&d.push({element:o,tag:o.tagName??"",id:o.id??"",className:o.className??"",text:a(o)});let p=w(o);if(!p)continue;let x;for(;x=p.nextNode();){if(!(x instanceof Element))continue;l(x)&&d.push({element:x,tag:x.tagName??"",id:x.id??"",className:x.className??"",text:a(x)});let b=x.shadowRoot;b&&g(b);let T=f(x);T&&g(T)}}let E=[];for(let o of d){let p=o.element,x=!1;for(let b of d)if(o!==b)try{if(p.contains(b.element)){x=!0;break}}catch{}x||E.push(o)}return E[s]?.element??null}',
            "resolveXPathMainWorld": 'function z(t,e){let i=String(t??"").trim();if(!i)return null;let n=N(e),s=window.__stagehandV3__;if(n===0){try{if(s&&typeof s.resolveSimpleXPath=="function"){let r=s.resolveSimpleXPath(i);if(r)return r}}catch{}try{return document.evaluate(i,document,null,XPathResult.FIRST_ORDERED_NODE_TYPE,null).singleNodeValue}catch{}}let u=(r=>{let d=String(r||"").trim();if(!d)return[];let g=d.replace(/^xpath=/i,""),w=[],E=0;for(;E<g.length;){let m="child";g.startsWith("//",E)?(m="desc",E+=2):g[E]==="/"&&(m="child",E+=1);let o=E;for(;E<g.length&&g[E]!=="/";)E+=1;let p=g.slice(o,E).trim();if(!p)continue;let x=p.match(/^(.*?)(\\[(\\d+)\\])?$/u),b=(x?.[1]??p).trim(),T=x?.[3]?Math.max(1,Number(x[3])):null,M=b===""?"*":b.toLowerCase();w.push({axis:m,tag:M,index:T})}return w})(i);if(!u.length)return null;let a=s&&typeof s.getClosedRoot=="function"?r=>{try{return s.getClosedRoot(r)??null}catch{return null}}:r=>null,l=r=>{let d=[];if(!r)return d;if(r instanceof Document)return r.documentElement&&d.push(r.documentElement),d;if(r instanceof ShadowRoot||r instanceof DocumentFragment)return d.push(...Array.from(r.children??[])),d;if(r instanceof Element){d.push(...Array.from(r.children??[]));let g=r.shadowRoot;g&&d.push(...Array.from(g.children??[]));let w=a(r);return w&&d.push(...Array.from(w.children??[])),d}return d},c=r=>{let d=[],g=new Set,w=[...l(r)];for(;w.length;){let E=w.shift();!E||g.has(E)||(g.add(E),d.push(E),w.push(...l(E)))}return d},f=[document];for(let r of u){let d=[],g=new Set;for(let w of f){if(!w)continue;let E=r.axis==="child"?l(w):c(w);if(!E.length)continue;let m=E.filter(o=>o instanceof Element?r.tag==="*"?!0:o.localName===r.tag:!1);if(r.index!=null){let o=r.index-1,p=o>=0&&o<m.length?m[o]:null;p&&!g.has(p)&&(g.add(p),d.push(p))}else for(let o of m)g.has(o)||(g.add(o),d.push(o))}if(!d.length)return null;f=d}return f[n]??null}',
            "scrollElementToPercent": 'function D(t){let e=i=>{if(typeof i=="number"&&Number.isFinite(i))return i;let n=String(i??"").trim();if(!n)return 0;let s=parseFloat(n.replace("%",""));return Number.isNaN(s)||!Number.isFinite(s)?0:s};try{let i=Math.max(0,Math.min(e(t),100)),n=this,s=n.tagName?.toLowerCase()??"";if(s==="html"||s==="body"){let h=(n.ownerDocument?.scrollingElement||n.ownerDocument?.documentElement||n.ownerDocument?.body||document.scrollingElement||document.documentElement||document.body)?.scrollHeight??document.body.scrollHeight??0,r=n.ownerDocument?.defaultView?.innerHeight??window.innerHeight,g=Math.max(0,h-r)*(i/100);return n.ownerDocument?.defaultView?.scrollTo({top:g,left:n.ownerDocument?.defaultView?.scrollX??window.scrollX??0,behavior:"smooth"}),!0}let u=n.scrollHeight??0,a=n.clientHeight??0,c=Math.max(0,u-a)*(i/100);return n.scrollTo({top:c,left:n.scrollLeft??0,behavior:"smooth"}),!0}catch{return!1}}',
            "selectElementOptions": 'function I(t){try{if(!(this instanceof HTMLSelectElement))return[];let e=Array.isArray(t)?t:[t],i=new Set(e.map(u=>String(u??"").trim())),n=u=>{let a=(u.label||u.textContent||"").trim(),l=String(u.value??"").trim();return i.has(a)||i.has(l)};if(this.multiple)for(let u of Array.from(this.options))u.selected=n(u);else{let u=!1;for(let a of Array.from(this.options))!u&&n(a)?(a.selected=!0,this.value=a.value,u=!0):a.selected=!1}let s=new Event("input",{bubbles:!0}),y=new Event("change",{bubbles:!0});return this.dispatchEvent(s),this.dispatchEvent(y),Array.from(this.selectedOptions).map(u=>u.value)}catch{return[]}}'
        };
        locatorScriptGlobalRefs = {
            "assignFilePayloadsToInputElement": "globalThis.__stagehandLocatorScripts.assignFilePayloadsToInputElement",
            "countCssMatchesPierce": "globalThis.__stagehandLocatorScripts.countCssMatchesPierce",
            "countCssMatchesPrimary": "globalThis.__stagehandLocatorScripts.countCssMatchesPrimary",
            "countTextMatches": "globalThis.__stagehandLocatorScripts.countTextMatches",
            "countXPathMatchesMainWorld": "globalThis.__stagehandLocatorScripts.countXPathMatchesMainWorld",
            "dispatchDomClick": "globalThis.__stagehandLocatorScripts.dispatchDomClick",
            "ensureFileInputElement": "globalThis.__stagehandLocatorScripts.ensureFileInputElement",
            "fillElementValue": "globalThis.__stagehandLocatorScripts.fillElementValue",
            "focusElement": "globalThis.__stagehandLocatorScripts.focusElement",
            "isElementChecked": "globalThis.__stagehandLocatorScripts.isElementChecked",
            "isElementVisible": "globalThis.__stagehandLocatorScripts.isElementVisible",
            "prepareElementForTyping": "globalThis.__stagehandLocatorScripts.prepareElementForTyping",
            "readElementInnerHTML": "globalThis.__stagehandLocatorScripts.readElementInnerHTML",
            "readElementInnerText": "globalThis.__stagehandLocatorScripts.readElementInnerText",
            "readElementInputValue": "globalThis.__stagehandLocatorScripts.readElementInputValue",
            "readElementTextContent": "globalThis.__stagehandLocatorScripts.readElementTextContent",
            "resolveCssSelector": "globalThis.__stagehandLocatorScripts.resolveCssSelector",
            "resolveCssSelectorPierce": "globalThis.__stagehandLocatorScripts.resolveCssSelectorPierce",
            "resolveTextSelector": "globalThis.__stagehandLocatorScripts.resolveTextSelector",
            "resolveXPathMainWorld": "globalThis.__stagehandLocatorScripts.resolveXPathMainWorld",
            "scrollElementToPercent": "globalThis.__stagehandLocatorScripts.scrollElementToPercent",
            "selectElementOptions": "globalThis.__stagehandLocatorScripts.selectElementOptions"
        };
    }
});
// lib/v3/understudy/selectorResolver.ts
var FrameSelectorResolver;
var init_selectorResolver = __esm({
    "lib/v3/understudy/selectorResolver.ts" () {
        init_locatorScripts_generated();
        init_logger();
        init_executionContextRegistry();
        FrameSelectorResolver = class {
            constructor(frame){
                this.frame = frame;
            }
            static parseSelector(raw) {
                const trimmed = raw.trim();
                const isText = /^text=/i.test(trimmed);
                const looksLikeXPath = /^xpath=/i.test(trimmed) || trimmed.startsWith("/") || trimmed.startsWith("(");
                const isCssPrefixed = /^css=/i.test(trimmed);
                if (isText) {
                    let value = trimmed.replace(/^text=/i, "").trim();
                    if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
                        value = value.slice(1, -1);
                    }
                    return {
                        kind: "text",
                        value
                    };
                }
                if (looksLikeXPath) {
                    const value = trimmed.replace(/^xpath=/i, "");
                    return {
                        kind: "xpath",
                        value
                    };
                }
                let selector = isCssPrefixed ? trimmed.replace(/^css=/i, "") : trimmed;
                if (selector.includes(">>")) {
                    selector = selector.split(">>").map((piece)=>piece.trim()).filter(Boolean).join(" ");
                }
                return {
                    kind: "css",
                    value: selector
                };
            }
            resolveFirst(query) {
                return __async(this, null, function*() {
                    return this.resolveAtIndex(query, 0);
                });
            }
            resolveAll(_0) {
                return __async(this, arguments, function*(query, { limit = Infinity } = {}) {
                    if (limit <= 0) return [];
                    switch(query.kind){
                        case "css":
                            return this.resolveCss(query.value, limit);
                        case "text":
                            return this.resolveText(query.value, limit);
                        case "xpath":
                            return this.resolveXPath(query.value, limit);
                        default:
                            return [];
                    }
                });
            }
            count(query) {
                return __async(this, null, function*() {
                    switch(query.kind){
                        case "css":
                            return this.countCss(query.value);
                        case "text":
                            return this.countText(query.value);
                        case "xpath":
                            return this.countXPath(query.value);
                        default:
                            return 0;
                    }
                });
            }
            resolveAtIndex(query, index) {
                return __async(this, null, function*() {
                    var _a;
                    if (index < 0 || !Number.isFinite(index)) return null;
                    const results = yield this.resolveAll(query, {
                        limit: index + 1
                    });
                    return (_a = results[index]) != null ? _a : null;
                });
            }
            buildLocatorInvocation(name, args) {
                const call = `${locatorScriptGlobalRefs[name]}(${args.join(", ")})`;
                return `(() => { ${locatorScriptBootstrap}; return ${call}; })()`;
            }
            resolveCss(selector, limit) {
                return __async(this, null, function*() {
                    if (limit <= 0) return [];
                    const session = this.frame.session;
                    const { executionContextId } = yield session.send("Page.createIsolatedWorld", {
                        frameId: this.frame.frameId,
                        worldName: "v3-world"
                    });
                    const ctxId = yield executionContexts.waitForMainWorld(session, this.frame.frameId, 1e3);
                    const results = [];
                    let loggedFallback = false;
                    for(let index = 0; index < limit; index += 1){
                        const primaryExpr = this.buildLocatorInvocation("resolveCssSelector", [
                            JSON.stringify(selector),
                            String(index)
                        ]);
                        const primary = yield this.evaluateElement(primaryExpr, executionContextId);
                        if (primary) {
                            results.push(primary);
                            continue;
                        }
                        if (!loggedFallback) {
                            v3Logger({
                                category: "locator",
                                message: "css pierce-fallback",
                                level: 2,
                                auxiliary: {
                                    frameId: {
                                        value: String(this.frame.frameId),
                                        type: "string"
                                    },
                                    selector: {
                                        value: selector,
                                        type: "string"
                                    }
                                }
                            });
                            loggedFallback = true;
                        }
                        const fallbackExpr = this.buildLocatorInvocation("resolveCssSelectorPierce", [
                            JSON.stringify(selector),
                            String(index)
                        ]);
                        const fallback = yield this.evaluateElement(fallbackExpr, ctxId);
                        if (fallback) {
                            results.push(fallback);
                            continue;
                        }
                        break;
                    }
                    return results;
                });
            }
            resolveText(value, limit) {
                return __async(this, null, function*() {
                    if (limit <= 0) return [];
                    const session = this.frame.session;
                    const ctxId = yield executionContexts.waitForMainWorld(session, this.frame.frameId, 1e3);
                    const results = [];
                    for(let index = 0; index < limit; index += 1){
                        const expr = this.buildLocatorInvocation("resolveTextSelector", [
                            JSON.stringify(value),
                            String(index)
                        ]);
                        const resolved = yield this.evaluateElement(expr, ctxId);
                        if (!resolved) break;
                        results.push(resolved);
                    }
                    return results;
                });
            }
            resolveXPath(value, limit) {
                return __async(this, null, function*() {
                    if (limit <= 0) return [];
                    const session = this.frame.session;
                    const ctxId = yield executionContexts.waitForMainWorld(session, this.frame.frameId, 1e3);
                    v3Logger({
                        category: "locator",
                        message: "xpath main-world",
                        level: 2,
                        auxiliary: {
                            frameId: {
                                value: String(this.frame.frameId),
                                type: "string"
                            },
                            xp: {
                                value,
                                type: "string"
                            },
                            ctxId: {
                                value: String(ctxId),
                                type: "string"
                            }
                        }
                    });
                    const results = [];
                    for(let index = 0; index < limit; index += 1){
                        const expr = this.buildLocatorInvocation("resolveXPathMainWorld", [
                            JSON.stringify(value),
                            String(index)
                        ]);
                        const resolved = yield this.evaluateElement(expr, ctxId);
                        if (!resolved) break;
                        results.push(resolved);
                    }
                    return results;
                });
            }
            countCss(selector) {
                return __async(this, null, function*() {
                    const session = this.frame.session;
                    const { executionContextId } = yield session.send("Page.createIsolatedWorld", {
                        frameId: this.frame.frameId,
                        worldName: "v3-world"
                    });
                    const primaryExpr = this.buildLocatorInvocation("countCssMatchesPrimary", [
                        JSON.stringify(selector)
                    ]);
                    const primary = yield this.evaluateCount(primaryExpr, executionContextId);
                    const ctxId = yield executionContexts.waitForMainWorld(session, this.frame.frameId, 1e3);
                    const fallbackExpr = this.buildLocatorInvocation("countCssMatchesPierce", [
                        JSON.stringify(selector)
                    ]);
                    const fallback = yield this.evaluateCount(fallbackExpr, ctxId);
                    return Math.max(primary, fallback);
                });
            }
            countText(value) {
                return __async(this, null, function*() {
                    var _a, _b, _c, _d, _e, _f;
                    const session = this.frame.session;
                    const ctxId = yield executionContexts.waitForMainWorld(session, this.frame.frameId, 1e3);
                    const expr = this.buildLocatorInvocation("countTextMatches", [
                        JSON.stringify(value)
                    ]);
                    try {
                        const evalRes = yield session.send("Runtime.evaluate", {
                            expression: expr,
                            contextId: ctxId,
                            returnByValue: true,
                            awaitPromise: true
                        });
                        if (evalRes.exceptionDetails) {
                            const details = evalRes.exceptionDetails;
                            v3Logger({
                                category: "locator",
                                message: "count text evaluate exception",
                                level: 0,
                                auxiliary: {
                                    frameId: {
                                        value: String(this.frame.frameId),
                                        type: "string"
                                    },
                                    selector: {
                                        value,
                                        type: "string"
                                    },
                                    exception: {
                                        value: (_e = details.text) != null ? _e : String((_d = (_c = (_a = details.exception) == null ? void 0 : _a.description) != null ? _c : (_b = details.exception) == null ? void 0 : _b.value) != null ? _d : ""),
                                        type: "string"
                                    }
                                }
                            });
                            return 0;
                        }
                        const data = (_f = evalRes.result.value) != null ? _f : {};
                        const num = typeof data.count === "number" ? data.count : Number(data.count);
                        if (!Number.isFinite(num)) return 0;
                        return Math.max(0, Math.floor(num));
                    } catch (e) {
                        return 0;
                    }
                });
            }
            countXPath(value) {
                return __async(this, null, function*() {
                    const session = this.frame.session;
                    const ctxId = yield executionContexts.waitForMainWorld(session, this.frame.frameId, 1e3);
                    const expr = this.buildLocatorInvocation("countXPathMatchesMainWorld", [
                        JSON.stringify(value)
                    ]);
                    try {
                        const evalRes = yield session.send("Runtime.evaluate", {
                            expression: expr,
                            contextId: ctxId,
                            returnByValue: true,
                            awaitPromise: true
                        });
                        if (evalRes.exceptionDetails) {
                            return 0;
                        }
                        const num = typeof evalRes.result.value === "number" ? evalRes.result.value : Number(evalRes.result.value);
                        if (!Number.isFinite(num)) return 0;
                        return Math.max(0, Math.floor(num));
                    } catch (e) {
                        return 0;
                    }
                });
            }
            resolveFromObjectId(objectId) {
                return __async(this, null, function*() {
                    var _a;
                    const session = this.frame.session;
                    let nodeId = null;
                    try {
                        const rn = yield session.send("DOM.requestNode", {
                            objectId
                        });
                        nodeId = (_a = rn.nodeId) != null ? _a : null;
                    } catch (e) {
                        nodeId = null;
                    }
                    return {
                        objectId,
                        nodeId
                    };
                });
            }
            evaluateCount(expression, contextId) {
                return __async(this, null, function*() {
                    const session = this.frame.session;
                    try {
                        const evalRes = yield session.send("Runtime.evaluate", {
                            expression,
                            contextId,
                            returnByValue: true,
                            awaitPromise: true
                        });
                        if (evalRes.exceptionDetails) {
                            return 0;
                        }
                        const value = evalRes.result.value;
                        const num = typeof value === "number" ? value : Number(value);
                        if (!Number.isFinite(num)) return 0;
                        return Math.max(0, Math.floor(num));
                    } catch (e) {
                        return 0;
                    }
                });
            }
            evaluateElement(expression, contextId) {
                return __async(this, null, function*() {
                    const session = this.frame.session;
                    try {
                        const evalRes = yield session.send("Runtime.evaluate", {
                            expression,
                            contextId,
                            returnByValue: false,
                            awaitPromise: true
                        });
                        if (evalRes.exceptionDetails || !evalRes.result.objectId) {
                            return null;
                        }
                        return this.resolveFromObjectId(evalRes.result.objectId);
                    } catch (e) {
                        return null;
                    }
                });
            }
        };
    }
});
// lib/v3/understudy/fileUploadUtils.ts
function normalizeInputFiles(_0) {
    return __async(this, arguments, function*(files, opts = {}) {
        var _a;
        if (files === null || files === void 0) return [];
        const flattened = Array.isArray(files) ? files : [
            files
        ];
        if (!flattened.length) return [];
        const baseDir = (_a = opts.baseDir) != null ? _a : process.cwd();
        const normalized = [];
        for (const entry of flattened){
            if (typeof entry === "string") {
                const absolutePath = import_path3.default.isAbsolute(entry) ? entry : import_path3.default.resolve(baseDir, entry);
                const stat = yield statFile(absolutePath);
                if (!stat.isFile()) {
                    throw new StagehandInvalidArgumentError(`setInputFiles(): expected a file but received directory or special entry at ${absolutePath}`);
                }
                const buffer = yield import_fs3.promises.readFile(absolutePath);
                normalized.push({
                    name: import_path3.default.basename(absolutePath) || "upload.bin",
                    mimeType: DEFAULT_MIME_TYPE,
                    buffer,
                    lastModified: stat.mtimeMs || Date.now(),
                    absolutePath
                });
                continue;
            }
            if (entry && typeof entry === "object" && "buffer" in entry) {
                const payload = entry;
                const buffer = toBuffer(payload.buffer);
                normalized.push({
                    name: payload.name || "upload.bin",
                    mimeType: payload.mimeType || DEFAULT_MIME_TYPE,
                    buffer,
                    lastModified: typeof payload.lastModified === "number" ? payload.lastModified : Date.now()
                });
                continue;
            }
            throw new StagehandInvalidArgumentError("setInputFiles(): expected file path(s) or payload object(s)");
        }
        return normalized;
    });
}
function statFile(absolutePath) {
    return __async(this, null, function*() {
        try {
            return yield import_fs3.promises.stat(absolutePath);
        } catch (error) {
            const code = error == null ? void 0 : error.code;
            if (code === "ENOENT") {
                throw new StagehandInvalidArgumentError(`setInputFiles(): file not found at ${absolutePath}`);
            }
            throw error;
        }
    });
}
function toBuffer(data) {
    if (import_buffer.Buffer.isBuffer(data)) return data;
    if (data instanceof Uint8Array) return import_buffer.Buffer.from(data);
    if (typeof data === "string") return import_buffer.Buffer.from(data);
    if (data instanceof ArrayBuffer) return import_buffer.Buffer.from(new Uint8Array(data));
    throw new StagehandInvalidArgumentError("Unsupported file payload buffer type");
}
var import_fs3, import_path3, import_buffer, DEFAULT_MIME_TYPE;
var init_fileUploadUtils = __esm({
    "lib/v3/understudy/fileUploadUtils.ts" () {
        import_fs3 = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
        import_path3 = __toESM(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
        import_buffer = __turbopack_context__.r("[externals]/buffer [external] (buffer, cjs)");
        init_sdkErrors();
        DEFAULT_MIME_TYPE = "application/octet-stream";
    }
});
// lib/v3/understudy/locator.ts
var fs4, os, path4, MAX_REMOTE_UPLOAD_BYTES, Locator;
var init_locator = __esm({
    "lib/v3/understudy/locator.ts" () {
        fs4 = __toESM(__turbopack_context__.r("[externals]/fs [external] (fs, cjs)"));
        os = __toESM(__turbopack_context__.r("[externals]/os [external] (os, cjs)"));
        path4 = __toESM(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
        init_locatorScripts_generated();
        init_selectorResolver();
        init_sdkErrors();
        init_fileUploadUtils();
        MAX_REMOTE_UPLOAD_BYTES = 50 * 1024 * 1024;
        Locator = class _Locator {
            constructor(frame, selector, options, nthIndex = 0){
                this.frame = frame;
                this.selector = selector;
                this.options = options;
                this.selectorResolver = new FrameSelectorResolver(this.frame);
                this.selectorQuery = FrameSelectorResolver.parseSelector(selector);
                this.nthIndex = Math.max(0, Math.floor(Number.isFinite(nthIndex) ? nthIndex : 0));
            }
            /** Return the owning Frame for this locator (typed accessor, no private access). */ getFrame() {
                return this.frame;
            }
            /**
       * Set files on an <input type="file"> element.
       *
       * Mirrors Playwright's Locator.setInputFiles basics:
       * - Accepts file path(s) or payload object(s) { name, mimeType, buffer }.
       * - Uses CDP DOM.setFileInputFiles under the hood.
       * - Besteffort dispatches change/input via CDP (Chrome does by default).
       * - Passing an empty array clears the selection.
       */ setInputFiles(files) {
                return __async(this, null, function*() {
                    const session = this.frame.session;
                    const { objectId } = yield this.resolveNode();
                    const tempFiles = [];
                    try {
                        try {
                            const res = yield session.send("Runtime.callFunctionOn", {
                                objectId,
                                functionDeclaration: locatorScriptSources.ensureFileInputElement,
                                returnByValue: true
                            });
                            const ok = Boolean(res.result.value);
                            if (!ok) throw new StagehandInvalidArgumentError('Target is not an <input type="file"> element');
                        } catch (e) {
                            throw new StagehandInvalidArgumentError(e instanceof Error ? e.message : "Unable to verify file input element");
                        }
                        const normalized = yield normalizeInputFiles(files);
                        if (!normalized.length) {
                            yield session.send("DOM.setFileInputFiles", {
                                objectId,
                                files: []
                            });
                            return;
                        }
                        if (this.frame.isBrowserRemote()) {
                            yield this.assignFilesViaPayloadInjection(objectId, normalized);
                            return;
                        }
                        const filePaths = [];
                        for (const payload of normalized){
                            if (payload.absolutePath) {
                                filePaths.push(payload.absolutePath);
                                continue;
                            }
                            const ext = path4.extname(payload.name);
                            const tmp = path4.join(os.tmpdir(), `stagehand-upload-${Date.now()}-${Math.random().toString(36).slice(2)}${ext}`);
                            yield fs4.promises.writeFile(tmp, payload.buffer);
                            tempFiles.push(tmp);
                            filePaths.push(tmp);
                        }
                        yield session.send("DOM.setFileInputFiles", {
                            objectId,
                            files: filePaths
                        });
                    } finally{
                        yield session.send("Runtime.releaseObject", {
                            objectId
                        }).catch(()=>{});
                        for (const p of tempFiles){
                            try {
                                yield fs4.promises.unlink(p);
                            } catch (e) {}
                        }
                    }
                });
            }
            /**
       * Remote browser fallback: build File objects inside the page and attach them via JS.
       *
       * When Stagehand is driving a browser that cannot see the local filesystem (Browserbase,
       * remote CDP, etc.), CDP's DOM.setFileInputFiles would fail because Chrome can't reach
       * our temp files. Instead we base64-encode the payloads, send them into the page, and
       * let a DOM helper create File objects + dispatch change/input events.
       */ assignFilesViaPayloadInjection(objectId, files) {
                return __async(this, null, function*() {
                    var _a;
                    const session = this.frame.session;
                    for (const payload of files){
                        if (payload.buffer.length > MAX_REMOTE_UPLOAD_BYTES) {
                            throw new StagehandInvalidArgumentError(`setInputFiles(): file "${payload.name}" is larger than the 50MB limit for remote uploads`);
                        }
                    }
                    const serialized = files.map((payload)=>({
                            name: payload.name,
                            mimeType: payload.mimeType,
                            lastModified: payload.lastModified,
                            base64: payload.buffer.toString("base64")
                        }));
                    const res = yield session.send("Runtime.callFunctionOn", {
                        objectId,
                        functionDeclaration: locatorScriptSources.assignFilePayloadsToInputElement,
                        arguments: [
                            {
                                value: serialized
                            }
                        ],
                        returnByValue: true
                    });
                    const ok = Boolean((_a = res.result) == null ? void 0 : _a.value);
                    if (!ok) {
                        throw new StagehandInvalidArgumentError("Unable to assign file payloads to remote input element");
                    }
                });
            }
            /**
       * Return the DOM backendNodeId for this locator's target element.
       * Useful for identity comparisons without needing element handles.
       */ backendNodeId() {
                return __async(this, null, function*() {
                    const session = this.frame.session;
                    const { objectId } = yield this.resolveNode();
                    try {
                        yield session.send("DOM.enable").catch(()=>{});
                        const { node } = yield session.send("DOM.describeNode", {
                            objectId
                        });
                        return node.backendNodeId;
                    } finally{
                        yield session.send("Runtime.releaseObject", {
                            objectId
                        }).catch(()=>{});
                    }
                });
            }
            /** Return how many nodes the current selector resolves to. */ count() {
                return __async(this, null, function*() {
                    const session = this.frame.session;
                    yield session.send("Runtime.enable");
                    yield session.send("DOM.enable");
                    return this.selectorResolver.count(this.selectorQuery);
                });
            }
            /**
       * Return the center of the element's bounding box in the owning frame's viewport
       * (CSS pixels), rounded to integers. Scrolls into view best-effort.
       */ centroid() {
                return __async(this, null, function*() {
                    const session = this.frame.session;
                    const { objectId } = yield this.resolveNode();
                    try {
                        yield session.send("DOM.scrollIntoViewIfNeeded", {
                            objectId
                        }).catch(()=>{});
                        const box = yield session.send("DOM.getBoxModel", {
                            objectId
                        });
                        if (!box.model) throw new ElementNotVisibleError(this.selector);
                        const { cx, cy } = this.centerFromBoxContent(box.model.content);
                        return {
                            x: Math.round(cx),
                            y: Math.round(cy)
                        };
                    } finally{
                        yield session.send("Runtime.releaseObject", {
                            objectId
                        }).catch(()=>{});
                    }
                });
            }
            /**
       * Highlight the element's bounding box using the CDP Overlay domain.
       * - Scrolls element into view best-effort.
       * - Shows a semi-transparent overlay briefly, then hides it.
       */ highlight(options) {
                return __async(this, null, function*() {
                    var _a, _b, _c;
                    const session = this.frame.session;
                    const { objectId } = yield this.resolveNode();
                    const duration = Math.max(0, (_a = options == null ? void 0 : options.durationMs) != null ? _a : 800);
                    const borderColor = (_b = options == null ? void 0 : options.borderColor) != null ? _b : {
                        r: 255,
                        g: 0,
                        b: 0,
                        a: 0.9
                    };
                    const contentColor = (_c = options == null ? void 0 : options.contentColor) != null ? _c : {
                        r: 255,
                        g: 200,
                        b: 0,
                        a: 0.2
                    };
                    try {
                        yield session.send("Overlay.enable").catch(()=>{});
                        yield session.send("DOM.scrollIntoViewIfNeeded", {
                            objectId
                        }).catch(()=>{});
                        yield session.send("DOM.enable").catch(()=>{});
                        let backendNodeId;
                        try {
                            const { node } = yield session.send("DOM.describeNode", {
                                objectId
                            });
                            backendNodeId = node.backendNodeId;
                        } catch (e) {
                            backendNodeId = void 0;
                        }
                        const highlightConfig = {
                            showInfo: false,
                            showStyles: false,
                            showRulers: false,
                            showExtensionLines: false,
                            borderColor,
                            contentColor
                        };
                        const highlightOnce = ()=>__async(this, null, function*() {
                                yield session.send("Overlay.highlightNode", __spreadProps(__spreadValues({}, backendNodeId ? {
                                    backendNodeId
                                } : {
                                    objectId
                                }), {
                                    highlightConfig
                                }));
                            });
                        yield highlightOnce();
                        if (duration > 0) {
                            const start = Date.now();
                            const tick = Math.min(300, Math.max(100, Math.floor(duration / 50)));
                            while(Date.now() - start < duration){
                                yield new Promise((r)=>setTimeout(r, tick));
                                try {
                                    yield highlightOnce();
                                } catch (e) {}
                            }
                            yield session.send("Overlay.hideHighlight").catch(()=>{});
                        }
                    } finally{
                        yield session.send("Runtime.releaseObject", {
                            objectId
                        }).catch(()=>{});
                    }
                });
            }
            /**
       * Move the mouse cursor to the element's visual center without clicking.
       * - Scrolls into view best-effort, resolves geometry, then dispatches a mouse move.
       */ hover() {
                return __async(this, null, function*() {
                    const session = this.frame.session;
                    const { objectId } = yield this.resolveNode();
                    try {
                        yield session.send("DOM.scrollIntoViewIfNeeded", {
                            objectId
                        }).catch(()=>{});
                        const box = yield session.send("DOM.getBoxModel", {
                            objectId
                        });
                        if (!box.model) throw new ElementNotVisibleError(this.selector);
                        const { cx, cy } = this.centerFromBoxContent(box.model.content);
                        yield session.send("Input.dispatchMouseEvent", {
                            type: "mouseMoved",
                            x: cx,
                            y: cy,
                            button: "none"
                        });
                    } finally{
                        yield session.send("Runtime.releaseObject", {
                            objectId
                        }).catch(()=>{});
                    }
                });
            }
            /**
       * Click the element at its visual center.
       * Steps:
       *  1) Resolve selector to { objectId } in the frame world.
       *  2) Scroll into view via `DOM.scrollIntoViewIfNeeded({ objectId })`.
       *  3) Read geometry via `DOM.getBoxModel({ objectId })`  compute a center point.
       *  4) Synthesize mouse press + release via `Input.dispatchMouseEvent`.
       */ click(options) {
                return __async(this, null, function*() {
                    var _a, _b;
                    const session = this.frame.session;
                    const { objectId } = yield this.resolveNode();
                    const button = (_a = options == null ? void 0 : options.button) != null ? _a : "left";
                    const clickCount = (_b = options == null ? void 0 : options.clickCount) != null ? _b : 1;
                    try {
                        yield session.send("DOM.scrollIntoViewIfNeeded", {
                            objectId
                        });
                        const box = yield session.send("DOM.getBoxModel", {
                            objectId
                        });
                        if (!box.model) throw new ElementNotVisibleError(this.selector);
                        const { cx, cy } = this.centerFromBoxContent(box.model.content);
                        yield session.send("Input.dispatchMouseEvent", {
                            type: "mouseMoved",
                            x: cx,
                            y: cy,
                            button: "none"
                        });
                        yield session.send("Input.dispatchMouseEvent", {
                            type: "mousePressed",
                            x: cx,
                            y: cy,
                            button,
                            clickCount
                        });
                        yield session.send("Input.dispatchMouseEvent", {
                            type: "mouseReleased",
                            x: cx,
                            y: cy,
                            button,
                            clickCount
                        });
                    } finally{
                        try {
                            yield session.send("Runtime.releaseObject", {
                                objectId
                            });
                        } catch (e) {}
                    }
                });
            }
            /**
       * Dispatch a DOM 'click' MouseEvent on the element itself.
       * - Does not synthesize real pointer input; directly dispatches an event.
       * - Useful for elements that rely on click handlers without needing hit-testing.
       */ sendClickEvent(options) {
                return __async(this, null, function*() {
                    var _a, _b, _c, _d;
                    const session = this.frame.session;
                    const { objectId } = yield this.resolveNode();
                    const bubbles = (_a = options == null ? void 0 : options.bubbles) != null ? _a : true;
                    const cancelable = (_b = options == null ? void 0 : options.cancelable) != null ? _b : true;
                    const composed = (_c = options == null ? void 0 : options.composed) != null ? _c : true;
                    const detail = (_d = options == null ? void 0 : options.detail) != null ? _d : 1;
                    try {
                        yield session.send("DOM.scrollIntoViewIfNeeded", {
                            objectId
                        }).catch(()=>{});
                        yield session.send("Runtime.callFunctionOn", {
                            objectId,
                            functionDeclaration: locatorScriptSources.dispatchDomClick,
                            arguments: [
                                {
                                    value: {
                                        bubbles,
                                        cancelable,
                                        composed,
                                        detail
                                    }
                                }
                            ],
                            returnByValue: true
                        });
                    } finally{
                        yield session.send("Runtime.releaseObject", {
                            objectId
                        }).catch(()=>{});
                    }
                });
            }
            /**
       * Scroll the element vertically to a given percentage (0100).
       * - If the element is <html> or <body>, scrolls the window/document.
       * - Otherwise, scrolls the element itself via element.scrollTo.
       */ scrollTo(percent) {
                return __async(this, null, function*() {
                    const session = this.frame.session;
                    const { objectId } = yield this.resolveNode();
                    try {
                        yield session.send("Runtime.callFunctionOn", {
                            objectId,
                            functionDeclaration: locatorScriptSources.scrollElementToPercent,
                            arguments: [
                                {
                                    value: percent
                                }
                            ],
                            returnByValue: true
                        });
                    } finally{
                        yield session.send("Runtime.releaseObject", {
                            objectId
                        }).catch(()=>{});
                    }
                });
            }
            /**
       * Fill an input/textarea/contenteditable element.
       * Mirrors Playwright semantics: the DOM helper either applies the native
       * value setter (for special input types) or asks us to type text via the CDP
       * Input domain after focusing/selecting.
       */ fill(value) {
                return __async(this, null, function*() {
                    const session = this.frame.session;
                    const { objectId } = yield this.resolveNode();
                    let releaseNeeded = true;
                    try {
                        const res = yield session.send("Runtime.callFunctionOn", {
                            objectId,
                            functionDeclaration: locatorScriptSources.fillElementValue,
                            arguments: [
                                {
                                    value
                                }
                            ],
                            returnByValue: true
                        });
                        const result = res.result.value;
                        const status = typeof result === "object" && result ? result.status : void 0;
                        if (status === "done") {
                            return;
                        }
                        if (status === "needsinput") {
                            yield session.send("Runtime.releaseObject", {
                                objectId
                            }).catch(()=>{});
                            releaseNeeded = false;
                            const valueToType = typeof (result == null ? void 0 : result.value) === "string" ? result.value : value;
                            let prepared = false;
                            try {
                                const { objectId: prepObjectId } = yield this.resolveNode();
                                try {
                                    const prepRes = yield session.send("Runtime.callFunctionOn", {
                                        objectId: prepObjectId,
                                        functionDeclaration: locatorScriptSources.prepareElementForTyping,
                                        returnByValue: true
                                    });
                                    prepared = Boolean(prepRes.result.value);
                                } finally{
                                    yield session.send("Runtime.releaseObject", {
                                        objectId: prepObjectId
                                    }).catch(()=>{});
                                }
                            } catch (e) {}
                            if (!prepared && valueToType.length > 0) {
                                yield this.type(valueToType);
                                return;
                            }
                            if (valueToType.length === 0) {
                                yield session.send("Input.dispatchKeyEvent", {
                                    type: "keyDown",
                                    key: "Backspace",
                                    code: "Backspace",
                                    windowsVirtualKeyCode: 8,
                                    nativeVirtualKeyCode: 8
                                });
                                yield session.send("Input.dispatchKeyEvent", {
                                    type: "keyUp",
                                    key: "Backspace",
                                    code: "Backspace",
                                    windowsVirtualKeyCode: 8,
                                    nativeVirtualKeyCode: 8
                                });
                            } else {
                                yield session.send("Input.insertText", {
                                    text: valueToType
                                });
                            }
                            return;
                        }
                        if (status === "error") {
                            const reason = typeof (result == null ? void 0 : result.reason) === "string" && result.reason.length > 0 ? result.reason : "Failed to fill element";
                            throw new StagehandInvalidArgumentError(`Failed to fill element (${reason})`);
                        }
                        if (!status) {
                            yield this.type(value);
                        }
                    } finally{
                        if (releaseNeeded) {
                            yield session.send("Runtime.releaseObject", {
                                objectId
                            }).catch(()=>{});
                        }
                    }
                });
            }
            /**
       * Type text into the element (focuses first).
       * - Focus via element.focus() in page JS (no DOM.focus(nodeId)).
       * - If no delay, uses `Input.insertText` for efficiency.
       * - With delay, synthesizes `keyDown`/`keyUp` per character.
       */ type(text, options) {
                return __async(this, null, function*() {
                    const session = this.frame.session;
                    const { objectId } = yield this.resolveNode();
                    try {
                        yield session.send("Runtime.callFunctionOn", {
                            objectId,
                            functionDeclaration: locatorScriptSources.focusElement,
                            returnByValue: true
                        });
                        if (!(options == null ? void 0 : options.delay)) {
                            yield session.send("Input.insertText", {
                                text
                            });
                            return;
                        }
                        for (const ch of text){
                            yield session.send("Input.dispatchKeyEvent", {
                                type: "keyDown",
                                text: ch,
                                key: ch
                            });
                            yield session.send("Input.dispatchKeyEvent", {
                                type: "keyUp",
                                text: ch,
                                key: ch
                            });
                            yield new Promise((r)=>setTimeout(r, options.delay));
                        }
                    } finally{
                        yield session.send("Runtime.releaseObject", {
                            objectId
                        });
                    }
                });
            }
            /**
       * Select one or more options on a `<select>` element.
       * Returns the values actually selected after the operation.
       */ selectOption(values) {
                return __async(this, null, function*() {
                    var _a;
                    const session = this.frame.session;
                    const desired = Array.isArray(values) ? values : [
                        values
                    ];
                    const { objectId } = yield this.resolveNode();
                    try {
                        const res = yield session.send("Runtime.callFunctionOn", {
                            objectId,
                            functionDeclaration: locatorScriptSources.selectElementOptions,
                            arguments: [
                                {
                                    value: desired
                                }
                            ],
                            returnByValue: true
                        });
                        return (_a = res.result.value) != null ? _a : [];
                    } finally{
                        yield session.send("Runtime.releaseObject", {
                            objectId
                        });
                    }
                });
            }
            /**
       * Return true if the element is attached and visible (rough heuristic).
       */ isVisible() {
                return __async(this, null, function*() {
                    const session = this.frame.session;
                    const { objectId } = yield this.resolveNode();
                    try {
                        const res = yield session.send("Runtime.callFunctionOn", {
                            objectId,
                            functionDeclaration: locatorScriptSources.isElementVisible,
                            returnByValue: true
                        });
                        return Boolean(res.result.value);
                    } finally{
                        yield session.send("Runtime.releaseObject", {
                            objectId
                        });
                    }
                });
            }
            /**
       * Return true if the element is an input[type=checkbox|radio] and is checked.
       * Also considers aria-checked for ARIA widgets.
       */ isChecked() {
                return __async(this, null, function*() {
                    const session = this.frame.session;
                    const { objectId } = yield this.resolveNode();
                    try {
                        const res = yield session.send("Runtime.callFunctionOn", {
                            objectId,
                            functionDeclaration: locatorScriptSources.isElementChecked,
                            returnByValue: true
                        });
                        return Boolean(res.result.value);
                    } finally{
                        yield session.send("Runtime.releaseObject", {
                            objectId
                        });
                    }
                });
            }
            /**
       * Return the element's input value (for input/textarea/select/contenteditable).
       */ inputValue() {
                return __async(this, null, function*() {
                    var _a;
                    const session = this.frame.session;
                    const { objectId } = yield this.resolveNode();
                    try {
                        const res = yield session.send("Runtime.callFunctionOn", {
                            objectId,
                            functionDeclaration: locatorScriptSources.readElementInputValue,
                            returnByValue: true
                        });
                        return String((_a = res.result.value) != null ? _a : "");
                    } finally{
                        yield session.send("Runtime.releaseObject", {
                            objectId
                        });
                    }
                });
            }
            /**
       * Return the element's textContent (raw, not innerText).
       */ textContent() {
                return __async(this, null, function*() {
                    var _a;
                    const session = this.frame.session;
                    const { objectId } = yield this.resolveNode();
                    try {
                        const res = yield session.send("Runtime.callFunctionOn", {
                            objectId,
                            functionDeclaration: locatorScriptSources.readElementTextContent,
                            returnByValue: true
                        });
                        return String((_a = res.result.value) != null ? _a : "");
                    } finally{
                        yield session.send("Runtime.releaseObject", {
                            objectId
                        });
                    }
                });
            }
            /**
       * Return the element's innerHTML string.
       */ innerHtml() {
                return __async(this, null, function*() {
                    var _a;
                    const session = this.frame.session;
                    const { objectId } = yield this.resolveNode();
                    try {
                        const res = yield session.send("Runtime.callFunctionOn", {
                            objectId,
                            functionDeclaration: locatorScriptSources.readElementInnerHTML,
                            returnByValue: true
                        });
                        return String((_a = res.result.value) != null ? _a : "");
                    } finally{
                        yield session.send("Runtime.releaseObject", {
                            objectId
                        });
                    }
                });
            }
            /**
       * Return the element's innerText (layout-aware, visible text).
       */ innerText() {
                return __async(this, null, function*() {
                    var _a;
                    const session = this.frame.session;
                    const { objectId } = yield this.resolveNode();
                    try {
                        const res = yield session.send("Runtime.callFunctionOn", {
                            objectId,
                            functionDeclaration: locatorScriptSources.readElementInnerText,
                            returnByValue: true
                        });
                        return String((_a = res.result.value) != null ? _a : "");
                    } finally{
                        yield session.send("Runtime.releaseObject", {
                            objectId
                        });
                    }
                });
            }
            /**
       * For API parity, returns the same locator (querySelector already returns the first match).
       */ first() {
                return this;
            }
            /** Return a locator narrowed to the element at the given zero-based index. */ nth(index) {
                const value = Number(index);
                if (!Number.isFinite(value) || value < 0) {
                    throw new StagehandInvalidArgumentError("locator().nth() expects a non-negative index");
                }
                const nextIndex = Math.floor(value);
                if (nextIndex === this.nthIndex) {
                    return this;
                }
                return new _Locator(this.frame, this.selector, this.options, nextIndex);
            }
            // ---------- helpers ----------
            /**
       * Resolve `this.selector` within the frame to `{ objectId, nodeId? }`:
       * Delegates to a shared selector resolver so all selector logic stays in sync.
       */ resolveNode() {
                return __async(this, null, function*() {
                    const session = this.frame.session;
                    yield session.send("Runtime.enable");
                    yield session.send("DOM.enable");
                    const resolved = yield this.selectorResolver.resolveAtIndex(this.selectorQuery, this.nthIndex);
                    if (!resolved) {
                        throw new StagehandElementNotFoundError([
                            this.selector
                        ]);
                    }
                    return resolved;
                });
            }
            /** Compute a center point from a BoxModel content quad */ centerFromBoxContent(content) {
                if (!content || content.length < 8) {
                    throw new StagehandInvalidArgumentError("Invalid box model content quad");
                }
                const xs = [
                    content[0],
                    content[2],
                    content[4],
                    content[6]
                ];
                const ys = [
                    content[1],
                    content[3],
                    content[5],
                    content[7]
                ];
                const cx = (xs[0] + xs[1] + xs[2] + xs[3]) / 4;
                const cy = (ys[0] + ys[1] + ys[2] + ys[3]) / 4;
                return {
                    cx,
                    cy
                };
            }
        };
    }
});
// lib/v3/understudy/frameLocator.ts
function frameLocatorFromFrame(page, root, selector) {
    return new FrameLocator(page, selector, void 0, root);
}
function listDirectChildFrameIdsFromRegistry(page, parentFrameId, timeoutMs) {
    return __async(this, null, function*() {
        var _a, _b;
        const deadline = Date.now() + timeoutMs;
        while(true){
            try {
                const tree = page.getFullFrameTree();
                const node = findFrameNode(tree, parentFrameId);
                const ids = (_b = (_a = node == null ? void 0 : node.childFrames) == null ? void 0 : _a.map((c)=>c.frame.id)) != null ? _b : [];
                if (ids.length > 0 || Date.now() >= deadline) return ids;
            } catch (e) {}
            yield new Promise((r)=>setTimeout(r, 50));
        }
    });
}
function findFrameNode(tree, targetId) {
    var _a;
    if (tree.frame.id === targetId) return tree;
    for (const c of (_a = tree.childFrames) != null ? _a : []){
        const hit = findFrameNode(c, targetId);
        if (hit) return hit;
    }
    return void 0;
}
function ensureChildFrameReady(page, parentFrame, childFrameId, budgetMs) {
    return __async(this, null, function*() {
        const parentSession2 = parentFrame.session;
        const deadline = Date.now() + Math.max(0, budgetMs);
        const owner = page.getSessionForFrame(childFrameId);
        if (owner && owner !== parentSession2) {
            try {
                yield executionContexts.waitForMainWorld(owner, childFrameId, 600);
            } catch (e) {}
            return;
        }
        const hasMainWorldOnParent = ()=>{
            try {
                return executionContexts.getMainWorld(parentSession2, childFrameId) !== null;
            } catch (e) {
                return false;
            }
        };
        if (hasMainWorldOnParent()) return;
        yield parentSession2.send("Page.setLifecycleEventsEnabled", {
            enabled: true
        }).catch(()=>{});
        yield parentSession2.send("Runtime.enable").catch(()=>{});
        yield new Promise((resolve2)=>{
            let done = false;
            const finish = ()=>{
                if (done) return;
                done = true;
                parentSession2.off("Page.lifecycleEvent", onLifecycle);
                resolve2();
            };
            const onLifecycle = (evt)=>{
                if (evt.frameId !== childFrameId || evt.name !== "DOMContentLoaded" && evt.name !== "load" && evt.name !== "networkIdle" && evt.name !== "networkidle") {
                    return;
                }
                if (hasMainWorldOnParent()) return finish();
                try {
                    const nowOwner = page.getSessionForFrame(childFrameId);
                    if (nowOwner && nowOwner !== parentSession2) {
                        const left = Math.max(150, deadline - Date.now());
                        executionContexts.waitForMainWorld(nowOwner, childFrameId, left).finally(finish);
                    }
                } catch (e) {}
            };
            parentSession2.on("Page.lifecycleEvent", onLifecycle);
            const tick = ()=>{
                if (done) return;
                if (hasMainWorldOnParent()) return finish();
                try {
                    const nowOwner = page.getSessionForFrame(childFrameId);
                    if (nowOwner && nowOwner !== parentSession2) {
                        const left = Math.max(150, deadline - Date.now());
                        executionContexts.waitForMainWorld(nowOwner, childFrameId, left).finally(finish);
                        return;
                    }
                } catch (e) {}
                if (Date.now() >= deadline) return finish();
                setTimeout(tick, 50);
            };
            tick();
        });
    });
}
var FrameLocator, LocatorDelegate;
var init_frameLocator = __esm({
    "lib/v3/understudy/frameLocator.ts" () {
        init_executionContextRegistry();
        init_sdkErrors();
        FrameLocator = class _FrameLocator {
            constructor(page, selector, parent, root){
                this.page = page;
                this.selector = selector;
                this.parent = parent;
                this.root = root;
            }
            /** Create a nested FrameLocator under this one. */ frameLocator(selector) {
                return new _FrameLocator(this.page, selector, this);
            }
            /** Resolve to the concrete Frame for this FrameLocator chain. */ resolveFrame() {
                return __async(this, null, function*() {
                    var _a;
                    const parentFrame = this.parent ? yield this.parent.resolveFrame() : (_a = this.root) != null ? _a : this.page.mainFrame();
                    const tmp = parentFrame.locator(this.selector);
                    const parentSession2 = parentFrame.session;
                    const { objectId } = yield tmp.resolveNode();
                    try {
                        yield parentSession2.send("DOM.enable").catch(()=>{});
                        const desc = yield parentSession2.send("DOM.describeNode", {
                            objectId
                        });
                        const iframeBackendNodeId = desc.node.backendNodeId;
                        const childIds = yield listDirectChildFrameIdsFromRegistry(this.page, parentFrame.frameId, 1e3);
                        for (const fid of childIds){
                            try {
                                const owner = yield parentSession2.send("DOM.getFrameOwner", {
                                    frameId: fid
                                });
                                if (owner.backendNodeId === iframeBackendNodeId) {
                                    yield ensureChildFrameReady(this.page, parentFrame, fid, 1200);
                                    return this.page.frameForId(fid);
                                }
                            } catch (e) {}
                        }
                        throw new ContentFrameNotFoundError(this.selector);
                    } finally{
                        yield parentSession2.send("Runtime.releaseObject", {
                            objectId
                        }).catch(()=>{});
                    }
                });
            }
            /** Return a Locator scoped to this frame. Methods delegate to the frame lazily. */ locator(selector) {
                return new LocatorDelegate(this, selector);
            }
        };
        LocatorDelegate = class {
            constructor(fl, sel){
                this.fl = fl;
                this.sel = sel;
            }
            real() {
                return __async(this, null, function*() {
                    const frame = yield this.fl.resolveFrame();
                    return frame.locator(this.sel);
                });
            }
            // Locator API delegates
            click(options) {
                return __async(this, null, function*() {
                    return (yield this.real()).click(options);
                });
            }
            hover() {
                return __async(this, null, function*() {
                    return (yield this.real()).hover();
                });
            }
            fill(value) {
                return __async(this, null, function*() {
                    return (yield this.real()).fill(value);
                });
            }
            type(text, options) {
                return __async(this, null, function*() {
                    return (yield this.real()).type(text, options);
                });
            }
            selectOption(values) {
                return __async(this, null, function*() {
                    return (yield this.real()).selectOption(values);
                });
            }
            scrollTo(percent) {
                return __async(this, null, function*() {
                    return (yield this.real()).scrollTo(percent);
                });
            }
            isVisible() {
                return __async(this, null, function*() {
                    return (yield this.real()).isVisible();
                });
            }
            isChecked() {
                return __async(this, null, function*() {
                    return (yield this.real()).isChecked();
                });
            }
            inputValue() {
                return __async(this, null, function*() {
                    return (yield this.real()).inputValue();
                });
            }
            textContent() {
                return __async(this, null, function*() {
                    return (yield this.real()).textContent();
                });
            }
            innerHtml() {
                return __async(this, null, function*() {
                    return (yield this.real()).innerHtml();
                });
            }
            innerText() {
                return __async(this, null, function*() {
                    return (yield this.real()).innerText();
                });
            }
            count() {
                return __async(this, null, function*() {
                    return (yield this.real()).count();
                });
            }
            first() {
                return this;
            }
        };
    }
});
// lib/v3/understudy/deepLocator.ts
function parseXPath(path7) {
    const s = path7.trim();
    let i = 0;
    const steps = [];
    while(i < s.length){
        let axis = "child";
        if (s.startsWith("//", i)) {
            axis = "desc";
            i += 2;
        } else if (s[i] === "/") {
            axis = "child";
            i += 1;
        }
        const start = i;
        while(i < s.length && s[i] !== "/")i++;
        const raw = s.slice(start, i).trim();
        if (!raw) continue;
        const name = raw.replace(/\[\d+\]\s*$/u, "").toLowerCase();
        steps.push({
            axis,
            raw,
            name
        });
    }
    return steps;
}
function buildXPathFromSteps2(steps) {
    let out = "";
    for (const st of steps){
        out += st.axis === "desc" ? "//" : "/";
        out += st.raw;
    }
    return out || "/";
}
function deepLocatorThroughIframes(page, root, xpathOrSelector) {
    return __async(this, null, function*() {
        let path7 = xpathOrSelector.trim();
        if (path7.startsWith("xpath=")) path7 = path7.slice("xpath=".length).trim();
        if (!path7.startsWith("/")) path7 = "/" + path7;
        const steps = parseXPath(path7);
        let fl;
        let buf = [];
        const flushIntoFrameLocator = ()=>{
            if (!buf.length) return;
            const selectorForIframe = "xpath=" + buildXPathFromSteps2(buf);
            v3Logger({
                category: "deep-hop",
                message: "resolving iframe via FrameLocator",
                level: 2,
                auxiliary: {
                    selectorForIframe: {
                        value: selectorForIframe,
                        type: "string"
                    },
                    rootFrameId: {
                        value: String(root.frameId),
                        type: "string"
                    }
                }
            });
            fl = fl ? fl.frameLocator(selectorForIframe) : frameLocatorFromFrame(page, root, selectorForIframe);
            buf = [];
        };
        for (const st of steps){
            buf.push(st);
            if (IFRAME_STEP_RE2.test(st.name)) flushIntoFrameLocator();
        }
        const finalSelector = "xpath=" + buildXPathFromSteps2(buf);
        const targetFrame = fl ? yield fl.resolveFrame() : root;
        v3Logger({
            category: "deep-hop",
            message: "final tail",
            level: 2,
            auxiliary: {
                frameId: {
                    value: String(targetFrame.frameId),
                    type: "string"
                },
                finalSelector: {
                    value: finalSelector,
                    type: "string"
                }
            }
        });
        return new Locator(targetFrame, finalSelector);
    });
}
function resolveLocatorWithHops(page, root, selectorRaw) {
    return __async(this, null, function*() {
        const sel = selectorRaw.trim();
        const parts = sel.split(">>").map((s)=>s.trim()).filter(Boolean);
        if (parts.length > 1) {
            let fl = frameLocatorFromFrame(page, root, parts[0]);
            for(let i = 1; i < parts.length - 1; i++){
                fl = fl.frameLocator(parts[i]);
            }
            const targetFrame = yield fl.resolveFrame();
            return new Locator(targetFrame, parts[parts.length - 1]);
        }
        const isXPath = sel.startsWith("xpath=") || sel.startsWith("/");
        if (isXPath) return deepLocatorThroughIframes(page, root, sel);
        return new Locator(root, sel);
    });
}
function deepLocatorFromPage(page, root, selector) {
    return new DeepLocatorDelegate(page, root, selector);
}
var IFRAME_STEP_RE2, DeepLocatorDelegate;
var init_deepLocator = __esm({
    "lib/v3/understudy/deepLocator.ts" () {
        init_locator();
        init_logger();
        init_frameLocator();
        init_sdkErrors();
        IFRAME_STEP_RE2 = /^iframe(?:\[\d+])?$/i;
        DeepLocatorDelegate = class _DeepLocatorDelegate {
            constructor(page, root, selector, nthIndex = 0){
                this.page = page;
                this.root = root;
                this.selector = selector;
                this.nthIndex = nthIndex;
            }
            real() {
                return __async(this, null, function*() {
                    const base = yield resolveLocatorWithHops(this.page, this.root, this.selector);
                    return base.nth(this.nthIndex);
                });
            }
            // Locator API delegates
            click(options) {
                return __async(this, null, function*() {
                    return (yield this.real()).click(options);
                });
            }
            count() {
                return __async(this, null, function*() {
                    return (yield this.real()).count();
                });
            }
            hover() {
                return __async(this, null, function*() {
                    return (yield this.real()).hover();
                });
            }
            fill(value) {
                return __async(this, null, function*() {
                    return (yield this.real()).fill(value);
                });
            }
            type(text, options) {
                return __async(this, null, function*() {
                    return (yield this.real()).type(text, options);
                });
            }
            selectOption(values) {
                return __async(this, null, function*() {
                    return (yield this.real()).selectOption(values);
                });
            }
            scrollTo(percent) {
                return __async(this, null, function*() {
                    return (yield this.real()).scrollTo(percent);
                });
            }
            isVisible() {
                return __async(this, null, function*() {
                    return (yield this.real()).isVisible();
                });
            }
            isChecked() {
                return __async(this, null, function*() {
                    return (yield this.real()).isChecked();
                });
            }
            inputValue() {
                return __async(this, null, function*() {
                    return (yield this.real()).inputValue();
                });
            }
            textContent() {
                return __async(this, null, function*() {
                    return (yield this.real()).textContent();
                });
            }
            innerHtml() {
                return __async(this, null, function*() {
                    return (yield this.real()).innerHtml();
                });
            }
            innerText() {
                return __async(this, null, function*() {
                    return (yield this.real()).innerText();
                });
            }
            centroid() {
                return __async(this, null, function*() {
                    return (yield this.real()).centroid();
                });
            }
            backendNodeId() {
                return __async(this, null, function*() {
                    return (yield this.real()).backendNodeId();
                });
            }
            highlight(options) {
                return __async(this, null, function*() {
                    return (yield this.real()).highlight(options);
                });
            }
            sendClickEvent(options) {
                return __async(this, null, function*() {
                    return (yield this.real()).sendClickEvent(options);
                });
            }
            setInputFiles(files) {
                return __async(this, null, function*() {
                    return (yield this.real()).setInputFiles(files);
                });
            }
            first() {
                return this.nth(0);
            }
            nth(index) {
                const value = Number(index);
                if (!Number.isFinite(value) || value < 0) {
                    throw new StagehandInvalidArgumentError("deepLocator().nth() expects a non-negative index");
                }
                const nextIndex = Math.floor(value);
                if (nextIndex === this.nthIndex) return this;
                return new _DeepLocatorDelegate(this.page, this.root, this.selector, nextIndex);
            }
        };
    }
});
// ../../node_modules/.pnpm/escape-string-regexp@4.0.0/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
    "../../node_modules/.pnpm/escape-string-regexp@4.0.0/node_modules/escape-string-regexp/index.js" (exports2, module2) {
        "use strict";
        module2.exports = (string)=>{
            if (typeof string !== "string") {
                throw new TypeError("Expected a string");
            }
            return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
        };
    }
});
// ../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js
var require_ms = __commonJS({
    "../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js" (exports2, module2) {
        var s = 1e3;
        var m = s * 60;
        var h = m * 60;
        var d = h * 24;
        var w = d * 7;
        var y = d * 365.25;
        module2.exports = function(val, options) {
            options = options || {};
            var type = typeof val;
            if (type === "string" && val.length > 0) {
                return parse(val);
            } else if (type === "number" && isFinite(val)) {
                return options.long ? fmtLong(val) : fmtShort(val);
            }
            throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
        };
        function parse(str) {
            str = String(str);
            if (str.length > 100) {
                return;
            }
            var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
            if (!match) {
                return;
            }
            var n = parseFloat(match[1]);
            var type = (match[2] || "ms").toLowerCase();
            switch(type){
                case "years":
                case "year":
                case "yrs":
                case "yr":
                case "y":
                    return n * y;
                case "weeks":
                case "week":
                case "w":
                    return n * w;
                case "days":
                case "day":
                case "d":
                    return n * d;
                case "hours":
                case "hour":
                case "hrs":
                case "hr":
                case "h":
                    return n * h;
                case "minutes":
                case "minute":
                case "mins":
                case "min":
                case "m":
                    return n * m;
                case "seconds":
                case "second":
                case "secs":
                case "sec":
                case "s":
                    return n * s;
                case "milliseconds":
                case "millisecond":
                case "msecs":
                case "msec":
                case "ms":
                    return n;
                default:
                    return void 0;
            }
        }
        function fmtShort(ms) {
            var msAbs = Math.abs(ms);
            if (msAbs >= d) {
                return Math.round(ms / d) + "d";
            }
            if (msAbs >= h) {
                return Math.round(ms / h) + "h";
            }
            if (msAbs >= m) {
                return Math.round(ms / m) + "m";
            }
            if (msAbs >= s) {
                return Math.round(ms / s) + "s";
            }
            return ms + "ms";
        }
        function fmtLong(ms) {
            var msAbs = Math.abs(ms);
            if (msAbs >= d) {
                return plural(ms, msAbs, d, "day");
            }
            if (msAbs >= h) {
                return plural(ms, msAbs, h, "hour");
            }
            if (msAbs >= m) {
                return plural(ms, msAbs, m, "minute");
            }
            if (msAbs >= s) {
                return plural(ms, msAbs, s, "second");
            }
            return ms + " ms";
        }
        function plural(ms, msAbs, n, name) {
            var isPlural = msAbs >= n * 1.5;
            return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
        }
    }
});
// ../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/common.js
var require_common = __commonJS({
    "../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/common.js" (exports2, module2) {
        function setup(env) {
            createDebug.debug = createDebug;
            createDebug.default = createDebug;
            createDebug.coerce = coerce;
            createDebug.disable = disable;
            createDebug.enable = enable;
            createDebug.enabled = enabled;
            createDebug.humanize = require_ms();
            createDebug.destroy = destroy;
            Object.keys(env).forEach((key)=>{
                createDebug[key] = env[key];
            });
            createDebug.names = [];
            createDebug.skips = [];
            createDebug.formatters = {};
            function selectColor(namespace) {
                let hash = 0;
                for(let i = 0; i < namespace.length; i++){
                    hash = (hash << 5) - hash + namespace.charCodeAt(i);
                    hash |= 0;
                }
                return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
            }
            createDebug.selectColor = selectColor;
            function createDebug(namespace) {
                let prevTime;
                let enableOverride = null;
                let namespacesCache;
                let enabledCache;
                function debug2(...args) {
                    if (!debug2.enabled) {
                        return;
                    }
                    const self = debug2;
                    const curr = Number(/* @__PURE__ */ new Date());
                    const ms = curr - (prevTime || curr);
                    self.diff = ms;
                    self.prev = prevTime;
                    self.curr = curr;
                    prevTime = curr;
                    args[0] = createDebug.coerce(args[0]);
                    if (typeof args[0] !== "string") {
                        args.unshift("%O");
                    }
                    let index = 0;
                    args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{
                        if (match === "%%") {
                            return "%";
                        }
                        index++;
                        const formatter = createDebug.formatters[format];
                        if (typeof formatter === "function") {
                            const val = args[index];
                            match = formatter.call(self, val);
                            args.splice(index, 1);
                            index--;
                        }
                        return match;
                    });
                    createDebug.formatArgs.call(self, args);
                    const logFn = self.log || createDebug.log;
                    logFn.apply(self, args);
                }
                debug2.namespace = namespace;
                debug2.useColors = createDebug.useColors();
                debug2.color = createDebug.selectColor(namespace);
                debug2.extend = extend;
                debug2.destroy = createDebug.destroy;
                Object.defineProperty(debug2, "enabled", {
                    enumerable: true,
                    configurable: false,
                    get: ()=>{
                        if (enableOverride !== null) {
                            return enableOverride;
                        }
                        if (namespacesCache !== createDebug.namespaces) {
                            namespacesCache = createDebug.namespaces;
                            enabledCache = createDebug.enabled(namespace);
                        }
                        return enabledCache;
                    },
                    set: (v)=>{
                        enableOverride = v;
                    }
                });
                if (typeof createDebug.init === "function") {
                    createDebug.init(debug2);
                }
                return debug2;
            }
            function extend(namespace, delimiter) {
                const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
                newDebug.log = this.log;
                return newDebug;
            }
            function enable(namespaces) {
                createDebug.save(namespaces);
                createDebug.namespaces = namespaces;
                createDebug.names = [];
                createDebug.skips = [];
                const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
                for (const ns of split){
                    if (ns[0] === "-") {
                        createDebug.skips.push(ns.slice(1));
                    } else {
                        createDebug.names.push(ns);
                    }
                }
            }
            function matchesTemplate(search, template) {
                let searchIndex = 0;
                let templateIndex = 0;
                let starIndex = -1;
                let matchIndex = 0;
                while(searchIndex < search.length){
                    if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
                        if (template[templateIndex] === "*") {
                            starIndex = templateIndex;
                            matchIndex = searchIndex;
                            templateIndex++;
                        } else {
                            searchIndex++;
                            templateIndex++;
                        }
                    } else if (starIndex !== -1) {
                        templateIndex = starIndex + 1;
                        matchIndex++;
                        searchIndex = matchIndex;
                    } else {
                        return false;
                    }
                }
                while(templateIndex < template.length && template[templateIndex] === "*"){
                    templateIndex++;
                }
                return templateIndex === template.length;
            }
            function disable() {
                const namespaces = [
                    ...createDebug.names,
                    ...createDebug.skips.map((namespace)=>"-" + namespace)
                ].join(",");
                createDebug.enable("");
                return namespaces;
            }
            function enabled(name) {
                for (const skip of createDebug.skips){
                    if (matchesTemplate(name, skip)) {
                        return false;
                    }
                }
                for (const ns of createDebug.names){
                    if (matchesTemplate(name, ns)) {
                        return true;
                    }
                }
                return false;
            }
            function coerce(val) {
                if (val instanceof Error) {
                    return val.stack || val.message;
                }
                return val;
            }
            function destroy() {
                console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
            }
            createDebug.enable(createDebug.load());
            return createDebug;
        }
        module2.exports = setup;
    }
});
// ../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/browser.js
var require_browser = __commonJS({
    "../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/browser.js" (exports2, module2) {
        exports2.formatArgs = formatArgs;
        exports2.save = save;
        exports2.load = load;
        exports2.useColors = useColors;
        exports2.storage = localstorage();
        exports2.destroy = /* @__PURE__ */ (()=>{
            let warned = false;
            return ()=>{
                if (!warned) {
                    warned = true;
                    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
                }
            };
        })();
        exports2.colors = [
            "#0000CC",
            "#0000FF",
            "#0033CC",
            "#0033FF",
            "#0066CC",
            "#0066FF",
            "#0099CC",
            "#0099FF",
            "#00CC00",
            "#00CC33",
            "#00CC66",
            "#00CC99",
            "#00CCCC",
            "#00CCFF",
            "#3300CC",
            "#3300FF",
            "#3333CC",
            "#3333FF",
            "#3366CC",
            "#3366FF",
            "#3399CC",
            "#3399FF",
            "#33CC00",
            "#33CC33",
            "#33CC66",
            "#33CC99",
            "#33CCCC",
            "#33CCFF",
            "#6600CC",
            "#6600FF",
            "#6633CC",
            "#6633FF",
            "#66CC00",
            "#66CC33",
            "#9900CC",
            "#9900FF",
            "#9933CC",
            "#9933FF",
            "#99CC00",
            "#99CC33",
            "#CC0000",
            "#CC0033",
            "#CC0066",
            "#CC0099",
            "#CC00CC",
            "#CC00FF",
            "#CC3300",
            "#CC3333",
            "#CC3366",
            "#CC3399",
            "#CC33CC",
            "#CC33FF",
            "#CC6600",
            "#CC6633",
            "#CC9900",
            "#CC9933",
            "#CCCC00",
            "#CCCC33",
            "#FF0000",
            "#FF0033",
            "#FF0066",
            "#FF0099",
            "#FF00CC",
            "#FF00FF",
            "#FF3300",
            "#FF3333",
            "#FF3366",
            "#FF3399",
            "#FF33CC",
            "#FF33FF",
            "#FF6600",
            "#FF6633",
            "#FF9900",
            "#FF9933",
            "#FFCC00",
            "#FFCC33"
        ];
        function useColors() {
            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
            ;
            if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
                return false;
            }
            let m;
            return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
            ("TURBOPACK compile-time value", "undefined") !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
            // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
            typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
            typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
        }
        function formatArgs(args) {
            args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
            if (!this.useColors) {
                return;
            }
            const c = "color: " + this.color;
            args.splice(1, 0, c, "color: inherit");
            let index = 0;
            let lastC = 0;
            args[0].replace(/%[a-zA-Z%]/g, (match)=>{
                if (match === "%%") {
                    return;
                }
                index++;
                if (match === "%c") {
                    lastC = index;
                }
            });
            args.splice(lastC, 0, c);
        }
        exports2.log = console.debug || console.log || (()=>{});
        function save(namespaces) {
            try {
                if (namespaces) {
                    exports2.storage.setItem("debug", namespaces);
                } else {
                    exports2.storage.removeItem("debug");
                }
            } catch (error) {}
        }
        function load() {
            let r;
            try {
                r = exports2.storage.getItem("debug") || exports2.storage.getItem("DEBUG");
            } catch (error) {}
            if (!r && typeof process !== "undefined" && "env" in process) {
                r = process.env.DEBUG;
            }
            return r;
        }
        function localstorage() {
            try {
                return localStorage;
            } catch (error) {}
        }
        module2.exports = require_common()(exports2);
        var { formatters } = module2.exports;
        formatters.j = function(v) {
            try {
                return JSON.stringify(v);
            } catch (error) {
                return "[UnexpectedJSONParseError]: " + error.message;
            }
        };
    }
});
// ../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js
var require_has_flag = __commonJS({
    "../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js" (exports2, module2) {
        "use strict";
        module2.exports = (flag, argv = process.argv)=>{
            const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
            const position = argv.indexOf(prefix + flag);
            const terminatorPosition = argv.indexOf("--");
            return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
        };
    }
});
// ../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js
var require_supports_color = __commonJS({
    "../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js" (exports2, module2) {
        "use strict";
        var os3 = __turbopack_context__.r("[externals]/os [external] (os, cjs)");
        var tty = __turbopack_context__.r("[externals]/tty [external] (tty, cjs)");
        var hasFlag = require_has_flag();
        var { env } = process;
        var forceColor;
        if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
            forceColor = 0;
        } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
            forceColor = 1;
        }
        if ("FORCE_COLOR" in env) {
            if (env.FORCE_COLOR === "true") {
                forceColor = 1;
            } else if (env.FORCE_COLOR === "false") {
                forceColor = 0;
            } else {
                forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
            }
        }
        function translateLevel(level) {
            if (level === 0) {
                return false;
            }
            return {
                level,
                hasBasic: true,
                has256: level >= 2,
                has16m: level >= 3
            };
        }
        function supportsColor(haveStream, streamIsTTY) {
            if (forceColor === 0) {
                return 0;
            }
            if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
                return 3;
            }
            if (hasFlag("color=256")) {
                return 2;
            }
            if (haveStream && !streamIsTTY && forceColor === void 0) {
                return 0;
            }
            const min = forceColor || 0;
            if (env.TERM === "dumb") {
                return min;
            }
            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
            ;
            if ("CI" in env) {
                if ([
                    "TRAVIS",
                    "CIRCLECI",
                    "APPVEYOR",
                    "GITLAB_CI",
                    "GITHUB_ACTIONS",
                    "BUILDKITE"
                ].some((sign)=>sign in env) || env.CI_NAME === "codeship") {
                    return 1;
                }
                return min;
            }
            if ("TEAMCITY_VERSION" in env) {
                return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
            }
            if (env.COLORTERM === "truecolor") {
                return 3;
            }
            if ("TERM_PROGRAM" in env) {
                const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
                switch(env.TERM_PROGRAM){
                    case "iTerm.app":
                        return version >= 3 ? 3 : 2;
                    case "Apple_Terminal":
                        return 2;
                }
            }
            if (/-256(color)?$/i.test(env.TERM)) {
                return 2;
            }
            if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
                return 1;
            }
            if ("COLORTERM" in env) {
                return 1;
            }
            return min;
        }
        function getSupportLevel(stream) {
            const level = supportsColor(stream, stream && stream.isTTY);
            return translateLevel(level);
        }
        module2.exports = {
            supportsColor: getSupportLevel,
            stdout: translateLevel(supportsColor(true, tty.isatty(1))),
            stderr: translateLevel(supportsColor(true, tty.isatty(2)))
        };
    }
});
// ../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/node.js
var require_node = __commonJS({
    "../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/node.js" (exports2, module2) {
        var tty = __turbopack_context__.r("[externals]/tty [external] (tty, cjs)");
        var util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
        exports2.init = init;
        exports2.log = log;
        exports2.formatArgs = formatArgs;
        exports2.save = save;
        exports2.load = load;
        exports2.useColors = useColors;
        exports2.destroy = util.deprecate(()=>{}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        exports2.colors = [
            6,
            2,
            3,
            4,
            5,
            1
        ];
        try {
            const supportsColor = require_supports_color();
            if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
                exports2.colors = [
                    20,
                    21,
                    26,
                    27,
                    32,
                    33,
                    38,
                    39,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    56,
                    57,
                    62,
                    63,
                    68,
                    69,
                    74,
                    75,
                    76,
                    77,
                    78,
                    79,
                    80,
                    81,
                    92,
                    93,
                    98,
                    99,
                    112,
                    113,
                    128,
                    129,
                    134,
                    135,
                    148,
                    149,
                    160,
                    161,
                    162,
                    163,
                    164,
                    165,
                    166,
                    167,
                    168,
                    169,
                    170,
                    171,
                    172,
                    173,
                    178,
                    179,
                    184,
                    185,
                    196,
                    197,
                    198,
                    199,
                    200,
                    201,
                    202,
                    203,
                    204,
                    205,
                    206,
                    207,
                    208,
                    209,
                    214,
                    215,
                    220,
                    221
                ];
            }
        } catch (error) {}
        exports2.inspectOpts = Object.keys(process.env).filter((key)=>{
            return /^debug_/i.test(key);
        }).reduce((obj, key)=>{
            const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k)=>{
                return k.toUpperCase();
            });
            let val = process.env[key];
            if (/^(yes|on|true|enabled)$/i.test(val)) {
                val = true;
            } else if (/^(no|off|false|disabled)$/i.test(val)) {
                val = false;
            } else if (val === "null") {
                val = null;
            } else {
                val = Number(val);
            }
            obj[prop] = val;
            return obj;
        }, {});
        function useColors() {
            return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
        }
        function formatArgs(args) {
            const { namespace: name, useColors: useColors2 } = this;
            if (useColors2) {
                const c = this.color;
                const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
                const prefix = `  ${colorCode};1m${name} \x1B[0m`;
                args[0] = prefix + args[0].split("\n").join("\n" + prefix);
                args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
            } else {
                args[0] = getDate() + name + " " + args[0];
            }
        }
        function getDate() {
            if (exports2.inspectOpts.hideDate) {
                return "";
            }
            return /* @__PURE__ */ new Date().toISOString() + " ";
        }
        function log(...args) {
            return process.stderr.write(util.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
        }
        function save(namespaces) {
            if (namespaces) {
                process.env.DEBUG = namespaces;
            } else {
                delete process.env.DEBUG;
            }
        }
        function load() {
            return process.env.DEBUG;
        }
        function init(debug2) {
            debug2.inspectOpts = {};
            const keys = Object.keys(exports2.inspectOpts);
            for(let i = 0; i < keys.length; i++){
                debug2.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
            }
        }
        module2.exports = require_common()(exports2);
        var { formatters } = module2.exports;
        formatters.o = function(v) {
            this.inspectOpts.colors = this.useColors;
            return util.inspect(v, this.inspectOpts).split("\n").map((str)=>str.trim()).join(" ");
        };
        formatters.O = function(v) {
            this.inspectOpts.colors = this.useColors;
            return util.inspect(v, this.inspectOpts);
        };
    }
});
// ../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/index.js
var require_src = __commonJS({
    "../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/index.js" (exports2, module2) {
        if (typeof process === "undefined" || process.type === "renderer" || ("TURBOPACK compile-time value", false) === true || process.__nwjs) {
            module2.exports = require_browser();
        } else {
            module2.exports = require_node();
        }
    }
});
// ../../node_modules/.pnpm/is-docker@2.2.1/node_modules/is-docker/index.js
var require_is_docker = __commonJS({
    "../../node_modules/.pnpm/is-docker@2.2.1/node_modules/is-docker/index.js" (exports2, module2) {
        "use strict";
        var fs9 = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
        var isDocker;
        function hasDockerEnv() {
            try {
                fs9.statSync("/.dockerenv");
                return true;
            } catch (_) {
                return false;
            }
        }
        function hasDockerCGroup() {
            try {
                return fs9.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
            } catch (_) {
                return false;
            }
        }
        module2.exports = ()=>{
            if (isDocker === void 0) {
                isDocker = hasDockerEnv() || hasDockerCGroup();
            }
            return isDocker;
        };
    }
});
// ../../node_modules/.pnpm/is-wsl@2.2.0/node_modules/is-wsl/index.js
var require_is_wsl = __commonJS({
    "../../node_modules/.pnpm/is-wsl@2.2.0/node_modules/is-wsl/index.js" (exports2, module2) {
        "use strict";
        var os3 = __turbopack_context__.r("[externals]/os [external] (os, cjs)");
        var fs9 = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
        var isDocker = require_is_docker();
        var isWsl3 = ()=>{
            if ("TURBOPACK compile-time truthy", 1) {
                return false;
            }
            //TURBOPACK unreachable
            ;
        };
        if (process.env.__IS_WSL_TEST__) {
            module2.exports = isWsl3;
        } else {
            module2.exports = isWsl3();
        }
    }
});
// lib/v3/understudy/consoleMessage.ts
function formatRemoteObject(obj) {
    var _a;
    if (!obj) return "";
    if ("value" in obj) {
        const value = obj.value;
        if (value === void 0) return "";
        if (typeof value === "string") return value;
        try {
            return JSON.stringify(value);
        } catch (e) {
            return String(value);
        }
    }
    if (obj.unserializableValue) return obj.unserializableValue;
    if (obj.description) return obj.description;
    return (_a = obj.type) != null ? _a : "";
}
var ConsoleMessage;
var init_consoleMessage = __esm({
    "lib/v3/understudy/consoleMessage.ts" () {
        ConsoleMessage = class {
            constructor(event, pageRef){
                this.event = event;
                this.pageRef = pageRef;
            }
            type() {
                return this.event.type;
            }
            text() {
                const args = this.args();
                if (!args.length) return "";
                return args.map((arg)=>formatRemoteObject(arg)).filter((chunk)=>chunk.length > 0).join(" ");
            }
            args() {
                return this.event.args ? [
                    ...this.event.args
                ] : [];
            }
            location() {
                var _a, _b;
                const frame = (_b = (_a = this.event.stackTrace) == null ? void 0 : _a.callFrames) == null ? void 0 : _b[0];
                return {
                    url: frame == null ? void 0 : frame.url,
                    lineNumber: frame == null ? void 0 : frame.lineNumber,
                    columnNumber: frame == null ? void 0 : frame.columnNumber
                };
            }
            page() {
                return this.pageRef;
            }
            timestamp() {
                return this.event.timestamp;
            }
            raw() {
                return this.event;
            }
            toString() {
                return this.text();
            }
        };
    }
});
// lib/v3/understudy/response.ts
function isSerializableResponse(value) {
    if (!value || typeof value !== "object") return false;
    const candidate = value;
    if (typeof candidate.requestId !== "string") return false;
    if (!candidate.response || typeof candidate.response !== "object") {
        return false;
    }
    return true;
}
function createDeferred() {
    let resolve2;
    let reject;
    const promise = new Promise((res, rej)=>{
        resolve2 = res;
        reject = rej;
    });
    return {
        promise,
        resolve: resolve2,
        reject
    };
}
function normaliseHeaderName(name) {
    return name.toLowerCase();
}
function splitHeaderValues(value) {
    return value.split(/\r?\n/).map((part)=>part.trim()).filter(Boolean);
}
function parseHeadersText(headersText) {
    if (!headersText) return [];
    const lines = headersText.split(/\r?\n/);
    const entries = [];
    for (const line of lines){
        if (!line || line.startsWith("HTTP/")) continue;
        const index = line.indexOf(":");
        if (index === -1) continue;
        const name = line.slice(0, index).trim();
        const value = line.slice(index + 1).trim();
        entries.push({
            name,
            value
        });
    }
    return entries;
}
var Response;
var init_response = __esm({
    "lib/v3/understudy/response.ts" () {
        init_sdkErrors();
        Response = class _Response {
            /**
       * Build a response wrapper from the CDP notification associated with a
       * navigation. The constructor captures the owning page/session so follow-up
       * methods (body/text/json) can query CDP on-demand. The `response` payload is
       * the raw `Protocol.Network.Response` object emitted by Chrome.
       */ constructor(params){
                this.headersArrayCache = null;
                this.allHeadersCache = null;
                this.headerValuesMap = /* @__PURE__ */ new Map();
                this.finishedDeferred = createDeferred();
                this.finishedSettled = false;
                this.extraInfoHeaders = null;
                var _a;
                this.page = params.page;
                this.session = params.session;
                this.requestId = params.requestId;
                this.frameId = params.frameId;
                this.loaderId = params.loaderId;
                this.response = params.response;
                this.fromServiceWorkerFlag = params.fromServiceWorker;
                if (params.response.remoteIPAddress && params.response.remotePort !== void 0) {
                    this.serverAddress = {
                        ipAddress: params.response.remoteIPAddress,
                        port: params.response.remotePort
                    };
                } else {
                    this.serverAddress = null;
                }
                this.headersObject = {};
                for (const [name, value] of Object.entries((_a = this.response.headers) != null ? _a : {})){
                    const lower = normaliseHeaderName(name);
                    if (value === void 0) continue;
                    const values = splitHeaderValues(String(value));
                    this.headerValuesMap.set(lower, values);
                    this.headersObject[lower] = values.join(", ");
                }
            }
            /** URL associated with the navigation request. */ url() {
                return this.response.url;
            }
            /** HTTP status code reported by Chrome. */ status() {
                return this.response.status;
            }
            /** Human-readable status text that accompanied the response. */ statusText() {
                return this.response.statusText;
            }
            /** Convenience predicate that checks for 2xx statuses. */ ok() {
                const status = this.status();
                return status >= 200 && status <= 299;
            }
            /** Returns the Stagehand frame object that initiated the navigation. */ frame() {
                if (!this.frameId) return null;
                try {
                    return this.page.frameForId(this.frameId);
                } catch (e) {
                    return null;
                }
            }
            /** Indicates whether the response was serviced by a Service Worker. */ fromServiceWorker() {
                return this.fromServiceWorkerFlag;
            }
            /**
       * Returns TLS security metadata when provided by the browser. In practice
       * this includes certificate issuer, protocol, and validity interval.
       */ securityDetails() {
                return __async(this, null, function*() {
                    var _a;
                    return (_a = this.response.securityDetails) != null ? _a : null;
                });
            }
            /** Returns the resolved server address for the navigation when available. */ serverAddr() {
                return __async(this, null, function*() {
                    var _a;
                    return (_a = this.serverAddress) != null ? _a : null;
                });
            }
            /**
       * Returns the response headers normalised to lowercase keys. Matches the
       * behaviour of Playwright's `headers()` by eliding duplicate header entries.
       */ headers() {
                return __spreadValues({}, this.headersObject);
            }
            /**
       * Returns all headers including those only surfaced through
       * `responseReceivedExtraInfo` such as `set-cookie`. Values are reported as the
       * browser sends them (no further splitting or concatenation).
       */ allHeaders() {
                return __async(this, null, function*() {
                    var _a, _b;
                    if (this.allHeadersCache) return __spreadValues({}, this.allHeadersCache);
                    const source = (_b = (_a = this.extraInfoHeaders) != null ? _a : this.response.headers) != null ? _b : {};
                    const map = {};
                    for (const [name, value] of Object.entries(source)){
                        map[name] = String(value);
                    }
                    this.allHeadersCache = map;
                    return __spreadValues({}, map);
                });
            }
            /** Returns a concatenated header string for the supplied header name. */ headerValue(name) {
                return __async(this, null, function*() {
                    const values = yield this.headerValues(name);
                    if (!values.length) return null;
                    return values.join(", ");
                });
            }
            /** Returns all values for a header (case-insensitive lookup). */ headerValues(name) {
                return __async(this, null, function*() {
                    var _a;
                    const lower = normaliseHeaderName(name);
                    if (this.extraInfoHeaders) {
                        const raw = (_a = this.extraInfoHeaders[name]) != null ? _a : this.extraInfoHeaders[lower];
                        if (raw !== void 0) {
                            return splitHeaderValues(String(raw));
                        }
                    }
                    const values = this.headerValuesMap.get(lower);
                    return values ? [
                        ...values
                    ] : [];
                });
            }
            /**
       * Returns header entries preserving their original wire casing and ordering.
       * Falls back to the CDP object when the raw header text is unavailable.
       */ headersArray() {
                return __async(this, null, function*() {
                    var _a, _b;
                    if (this.headersArrayCache) return [
                        ...this.headersArrayCache
                    ];
                    const entriesFromText = parseHeadersText(this.extraInfoHeadersText);
                    if (entriesFromText.length > 0) {
                        this.headersArrayCache = entriesFromText;
                        return [
                            ...entriesFromText
                        ];
                    }
                    const entries = [];
                    const source = (_b = (_a = this.extraInfoHeaders) != null ? _a : this.response.headers) != null ? _b : {};
                    for (const [name, value] of Object.entries(source)){
                        const values = splitHeaderValues(String(value));
                        for (const val of values){
                            entries.push({
                                name,
                                value: val
                            });
                        }
                    }
                    this.headersArrayCache = entries;
                    return [
                        ...entries
                    ];
                });
            }
            /**
       * Requests the raw response body from Chrome DevTools Protocol. The method is
       * intentionally lazy because not every caller needs the payload, and CDP only
       * allows retrieving it once the response completes.
       */ body() {
                return __async(this, null, function*() {
                    const result = yield this.session.send("Network.getResponseBody", {
                        requestId: this.requestId
                    }).catch((error)=>{
                        throw new ResponseBodyError(String(error));
                    });
                    if (result.base64Encoded) {
                        return Buffer.from(result.body, "base64");
                    }
                    return Buffer.from(result.body, "utf-8");
                });
            }
            /** Decodes the response body as UTF-8 text. */ text() {
                return __async(this, null, function*() {
                    const buffer = yield this.body();
                    return buffer.toString("utf-8");
                });
            }
            /** Parses the response body as JSON and throws if parsing fails. */ json() {
                return __async(this, null, function*() {
                    const text = yield this.text();
                    try {
                        return JSON.parse(text);
                    } catch (error) {
                        throw new ResponseParseError(String(error));
                    }
                });
            }
            /**
       * Resolves once the underlying network request completes or fails. Mirrors
       * Playwright's behaviour by resolving to `null` on success and to an `Error`
       * instance when Chrome reports `Network.loadingFailed`.
       */ finished() {
                return __async(this, null, function*() {
                    return this.finishedDeferred.promise;
                });
            }
            /**
       * Internal helper invoked by the navigation tracker when CDP reports extra
       * header information. This keeps the cached header views in sync with the
       * richer metadata.
       */ applyExtraInfo(event) {
                var _a;
                this.extraInfoHeaders = event.headers;
                this.extraInfoHeadersText = event.headersText;
                this.allHeadersCache = null;
                this.headersArrayCache = null;
                this.headersObject = {};
                this.headerValuesMap.clear();
                const source = (_a = event.headers) != null ? _a : {};
                for (const [name, value] of Object.entries(source)){
                    const lower = normaliseHeaderName(name);
                    const segments = splitHeaderValues(String(value));
                    this.headerValuesMap.set(lower, segments);
                    this.headersObject[lower] = segments.join(", ");
                }
            }
            /**
       * Internal helper for creating a Response object from a Serializable
       * goto response from the Stagehand API
       */ static fromSerializable(serialized, context) {
                var _a;
                const reconstructed = new _Response({
                    page: context.page,
                    session: context.session,
                    requestId: serialized.requestId,
                    frameId: serialized.frameId,
                    loaderId: serialized.loaderId,
                    response: serialized.response,
                    fromServiceWorker: (_a = serialized.fromServiceWorkerFlag) != null ? _a : false
                });
                if (serialized.extraInfoHeaders) {
                    reconstructed.applyExtraInfo({
                        requestId: serialized.requestId,
                        headers: serialized.extraInfoHeaders,
                        headersText: serialized.extraInfoHeadersText
                    });
                }
                if (serialized.finishedSettled) {
                    reconstructed.markFinished(null);
                }
                return reconstructed;
            }
            /** Marks the response as finished and resolves the `finished()` promise. */ markFinished(error) {
                if (this.finishedSettled) return;
                this.finishedSettled = true;
                if (error) {
                    this.finishedDeferred.resolve(error);
                } else {
                    this.finishedDeferred.resolve(null);
                }
            }
        };
    }
});
// lib/v3/understudy/frame.ts
var Frame;
var init_frame = __esm({
    "lib/v3/understudy/frame.ts" () {
        init_locator();
        init_sdkErrors();
        Frame = class _Frame {
            constructor(session, frameId, pageId, remoteBrowser){
                this.session = session;
                this.frameId = frameId;
                this.pageId = pageId;
                this.remoteBrowser = remoteBrowser;
                var _a;
                this.sessionId = (_a = this.session.id) != null ? _a : null;
            }
            /** True when the controlled browser runs on a different machine. */ isBrowserRemote() {
                return this.remoteBrowser;
            }
            /** DOM.getNodeForLocation  DOM.describeNode */ getNodeAtLocation(x, y) {
                return __async(this, null, function*() {
                    yield this.session.send("DOM.enable");
                    const { backendNodeId } = yield this.session.send("DOM.getNodeForLocation", {
                        x,
                        y,
                        includeUserAgentShadowDOM: true,
                        ignorePointerEventsNone: false
                    });
                    const { node } = yield this.session.send("DOM.describeNode", {
                        backendNodeId
                    });
                    return node;
                });
            }
            /** CSS selector  DOM.querySelector  DOM.getBoxModel */ getLocationForSelector(selector) {
                return __async(this, null, function*() {
                    yield this.session.send("DOM.enable");
                    const { root } = yield this.session.send("DOM.getDocument");
                    const { nodeId } = yield this.session.send("DOM.querySelector", {
                        nodeId: root.nodeId,
                        selector
                    });
                    const { model } = yield this.session.send("DOM.getBoxModel", {
                        nodeId
                    });
                    const x = model.content[0];
                    const y = model.content[1];
                    const width = model.width;
                    const height = model.height;
                    return {
                        x,
                        y,
                        width,
                        height
                    };
                });
            }
            /** Accessibility.getFullAXTree (+ recurse into child frames if requested) */ getAccessibilityTree(withFrames = false) {
                return __async(this, null, function*() {
                    var _a, _b;
                    yield this.session.send("Accessibility.enable");
                    let nodes = [];
                    try {
                        ({ nodes } = yield this.session.send("Accessibility.getFullAXTree", {
                            frameId: this.frameId
                        }));
                    } catch (e) {
                        const msg = String((_b = (_a = e == null ? void 0 : e.message) != null ? _a : e) != null ? _b : "");
                        const isFrameScopeError = msg.includes("Frame with the given") || msg.includes("does not belong to the target") || msg.includes("is not found");
                        if (!isFrameScopeError) throw e;
                        ({ nodes } = yield this.session.send("Accessibility.getFullAXTree"));
                    }
                    if (!withFrames) return nodes;
                    const children = yield this.childFrames();
                    for (const child of children){
                        const childNodes = yield child.getAccessibilityTree(false);
                        nodes.push(...childNodes);
                    }
                    return nodes;
                });
            }
            /**
       * Evaluate a function or expression in this frame's isolated world.
       * - If a string is provided, treated as a JS expression.
       * - If a function is provided, it is stringified and invoked with the optional argument.
       */ evaluate(pageFunctionOrExpression, arg) {
                return __async(this, null, function*() {
                    var _a;
                    yield this.session.send("Runtime.enable").catch(()=>{});
                    const contextId = yield this.getExecutionContextId();
                    const isString = typeof pageFunctionOrExpression === "string";
                    let expression;
                    if (isString) {
                        expression = String(pageFunctionOrExpression);
                    } else {
                        const fnSrc = pageFunctionOrExpression.toString();
                        const argJson = JSON.stringify(arg);
                        expression = `(() => {
        const __fn = ${fnSrc};
        const __arg = ${argJson};
        try {
          const __res = __fn(__arg);
          return Promise.resolve(__res).then(v => {
            try { return JSON.parse(JSON.stringify(v)); } catch { return v; }
          });
        } catch (e) { throw e; }
      })()`;
                    }
                    const res = yield this.session.send("Runtime.evaluate", {
                        expression,
                        contextId,
                        awaitPromise: true,
                        returnByValue: true
                    });
                    if (res.exceptionDetails) {
                        throw new StagehandEvalError((_a = res.exceptionDetails.text) != null ? _a : "Evaluation failed");
                    }
                    return res.result.value;
                });
            }
            /** Page.captureScreenshot (frame-scoped session) */ screenshot(options) {
                return __async(this, null, function*() {
                    var _a;
                    yield this.session.send("Page.enable");
                    const format = (_a = options == null ? void 0 : options.type) != null ? _a : "png";
                    const params = {
                        format,
                        fromSurface: true,
                        captureBeyondViewport: options == null ? void 0 : options.fullPage
                    };
                    const clampScale = (value)=>Math.min(2, Math.max(0.1, value));
                    const normalizedScale = typeof (options == null ? void 0 : options.scale) === "number" ? clampScale(options.scale) : void 0;
                    if (options == null ? void 0 : options.clip) {
                        const clip = {
                            x: options.clip.x,
                            y: options.clip.y,
                            width: options.clip.width,
                            height: options.clip.height,
                            scale: normalizedScale != null ? normalizedScale : 1
                        };
                        params.clip = clip;
                    } else if (normalizedScale !== void 0 && normalizedScale !== 1) {
                        params.scale = normalizedScale;
                    }
                    if (format === "jpeg" && typeof (options == null ? void 0 : options.quality) === "number") {
                        const q = Math.round(options.quality);
                        params.quality = Math.min(100, Math.max(0, q));
                    }
                    const { data } = yield this.session.send("Page.captureScreenshot", params);
                    return Buffer.from(data, "base64");
                });
            }
            /** Child frames via Page.getFrameTree */ childFrames() {
                return __async(this, null, function*() {
                    const { frameTree } = yield this.session.send("Page.getFrameTree");
                    const frames = [];
                    const collect = (tree)=>{
                        var _a;
                        if (tree.frame.parentId === this.frameId) {
                            frames.push(new _Frame(this.session, tree.frame.id, this.pageId, this.remoteBrowser));
                        }
                        (_a = tree.childFrames) == null ? void 0 : _a.forEach(collect);
                    };
                    collect(frameTree);
                    return frames;
                });
            }
            /** Wait for a lifecycle state (load/domcontentloaded/networkidle) */ waitForLoadState(state = "load") {
                return __async(this, null, function*() {
                    yield this.session.send("Page.enable");
                    yield new Promise((resolve2)=>{
                        const handler = (evt)=>{
                            if (evt.frameId === this.frameId && evt.name === state) {
                                this.session.off("Page.lifecycleEvent", handler);
                                resolve2();
                            }
                        };
                        this.session.on("Page.lifecycleEvent", handler);
                    });
                });
            }
            /** Simple placeholder for your own locator abstraction */ locator(selector, options) {
                return new Locator(this, selector, options);
            }
            /** Create/get an isolated world for this frame and return its executionContextId */ getExecutionContextId() {
                return __async(this, null, function*() {
                    yield this.session.send("Page.enable");
                    yield this.session.send("Runtime.enable");
                    const { executionContextId } = yield this.session.send("Page.createIsolatedWorld", {
                        frameId: this.frameId,
                        worldName: "v3-world"
                    });
                    return executionContextId;
                });
            }
        };
    }
});
// lib/v3/understudy/frameRegistry.ts
function shellFrame(id) {
    return {
        id,
        loaderId: "",
        url: "",
        domainAndRegistry: "",
        securityOrigin: "",
        mimeType: "text/html",
        secureContextType: "InsecureScheme",
        crossOriginIsolatedContextType: "NotIsolated",
        gatedAPIFeatures: []
    };
}
var FrameRegistry;
var init_frameRegistry = __esm({
    "lib/v3/understudy/frameRegistry.ts" () {
        FrameRegistry = class {
            constructor(ownerTargetId, mainFrameId){
                /** frameId  FrameInfo */ this.frames = /* @__PURE__ */ new Map();
                /** sessionId  Set<frameId> (inverse map for diagnostics/fast membership checks) */ this.framesBySession = /* @__PURE__ */ new Map();
                this.ownerTargetId = ownerTargetId;
                this.rootFrameId = mainFrameId;
                this.ensureNode(mainFrameId);
            }
            // ---------------------- Mutators (called by Context/Page bridges) ----------------------
            /**
       * Record that a frame attached. If `parentId` is null and `frameId` differs from the current
       * root, this is a root swap and we rename the root id.
       *
       * IMPORTANT: The emitter's `sessionId` is the **owner** for the new/attached frame.
       */ onFrameAttached(frameId, parentId, sessionId) {
                if (!parentId && frameId !== this.rootFrameId) {
                    this.renameNodeId(this.rootFrameId, frameId);
                    this.rootFrameId = frameId;
                    this.setOwnerSessionIdInternal(frameId, sessionId);
                    return;
                }
                this.ensureNode(frameId);
                if (parentId) this.ensureNode(parentId);
                const info = this.frames.get(frameId);
                info.parentId = parentId != null ? parentId : null;
                if (parentId) {
                    this.frames.get(parentId).children.add(frameId);
                }
                this.setOwnerSessionIdInternal(frameId, sessionId);
            }
            /**
       * Record a navigation with the full CDP `Frame`. Also updates ownership based on the emitting
       * session id. Handles root swap if the navigated frame is the new main (no parentId).
       */ onFrameNavigated(frame, sessionId) {
                this.ensureNode(frame.id);
                const info = this.frames.get(frame.id);
                info.lastSeen = frame;
                this.setOwnerSessionIdInternal(frame.id, sessionId);
                if (!("parentId" in frame) || !frame.parentId) {
                    if (frame.id !== this.rootFrameId) {
                        this.renameNodeId(this.rootFrameId, frame.id);
                        this.rootFrameId = frame.id;
                    }
                }
            }
            onNavigatedWithinDocument(frameId, url, sessionId) {
                var _a;
                this.ensureNode(frameId);
                const info = this.frames.get(frameId);
                const lastSeen = (_a = info.lastSeen) != null ? _a : shellFrame(frameId);
                info.lastSeen = __spreadProps(__spreadValues({}, lastSeen), {
                    url
                });
                this.setOwnerSessionIdInternal(frameId, sessionId);
            }
            /**
       * Record that a frame detached. If `reason !== "swap"`, remove the subtree from the graph,
       * and clean the inverse maps. For swap we keep the node to preserve continuity.
       */ onFrameDetached(frameId, reason = "remove") {
                if (reason === "swap") return;
                const toRemove = [];
                const collect = (fid)=>{
                    var _a, _b;
                    toRemove.push(fid);
                    const kids = (_b = (_a = this.frames.get(fid)) == null ? void 0 : _a.children) != null ? _b : /* @__PURE__ */ new Set();
                    for (const k of kids)collect(k);
                };
                collect(frameId);
                for (const fid of toRemove){
                    const info = this.frames.get(fid);
                    if (!info) continue;
                    if (info.parentId) {
                        const p = this.frames.get(info.parentId);
                        p == null ? void 0 : p.children.delete(fid);
                    }
                    if (info.ownerSessionId) {
                        const bag = this.framesBySession.get(info.ownerSessionId);
                        bag == null ? void 0 : bag.delete(fid);
                        if (bag && bag.size === 0) this.framesBySession.delete(info.ownerSessionId);
                    }
                    this.frames.delete(fid);
                }
                if (!this.frames.has(this.rootFrameId)) {
                    const iter = this.frames.keys().next();
                    if (!iter.done) this.rootFrameId = iter.value;
                }
            }
            /**
       * An adopted OOPIF child session was created whose **main** frame id equals the parent iframes frameId.
       * We mark the entire child subtree as owned by `childSessionId`.
       * (Topology edges remain aligned by the parent sessions `frameAttached` events.)
       */ adoptChildSession(childSessionId, childMainFrameId) {
                this.setOwnerSessionIdInternal(childMainFrameId, childSessionId);
            }
            /**
       * Seed topology and ownership from an existing `Page.getFrameTree` snapshot, typically right after
       * a session is attached. This is a best-effort: we record frames and set the provided `sessionId`
       * as owner for the subtree **if** an owner isn't already set.
       */ seedFromFrameTree(sessionId, frameTree) {
                const walk = (tree, parent)=>{
                    var _a;
                    this.ensureNode(tree.frame.id);
                    this.frames.get(tree.frame.id).parentId = parent;
                    if (parent) this.frames.get(parent).children.add(tree.frame.id);
                    this.frames.get(tree.frame.id).lastSeen = tree.frame;
                    if (!this.frames.get(tree.frame.id).ownerSessionId) {
                        this.setOwnerSessionIdInternal(tree.frame.id, sessionId);
                    }
                    for (const c of (_a = tree.childFrames) != null ? _a : [])walk(c, tree.frame.id);
                };
                walk(frameTree, null);
            }
            /**
       * Set the backendNodeId of the `<iframe>` element for a child frame **as seen from its parent**.
       * This is useful for building absolute XPath prefixes later (from the parent document).
       */ setOwnerBackendNodeId(childFrameId, backendNodeId) {
                this.ensureNode(childFrameId);
                this.frames.get(childFrameId).ownerBackendNodeId = backendNodeId;
            }
            // ---------------------- Readers (consumed by Page/snapshot/locators) ----------------------
            mainFrameId() {
                return this.rootFrameId;
            }
            /**
       * Return the owner session id for this frame. If unknown, returns `undefined`.
       */ getOwnerSessionId(frameId) {
                var _a;
                return (_a = this.frames.get(frameId)) == null ? void 0 : _a.ownerSessionId;
            }
            /**
       * Return the owner backendNodeId (iframe element) if recorded.
       * This is in the **parent** document; pair it with `getParent`.
       */ getOwnerBackendNodeId(frameId) {
                var _a;
                return (_a = this.frames.get(frameId)) == null ? void 0 : _a.ownerBackendNodeId;
            }
            /**
       * Return the parent frame id, or null for root/unknown.
       */ getParent(frameId) {
                var _a, _b;
                return (_b = (_a = this.frames.get(frameId)) == null ? void 0 : _a.parentId) != null ? _b : null;
            }
            /**
       * List frame ids in root-first DFS order (same shape as CDPs FrameTree traversal).
       */ listAllFrames() {
                const out = [];
                const dfs = (fid)=>{
                    var _a, _b;
                    out.push(fid);
                    const kids = (_b = (_a = this.frames.get(fid)) == null ? void 0 : _a.children) != null ? _b : /* @__PURE__ */ new Set();
                    for (const k of kids)dfs(k);
                };
                if (this.frames.has(this.rootFrameId)) dfs(this.rootFrameId);
                return out;
            }
            /**
       * Serialize to `Protocol.Page.FrameTree` starting at the given root id (typically mainFrameId()).
       */ asProtocolFrameTree(rootId) {
                const build = (fid)=>{
                    var _a, _b;
                    const info = this.frames.get(fid);
                    const frame = (_a = info == null ? void 0 : info.lastSeen) != null ? _a : shellFrame(fid);
                    const kids = (_b = info == null ? void 0 : info.children) != null ? _b : /* @__PURE__ */ new Set();
                    const childFrames = kids.size ? [
                        ...kids
                    ].map((k)=>build(k)) : void 0;
                    return childFrames ? {
                        frame,
                        childFrames
                    } : {
                        frame
                    };
                };
                return build(rootId);
            }
            /**
       * For diagnostics: return the current owner sessions for a frame id (0..n),
       * usually 0 or 1, but helpful to see potential inconsistencies during wiring.
       */ sessionsForFrame(frameId) {
                const info = this.frames.get(frameId);
                return (info == null ? void 0 : info.ownerSessionId) ? [
                    info.ownerSessionId
                ] : [];
            }
            /**
       * For diagnostics: return current frame set per session.
       */ framesForSession(sessionId) {
                var _a;
                return [
                    ...(_a = this.framesBySession.get(sessionId)) != null ? _a : /* @__PURE__ */ new Set()
                ];
            }
            // ---------------------- Internal helpers ----------------------
            ensureNode(fid) {
                if (this.frames.has(fid)) return;
                this.frames.set(fid, {
                    parentId: null,
                    children: /* @__PURE__ */ new Set(),
                    lastSeen: shellFrame(fid),
                    ownerSessionId: void 0,
                    ownerBackendNodeId: void 0
                });
            }
            renameNodeId(oldId, newId) {
                if (oldId === newId) return;
                this.ensureNode(oldId);
                const info = this.frames.get(oldId);
                this.frames.delete(oldId);
                this.frames.set(newId, __spreadValues({}, info));
                if (info.parentId) {
                    const p = this.frames.get(info.parentId);
                    if (p) {
                        p.children.delete(oldId);
                        p.children.add(newId);
                    }
                }
                for (const c of info.children){
                    const ci = this.frames.get(c);
                    if (ci) ci.parentId = newId;
                }
                if (info.ownerSessionId) {
                    const bag = this.framesBySession.get(info.ownerSessionId);
                    if (bag) {
                        bag.delete(oldId);
                        bag.add(newId);
                    }
                }
            }
            setOwnerSessionIdInternal(frameId, sessionId) {
                var _a;
                this.ensureNode(frameId);
                const info = this.frames.get(frameId);
                if (info.ownerSessionId === sessionId) return;
                if (info.ownerSessionId) {
                    const prev = this.framesBySession.get(info.ownerSessionId);
                    prev == null ? void 0 : prev.delete(frameId);
                    if (prev && prev.size === 0) this.framesBySession.delete(info.ownerSessionId);
                }
                info.ownerSessionId = sessionId;
                const bag = (_a = this.framesBySession.get(sessionId)) != null ? _a : /* @__PURE__ */ new Set();
                bag.add(frameId);
                this.framesBySession.set(sessionId, bag);
            }
        };
    }
});
// lib/v3/types/private/network.ts
var DEFAULT_IDLE_WAIT, IGNORED_RESOURCE_TYPES;
var init_network = __esm({
    "lib/v3/types/private/network.ts" () {
        DEFAULT_IDLE_WAIT = 500;
        IGNORED_RESOURCE_TYPES = /* @__PURE__ */ new Set([
            "EventSource",
            "WebSocket"
        ]);
    }
});
// lib/v3/understudy/networkManager.ts
var NetworkManager;
var init_networkManager = __esm({
    "lib/v3/understudy/networkManager.ts" () {
        init_network();
        NetworkManager = class {
            constructor(){
                this.sessions = /* @__PURE__ */ new Map();
                this.observers = /* @__PURE__ */ new Set();
                this.requests = /* @__PURE__ */ new Map();
                this.documentRequestsByFrame = /* @__PURE__ */ new Map();
            }
            /**
       * Begin tracking network traffic for a CDP session (top-level or OOPIF).
       * Safe to call multiple times; duplicate registrations are ignored.
       */ trackSession(session) {
                const sid = this.sessionKey(session);
                if (this.sessions.has(sid)) return;
                const onRequest = (evt)=>{
                    var _a, _b, _c;
                    if (!evt || !evt.requestId) return;
                    const info = {
                        sessionId: sid,
                        requestId: evt.requestId,
                        requestKey: this.requestKey(sid, evt.requestId),
                        frameId: (_a = evt.frameId) != null ? _a : void 0,
                        loaderId: (_b = evt.loaderId) != null ? _b : void 0,
                        url: (_c = evt.request) == null ? void 0 : _c.url,
                        timestamp: Date.now(),
                        resourceType: evt.type,
                        documentRequest: evt.type === "Document"
                    };
                    this.requests.set(info.requestKey, info);
                    if (info.documentRequest && info.frameId) {
                        this.documentRequestsByFrame.set(info.frameId, info.requestKey);
                    }
                    this.emitStart(info);
                };
                const finish = (reqId)=>{
                    const key = this.requestKey(sid, reqId);
                    const stored = this.requests.get(key);
                    if (stored == null ? void 0 : stored.frameId) {
                        this.documentRequestsByFrame.delete(stored.frameId);
                    }
                    const info = stored != null ? stored : {
                        sessionId: sid,
                        requestId: reqId,
                        requestKey: key,
                        timestamp: Date.now(),
                        documentRequest: false
                    };
                    this.requests.delete(key);
                    this.emitFinish(info);
                };
                const fail = (reqId)=>{
                    const key = this.requestKey(sid, reqId);
                    const stored = this.requests.get(key);
                    if (stored == null ? void 0 : stored.frameId) {
                        this.documentRequestsByFrame.delete(stored.frameId);
                    }
                    const info = stored != null ? stored : {
                        sessionId: sid,
                        requestId: reqId,
                        requestKey: key,
                        timestamp: Date.now(),
                        documentRequest: false
                    };
                    this.requests.delete(key);
                    this.emitFailure(info);
                };
                const onFinished = (evt)=>{
                    if (!(evt == null ? void 0 : evt.requestId)) return;
                    finish(evt.requestId);
                };
                const onFailed = (evt)=>{
                    if (!(evt == null ? void 0 : evt.requestId)) return;
                    fail(evt.requestId);
                };
                const onResponse = (evt)=>{
                    var _a, _b;
                    if (!(evt == null ? void 0 : evt.requestId)) return;
                    const url = (_b = (_a = evt.response) == null ? void 0 : _a.url) != null ? _b : "";
                    if (url.startsWith("data:")) finish(evt.requestId);
                };
                const onFrameStopped = (evt)=>{
                    if (!(evt == null ? void 0 : evt.frameId)) return;
                    const key = this.documentRequestsByFrame.get(evt.frameId);
                    if (!key) return;
                    const stored = this.requests.get(key);
                    if (!stored) {
                        this.documentRequestsByFrame.delete(evt.frameId);
                        return;
                    }
                    this.requests.delete(key);
                    this.documentRequestsByFrame.delete(evt.frameId);
                    this.emitFinish(__spreadProps(__spreadValues({}, stored), {
                        timestamp: Date.now()
                    }));
                };
                session.on("Network.requestWillBeSent", onRequest);
                session.on("Network.loadingFinished", onFinished);
                session.on("Network.loadingFailed", onFailed);
                session.on("Network.requestServedFromCache", onFinished);
                session.on("Network.responseReceived", onResponse);
                session.on("Page.frameStoppedLoading", onFrameStopped);
                void session.send("Network.enable").catch(()=>{});
                void session.send("Page.enable").catch(()=>{});
                this.sessions.set(sid, {
                    session,
                    detach: ()=>{
                        session.off("Network.requestWillBeSent", onRequest);
                        session.off("Network.loadingFinished", onFinished);
                        session.off("Network.loadingFailed", onFailed);
                        session.off("Network.requestServedFromCache", onFinished);
                        session.off("Network.responseReceived", onResponse);
                        session.off("Page.frameStoppedLoading", onFrameStopped);
                    }
                });
            }
            /**
       * Stop tracking a session and discard any inflight bookkeeping owned by it.
       */ untrackSession(rawSessionId) {
                const sid = rawSessionId != null ? rawSessionId : "__main__";
                const entry = this.sessions.get(sid);
                if (!entry) return;
                entry.detach();
                this.sessions.delete(sid);
                for (const key of [
                    ...this.requests.keys()
                ]){
                    if (key.startsWith(`${sid}:`)) this.requests.delete(key);
                }
                for (const [frameId, key] of [
                    ...this.documentRequestsByFrame.entries()
                ]){
                    if (key.startsWith(`${sid}:`)) {
                        this.documentRequestsByFrame.delete(frameId);
                    }
                }
            }
            /**
       * Register a passive observer for request lifecycle notifications.
       * Returns a disposer that removes the observer.
       */ addObserver(observer) {
                this.observers.add(observer);
                return ()=>{
                    this.observers.delete(observer);
                };
            }
            /**
       * Resolve once no (filtered) requests are in flight for the given quiet window.
       * The waiter automatically unregisters itself on completion or timeout.
       */ waitForIdle(options) {
                var _a, _b, _c, _d;
                const startTime = (_a = options.startTime) != null ? _a : Date.now();
                const idleTimeMs = (_b = options.idleTimeMs) != null ? _b : DEFAULT_IDLE_WAIT;
                const timeoutMs = options.timeoutMs;
                const remainingBudgetMs = Number.isFinite(timeoutMs) ? timeoutMs : void 0;
                const originalBudgetMs = Number.isFinite((_c = options.totalBudgetMs) != null ? _c : NaN) ? options.totalBudgetMs : remainingBudgetMs;
                const filter2 = (_d = options.filter) != null ? _d : (info)=>{
                    return !IGNORED_RESOURCE_TYPES.has(info.resourceType);
                };
                const tracked = /* @__PURE__ */ new Set();
                let idleTimer = null;
                let timeoutTimer = null;
                let settled = false;
                let resolveFn = null;
                let rejectFn = null;
                const cleanup = (error)=>{
                    if (settled) return;
                    settled = true;
                    if (idleTimer) clearTimeout(idleTimer);
                    if (timeoutTimer) clearTimeout(timeoutTimer);
                    removeObserver();
                    tracked.clear();
                    if (error) {
                        rejectFn == null ? void 0 : rejectFn(error);
                    } else {
                        resolveFn == null ? void 0 : resolveFn();
                    }
                };
                const maybeIdle = ()=>{
                    if (settled) return;
                    if (tracked.size === 0) {
                        if (!idleTimer) {
                            idleTimer = setTimeout(()=>{
                                cleanup();
                            }, idleTimeMs);
                        }
                    } else if (idleTimer) {
                        clearTimeout(idleTimer);
                        idleTimer = null;
                    }
                };
                const observer = {
                    onRequestStarted: (info)=>{
                        if (settled) return;
                        if (info.timestamp < startTime) return;
                        if (!filter2(info)) return;
                        tracked.add(info.requestKey);
                        if (idleTimer) {
                            clearTimeout(idleTimer);
                            idleTimer = null;
                        }
                    },
                    onRequestFinished: (info)=>{
                        if (settled) return;
                        if (!tracked.delete(info.requestKey)) return;
                        maybeIdle();
                    },
                    onRequestFailed: (info)=>{
                        if (settled) return;
                        if (!tracked.delete(info.requestKey)) return;
                        maybeIdle();
                    }
                };
                const removeObserver = this.addObserver(observer);
                const promise = new Promise((resolve2, reject)=>{
                    resolveFn = resolve2;
                    rejectFn = reject;
                });
                maybeIdle();
                if (Number.isFinite(timeoutMs)) {
                    timeoutTimer = setTimeout(()=>{
                        const elapsed = Date.now() - startTime;
                        const message = originalBudgetMs !== void 0 ? `networkidle timed out after ${originalBudgetMs}ms` : `networkidle timed out after ${elapsed}ms`;
                        cleanup(new Error(message));
                    }, Math.max(0, timeoutMs));
                }
                return {
                    promise,
                    dispose: ()=>cleanup(new Error("waitForIdle disposed"))
                };
            }
            /**
       * Tear down all session listeners and clear observers/bookkeeping.
       */ dispose() {
                for (const { detach } of this.sessions.values()){
                    detach();
                }
                this.sessions.clear();
                this.observers.clear();
                this.requests.clear();
                this.documentRequestsByFrame.clear();
            }
            /** Fan-out helper when a tracked request starts. */ emitStart(info) {
                for (const obs of this.observers){
                    obs.onRequestStarted(info);
                }
            }
            /** Fan-out helper when a tracked request completes successfully. */ emitFinish(info) {
                for (const obs of this.observers){
                    obs.onRequestFinished(info);
                }
            }
            /** Fan-out helper when a tracked request fails mid-flight. */ emitFailure(info) {
                for (const obs of this.observers){
                    obs.onRequestFailed(info);
                }
            }
            /** Compute a stable key for a session (falls back to synthetic root id). */ sessionKey(session) {
                var _a;
                return (_a = session.id) != null ? _a : "__main__";
            }
            /** Compose the unique key for tracking a request under a session. */ requestKey(sessionId, requestId) {
                return `${sessionId}:${requestId}`;
            }
        };
    }
});
// lib/v3/understudy/lifecycleWatcher.ts
var LifecycleWatcher;
var init_lifecycleWatcher = __esm({
    "lib/v3/understudy/lifecycleWatcher.ts" () {
        init_sdkErrors();
        init_network();
        LifecycleWatcher = class {
            /**
       * Create a watcher; callers should subsequently invoke {@link wait}.
       */ constructor(params){
                this.cleanupCallbacks = [];
                this.idleHandle = null;
                this.abortReject = null;
                this.abortError = null;
                this.disposed = false;
                this.pendingFollowupNavigation = false;
                this.page = params.page;
                this.mainSession = params.mainSession;
                this.networkManager = params.networkManager;
                this.waitUntil = params.waitUntil;
                this.timeoutMs = params.timeoutMs;
                this.startTime = Date.now();
                this.navigationCommandId = params.navigationCommandId;
                this.idleStartTime = this.startTime;
                this.abortPromise = new Promise((_, reject)=>{
                    this.abortReject = reject;
                });
                this.installSessionListeners();
            }
            /** Hint the watcher with the loader id returned by Page.navigate. */ setExpectedLoaderId(loaderId) {
                if (!loaderId) return;
                this.expectedLoaderId = loaderId;
                this.initialLoaderId = loaderId;
                this.currentLoaderId = loaderId;
                this.idleStartTime = Date.now();
            }
            /** Wait for the requested lifecycle state or throw on timeout/abort. */ wait() {
                return __async(this, null, function*() {
                    const deadline = Date.now() + this.timeoutMs;
                    try {
                        if (this.waitUntil === "domcontentloaded") {
                            yield this.awaitWithAbort(this.page.waitForMainLoadState("domcontentloaded", this.timeRemaining(deadline)));
                            return;
                        }
                        while(true){
                            yield this.awaitWithAbort(this.page.waitForMainLoadState("load", this.timeRemaining(deadline)));
                            if (this.waitUntil !== "networkidle") break;
                            try {
                                yield this.awaitWithAbort(this.waitForNetworkIdle(deadline));
                                break;
                            } catch (error) {
                                if (this.shouldRestartAfterFollowup(error)) {
                                    continue;
                                }
                                throw error;
                            }
                        }
                    } finally{
                        this.dispose();
                    }
                    if (this.abortError) throw this.abortError;
                });
            }
            /** Cancel any outstanding network-idle waits and remove event listeners. */ dispose() {
                if (this.disposed) return;
                this.disposed = true;
                if (this.idleHandle) {
                    void this.idleHandle.promise.catch(()=>{});
                    this.idleHandle.dispose();
                    this.idleHandle = null;
                }
                for (const fn of this.cleanupCallbacks){
                    try {
                        fn();
                    } catch (e) {}
                }
                this.cleanupCallbacks = [];
                this.abortReject = null;
            }
            /** Subscribe to main-frame events to detect abort conditions. */ installSessionListeners() {
                const onFrameNavigated = (evt)=>{
                    var _a;
                    if (!((_a = evt == null ? void 0 : evt.frame) == null ? void 0 : _a.id)) return;
                    const mainFrameId = this.page.mainFrameId();
                    if (evt.frame.id !== mainFrameId) return;
                    const loaderId = evt.frame.loaderId;
                    if (!loaderId) return;
                    if (!this.initialLoaderId) {
                        this.initialLoaderId = loaderId;
                        this.currentLoaderId = loaderId;
                        this.idleStartTime = Date.now();
                    }
                    if (!this.expectedLoaderId) {
                        this.expectedLoaderId = loaderId;
                        this.currentLoaderId = loaderId;
                        this.idleStartTime = Date.now();
                        return;
                    }
                    if (loaderId !== this.expectedLoaderId) {
                        if (!this.page.isCurrentNavigationCommand(this.navigationCommandId)) {
                            this.triggerAbort(new Error("Navigation was superseded by a new request"));
                            return;
                        }
                        this.adoptNewMainLoader(loaderId);
                    }
                };
                const onFrameDetached = (evt)=>{
                    if (!(evt == null ? void 0 : evt.frameId)) return;
                    const mainFrameId = this.page.mainFrameId();
                    if (evt.frameId !== mainFrameId) return;
                    if (evt.reason === "swap") return;
                    this.triggerAbort(new Error("Main frame was detached"));
                };
                this.mainSession.on("Page.frameNavigated", onFrameNavigated);
                this.cleanupCallbacks.push(()=>{
                    this.mainSession.off("Page.frameNavigated", onFrameNavigated);
                });
                this.mainSession.on("Page.frameDetached", onFrameDetached);
                this.cleanupCallbacks.push(()=>{
                    this.mainSession.off("Page.frameDetached", onFrameDetached);
                });
            }
            /** Compute remaining time until the shared deadline elapses. */ timeRemaining(deadline) {
                const remaining = deadline - Date.now();
                if (remaining <= 0) {
                    throw new TimeoutError("Lifecycle wait", this.timeoutMs);
                }
                return remaining;
            }
            /** Await an operation but abort early if navigation replacement fires. */ awaitWithAbort(operation) {
                return __async(this, null, function*() {
                    try {
                        return yield Promise.race([
                            operation,
                            this.abortPromise
                        ]);
                    } catch (error) {
                        if (this.abortError) throw this.abortError;
                        throw error;
                    }
                });
            }
            /** Mark the watcher as aborted and reject any pending waiters. */ triggerAbort(error) {
                if (this.abortError) return;
                this.abortError = error;
                if (this.abortReject) {
                    this.abortReject(error);
                    this.abortReject = null;
                }
            }
            waitForNetworkIdle(deadline) {
                this.pendingFollowupNavigation = false;
                const remaining = this.timeRemaining(deadline);
                const idleWindow = Math.min(DEFAULT_IDLE_WAIT, remaining);
                this.idleHandle = this.networkManager.waitForIdle({
                    startTime: this.idleStartTime,
                    timeoutMs: remaining,
                    totalBudgetMs: this.timeoutMs,
                    idleTimeMs: idleWindow,
                    filter: this.buildIdleFilter()
                });
                return this.idleHandle.promise.catch((error)=>{
                    if (this.abortError) throw this.abortError;
                    throw error;
                });
            }
            shouldRestartAfterFollowup(error) {
                if (!this.pendingFollowupNavigation) return false;
                if (!(error instanceof Error)) return false;
                if (error.message !== "waitForIdle disposed") return false;
                this.pendingFollowupNavigation = false;
                return true;
            }
            adoptNewMainLoader(loaderId) {
                this.expectedLoaderId = loaderId;
                this.currentLoaderId = loaderId;
                this.idleStartTime = Date.now();
                if (this.waitUntil !== "networkidle") return;
                this.pendingFollowupNavigation = true;
                if (this.idleHandle) {
                    const handle = this.idleHandle;
                    this.idleHandle = null;
                    void handle.promise.catch(()=>{});
                    handle.dispose();
                }
            }
            buildIdleFilter() {
                const loaderId = this.currentLoaderId;
                const mainFrameId = this.page.mainFrameId();
                return (info)=>{
                    if (IGNORED_RESOURCE_TYPES.has(info.resourceType)) return false;
                    if (loaderId && info.loaderId) {
                        return info.loaderId === loaderId;
                    }
                    if (!info.loaderId && info.frameId) {
                        return info.frameId === mainFrameId;
                    }
                    return true;
                };
            }
        };
    }
});
// lib/v3/understudy/navigationResponseTracker.ts
var NavigationResponseTracker;
var init_navigationResponseTracker = __esm({
    "lib/v3/understudy/navigationResponseTracker.ts" () {
        init_response();
        NavigationResponseTracker = class {
            /**
       * Create a tracker bound to a specific navigation command. The tracker begins
       * listening for network events immediately so it should be constructed before
       * the navigation request is dispatched.
       */ constructor(params){
                this.selectedRequestId = null;
                this.selectedResponse = null;
                this.acceptNextWithoutLoader = false;
                this.responseResolved = false;
                this.pendingResponsesByLoader = /* @__PURE__ */ new Map();
                this.pendingExtraInfo = /* @__PURE__ */ new Map();
                this.listeners = [];
                this.page = params.page;
                this.session = params.session;
                this.navigationCommandId = params.navigationCommandId;
                this.responsePromise = new Promise((resolve2)=>{
                    this.resolveResponse = (value)=>{
                        if (this.responseResolved) return;
                        this.responseResolved = true;
                        resolve2(value);
                    };
                });
                this.installListeners();
            }
            /** Stop listening for CDP events and release any pending bookkeeping. */ dispose() {
                for (const { event, handler } of this.listeners){
                    this.session.off(event, handler);
                }
                this.listeners.length = 0;
                this.pendingResponsesByLoader.clear();
                this.pendingExtraInfo.clear();
            }
            /**
       * Hint the tracker with the loader id returned by `Page.navigate`. Chrome only
       * emits this once the browser begins navigating, so we store early responses
       * and match them once the loader id is known.
       */ setExpectedLoaderId(loaderId) {
                if (!loaderId) return;
                this.expectedLoaderId = loaderId;
                const pending = this.pendingResponsesByLoader.get(loaderId);
                if (pending) {
                    this.pendingResponsesByLoader.delete(loaderId);
                    this.selectResponse(pending);
                }
            }
            /**
       * Some navigation APIs (reload/history traversal) do not provide a loader id
       * up front. This flag instructs the tracker to accept the next qualifying
       * document response even if no loader id has been announced yet.
       */ expectNavigationWithoutKnownLoader() {
                this.acceptNextWithoutLoader = true;
            }
            /**
       * Returns a promise that resolves with the matched response (or `null` when
       * no document response was observed).
       */ navigationCompleted() {
                return __async(this, null, function*() {
                    if (!this.responseResolved) {
                        queueMicrotask(()=>{
                            if (!this.responseResolved) this.resolveResponse(null);
                        });
                    }
                    return this.responsePromise;
                });
            }
            /** Expose the raw response promise (mainly for tests). */ response() {
                return __async(this, null, function*() {
                    return this.responsePromise;
                });
            }
            /** Register all CDP listeners relevant to navigation tracking. */ installListeners() {
                this.addListener("Network.responseReceived", (event)=>{
                    this.onResponseReceived(event);
                });
                this.addListener("Network.responseReceivedExtraInfo", (event)=>{
                    this.onResponseReceivedExtraInfo(event);
                });
                this.addListener("Network.loadingFinished", (event)=>{
                    this.onLoadingFinished(event);
                });
                this.addListener("Network.loadingFailed", (event)=>{
                    this.onLoadingFailed(event);
                });
            }
            /** Attach a CDP listener and track it for later disposal. */ addListener(event, handler) {
                this.session.on(event, handler);
                this.listeners.push({
                    event,
                    handler
                });
            }
            /** Handle the initial response payload for document navigations. */ onResponseReceived(event) {
                var _a;
                if (!this.page.isCurrentNavigationCommand(this.navigationCommandId)) return;
                if (!event || !event.response) return;
                if (event.type !== "Document") return;
                if (event.frameId !== this.page.mainFrameId()) return;
                const loaderId = (_a = event.loaderId) != null ? _a : "";
                if (this.acceptNextWithoutLoader) {
                    this.acceptNextWithoutLoader = false;
                    this.selectResponse(event);
                    return;
                }
                if (this.expectedLoaderId) {
                    if (loaderId && loaderId !== this.expectedLoaderId) {
                        this.pendingResponsesByLoader.set(loaderId, event);
                        return;
                    }
                    this.selectResponse(event);
                    return;
                }
                if (loaderId) {
                    this.pendingResponsesByLoader.set(loaderId, event);
                    return;
                }
                this.selectResponse(event);
            }
            /** Merge auxiliary header information once Chrome exposes it. */ onResponseReceivedExtraInfo(event) {
                var _a;
                if (!event || !event.requestId) return;
                if (this.selectedRequestId && event.requestId === this.selectedRequestId) {
                    (_a = this.selectedResponse) == null ? void 0 : _a.applyExtraInfo(event);
                    return;
                }
                this.pendingExtraInfo.set(event.requestId, event);
            }
            /** Resolve the response's finished promise when the request completes. */ onLoadingFinished(event) {
                var _a;
                if (!event || !event.requestId) return;
                if (event.requestId !== this.selectedRequestId) return;
                (_a = this.selectedResponse) == null ? void 0 : _a.markFinished(null);
            }
            /** Resolve the response's finished promise with an error on failure. */ onLoadingFailed(event) {
                var _a;
                if (!event || !event.requestId) return;
                if (event.requestId !== this.selectedRequestId) return;
                const errorText = event.errorText || "Navigation request failed";
                (_a = this.selectedResponse) == null ? void 0 : _a.markFinished(new Error(errorText));
            }
            /**
       * Create the `Response` wrapper for the chosen document response and
       * resolve awaiting consumers. Subsequent events flesh out the header/body
       * helpers and mark the request as finished.
       */ selectResponse(event) {
                var _a, _b, _c, _d, _e, _f;
                if (event.loaderId) {
                    this.pendingResponsesByLoader.delete(event.loaderId);
                }
                if (this.responseResolved) return;
                if (this.selectedResponse) return;
                const protocol = (_c = (_b = (_a = event.response) == null ? void 0 : _a.protocol) == null ? void 0 : _b.toLowerCase()) != null ? _c : "";
                const url = (_e = (_d = event.response) == null ? void 0 : _d.url) != null ? _e : "";
                const isDataUrl = protocol === "data" || url.startsWith("data:");
                const isAboutUrl = protocol === "about" || url.startsWith("about:");
                if (isDataUrl || isAboutUrl) {
                    this.pendingExtraInfo.delete(event.requestId);
                    this.selectedRequestId = null;
                    this.selectedResponse = null;
                    this.resolveResponse(null);
                    return;
                }
                const response = new Response({
                    page: this.page,
                    session: this.session,
                    requestId: event.requestId,
                    frameId: event.frameId,
                    loaderId: event.loaderId,
                    response: event.response,
                    fromServiceWorker: Boolean((_f = event.response) == null ? void 0 : _f.fromServiceWorker)
                });
                this.selectedRequestId = event.requestId;
                this.selectedResponse = response;
                const extraInfo = this.pendingExtraInfo.get(event.requestId);
                if (extraInfo) {
                    response.applyExtraInfo(extraInfo);
                    this.pendingExtraInfo.delete(event.requestId);
                }
                this.resolveResponse(response);
            }
        };
    }
});
// lib/v3/understudy/screenshotUtils.ts
function collectFramesForScreenshot(page) {
    const seen = /* @__PURE__ */ new Map();
    const main = page.mainFrame();
    seen.set(main.frameId, main);
    for (const frame of page.frames()){
        seen.set(frame.frameId, frame);
    }
    return Array.from(seen.values());
}
function normalizeScreenshotClip(clip) {
    const x = Number(clip.x);
    const y = Number(clip.y);
    const width = Number(clip.width);
    const height = Number(clip.height);
    for (const [key, value] of Object.entries({
        x,
        y,
        width,
        height
    })){
        if (!Number.isFinite(value)) {
            throw new StagehandInvalidArgumentError(`screenshot: clip.${key} must be a finite number`);
        }
    }
    if (width <= 0 || height <= 0) {
        throw new StagehandInvalidArgumentError("screenshot: clip width/height must be positive");
    }
    return {
        x,
        y,
        width,
        height
    };
}
function computeScreenshotScale(page, mode) {
    return __async(this, null, function*() {
        if (mode !== "css") return void 0;
        try {
            const frame = page.mainFrame();
            const dpr = yield frame.evaluate(()=>{
                const ratio = Number(window.devicePixelRatio || 1);
                return Number.isFinite(ratio) && ratio > 0 ? ratio : 1;
            }).catch(()=>1);
            const safeRatio = Number.isFinite(dpr) && dpr > 0 ? dpr : 1;
            return Math.min(2, Math.max(0.1, 1 / safeRatio));
        } catch (e) {
            return 1;
        }
    });
}
function setTransparentBackground(session) {
    return __async(this, null, function*() {
        yield session.send("Emulation.setDefaultBackgroundColorOverride", {
            color: {
                r: 0,
                g: 0,
                b: 0,
                a: 0
            }
        }).catch(()=>{});
        return ()=>__async(null, null, function*() {
                yield session.send("Emulation.setDefaultBackgroundColorOverride", {}).catch(()=>{});
            });
    });
}
function applyStyleToFrames(frames, css, label) {
    return __async(this, null, function*() {
        const trimmed = css.trim();
        if (!trimmed) return ()=>__async(null, null, function*() {});
        const token = `__v3_style_${label}_${Date.now()}_${Math.random().toString(36).slice(2)}`;
        yield Promise.all(frames.map((frame)=>frame.evaluate(({ css: css2, token: token2 })=>{
                try {
                    const doc = document;
                    if (!doc) return;
                    const style = doc.createElement("style");
                    style.setAttribute("data-stagehand-style", token2);
                    style.textContent = css2;
                    const parent = doc.head || doc.documentElement || doc.body;
                    parent == null ? void 0 : parent.appendChild(style);
                } catch (e) {}
            }, {
                css: trimmed,
                token
            }).catch(()=>{})));
        return ()=>__async(null, null, function*() {
                yield Promise.all(frames.map((frame)=>frame.evaluate((token2)=>{
                        try {
                            const doc = document;
                            if (!doc) return;
                            const nodes = doc.querySelectorAll(`[data-stagehand-style="${token2}"]`);
                            nodes.forEach((node)=>node.remove());
                        } catch (e) {}
                    }, token).catch(()=>{})));
            });
    });
}
function disableAnimations(frames) {
    return __async(this, null, function*() {
        const css = `
*,
*::before,
*::after {
  animation-delay: 0s !important;
  animation-duration: 0s !important;
  animation-iteration-count: 1 !important;
  animation-play-state: paused !important;
  transition-property: none !important;
  transition-duration: 0s !important;
  transition-delay: 0s !important;
}`;
        const cleanup = yield applyStyleToFrames(frames, css, "animations");
        yield Promise.all(frames.map((frame)=>frame.evaluate(()=>{
                var _a, _b, _c, _d, _e;
                try {
                    const animations = typeof document.getAnimations === "function" ? document.getAnimations() : [];
                    for (const animation of animations){
                        try {
                            const details = (_b = (_a = animation.effect) == null ? void 0 : _a.getComputedTiming) == null ? void 0 : _b.call(_a);
                            if (details && details.iterations !== Infinity) {
                                (_c = animation.finish) == null ? void 0 : _c.call(animation);
                            } else {
                                (_d = animation.cancel) == null ? void 0 : _d.call(animation);
                            }
                        } catch (e) {
                            (_e = animation.cancel) == null ? void 0 : _e.call(animation);
                        }
                    }
                } catch (e) {}
            }).catch(()=>{})));
        return cleanup;
    });
}
function hideCaret(frames) {
    return __async(this, null, function*() {
        const css = `
input,
textarea,
[contenteditable],
[contenteditable=""],
[contenteditable="true"],
[contenteditable="plaintext-only"],
*:focus {
  caret-color: transparent !important;
}`;
        return applyStyleToFrames(frames, css, "caret");
    });
}
function applyMaskOverlays(locators, color) {
    return __async(this, null, function*() {
        var _a;
        const rectsByFrame = /* @__PURE__ */ new Map();
        for (const locator of locators){
            try {
                const info = yield resolveMaskRect(locator);
                if (!info) continue;
                const list = (_a = rectsByFrame.get(info.frame)) != null ? _a : [];
                list.push(info.rect);
                rectsByFrame.set(info.frame, list);
            } catch (e) {}
        }
        if (rectsByFrame.size === 0) {
            return ()=>__async(null, null, function*() {});
        }
        const token = `__v3_mask_${Date.now()}_${Math.random().toString(36).slice(2)}`;
        yield Promise.all(Array.from(rectsByFrame.entries()).map(([frame, rects])=>frame.evaluate(({ rects: rects2, color: color2, token: token2 })=>{
                try {
                    const doc = document;
                    if (!doc) return;
                    const root = doc.documentElement || doc.body;
                    if (!root) return;
                    for (const rect of rects2){
                        const el = doc.createElement("div");
                        el.setAttribute("data-stagehand-mask", token2);
                        el.style.position = "absolute";
                        el.style.left = `${rect.x}px`;
                        el.style.top = `${rect.y}px`;
                        el.style.width = `${rect.width}px`;
                        el.style.height = `${rect.height}px`;
                        el.style.backgroundColor = color2;
                        el.style.pointerEvents = "none";
                        el.style.zIndex = "2147483647";
                        el.style.opacity = "1";
                        el.style.mixBlendMode = "normal";
                        root.appendChild(el);
                    }
                } catch (e) {}
            }, {
                rects,
                color,
                token
            }).catch(()=>{})));
        return ()=>__async(null, null, function*() {
                yield Promise.all(Array.from(rectsByFrame.keys()).map((frame)=>frame.evaluate((token2)=>{
                        try {
                            const doc = document;
                            if (!doc) return;
                            const nodes = doc.querySelectorAll(`[data-stagehand-mask="${token2}"]`);
                            nodes.forEach((node)=>node.remove());
                        } catch (e) {}
                    }, token).catch(()=>{})));
            });
    });
}
function resolveMaskRect(locator) {
    return __async(this, null, function*() {
        const frame = locator.getFrame();
        const session = frame.session;
        let objectId = null;
        try {
            const resolved = yield locator.resolveNode();
            objectId = resolved.objectId;
            const result = yield session.send("Runtime.callFunctionOn", {
                objectId,
                functionDeclaration: `function() {
          if (!this || typeof this.getBoundingClientRect !== 'function') return null;
          const rect = this.getBoundingClientRect();
          if (!rect) return null;
          const style = window.getComputedStyle(this);
          if (!style) return null;
          if (style.visibility === 'hidden' || style.display === 'none') return null;
          if (rect.width <= 0 || rect.height <= 0) return null;
          return {
            x: rect.left + window.scrollX,
            y: rect.top + window.scrollY,
            width: rect.width,
            height: rect.height,
          };
        }`,
                returnByValue: true
            });
            if (result.exceptionDetails) {
                return null;
            }
            const rect = result.result.value;
            if (!rect) return null;
            const { x, y, width, height } = rect;
            if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(width) || !Number.isFinite(height) || width <= 0 || height <= 0) {
                return null;
            }
            return {
                frame,
                rect: {
                    x,
                    y,
                    width,
                    height
                }
            };
        } catch (e) {
            return null;
        } finally{
            if (objectId) {
                yield session.send("Runtime.releaseObject", {
                    objectId
                }).catch(()=>{});
            }
        }
    });
}
function runScreenshotCleanups(cleanups) {
    return __async(this, null, function*() {
        for(let i = cleanups.length - 1; i >= 0; i -= 1){
            const fn = cleanups[i];
            if (!fn) continue;
            try {
                const result = fn();
                if (result && typeof result.then === "function") {
                    yield result;
                }
            } catch (e) {}
        }
    });
}
function withScreenshotTimeout(timeoutMs, task) {
    return __async(this, null, function*() {
        if (!timeoutMs || timeoutMs <= 0) return task();
        let timer = null;
        const timeoutPromise = new Promise((_, reject)=>{
            timer = setTimeout(()=>{
                reject(new Error(`screenshot: timeout of ${timeoutMs}ms exceeded`));
            }, timeoutMs);
        });
        try {
            return yield Promise.race([
                task(),
                timeoutPromise
            ]);
        } finally{
            if (timer) clearTimeout(timer);
        }
    });
}
var init_screenshotUtils = __esm({
    "lib/v3/understudy/screenshotUtils.ts" () {
        init_sdkErrors();
    }
});
// lib/v3/understudy/page.ts
var page_exports = {};
__export(page_exports, {
    Page: ()=>Page
});
var import_fs6, LIFECYCLE_NAME, Page;
var init_page = __esm({
    "lib/v3/understudy/page.ts" () {
        import_fs6 = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
        init_logger();
        init_frame();
        init_frameLocator();
        init_deepLocator();
        init_snapshot();
        init_frameRegistry();
        init_networkManager();
        init_lifecycleWatcher();
        init_navigationResponseTracker();
        init_response();
        init_consoleMessage();
        init_sdkErrors();
        init_screenshotUtils();
        LIFECYCLE_NAME = {
            load: "load",
            domcontentloaded: "DOMContentLoaded",
            networkidle: "networkIdle"
        };
        Page = class _Page {
            constructor(conn, mainSession, _targetId, mainFrameId, apiClient, browserIsRemote = false){
                this.conn = conn;
                this.mainSession = mainSession;
                this._targetId = _targetId;
                /** Every CDP child session this page owns (top-level + adopted OOPIF sessions). */ this.sessions = /* @__PURE__ */ new Map();
                /** Compact ordinal per frameId (used by snapshot encoding). */ this.frameOrdinals = /* @__PURE__ */ new Map();
                this.nextOrdinal = 0;
                /** cache Frames per frameId so everyone uses the same one */ this.frameCache = /* @__PURE__ */ new Map();
                /** Cached current URL for synchronous page.url() */ this._currentUrl = "about:blank";
                this.navigationCommandSeq = 0;
                this.latestNavigationCommandId = 0;
                /** Optional API client for routing page operations to the API */ this.apiClient = null;
                this.consoleListeners = /* @__PURE__ */ new Set();
                this.consoleHandlers = /* @__PURE__ */ new Map();
                // --- Optional visual cursor overlay management ---
                this.cursorEnabled = false;
                // Track pressed modifier keys
                this._pressedModifiers = /* @__PURE__ */ new Set();
                this.pageId = _targetId;
                this.apiClient = apiClient != null ? apiClient : null;
                this.browserIsRemote = browserIsRemote;
                if (mainSession.id) this.sessions.set(mainSession.id, mainSession);
                this.registry = new FrameRegistry(_targetId, mainFrameId);
                this.mainFrameWrapper = new Frame(this.mainSession, mainFrameId, this.pageId, this.browserIsRemote);
                this.networkManager = new NetworkManager();
                this.networkManager.trackSession(this.mainSession);
            }
            ensureCursorScript() {
                return __async(this, null, function*() {
                    const script = `(() => {
      const ID = '__v3_cursor_overlay__';
      const state = { el: null, last: null };
      // Expose API early so move() calls before install are buffered
      try {
        if (!window.__v3Cursor || !window.__v3Cursor.__installed) {
          const api = {
            __installed: false,
            move(x, y) {
              if (state.el) {
                state.el.style.left = Math.max(0, x) + 'px';
                state.el.style.top = Math.max(0, y) + 'px';
              } else {
                state.last = [x, y];
              }
            },
            show() { if (state.el) state.el.style.display = 'block'; },
            hide() { if (state.el) state.el.style.display = 'none'; },
          };
          window.__v3Cursor = api;
        }
      } catch {}

      function install() {
        try {
          if (state.el) return; // already installed
          let el = document.getElementById(ID);
          if (!el) {
            const root = document.documentElement || document.body || document.head;
            if (!root) { setTimeout(install, 50); return; }
            el = document.createElement('div');
            el.id = ID;
            el.style.position = 'fixed';
            el.style.left = '0px';
            el.style.top = '0px';
            el.style.width = '16px';
            el.style.height = '24px';
            el.style.zIndex = '2147483647';
            el.style.pointerEvents = 'none';
            el.style.userSelect = 'none';
            el.style.mixBlendMode = 'normal';
            el.style.contain = 'layout style paint';
            el.style.willChange = 'transform,left,top';
            el.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="24" viewBox="0 0 16 24"><path d="M1 0 L1 22 L6 14 L15 14 Z" fill="black" stroke="white" stroke-width="0.7"/></svg>';
            root.appendChild(el);
          }
          state.el = el;
          try { window.__v3Cursor.__installed = true; } catch {}
          if (state.last) {
            window.__v3Cursor.move(state.last[0], state.last[1]);
            state.last = null;
          }
        } catch {}
      }

      if (document.readyState === 'complete' || document.readyState === 'interactive') {
        install();
      } else {
        document.addEventListener('DOMContentLoaded', install, { once: true });
        setTimeout(install, 100);
      }
    })();`;
                    yield this.mainSession.send("Page.addScriptToEvaluateOnNewDocument", {
                        source: script
                    }).catch(()=>{});
                    yield this.mainSession.send("Runtime.evaluate", {
                        expression: script,
                        includeCommandLineAPI: false
                    }).catch(()=>{});
                });
            }
            enableCursorOverlay() {
                return __async(this, null, function*() {
                    if (this.cursorEnabled) return;
                    yield this.ensureCursorScript();
                    this.cursorEnabled = true;
                });
            }
            updateCursor(x, y) {
                return __async(this, null, function*() {
                    if (!this.cursorEnabled) return;
                    try {
                        yield this.mainSession.send("Runtime.evaluate", {
                            expression: `typeof window.__v3Cursor!=="undefined"&&window.__v3Cursor.move(${Math.round(x)}, ${Math.round(y)})`
                        });
                    } catch (e) {}
                });
            }
            /**
       * Factory: create Page and seed registry with the shallow tree from Page.getFrameTree.
       * Assumes Page domain is already enabled on the session passed in.
       */ static create(conn, session, targetId, apiClient, localBrowserLaunchOptions, browserIsRemote = false) {
                return __async(this, null, function*() {
                    var _a, _b, _c, _d;
                    yield session.send("Page.enable").catch(()=>{});
                    yield session.send("Page.setLifecycleEventsEnabled", {
                        enabled: true
                    }).catch(()=>{});
                    const { frameTree } = yield session.send("Page.getFrameTree");
                    const mainFrameId = frameTree.frame.id;
                    const page = new _Page(conn, session, targetId, mainFrameId, apiClient, browserIsRemote);
                    try {
                        page._currentUrl = String((_b = (_a = frameTree == null ? void 0 : frameTree.frame) == null ? void 0 : _a.url) != null ? _b : page._currentUrl);
                        if (localBrowserLaunchOptions == null ? void 0 : localBrowserLaunchOptions.viewport) {
                            yield page.setViewportSize(localBrowserLaunchOptions.viewport.width, localBrowserLaunchOptions.viewport.height, {
                                deviceScaleFactor: (_c = localBrowserLaunchOptions.deviceScaleFactor) != null ? _c : 1
                            });
                        }
                    } catch (e) {}
                    page.registry.seedFromFrameTree((_d = session.id) != null ? _d : "root", frameTree);
                    return page;
                });
            }
            // ---------------- Event-driven updates from Context ----------------
            /**
       * Parent/child session emitted a `frameAttached`.
       * Topology update + ownership stamped to **emitting session**.
       */ onFrameAttached(frameId, parentId, session) {
                var _a;
                this.ensureOrdinal(frameId);
                this.registry.onFrameAttached(frameId, parentId, (_a = session.id) != null ? _a : "root");
                this.frameCache.delete(frameId);
            }
            /**
       * Parent/child session emitted a `frameDetached`.
       */ onFrameDetached(frameId, reason = "remove") {
                this.registry.onFrameDetached(frameId, reason);
                this.frameCache.delete(frameId);
            }
            /**
       * Parent/child session emitted a `frameNavigated`.
       * Topology + ownership update. Handles root swaps.
       */ onFrameNavigated(frame, session) {
                var _a, _b, _c;
                const prevRoot = this.mainFrameId();
                this.registry.onFrameNavigated(frame, (_a = session.id) != null ? _a : "root");
                const newRoot = this.mainFrameId();
                if (newRoot !== prevRoot) {
                    const oldOrd = (_b = this.frameOrdinals.get(prevRoot)) != null ? _b : 0;
                    this.frameOrdinals.set(newRoot, oldOrd);
                    this.mainFrameWrapper = new Frame(this.mainSession, newRoot, this.pageId, this.browserIsRemote);
                }
                if (frame.id === this.mainFrameId()) {
                    try {
                        this._currentUrl = String((_c = frame == null ? void 0 : frame.url) != null ? _c : this._currentUrl);
                    } catch (e) {}
                }
                this.frameCache.delete(frame.id);
            }
            onNavigatedWithinDocument(frameId, url, session) {
                var _a;
                const normalized = String(url != null ? url : "").trim();
                if (!normalized) return;
                this.registry.onNavigatedWithinDocument(frameId, normalized, (_a = session.id) != null ? _a : "root");
                if (frameId === this.mainFrameId()) {
                    this._currentUrl = normalized;
                }
            }
            /**
       * An OOPIF child session whose **main** frame id equals the parent iframes frameId
       * has been attached; adopt the session into this Page and seed ownership for its subtree.
       */ adoptOopifSession(childSession, childMainFrameId) {
                var _a;
                if (childSession.id) this.sessions.set(childSession.id, childSession);
                this.networkManager.trackSession(childSession);
                if (this.consoleListeners.size > 0) {
                    this.installConsoleTap(childSession);
                }
                this.registry.adoptChildSession((_a = childSession.id) != null ? _a : "child", childMainFrameId);
                this.frameCache.delete(childMainFrameId);
                childSession.on("Page.frameNavigated", (evt)=>{
                    this.onFrameNavigated(evt.frame, childSession);
                });
                childSession.on("Page.frameAttached", (evt)=>{
                    var _a2;
                    this.onFrameAttached(evt.frameId, (_a2 = evt.parentFrameId) != null ? _a2 : null, childSession);
                });
                childSession.on("Page.frameDetached", (evt)=>{
                    var _a2;
                    this.onFrameDetached(evt.frameId, (_a2 = evt.reason) != null ? _a2 : "remove");
                });
                void (()=>__async(this, null, function*() {
                        var _a2;
                        try {
                            yield childSession.send("Page.enable").catch(()=>{});
                            let { frameTree } = yield childSession.send("Page.getFrameTree");
                            if (frameTree.frame.id !== childMainFrameId) {
                                frameTree = __spreadProps(__spreadValues({}, frameTree), {
                                    frame: __spreadProps(__spreadValues({}, frameTree.frame), {
                                        id: childMainFrameId
                                    })
                                });
                            }
                            this.registry.seedFromFrameTree((_a2 = childSession.id) != null ? _a2 : "child", frameTree);
                        } catch (e) {}
                    }))();
            }
            /** Detach an adopted child session and prune its subtree */ detachOopifSession(sessionId) {
                for (const fid of this.registry.framesForSession(sessionId)){
                    this.registry.onFrameDetached(fid, "remove");
                    this.frameCache.delete(fid);
                }
                this.teardownConsoleTap(sessionId);
                this.sessions.delete(sessionId);
                this.networkManager.untrackSession(sessionId);
            }
            // ---------------- Ownership helpers / lookups ----------------
            /** Return the owning CDP session for a frameId (falls back to main session) */ getSessionForFrame(frameId) {
                var _a;
                const sid = this.registry.getOwnerSessionId(frameId);
                if (!sid) return this.mainSession;
                return (_a = this.sessions.get(sid)) != null ? _a : this.mainSession;
            }
            /** Always returns a Frame bound to the owning session */ frameForId(frameId) {
                const hit = this.frameCache.get(frameId);
                if (hit) return hit;
                const sess = this.getSessionForFrame(frameId);
                const f = new Frame(sess, frameId, this.pageId, this.browserIsRemote);
                this.frameCache.set(frameId, f);
                return f;
            }
            /** Expose a session by id (used by snapshot to resolve session id -> session) */ getSessionById(id) {
                return this.sessions.get(id);
            }
            registerSessionForNetwork(session) {
                this.networkManager.trackSession(session);
            }
            unregisterSessionForNetwork(sessionId) {
                this.networkManager.untrackSession(sessionId);
            }
            on(event, listener) {
                if (event !== "console") {
                    throw new StagehandInvalidArgumentError(`Unsupported event: ${event}`);
                }
                const firstListener = this.consoleListeners.size === 0;
                this.consoleListeners.add(listener);
                if (firstListener) {
                    this.ensureConsoleTaps();
                }
                return this;
            }
            once(event, listener) {
                if (event !== "console") {
                    throw new StagehandInvalidArgumentError(`Unsupported event: ${event}`);
                }
                const wrapper = (message)=>{
                    this.off("console", wrapper);
                    listener(message);
                };
                return this.on("console", wrapper);
            }
            off(event, listener) {
                if (event !== "console") {
                    throw new StagehandInvalidArgumentError(`Unsupported event: ${event}`);
                }
                this.consoleListeners.delete(listener);
                if (this.consoleListeners.size === 0) {
                    this.removeAllConsoleTaps();
                }
                return this;
            }
            // ---------------- MAIN APIs ----------------
            targetId() {
                return this._targetId;
            }
            /**
       * Send a CDP command through the main session.
       * Allows external consumers to execute arbitrary Chrome DevTools Protocol commands.
       *
       * @param method - The CDP method name (e.g., "Page.enable", "Runtime.evaluate")
       * @param params - Optional parameters for the CDP command
       * @returns Promise resolving to the typed CDP response
       *
       * @example
       * // Enable the Runtime domain
       * await page.sendCDP("Runtime.enable");
       *
       * @example
       * // Evaluate JavaScript with typed response
       * const result = await page.sendCDP<Protocol.Runtime.EvaluateResponse>(
       *   "Runtime.evaluate",
       *   { expression: "1 + 1" }
       * );
       */ sendCDP(method, params) {
                return __async(this, null, function*() {
                    return this.mainSession.send(method, params);
                });
            }
            /** Seed the cached URL before navigation events converge. */ seedCurrentUrl(url) {
                if (!url) return;
                try {
                    const normalized = String(url).trim();
                    if (!normalized) return;
                    this._currentUrl = normalized;
                } catch (e) {}
            }
            mainFrameId() {
                return this.registry.mainFrameId();
            }
            mainFrame() {
                return this.mainFrameWrapper;
            }
            /**
       * Close this top-level page (tab). Best-effort via Target.closeTarget.
       */ close() {
                return __async(this, null, function*() {
                    try {
                        yield this.conn.send("Target.closeTarget", {
                            targetId: this._targetId
                        });
                    } catch (e) {}
                    const deadline = Date.now() + 2e3;
                    while(Date.now() < deadline){
                        try {
                            const targets = yield this.conn.getTargets();
                            if (!targets.some((t)=>t.targetId === this._targetId)) {
                                this.networkManager.dispose();
                                return;
                            }
                        } catch (e) {}
                        yield new Promise((r)=>setTimeout(r, 25));
                    }
                    this.networkManager.dispose();
                    this.removeAllConsoleTaps();
                    this.consoleListeners.clear();
                });
            }
            getFullFrameTree() {
                return this.asProtocolFrameTree(this.mainFrameId());
            }
            asProtocolFrameTree(rootMainFrameId) {
                return this.registry.asProtocolFrameTree(rootMainFrameId);
            }
            ensureOrdinal(frameId) {
                const hit = this.frameOrdinals.get(frameId);
                if (hit !== void 0) return hit;
                const ord = this.nextOrdinal++;
                this.frameOrdinals.set(frameId, ord);
                return ord;
            }
            /** Public getter for snapshot code / handlers. */ getOrdinal(frameId) {
                return this.ensureOrdinal(frameId);
            }
            listAllFrameIds() {
                return this.registry.listAllFrames();
            }
            ensureConsoleTaps() {
                if (this.consoleListeners.size === 0) return;
                this.installConsoleTap(this.mainSession);
                for (const session of this.sessions.values()){
                    this.installConsoleTap(session);
                }
            }
            installConsoleTap(session) {
                const key = this.sessionKey(session);
                if (this.consoleHandlers.has(key)) return;
                void session.send("Runtime.enable").catch(()=>{});
                const handler = (evt)=>{
                    this.emitConsole(evt);
                };
                session.on("Runtime.consoleAPICalled", handler);
                this.consoleHandlers.set(key, handler);
            }
            sessionKey(session) {
                var _a;
                return (_a = session.id) != null ? _a : "__root__";
            }
            resolveSessionByKey(key) {
                if (this.mainSession.id) {
                    if (this.mainSession.id === key) return this.mainSession;
                } else if (key === "__root__") {
                    return this.mainSession;
                }
                return this.sessions.get(key);
            }
            teardownConsoleTap(key) {
                const handler = this.consoleHandlers.get(key);
                if (!handler) return;
                const session = this.resolveSessionByKey(key);
                session == null ? void 0 : session.off("Runtime.consoleAPICalled", handler);
                this.consoleHandlers.delete(key);
            }
            removeAllConsoleTaps() {
                for (const key of [
                    ...this.consoleHandlers.keys()
                ]){
                    this.teardownConsoleTap(key);
                }
            }
            emitConsole(evt) {
                if (this.consoleListeners.size === 0) return;
                const message = new ConsoleMessage(evt, this);
                const listeners = [
                    ...this.consoleListeners
                ];
                for (const listener of listeners){
                    try {
                        listener(message);
                    } catch (error) {
                        v3Logger({
                            category: "page",
                            message: "Console listener threw",
                            level: 2,
                            auxiliary: {
                                error: {
                                    value: String(error),
                                    type: "string"
                                },
                                type: {
                                    value: evt.type,
                                    type: "string"
                                }
                            }
                        });
                    }
                }
            }
            // -------- Convenience APIs delegated to the current main frame --------
            /**
       * Navigate the page; optionally wait for a lifecycle state.
       * Waits on the **current** main frame and follows root swaps during navigation.
       */ goto(url, options) {
                return __async(this, null, function*() {
                    var _a, _b;
                    const waitUntil = (_a = options == null ? void 0 : options.waitUntil) != null ? _a : "domcontentloaded";
                    const timeout = (_b = options == null ? void 0 : options.timeoutMs) != null ? _b : 15e3;
                    const navigationCommandId = this.beginNavigationCommand();
                    const tracker = new NavigationResponseTracker({
                        page: this,
                        session: this.mainSession,
                        navigationCommandId
                    });
                    const watcher = new LifecycleWatcher({
                        page: this,
                        mainSession: this.mainSession,
                        networkManager: this.networkManager,
                        waitUntil,
                        timeoutMs: timeout,
                        navigationCommandId
                    });
                    try {
                        if (this.apiClient) {
                            const result = yield this.apiClient.goto(url, {
                                waitUntil: options == null ? void 0 : options.waitUntil
                            }, this.mainFrameId());
                            this._currentUrl = url;
                            if (isSerializableResponse(result)) {
                                return Response.fromSerializable(result, {
                                    page: this,
                                    session: this.mainSession
                                });
                            }
                            return result;
                        }
                        const response = yield this.mainSession.send("Page.navigate", {
                            url
                        });
                        this._currentUrl = url;
                        if (response == null ? void 0 : response.loaderId) {
                            watcher.setExpectedLoaderId(response.loaderId);
                            tracker.setExpectedLoaderId(response.loaderId);
                        }
                        yield watcher.wait();
                        return yield tracker.navigationCompleted();
                    } finally{
                        watcher.dispose();
                        tracker.dispose();
                    }
                });
            }
            /**
       * Reload the page; optionally wait for a lifecycle state.
       */ reload(options) {
                return __async(this, null, function*() {
                    var _a, _b;
                    const waitUntil = options == null ? void 0 : options.waitUntil;
                    const timeout = (_a = options == null ? void 0 : options.timeoutMs) != null ? _a : 15e3;
                    const navigationCommandId = this.beginNavigationCommand();
                    const tracker = new NavigationResponseTracker({
                        page: this,
                        session: this.mainSession,
                        navigationCommandId
                    });
                    tracker.expectNavigationWithoutKnownLoader();
                    const watcher = waitUntil ? new LifecycleWatcher({
                        page: this,
                        mainSession: this.mainSession,
                        networkManager: this.networkManager,
                        waitUntil,
                        timeoutMs: timeout,
                        navigationCommandId
                    }) : null;
                    try {
                        yield this.mainSession.send("Page.reload", {
                            ignoreCache: (_b = options == null ? void 0 : options.ignoreCache) != null ? _b : false
                        });
                        if (watcher) {
                            yield watcher.wait();
                        }
                        return yield tracker.navigationCompleted();
                    } finally{
                        watcher == null ? void 0 : watcher.dispose();
                        tracker.dispose();
                    }
                });
            }
            /**
       * Navigate back in history if possible; optionally wait for a lifecycle state.
       */ goBack(options) {
                return __async(this, null, function*() {
                    var _a, _b;
                    const { entries, currentIndex } = yield this.mainSession.send("Page.getNavigationHistory");
                    const prev = entries[currentIndex - 1];
                    if (!prev) return null;
                    const waitUntil = options == null ? void 0 : options.waitUntil;
                    const timeout = (_a = options == null ? void 0 : options.timeoutMs) != null ? _a : 15e3;
                    const navigationCommandId = this.beginNavigationCommand();
                    const tracker = new NavigationResponseTracker({
                        page: this,
                        session: this.mainSession,
                        navigationCommandId
                    });
                    tracker.expectNavigationWithoutKnownLoader();
                    const watcher = waitUntil ? new LifecycleWatcher({
                        page: this,
                        mainSession: this.mainSession,
                        networkManager: this.networkManager,
                        waitUntil,
                        timeoutMs: timeout,
                        navigationCommandId
                    }) : null;
                    try {
                        yield this.mainSession.send("Page.navigateToHistoryEntry", {
                            entryId: prev.id
                        });
                        this._currentUrl = (_b = prev.url) != null ? _b : this._currentUrl;
                        if (watcher) {
                            yield watcher.wait();
                        }
                        return yield tracker.navigationCompleted();
                    } finally{
                        watcher == null ? void 0 : watcher.dispose();
                        tracker.dispose();
                    }
                });
            }
            /**
       * Navigate forward in history if possible; optionally wait for a lifecycle state.
       */ goForward(options) {
                return __async(this, null, function*() {
                    var _a, _b;
                    const { entries, currentIndex } = yield this.mainSession.send("Page.getNavigationHistory");
                    const next = entries[currentIndex + 1];
                    if (!next) return null;
                    const waitUntil = options == null ? void 0 : options.waitUntil;
                    const timeout = (_a = options == null ? void 0 : options.timeoutMs) != null ? _a : 15e3;
                    const navigationCommandId = this.beginNavigationCommand();
                    const tracker = new NavigationResponseTracker({
                        page: this,
                        session: this.mainSession,
                        navigationCommandId
                    });
                    tracker.expectNavigationWithoutKnownLoader();
                    const watcher = waitUntil ? new LifecycleWatcher({
                        page: this,
                        mainSession: this.mainSession,
                        networkManager: this.networkManager,
                        waitUntil,
                        timeoutMs: timeout,
                        navigationCommandId
                    }) : null;
                    try {
                        yield this.mainSession.send("Page.navigateToHistoryEntry", {
                            entryId: next.id
                        });
                        this._currentUrl = (_b = next.url) != null ? _b : this._currentUrl;
                        if (watcher) {
                            yield watcher.wait();
                        }
                        return yield tracker.navigationCompleted();
                    } finally{
                        watcher == null ? void 0 : watcher.dispose();
                        tracker.dispose();
                    }
                });
            }
            /**
       * Return the current page URL (synchronous, cached from navigation events).
       */ url() {
                return this._currentUrl;
            }
            beginNavigationCommand() {
                const id = ++this.navigationCommandSeq;
                this.latestNavigationCommandId = id;
                return id;
            }
            isCurrentNavigationCommand(id) {
                return this.latestNavigationCommandId === id;
            }
            /**
       * Return the current page title.
       * Prefers reading from the active document via Runtime.evaluate to reflect dynamic changes.
       * Falls back to navigation history title if evaluation is unavailable.
       */ title() {
                return __async(this, null, function*() {
                    var _a, _b, _c;
                    try {
                        yield this.mainSession.send("Runtime.enable").catch(()=>{});
                        const ctxId = yield this.createIsolatedWorldForCurrentMain();
                        const { result } = yield this.mainSession.send("Runtime.evaluate", {
                            expression: "document.title",
                            contextId: ctxId,
                            returnByValue: true
                        });
                        return String((_a = result == null ? void 0 : result.value) != null ? _a : "");
                    } catch (e) {
                        try {
                            const { entries, currentIndex } = yield this.mainSession.send("Page.getNavigationHistory");
                            return (_c = (_b = entries[currentIndex]) == null ? void 0 : _b.title) != null ? _c : "";
                        } catch (e2) {
                            return "";
                        }
                    }
                });
            }
            /**
       * Capture a screenshot with Playwright-style options.
       *
       * @param options Optional screenshot configuration.
       * @param options.animations Control CSS/Web animations during capture. Use
       * "disabled" to fast-forward finite animations and pause infinite ones.
       * @param options.caret Either hide the text caret (default) or leave it
       * visible via "initial".
       * @param options.clip Restrict capture to a specific rectangle (in CSS
       * pixels). Cannot be combined with `fullPage`.
       * @param options.fullPage Capture the full scrollable page instead of the
       * current viewport.
       * @param options.mask Array of locators that should be covered with an
       * overlay while the screenshot is taken.
       * @param options.maskColor CSS color used for the mask overlay (default
       * `#FF00FF`).
       * @param options.omitBackground Make the default page background transparent
       * (PNG only).
       * @param options.path File path to write the screenshot to. The file extension
       * determines the image type when `type` is not explicitly provided.
       * @param options.quality JPEG quality (0100). Only applies when
       * `type === "jpeg"`.
       * @param options.scale Render scale: use "css" for one pixel per CSS pixel,
       * otherwise the default "device" leverages the current device pixel ratio.
       * @param options.style Additional CSS text injected into every frame before
       * capture (removed afterwards).
       * @param options.timeout Maximum capture duration in milliseconds before a
       * timeout error is thrown.
       * @param options.type Image format (`"png"` by default).
       */ screenshot(options) {
                return __async(this, null, function*() {
                    var _a, _b, _c, _d, _e;
                    const opts = options != null ? options : {};
                    const type = (_a = opts.type) != null ? _a : "png";
                    if (type !== "png" && type !== "jpeg") {
                        throw new StagehandInvalidArgumentError(`screenshot: unsupported image type "${type}"`);
                    }
                    if (opts.fullPage && opts.clip) {
                        throw new StagehandInvalidArgumentError("screenshot: clip and fullPage cannot be used together");
                    }
                    if (type === "png" && typeof opts.quality === "number") {
                        throw new StagehandInvalidArgumentError('screenshot: quality option is only valid for type="jpeg"');
                    }
                    const caretMode = (_b = opts.caret) != null ? _b : "hide";
                    const animationsMode = (_c = opts.animations) != null ? _c : "allow";
                    const scaleMode = (_d = opts.scale) != null ? _d : "device";
                    const frames = collectFramesForScreenshot(this);
                    const clip = opts.clip ? normalizeScreenshotClip(opts.clip) : void 0;
                    const captureScale = yield computeScreenshotScale(this, scaleMode);
                    const maskLocators = ((_e = opts.mask) != null ? _e : []).filter((locator)=>Boolean(locator));
                    const cleanupTasks = [];
                    const exec = ()=>__async(this, null, function*() {
                            var _a2;
                            try {
                                if (opts.omitBackground) {
                                    cleanupTasks.push((yield setTransparentBackground(this.mainSession)));
                                }
                                if (animationsMode === "disabled") {
                                    cleanupTasks.push((yield disableAnimations(frames)));
                                }
                                if (caretMode === "hide") {
                                    cleanupTasks.push((yield hideCaret(frames)));
                                }
                                if (opts.style && opts.style.trim()) {
                                    cleanupTasks.push((yield applyStyleToFrames(frames, opts.style, "custom")));
                                }
                                if (maskLocators.length > 0) {
                                    cleanupTasks.push((yield applyMaskOverlays(maskLocators, (_a2 = opts.maskColor) != null ? _a2 : "#FF00FF")));
                                }
                                const buffer = yield this.mainFrameWrapper.screenshot({
                                    fullPage: opts.fullPage,
                                    clip,
                                    type,
                                    quality: type === "jpeg" ? opts.quality : void 0,
                                    scale: captureScale
                                });
                                if (opts.path) {
                                    yield import_fs6.promises.writeFile(opts.path, buffer);
                                }
                                return buffer;
                            } finally{
                                yield runScreenshotCleanups(cleanupTasks);
                            }
                        });
                    return withScreenshotTimeout(opts.timeout, exec);
                });
            }
            /**
       * Create a locator bound to the current main frame.
       */ locator(selector) {
                return this.mainFrameWrapper.locator(selector);
            }
            /**
       * Deep locator that supports cross-iframe traversal.
       * - Recognizes '>>' hop notation to enter iframe contexts.
       * - Supports deep XPath that includes iframe steps (e.g., '/html/body/iframe[2]//div').
       * Returns a Locator scoped to the appropriate frame.
       */ deepLocator(selector) {
                return deepLocatorFromPage(this, this.mainFrameWrapper, selector);
            }
            /**
       * Frame locator similar to Playwright: targets iframe elements and scopes
       * subsequent locators to that frame. Supports chaining.
       */ frameLocator(selector) {
                return new FrameLocator(this, selector);
            }
            /**
       * List all frames belonging to this page as Frame objects bound to their owning sessions.
       * The list is ordered by a stable ordinal assigned during the page lifetime.
       */ frames() {
                const ids = this.listAllFrameIds();
                const withOrd = ids.map((id)=>({
                        id,
                        ord: this.getOrdinal(id)
                    }));
                withOrd.sort((a, b)=>a.ord - b.ord);
                return withOrd.map(({ id })=>this.frameForId(id));
            }
            /**
       * Wait until the page reaches a lifecycle state on the current main frame.
       * Mirrors Playwright's API signatures.
       */ waitForLoadState(state, timeoutMs) {
                return __async(this, null, function*() {
                    yield this.waitForMainLoadState(state, timeoutMs != null ? timeoutMs : 15e3);
                });
            }
            /**
       * Evaluate a function or expression in the current main frame's isolated world.
       * - If a string is provided, it is treated as a JS expression.
       * - If a function is provided, it is stringified and invoked with the optional argument.
       * - The return value should be JSON-serializable. Non-serializable objects will
       *   best-effort serialize via JSON.stringify inside the page context.
       */ evaluate(pageFunctionOrExpression, arg) {
                return __async(this, null, function*() {
                    var _a;
                    yield this.mainSession.send("Runtime.enable").catch(()=>{});
                    const ctxId = yield this.createIsolatedWorldForCurrentMain();
                    const isString = typeof pageFunctionOrExpression === "string";
                    let expression;
                    if (isString) {
                        expression = String(pageFunctionOrExpression);
                    } else {
                        const fnSrc = pageFunctionOrExpression.toString();
                        const argJson = JSON.stringify(arg);
                        expression = `(() => {
        const __fn = ${fnSrc};
        const __arg = ${argJson};
        try {
          const __res = __fn(__arg);
          return Promise.resolve(__res).then(v => {
            try { return JSON.parse(JSON.stringify(v)); } catch { return v; }
          });
        } catch (e) { throw e; }
      })()`;
                    }
                    const { result, exceptionDetails } = yield this.mainSession.send("Runtime.evaluate", {
                        expression,
                        contextId: ctxId,
                        returnByValue: true,
                        awaitPromise: true
                    });
                    if (exceptionDetails) {
                        const msg = exceptionDetails.text || ((_a = exceptionDetails.exception) == null ? void 0 : _a.description) || "Evaluation failed";
                        throw new StagehandEvalError(msg);
                    }
                    return result == null ? void 0 : result.value;
                });
            }
            /**
       * Force the page viewport to an exact CSS size and device scale factor.
       * Ensures screenshots match width x height pixels when deviceScaleFactor = 1.
       */ setViewportSize(width, height, options) {
                return __async(this, null, function*() {
                    var _a;
                    const dsf = Math.max(0.01, (_a = options == null ? void 0 : options.deviceScaleFactor) != null ? _a : 1);
                    yield this.mainSession.send("Emulation.setDeviceMetricsOverride", {
                        width,
                        height,
                        deviceScaleFactor: dsf,
                        mobile: false,
                        screenWidth: width,
                        screenHeight: height,
                        positionX: 0,
                        positionY: 0,
                        scale: 1
                    }).catch(()=>{});
                    yield this.mainSession.send("Emulation.setVisibleSize", {
                        width,
                        height
                    }).catch(()=>{});
                });
            }
            click(x, y, options) {
                return __async(this, null, function*() {
                    var _a, _b;
                    const button = (_a = options == null ? void 0 : options.button) != null ? _a : "left";
                    const clickCount = (_b = options == null ? void 0 : options.clickCount) != null ? _b : 1;
                    let xpathResult;
                    if (options == null ? void 0 : options.returnXpath) {
                        try {
                            const hit = yield resolveXpathForLocation(this, x, y);
                            if (hit) {
                                v3Logger({
                                    category: "page",
                                    message: "click resolved hit",
                                    level: 2,
                                    auxiliary: {
                                        frameId: {
                                            value: String(hit.frameId),
                                            type: "string"
                                        },
                                        backendNodeId: {
                                            value: String(hit.backendNodeId),
                                            type: "string"
                                        },
                                        x: {
                                            value: String(x),
                                            type: "integer"
                                        },
                                        y: {
                                            value: String(y),
                                            type: "integer"
                                        }
                                    }
                                });
                                xpathResult = hit.absoluteXPath;
                                v3Logger({
                                    category: "page",
                                    message: `click resolved xpath`,
                                    level: 2,
                                    auxiliary: {
                                        xpath: {
                                            value: String(xpathResult != null ? xpathResult : ""),
                                            type: "string"
                                        }
                                    }
                                });
                            }
                        } catch (e) {}
                    }
                    yield this.updateCursor(x, y);
                    yield this.mainSession.send("Input.dispatchMouseEvent", {
                        type: "mouseMoved",
                        x,
                        y,
                        button: "none"
                    });
                    yield this.mainSession.send("Input.dispatchMouseEvent", {
                        type: "mousePressed",
                        x,
                        y,
                        button,
                        clickCount
                    });
                    yield this.mainSession.send("Input.dispatchMouseEvent", {
                        type: "mouseReleased",
                        x,
                        y,
                        button,
                        clickCount
                    });
                    if (options == null ? void 0 : options.returnXpath) return xpathResult != null ? xpathResult : "";
                });
            }
            scroll(x, y, deltaX, deltaY, options) {
                return __async(this, null, function*() {
                    let xpathResult;
                    if (options == null ? void 0 : options.returnXpath) {
                        try {
                            const hit = yield resolveXpathForLocation(this, x, y);
                            if (hit) xpathResult = hit.absoluteXPath;
                        } catch (e) {}
                    }
                    yield this.updateCursor(x, y);
                    yield this.mainSession.send("Input.dispatchMouseEvent", {
                        type: "mouseMoved",
                        x,
                        y,
                        button: "none"
                    });
                    yield this.mainSession.send("Input.dispatchMouseEvent", {
                        type: "mouseWheel",
                        x,
                        y,
                        button: "none",
                        deltaX,
                        deltaY
                    });
                    if (options == null ? void 0 : options.returnXpath) return xpathResult != null ? xpathResult : "";
                });
            }
            dragAndDrop(fromX, fromY, toX, toY, options) {
                return __async(this, null, function*() {
                    var _a, _b, _c;
                    const button = (_a = options == null ? void 0 : options.button) != null ? _a : "left";
                    const steps = Math.max(1, Math.floor((_b = options == null ? void 0 : options.steps) != null ? _b : 1));
                    const delay2 = Math.max(0, (_c = options == null ? void 0 : options.delay) != null ? _c : 0);
                    const sleep = (ms)=>new Promise((r)=>ms > 0 ? setTimeout(r, ms) : r());
                    const buttonMask = (b)=>{
                        switch(b){
                            case "left":
                                return 1;
                            case "right":
                                return 2;
                            case "middle":
                                return 4;
                            default:
                                return 1;
                        }
                    };
                    let fromXpath;
                    let toXpath;
                    if (options == null ? void 0 : options.returnXpath) {
                        try {
                            const start = yield resolveXpathForLocation(this, fromX, fromY);
                            if (start) fromXpath = start.absoluteXPath;
                        } catch (e) {}
                        try {
                            const end = yield resolveXpathForLocation(this, toX, toY);
                            if (end) toXpath = end.absoluteXPath;
                        } catch (e) {}
                    }
                    yield this.updateCursor(fromX, fromY);
                    yield this.mainSession.send("Input.dispatchMouseEvent", {
                        type: "mouseMoved",
                        x: fromX,
                        y: fromY,
                        button: "none"
                    });
                    yield this.mainSession.send("Input.dispatchMouseEvent", {
                        type: "mousePressed",
                        x: fromX,
                        y: fromY,
                        button,
                        buttons: buttonMask(button),
                        clickCount: 1
                    });
                    for(let i = 1; i <= steps; i++){
                        const t = i / steps;
                        const x = fromX + (toX - fromX) * t;
                        const y = fromY + (toY - fromY) * t;
                        yield this.updateCursor(x, y);
                        yield this.mainSession.send("Input.dispatchMouseEvent", {
                            type: "mouseMoved",
                            x,
                            y,
                            button,
                            buttons: buttonMask(button)
                        });
                        if (delay2) yield sleep(delay2);
                    }
                    yield this.updateCursor(toX, toY);
                    yield this.mainSession.send("Input.dispatchMouseEvent", {
                        type: "mouseReleased",
                        x: toX,
                        y: toY,
                        button,
                        buttons: buttonMask(button),
                        clickCount: 1
                    });
                    if (options == null ? void 0 : options.returnXpath) return [
                        fromXpath != null ? fromXpath : "",
                        toXpath != null ? toXpath : ""
                    ];
                });
            }
            /**
       * Type a string by dispatching keyDown/keyUp events per character.
       * Focus must already be on the desired element. Uses CDP Input.dispatchKeyEvent
       * and never falls back to Input.insertText. Optional delay applies between
       * successive characters.
       */ type(text, options) {
                return __async(this, null, function*() {
                    var _a;
                    const delay2 = Math.max(0, (_a = options == null ? void 0 : options.delay) != null ? _a : 0);
                    const withMistakes = !!(options == null ? void 0 : options.withMistakes);
                    const sleep = (ms)=>new Promise((r)=>ms > 0 ? setTimeout(r, ms) : r());
                    const keyStroke = (ch, override)=>__async(this, null, function*() {
                            if (override) {
                                const base = {
                                    type: "keyDown",
                                    key: override.key,
                                    code: override.code,
                                    windowsVirtualKeyCode: override.windowsVirtualKeyCode
                                };
                                yield this.mainSession.send("Input.dispatchKeyEvent", base);
                                yield this.mainSession.send("Input.dispatchKeyEvent", __spreadProps(__spreadValues({}, base), {
                                    type: "keyUp"
                                }));
                                return;
                            }
                            const down = {
                                type: "keyDown",
                                text: ch,
                                unmodifiedText: ch
                            };
                            yield this.mainSession.send("Input.dispatchKeyEvent", down);
                            yield this.mainSession.send("Input.dispatchKeyEvent", {
                                type: "keyUp"
                            });
                        });
                    const pressBackspace = ()=>__async(this, null, function*() {
                            return keyStroke("\b", {
                                key: "Backspace",
                                code: "Backspace",
                                windowsVirtualKeyCode: 8
                            });
                        });
                    const randomPrintable = (avoid)=>{
                        const pool = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 .,;:'\"!?@#$%^&*()-_=+[]{}<>/\\|`~";
                        let c = avoid;
                        while(c === avoid){
                            c = pool[Math.floor(Math.random() * pool.length)];
                        }
                        return c;
                    };
                    for (const ch of text){
                        if (ch === "\n" || ch === "\r") {
                            yield keyStroke(ch, {
                                key: "Enter",
                                code: "Enter",
                                windowsVirtualKeyCode: 13
                            });
                        } else if (ch === "	") {
                            yield keyStroke(ch, {
                                key: "Tab",
                                code: "Tab",
                                windowsVirtualKeyCode: 9
                            });
                        } else {
                            if (withMistakes && Math.random() < 0.12) {
                                const wrong = randomPrintable(ch);
                                yield keyStroke(wrong);
                                if (delay2) yield sleep(delay2);
                                yield pressBackspace();
                                if (delay2) yield sleep(delay2);
                            }
                            yield keyStroke(ch);
                        }
                        if (delay2) yield sleep(delay2);
                    }
                });
            }
            /**
       * Press a single key or key combination (keyDown then keyUp).
       * For printable characters, uses the text path on keyDown; for named keys, sets key/code/VK.
       * Supports key combinations with modifiers like "Cmd+A", "Ctrl+C", "Shift+Tab", etc.
       */ keyPress(key, options) {
                return __async(this, null, function*() {
                    var _a;
                    const delay2 = Math.max(0, (_a = options == null ? void 0 : options.delay) != null ? _a : 0);
                    const sleep = (ms)=>new Promise((r)=>ms > 0 ? setTimeout(r, ms) : r());
                    function split(keyString) {
                        if (keyString === "+") {
                            return [
                                "+"
                            ];
                        }
                        const keys = [];
                        let building = "";
                        for (const char of keyString){
                            if (char === "+" && building) {
                                keys.push(building);
                                building = "";
                            } else {
                                building += char;
                            }
                        }
                        if (building) {
                            keys.push(building);
                        }
                        return keys;
                    }
                    const tokens = split(key);
                    const mainKey = tokens[tokens.length - 1];
                    const modifierKeys = tokens.slice(0, -1);
                    try {
                        for (const modKey of modifierKeys){
                            yield this.keyDown(modKey);
                        }
                        yield this.keyDown(mainKey);
                        if (delay2) yield sleep(delay2);
                        yield this.keyUp(mainKey);
                        for(let i = modifierKeys.length - 1; i >= 0; i--){
                            yield this.keyUp(modifierKeys[i]);
                        }
                    } catch (error) {
                        this._pressedModifiers.clear();
                        throw error;
                    }
                });
            }
            /** Press a key down without releasing it */ keyDown(key) {
                return __async(this, null, function*() {
                    var _a, _b, _c;
                    const normalizedKey = this.normalizeModifierKey(key);
                    const modifierKeys = [
                        "Alt",
                        "Control",
                        "Meta",
                        "Shift"
                    ];
                    if (modifierKeys.includes(normalizedKey)) {
                        this._pressedModifiers.add(normalizedKey);
                    }
                    let modifiers = 0;
                    if (this._pressedModifiers.has("Alt")) modifiers |= 1;
                    if (this._pressedModifiers.has("Control")) modifiers |= 2;
                    if (this._pressedModifiers.has("Meta")) modifiers |= 4;
                    if (this._pressedModifiers.has("Shift")) modifiers |= 8;
                    const named = this.getNamedKeys();
                    if (normalizedKey.length === 1) {
                        const hasNonShiftModifier = this._pressedModifiers.has("Alt") || this._pressedModifiers.has("Control") || this._pressedModifiers.has("Meta");
                        if (hasNonShiftModifier) {
                            const desc = this.describePrintableKey(normalizedKey);
                            const macCommands = this.isMacOS() ? this.macCommandsFor((_a = desc.code) != null ? _a : "") : [];
                            const req = __spreadValues(__spreadValues(__spreadValues({
                                type: "rawKeyDown",
                                modifiers,
                                key: desc.key
                            }, desc.code ? {
                                code: desc.code
                            } : {}), typeof desc.vk === "number" ? {
                                windowsVirtualKeyCode: desc.vk
                            } : {}), macCommands.length ? {
                                commands: macCommands
                            } : {});
                            yield this.mainSession.send("Input.dispatchKeyEvent", req);
                        } else {
                            yield this.mainSession.send("Input.dispatchKeyEvent", {
                                type: "keyDown",
                                text: normalizedKey,
                                unmodifiedText: normalizedKey,
                                modifiers
                            });
                        }
                        return;
                    }
                    const entry = (_b = named[normalizedKey]) != null ? _b : null;
                    if (entry) {
                        const macCommands = this.isMacOS() ? this.macCommandsFor(entry.code) : [];
                        const includeText = !!entry.text && modifiers === 0;
                        const keyDown = __spreadValues(__spreadValues({
                            type: includeText ? "keyDown" : "rawKeyDown",
                            key: entry.key,
                            code: entry.code,
                            windowsVirtualKeyCode: entry.vk,
                            modifiers
                        }, includeText ? {
                            text: entry.text,
                            unmodifiedText: (_c = entry.unmodifiedText) != null ? _c : entry.text
                        } : {}), macCommands.length ? {
                            commands: macCommands
                        } : {});
                        yield this.mainSession.send("Input.dispatchKeyEvent", keyDown);
                        return;
                    }
                    yield this.mainSession.send("Input.dispatchKeyEvent", {
                        type: "keyDown",
                        key: normalizedKey,
                        modifiers
                    });
                });
            }
            /** Release a pressed key */ keyUp(key) {
                return __async(this, null, function*() {
                    var _a;
                    const normalizedKey = this.normalizeModifierKey(key);
                    let modifiers = 0;
                    if (this._pressedModifiers.has("Alt")) modifiers |= 1;
                    if (this._pressedModifiers.has("Control")) modifiers |= 2;
                    if (this._pressedModifiers.has("Meta")) modifiers |= 4;
                    if (this._pressedModifiers.has("Shift")) modifiers |= 8;
                    const modifierKeys = [
                        "Alt",
                        "Control",
                        "Meta",
                        "Shift"
                    ];
                    if (modifierKeys.includes(normalizedKey)) {
                        this._pressedModifiers.delete(normalizedKey);
                    }
                    const named = this.getNamedKeys();
                    if (normalizedKey.length === 1) {
                        const desc = this.describePrintableKey(normalizedKey);
                        yield this.mainSession.send("Input.dispatchKeyEvent", {
                            type: "keyUp",
                            key: desc.key,
                            code: desc.code,
                            windowsVirtualKeyCode: typeof desc.vk === "number" ? desc.vk : void 0,
                            modifiers
                        });
                        return;
                    }
                    const entry = (_a = named[normalizedKey]) != null ? _a : null;
                    if (entry) {
                        yield this.mainSession.send("Input.dispatchKeyEvent", {
                            type: "keyUp",
                            key: entry.key,
                            code: entry.code,
                            windowsVirtualKeyCode: entry.vk,
                            modifiers
                        });
                        return;
                    }
                    yield this.mainSession.send("Input.dispatchKeyEvent", {
                        type: "keyUp",
                        key: normalizedKey,
                        modifiers
                    });
                });
            }
            /** Normalize modifier key names to match CDP expectations */ normalizeModifierKey(key) {
                const normalized = key.toLowerCase();
                switch(normalized){
                    case "cmd":
                    case "command":
                        return this.isMacOS() ? "Meta" : "Control";
                    case "win":
                    case "windows":
                        return "Meta";
                    case "ctrl":
                        return "Control";
                    case "option":
                        return "Alt";
                    case "shift":
                        return "Shift";
                    default:
                        return key;
                }
            }
            /**
       * Get the map of named keys with their properties
       */ getNamedKeys() {
                return {
                    Enter: {
                        key: "Enter",
                        code: "Enter",
                        vk: 13,
                        text: "\r",
                        unmodifiedText: "\r"
                    },
                    Tab: {
                        key: "Tab",
                        code: "Tab",
                        vk: 9
                    },
                    Backspace: {
                        key: "Backspace",
                        code: "Backspace",
                        vk: 8
                    },
                    Escape: {
                        key: "Escape",
                        code: "Escape",
                        vk: 27
                    },
                    Delete: {
                        key: "Delete",
                        code: "Delete",
                        vk: 46
                    },
                    ArrowLeft: {
                        key: "ArrowLeft",
                        code: "ArrowLeft",
                        vk: 37
                    },
                    ArrowUp: {
                        key: "ArrowUp",
                        code: "ArrowUp",
                        vk: 38
                    },
                    ArrowRight: {
                        key: "ArrowRight",
                        code: "ArrowRight",
                        vk: 39
                    },
                    ArrowDown: {
                        key: "ArrowDown",
                        code: "ArrowDown",
                        vk: 40
                    },
                    Home: {
                        key: "Home",
                        code: "Home",
                        vk: 36
                    },
                    End: {
                        key: "End",
                        code: "End",
                        vk: 35
                    },
                    PageUp: {
                        key: "PageUp",
                        code: "PageUp",
                        vk: 33
                    },
                    PageDown: {
                        key: "PageDown",
                        code: "PageDown",
                        vk: 34
                    },
                    // Modifier keys
                    Alt: {
                        key: "Alt",
                        code: "AltLeft",
                        vk: 18
                    },
                    Control: {
                        key: "Control",
                        code: "ControlLeft",
                        vk: 17
                    },
                    Meta: {
                        key: "Meta",
                        code: "MetaLeft",
                        vk: 91
                    },
                    Shift: {
                        key: "Shift",
                        code: "ShiftLeft",
                        vk: 16
                    }
                };
            }
            /**
       * Minimal description for printable keys (letters/digits/space) to provide code and VK.
       * Used when non-Shift modifiers are pressed to avoid sending text while keeping accelerator info.
       */ describePrintableKey(ch) {
                const shiftDown = this._pressedModifiers.has("Shift");
                const isLetter = /^[a-zA-Z]$/.test(ch);
                const isDigit = /^[0-9]$/.test(ch);
                if (isLetter) {
                    const upper = ch.toUpperCase();
                    return {
                        key: shiftDown ? upper : upper.toLowerCase(),
                        code: `Key${upper}`,
                        vk: upper.charCodeAt(0)
                    };
                }
                if (isDigit) {
                    return {
                        key: ch,
                        code: `Digit${ch}`,
                        vk: ch.charCodeAt(0)
                    };
                }
                if (ch === " ") {
                    return {
                        key: " ",
                        code: "Space",
                        vk: 32
                    };
                }
                return {
                    key: shiftDown ? ch.toUpperCase() : ch,
                    vk: ch.toUpperCase().charCodeAt(0)
                };
            }
            isMacOS() {
                try {
                    return process.platform === "darwin";
                } catch (e) {
                    return false;
                }
            }
            /**
       * Return Chromium mac editing commands (without trailing ':') for a given code like 'KeyA'
       * Only used on macOS to trigger system editing shortcuts (e.g., selectAll, copy, paste...).
       */ macCommandsFor(code) {
                if (!this.isMacOS()) return [];
                const parts = [];
                if (this._pressedModifiers.has("Shift")) parts.push("Shift");
                if (this._pressedModifiers.has("Control")) parts.push("Control");
                if (this._pressedModifiers.has("Alt")) parts.push("Alt");
                if (this._pressedModifiers.has("Meta")) parts.push("Meta");
                parts.push(code);
                const shortcut = parts.join("+");
                const table = {
                    "Meta+KeyA": "selectAll:",
                    "Meta+KeyC": "copy:",
                    "Meta+KeyX": "cut:",
                    "Meta+KeyV": "paste:",
                    "Meta+KeyZ": "undo:"
                };
                const value = table[shortcut];
                if (!value) return [];
                const list = Array.isArray(value) ? value : [
                    value
                ];
                return list.filter((c)=>!c.startsWith("insert")).map((c)=>c.substring(0, c.length - 1));
            }
            // ---- Page-level lifecycle waiter that follows main frame id swaps ----
            /**
       * Create an isolated world for the **current** main frame and return its context id.
       */ createIsolatedWorldForCurrentMain() {
                return __async(this, null, function*() {
                    yield this.mainSession.send("Runtime.enable").catch(()=>{});
                    const { executionContextId } = yield this.mainSession.send("Page.createIsolatedWorld", {
                        frameId: this.mainFrameId(),
                        worldName: "v3-world"
                    });
                    return executionContextId;
                });
            }
            /**
       * Wait until the **current** main frame reaches a lifecycle state.
       * - Fast path via `document.readyState`.
       * - Event path listens at the session level and compares incoming `frameId`
       *   to `mainFrameId()` **at event time** to follow root swaps.
       */ waitForMainLoadState(state, timeoutMs = 15e3) {
                return __async(this, null, function*() {
                    var _a;
                    yield this.mainSession.send("Page.setLifecycleEventsEnabled", {
                        enabled: true
                    }).catch(()=>{});
                    try {
                        const ctxId = yield this.createIsolatedWorldForCurrentMain();
                        const { result } = yield this.mainSession.send("Runtime.evaluate", {
                            expression: "document.readyState",
                            contextId: ctxId,
                            returnByValue: true
                        });
                        const rs = String((_a = result == null ? void 0 : result.value) != null ? _a : "");
                        if (state === "domcontentloaded" && (rs === "interactive" || rs === "complete") || state === "load" && rs === "complete") {
                            return;
                        }
                    } catch (e) {}
                    const wanted = LIFECYCLE_NAME[state];
                    return new Promise((resolve2, reject)=>{
                        let done = false;
                        let timer = null;
                        const off = ()=>{
                            this.mainSession.off("Page.lifecycleEvent", onLifecycle);
                            this.mainSession.off("Page.domContentEventFired", onDomContent);
                            this.mainSession.off("Page.loadEventFired", onLoad);
                        };
                        const finish = ()=>{
                            if (done) return;
                            done = true;
                            if (timer) {
                                clearTimeout(timer);
                                timer = null;
                            }
                            off();
                            resolve2();
                        };
                        const onLifecycle = (evt)=>{
                            if (evt.name !== wanted) return;
                            if (evt.frameId === this.mainFrameId()) finish();
                        };
                        const onDomContent = ()=>{
                            if (state === "domcontentloaded") finish();
                        };
                        const onLoad = ()=>{
                            if (state === "load") finish();
                        };
                        this.mainSession.on("Page.lifecycleEvent", onLifecycle);
                        this.mainSession.on("Page.domContentEventFired", onDomContent);
                        this.mainSession.on("Page.loadEventFired", onLoad);
                        timer = setTimeout(()=>{
                            if (done) return;
                            done = true;
                            off();
                            reject(new Error(`waitForMainLoadState(${state}) timed out after ${timeoutMs}ms`));
                        }, timeoutMs);
                    });
                });
            }
        };
    }
});
// lib/v3/index.ts
var v3_exports = {};
__export(v3_exports, {
    AISdkClient: ()=>AISdkClient2,
    AVAILABLE_CUA_MODELS: ()=>AVAILABLE_CUA_MODELS,
    AgentProvider: ()=>AgentProvider,
    AgentScreenshotProviderError: ()=>AgentScreenshotProviderError,
    AnnotatedScreenshotText: ()=>AnnotatedScreenshotText,
    BrowserbaseSessionNotFoundError: ()=>BrowserbaseSessionNotFoundError,
    CaptchaTimeoutError: ()=>CaptchaTimeoutError,
    ConnectionTimeoutError: ()=>ConnectionTimeoutError,
    ConsoleMessage: ()=>ConsoleMessage,
    ContentFrameNotFoundError: ()=>ContentFrameNotFoundError,
    CreateChatCompletionResponseError: ()=>CreateChatCompletionResponseError,
    CuaModelRequiredError: ()=>CuaModelRequiredError,
    ElementNotVisibleError: ()=>ElementNotVisibleError,
    ExperimentalApiConflictError: ()=>ExperimentalApiConflictError,
    ExperimentalNotConfiguredError: ()=>ExperimentalNotConfiguredError,
    HandlerNotInitializedError: ()=>HandlerNotInitializedError,
    InvalidAISDKModelFormatError: ()=>InvalidAISDKModelFormatError,
    LLMClient: ()=>LLMClient,
    LLMResponseError: ()=>LLMResponseError,
    LOG_LEVEL_NAMES: ()=>LOG_LEVEL_NAMES,
    MCPConnectionError: ()=>MCPConnectionError,
    MissingEnvironmentVariableError: ()=>MissingEnvironmentVariableError,
    MissingLLMConfigurationError: ()=>MissingLLMConfigurationError,
    PageNotFoundError: ()=>PageNotFoundError,
    Response: ()=>Response,
    ResponseBodyError: ()=>ResponseBodyError,
    ResponseParseError: ()=>ResponseParseError,
    Stagehand: ()=>V3,
    StagehandAPIError: ()=>StagehandAPIError,
    StagehandAPIUnauthorizedError: ()=>StagehandAPIUnauthorizedError,
    StagehandClickError: ()=>StagehandClickError,
    StagehandDefaultError: ()=>StagehandDefaultError,
    StagehandDomProcessError: ()=>StagehandDomProcessError,
    StagehandElementNotFoundError: ()=>StagehandElementNotFoundError,
    StagehandEnvironmentError: ()=>StagehandEnvironmentError,
    StagehandError: ()=>StagehandError,
    StagehandEvalError: ()=>StagehandEvalError,
    StagehandHttpError: ()=>StagehandHttpError,
    StagehandIframeError: ()=>StagehandIframeError,
    StagehandInitError: ()=>StagehandInitError,
    StagehandInvalidArgumentError: ()=>StagehandInvalidArgumentError,
    StagehandMissingArgumentError: ()=>StagehandMissingArgumentError,
    StagehandNotInitializedError: ()=>StagehandNotInitializedError,
    StagehandResponseBodyError: ()=>StagehandResponseBodyError,
    StagehandResponseParseError: ()=>StagehandResponseParseError,
    StagehandServerError: ()=>StagehandServerError,
    StagehandShadowRootMissingError: ()=>StagehandShadowRootMissingError,
    StagehandShadowSegmentEmptyError: ()=>StagehandShadowSegmentEmptyError,
    StagehandShadowSegmentNotFoundError: ()=>StagehandShadowSegmentNotFoundError,
    TimeoutError: ()=>TimeoutError,
    UnsupportedAISDKModelProviderError: ()=>UnsupportedAISDKModelProviderError,
    UnsupportedModelError: ()=>UnsupportedModelError,
    UnsupportedModelProviderError: ()=>UnsupportedModelProviderError,
    V3: ()=>V3,
    V3Evaluator: ()=>V3Evaluator,
    V3FunctionName: ()=>V3FunctionName,
    XPathResolutionError: ()=>XPathResolutionError,
    ZodSchemaValidationError: ()=>ZodSchemaValidationError,
    connectToMCPServer: ()=>connectToMCPServer,
    defaultExtractSchema: ()=>defaultExtractSchema,
    getZodType: ()=>getZodType,
    injectUrls: ()=>injectUrls,
    isRunningInBun: ()=>isRunningInBun,
    jsonSchemaToZod: ()=>jsonSchemaToZod,
    loadApiKeyFromEnv: ()=>loadApiKeyFromEnv,
    modelToAgentProviderMap: ()=>modelToAgentProviderMap,
    pageTextSchema: ()=>pageTextSchema,
    providerEnvVarMap: ()=>providerEnvVarMap,
    toGeminiSchema: ()=>toGeminiSchema,
    transformSchema: ()=>transformSchema,
    trimTrailingTextNode: ()=>trimTrailingTextNode,
    validateZodSchema: ()=>validateZodSchema
});
module.exports = __toCommonJS(v3_exports);
// lib/v3/v3.ts
var import_dotenv = __toESM(__turbopack_context__.r("[project]/node_modules/dotenv/lib/main.js [app-route] (ecmascript)"));
var import_fs7 = __toESM(__turbopack_context__.r("[externals]/fs [external] (fs, cjs)"));
var import_os2 = __toESM(__turbopack_context__.r("[externals]/os [external] (os, cjs)"));
var import_path6 = __toESM(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
var import_process2 = __toESM(__turbopack_context__.r("[externals]/process [external] (process, cjs)"));
// lib/utils.ts
init_sdkErrors();
var import_genai = __turbopack_context__.r("[project]/node_modules/@google/genai/dist/node/index.cjs [app-route] (ecmascript)");
var import_v3 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/index.js [app-route] (ecmascript)");
var ID_PATTERN = /^\d+-\d+$/;
function validateZodSchema(schema, data) {
    const result = schema.safeParse(data);
    if (result.success) {
        return true;
    }
    throw new ZodSchemaValidationError(data, result.error.format());
}
function isRunningInBun() {
    return typeof process !== "undefined" && typeof process.versions !== "undefined" && "bun" in process.versions;
}
function decorateGeminiSchema(geminiSchema, zodSchema2) {
    if (geminiSchema.nullable === void 0) {
        geminiSchema.nullable = zodSchema2.isOptional();
    }
    if (zodSchema2.description) {
        geminiSchema.description = zodSchema2.description;
    }
    return geminiSchema;
}
function toGeminiSchema(zodSchema2) {
    const zodType = getZodType(zodSchema2);
    switch(zodType){
        case "ZodArray":
            {
                return decorateGeminiSchema({
                    type: import_genai.Type.ARRAY,
                    items: toGeminiSchema(zodSchema2.element)
                }, zodSchema2);
            }
        case "ZodObject":
            {
                const properties = {};
                const required = [];
                Object.entries(zodSchema2.shape).forEach(([key, value])=>{
                    properties[key] = toGeminiSchema(value);
                    if (getZodType(value) !== "ZodOptional") {
                        required.push(key);
                    }
                });
                return decorateGeminiSchema({
                    type: import_genai.Type.OBJECT,
                    properties,
                    required: required.length > 0 ? required : void 0
                }, zodSchema2);
            }
        case "ZodString":
            return decorateGeminiSchema({
                type: import_genai.Type.STRING
            }, zodSchema2);
        case "ZodNumber":
            return decorateGeminiSchema({
                type: import_genai.Type.NUMBER
            }, zodSchema2);
        case "ZodBoolean":
            return decorateGeminiSchema({
                type: import_genai.Type.BOOLEAN
            }, zodSchema2);
        case "ZodEnum":
            return decorateGeminiSchema({
                type: import_genai.Type.STRING,
                enum: zodSchema2._def.values
            }, zodSchema2);
        case "ZodDefault":
        case "ZodNullable":
        case "ZodOptional":
            {
                const innerSchema = toGeminiSchema(zodSchema2._def.innerType);
                return decorateGeminiSchema(__spreadProps(__spreadValues({}, innerSchema), {
                    nullable: true
                }), zodSchema2);
            }
        case "ZodLiteral":
            return decorateGeminiSchema({
                type: import_genai.Type.STRING,
                enum: [
                    zodSchema2._def.value
                ]
            }, zodSchema2);
        default:
            return decorateGeminiSchema({
                type: import_genai.Type.OBJECT,
                nullable: true
            }, zodSchema2);
    }
}
function getZodType(schema) {
    return schema._def.typeName;
}
function transformSchema(schema, currentPath) {
    var _a, _b;
    if (isKind(schema, import_v3.ZodFirstPartyTypeKind.ZodString)) {
        const hasUrlCheck = (_b = (_a = schema._def.checks) == null ? void 0 : _a.some((check)=>check.kind === "url")) != null ? _b : false;
        if (hasUrlCheck) {
            return [
                makeIdStringSchema(schema),
                [
                    {
                        segments: []
                    }
                ]
            ];
        }
        return [
            schema,
            []
        ];
    }
    if (isKind(schema, import_v3.ZodFirstPartyTypeKind.ZodObject)) {
        const shape = schema._def.shape();
        const newShape = {};
        const urlPaths = [];
        let changed = false;
        const shapeKeys = Object.keys(shape);
        for (const key of shapeKeys){
            const child = shape[key];
            const [transformedChild, childPaths] = transformSchema(child, [
                ...currentPath,
                key
            ]);
            if (transformedChild !== child) {
                changed = true;
            }
            newShape[key] = transformedChild;
            if (childPaths.length > 0) {
                for (const cp of childPaths){
                    urlPaths.push({
                        segments: [
                            key,
                            ...cp.segments
                        ]
                    });
                }
            }
        }
        if (changed) {
            return [
                import_v3.z.object(newShape),
                urlPaths
            ];
        }
        return [
            schema,
            urlPaths
        ];
    }
    if (isKind(schema, import_v3.ZodFirstPartyTypeKind.ZodArray)) {
        const itemType = schema._def.type;
        const [transformedItem, childPaths] = transformSchema(itemType, [
            ...currentPath,
            "*"
        ]);
        const changed = transformedItem !== itemType;
        const arrayPaths = childPaths.map((cp)=>({
                segments: [
                    "*",
                    ...cp.segments
                ]
            }));
        if (changed) {
            return [
                import_v3.z.array(transformedItem),
                arrayPaths
            ];
        }
        return [
            schema,
            arrayPaths
        ];
    }
    if (isKind(schema, import_v3.ZodFirstPartyTypeKind.ZodUnion)) {
        const unionOptions = schema._def.options;
        const newOptions = [];
        let changed = false;
        let allPaths = [];
        unionOptions.forEach((option, idx)=>{
            const [newOption, childPaths] = transformSchema(option, [
                ...currentPath,
                `union_${idx}`
            ]);
            if (newOption !== option) {
                changed = true;
            }
            newOptions.push(newOption);
            allPaths = [
                ...allPaths,
                ...childPaths
            ];
        });
        if (changed) {
            return [
                import_v3.z.union(newOptions),
                allPaths
            ];
        }
        return [
            schema,
            allPaths
        ];
    }
    if (isKind(schema, import_v3.ZodFirstPartyTypeKind.ZodIntersection)) {
        const leftType = schema._def.left;
        const rightType = schema._def.right;
        const [left, leftPaths] = transformSchema(leftType, [
            ...currentPath,
            "intersection_left"
        ]);
        const [right, rightPaths] = transformSchema(rightType, [
            ...currentPath,
            "intersection_right"
        ]);
        const changed = left !== leftType || right !== rightType;
        const allPaths = [
            ...leftPaths,
            ...rightPaths
        ];
        if (changed) {
            return [
                import_v3.z.intersection(left, right),
                allPaths
            ];
        }
        return [
            schema,
            allPaths
        ];
    }
    if (isKind(schema, import_v3.ZodFirstPartyTypeKind.ZodOptional)) {
        const innerType = schema._def.innerType;
        const [inner, innerPaths] = transformSchema(innerType, currentPath);
        if (inner !== innerType) {
            return [
                import_v3.z.optional(inner),
                innerPaths
            ];
        }
        return [
            schema,
            innerPaths
        ];
    }
    if (isKind(schema, import_v3.ZodFirstPartyTypeKind.ZodNullable)) {
        const innerType = schema._def.innerType;
        const [inner, innerPaths] = transformSchema(innerType, currentPath);
        if (inner !== innerType) {
            return [
                import_v3.z.nullable(inner),
                innerPaths
            ];
        }
        return [
            schema,
            innerPaths
        ];
    }
    if (isKind(schema, import_v3.ZodFirstPartyTypeKind.ZodEffects)) {
        const baseSchema = schema._def.schema;
        const [newBaseSchema, basePaths] = transformSchema(baseSchema, currentPath);
        if (newBaseSchema !== baseSchema) {
            return [
                import_v3.z.effect(newBaseSchema, schema._def.effect),
                basePaths
            ];
        }
        return [
            schema,
            basePaths
        ];
    }
    return [
        schema,
        []
    ];
}
function injectUrls(obj, path7, idToUrlMapping) {
    var _a, _b;
    if (path7.length === 0) return;
    const toId = (value)=>{
        if (typeof value === "number") {
            return String(value);
        }
        if (typeof value === "string" && ID_PATTERN.test(value)) {
            return value;
        }
        return void 0;
    };
    const [key, ...rest] = path7;
    if (key === "*") {
        if (Array.isArray(obj)) {
            if (rest.length === 0) {
                for(let i = 0; i < obj.length; i += 1){
                    const id = toId(obj[i]);
                    if (id !== void 0) {
                        obj[i] = (_a = idToUrlMapping[id]) != null ? _a : "";
                    }
                }
            } else {
                for (const item of obj)injectUrls(item, rest, idToUrlMapping);
            }
        }
        return;
    }
    if (obj && typeof obj === "object") {
        const record = obj;
        if (path7.length === 1) {
            const fieldValue = record[key];
            const id = toId(fieldValue);
            if (id !== void 0) {
                record[key] = (_b = idToUrlMapping[id]) != null ? _b : "";
            }
        } else {
            injectUrls(record[key], rest, idToUrlMapping);
        }
    }
}
function isKind(s, kind) {
    return s._def.typeName === kind;
}
function makeIdStringSchema(orig) {
    var _a, _b, _c;
    const userDesc = // Zod 3.23 exposes .description directly; fall back to _def for older minor versions
    (_c = (_b = orig.description) != null ? _b : (_a = orig._def) == null ? void 0 : _a.description) != null ? _c : "";
    const base = `This field must be the element-ID in the form 'frameId-backendId' (e.g. "0-432").`;
    const composed = userDesc.trim().length > 0 ? `${base} that follows this user-defined description: ${userDesc}` : base;
    return import_v3.z.string().regex(ID_PATTERN).describe(composed);
}
var providerEnvVarMap = {
    openai: "OPENAI_API_KEY",
    anthropic: "ANTHROPIC_API_KEY",
    google: [
        "GEMINI_API_KEY",
        "GOOGLE_GENERATIVE_AI_API_KEY"
    ],
    groq: "GROQ_API_KEY",
    cerebras: "CEREBRAS_API_KEY",
    togetherai: "TOGETHER_AI_API_KEY",
    mistral: "MISTRAL_API_KEY",
    deepseek: "DEEPSEEK_API_KEY",
    perplexity: "PERPLEXITY_API_KEY",
    azure: "AZURE_API_KEY",
    xai: "XAI_API_KEY",
    google_legacy: "GOOGLE_API_KEY"
};
function loadApiKeyFromEnv(provider, logger) {
    if (!provider) {
        return void 0;
    }
    const envVarName = providerEnvVarMap[provider];
    if (!envVarName) {
        logger({
            category: "init",
            message: `No known environment variable for provider '${provider}'`,
            level: 0
        });
        return void 0;
    }
    const apiKeyFromEnv = Array.isArray(envVarName) ? envVarName.map((name)=>process.env[name]).find((key)=>key && key.length > 0) : process.env[envVarName];
    if (typeof apiKeyFromEnv === "string" && apiKeyFromEnv.length > 0) {
        return apiKeyFromEnv;
    }
    return void 0;
}
function trimTrailingTextNode(path7) {
    return path7 == null ? void 0 : path7.replace(/\/text\(\)(\[\d+\])?$/iu, "");
}
function jsonSchemaToZod(schema) {
    switch(schema.type){
        case "object":
            if (schema.properties) {
                const shape = {};
                for(const key in schema.properties){
                    shape[key] = jsonSchemaToZod(schema.properties[key]);
                }
                let zodObject = import_v3.z.object(shape);
                if (schema.required && Array.isArray(schema.required)) {
                    const requiredFields = schema.required.reduce((acc, field)=>__spreadProps(__spreadValues({}, acc), {
                            [field]: true
                        }), {});
                    zodObject = zodObject.partial().required(requiredFields);
                }
                if (schema.description) {
                    zodObject = zodObject.describe(schema.description);
                }
                return zodObject;
            } else {
                return import_v3.z.object({});
            }
        case "array":
            if (schema.items) {
                let zodArray = import_v3.z.array(jsonSchemaToZod(schema.items));
                if (schema.description) {
                    zodArray = zodArray.describe(schema.description);
                }
                return zodArray;
            } else {
                return import_v3.z.array(import_v3.z.any());
            }
        case "string":
            {
                if (schema.enum) {
                    return import_v3.z.string().refine((val)=>schema.enum.includes(val));
                }
                let zodString = import_v3.z.string();
                if (schema.description) {
                    zodString = zodString.describe(schema.description);
                }
                return zodString;
            }
        case "number":
            {
                let zodNumber = import_v3.z.number();
                if (schema.minimum !== void 0) {
                    zodNumber = zodNumber.min(schema.minimum);
                }
                if (schema.maximum !== void 0) {
                    zodNumber = zodNumber.max(schema.maximum);
                }
                if (schema.description) {
                    zodNumber = zodNumber.describe(schema.description);
                }
                return zodNumber;
            }
        case "boolean":
            {
                let zodBoolean = import_v3.z.boolean();
                if (schema.description) {
                    zodBoolean = zodBoolean.describe(schema.description);
                }
                return zodBoolean;
            }
        default:
            return import_v3.z.any();
    }
}
// lib/logger.ts
var import_pino = __toESM(__turbopack_context__.r("[externals]/pino [external] (pino, cjs, [project]/node_modules/pino)"));
var levelMapping = {
    0: "error",
    // Critical/important messages
    1: "info",
    // Standard information
    2: "debug"
};
function createLogger(options = {}) {
    const loggerConfig = {
        level: options.level || "info",
        base: void 0,
        // Don't include pid and hostname
        browser: {
            asObject: true
        },
        // Disable worker threads to avoid issues in tests
        transport: void 0
    };
    if (options.pretty && !isTestEnvironment()) {
        try {
            const transport = {
                transport: {
                    target: "pino-pretty",
                    options: {
                        colorize: true,
                        translateTime: "SYS:standard",
                        ignore: "pid,hostname"
                    }
                }
            };
            Object.assign(loggerConfig, transport);
        } catch (e) {
            console.warn("pino-pretty not available, falling back to standard logging");
        }
    }
    return (0, import_pino.default)(loggerConfig, options.destination);
}
function isTestEnvironment() {
    return ("TURBOPACK compile-time value", "development") === "test" || process.env.JEST_WORKER_ID !== void 0 || process.env.PLAYWRIGHT_TEST_BASE_DIR !== void 0 || // Check if we're in a CI environment
    process.env.CI === "true";
}
var _StagehandLogger = class _StagehandLogger {
    constructor(options = {}, externalLogger){
        this.isTest = isTestEnvironment();
        this.externalLogger = externalLogger;
        const externalProvided = typeof externalLogger === "function";
        const explicitUsePino = options.usePino;
        if (this.isTest) {
            this.usePino = false;
        } else if (explicitUsePino === true) {
            this.usePino = true;
        } else if (explicitUsePino === false) {
            this.usePino = false;
        } else {
            this.usePino = !externalProvided;
        }
        if (this.usePino) {
            if (!_StagehandLogger.sharedPinoLogger) {
                _StagehandLogger.sharedPinoLogger = createLogger(options);
            }
            this.logger = _StagehandLogger.sharedPinoLogger;
        }
        this.verbose = 1;
    }
    /**
   * Set the verbosity level
   */ setVerbosity(level) {
        this.verbose = level;
        if (this.usePino && this.logger) {
            switch(level){
                case 0:
                    this.logger.level = "error";
                    break;
                case 1:
                    this.logger.level = "info";
                    break;
                case 2:
                    this.logger.level = "debug";
                    break;
            }
        }
    }
    /**
   * Log a message using our LogLine format
   */ log(logLine) {
        var _a, _b, _c, _d;
        if (((_a = logLine.level) != null ? _a : 1) > this.verbose) {
            return;
        }
        const shouldFallbackToConsole = !this.usePino && !this.externalLogger || this.isTest && !this.externalLogger;
        if (shouldFallbackToConsole) {
            const level = (_b = logLine.level) != null ? _b : 1;
            const ts = (_c = logLine.timestamp) != null ? _c : /* @__PURE__ */ new Date().toISOString();
            const levelStr = level === 0 ? "ERROR" : level === 2 ? "DEBUG" : "INFO";
            let output = `[${ts}] ${levelStr}: ${logLine.message}`;
            if (logLine.auxiliary) {
                const formattedData = this.formatAuxiliaryData(logLine.auxiliary);
                for (const [key, value] of Object.entries(formattedData)){
                    let formattedValue;
                    if (typeof value === "object" && value !== null) {
                        formattedValue = JSON.stringify(value, null, 2).split("\n").map((line, i)=>i === 0 ? line : `    ${line}`).join("\n");
                    } else {
                        formattedValue = String(value);
                    }
                    output += `
    ${key}: ${formattedValue}`;
                }
            }
            switch(level){
                case 0:
                    console.error(output);
                    break;
                case 1:
                    console.log(output);
                    break;
                case 2:
                    console.debug(output);
                    break;
            }
            return;
        }
        if (this.usePino && this.logger) {
            const pinoLevel = levelMapping[(_d = logLine.level) != null ? _d : 1] || "info";
            const logData = __spreadValues({
                category: logLine.category,
                timestamp: logLine.timestamp || /* @__PURE__ */ new Date().toISOString()
            }, this.formatAuxiliaryData(logLine.auxiliary));
            if (pinoLevel === "error") {
                this.logger.error(logData, logLine.message);
            } else if (pinoLevel === "info") {
                this.logger.info(logData, logLine.message);
            } else if (pinoLevel === "debug") {
                this.logger.debug(logData, logLine.message);
            } else if (pinoLevel === "warn") {
                this.logger.warn(logData, logLine.message);
            } else if (pinoLevel === "trace") {
                this.logger.trace(logData, logLine.message);
            } else {
                this.logger.info(logData, logLine.message);
            }
        }
        if (this.externalLogger) {
            this.externalLogger(logLine);
        }
    }
    /**
   * Helper to format auxiliary data for structured logging
   */ formatAuxiliaryData(auxiliary) {
        if (!auxiliary) return {};
        const formattedData = {};
        for (const [key, { value, type }] of Object.entries(auxiliary)){
            let formattedValue;
            switch(type){
                case "integer":
                    formattedValue = parseInt(value, 10);
                    break;
                case "float":
                    formattedValue = parseFloat(value);
                    break;
                case "boolean":
                    formattedValue = value === "true";
                    break;
                case "object":
                    try {
                        formattedValue = JSON.parse(value);
                    } catch (e) {
                        formattedValue = value;
                    }
                    break;
                default:
                    formattedValue = value;
            }
            if (formattedValue === void 0) continue;
            if (typeof formattedValue === "object" && formattedValue !== null) {
                const isEmpty = Array.isArray(formattedValue) ? formattedValue.length === 0 : Object.keys(formattedValue).length === 0;
                if (isEmpty) continue;
            }
            formattedData[key] = formattedValue;
        }
        return formattedData;
    }
    /**
   * Convenience methods for different log levels
   */ error(message, data) {
        this.log({
            message,
            level: 0,
            auxiliary: this.convertToAuxiliary(data)
        });
    }
    warn(message, data) {
        this.log({
            message,
            level: 1,
            category: "warning",
            auxiliary: this.convertToAuxiliary(data)
        });
    }
    info(message, data) {
        this.log({
            message,
            level: 1,
            auxiliary: this.convertToAuxiliary(data)
        });
    }
    debug(message, data) {
        this.log({
            message,
            level: 2,
            auxiliary: this.convertToAuxiliary(data)
        });
    }
    /**
   * Convert a plain object to our auxiliary format
   */ convertToAuxiliary(data) {
        if (!data) return void 0;
        const auxiliary = {};
        for (const [key, value] of Object.entries(data)){
            if (value === void 0) continue;
            const type = typeof value;
            auxiliary[key] = {
                value: type === "object" ? JSON.stringify(value) : String(value),
                type: type === "number" ? Number.isInteger(value) ? "integer" : "float" : type === "boolean" ? "boolean" : type === "object" ? "object" : "string"
            };
        }
        return auxiliary;
    }
};
/**
 * Shared Pino logger instance across all StagehandLogger instances.
 * First instance to enable Pino creates it, subsequent instances reuse it.
 */ _StagehandLogger.sharedPinoLogger = null;
var StagehandLogger = _StagehandLogger;
// lib/v3/cache/ActCache.ts
var import_crypto = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)");
// lib/v3/cache/utils.ts
function cloneForCache(value) {
    return JSON.parse(JSON.stringify(value));
}
function safeGetPageUrl(page) {
    return __async(this, null, function*() {
        try {
            return page.url();
        } catch (e) {
            return "";
        }
    });
}
// lib/v3/cache/ActCache.ts
init_sdkErrors();
var ActCache = class {
    constructor({ storage, logger, getActHandler, getDefaultLlmClient, domSettleTimeoutMs }){
        this.storage = storage;
        this.logger = logger;
        this.getActHandler = getActHandler;
        this.getDefaultLlmClient = getDefaultLlmClient;
        this.domSettleTimeoutMs = domSettleTimeoutMs;
    }
    get enabled() {
        return this.storage.enabled;
    }
    prepareContext(instruction, page, variables) {
        return __async(this, null, function*() {
            if (!this.enabled) return null;
            const sanitizedInstruction = instruction.trim();
            const sanitizedVariables = variables ? __spreadValues({}, variables) : {};
            const pageUrl = yield safeGetPageUrl(page);
            const cacheKey = this.buildActCacheKey(sanitizedInstruction, pageUrl, sanitizedVariables);
            return {
                instruction: sanitizedInstruction,
                cacheKey,
                pageUrl,
                variables: sanitizedVariables
            };
        });
    }
    tryReplay(context, page, timeout) {
        return __async(this, null, function*() {
            var _a;
            if (!this.enabled) return null;
            const { value: entry, error, path: path7 } = yield this.storage.readJson(`${context.cacheKey}.json`);
            if (error && path7) {
                this.logger({
                    category: "cache",
                    message: `failed to read act cache entry: ${path7}`,
                    level: 2,
                    auxiliary: {
                        error: {
                            value: String(error),
                            type: "string"
                        }
                    }
                });
                return null;
            }
            if (!entry) return null;
            if (entry.version !== 1) return null;
            if (!Array.isArray(entry.actions) || entry.actions.length === 0) {
                return null;
            }
            this.logger({
                category: "cache",
                message: "act cache hit",
                level: 1,
                auxiliary: {
                    instruction: {
                        value: context.instruction,
                        type: "string"
                    },
                    url: {
                        value: (_a = entry.url) != null ? _a : context.pageUrl,
                        type: "string"
                    }
                }
            });
            return yield this.replayCachedActions(context, entry, page, timeout);
        });
    }
    store(context, result) {
        return __async(this, null, function*() {
            var _a;
            if (!this.enabled) return;
            const entry = {
                version: 1,
                instruction: context.instruction,
                url: context.pageUrl,
                variables: context.variables,
                actions: (_a = result.actions) != null ? _a : [],
                actionDescription: result.actionDescription,
                message: result.message
            };
            const { error, path: path7 } = yield this.storage.writeJson(`${context.cacheKey}.json`, entry);
            if (error && path7) {
                this.logger({
                    category: "cache",
                    message: "failed to write act cache entry",
                    level: 1,
                    auxiliary: {
                        error: {
                            value: String(error),
                            type: "string"
                        }
                    }
                });
                return;
            }
            this.logger({
                category: "cache",
                message: "act cache stored",
                level: 2,
                auxiliary: {
                    instruction: {
                        value: context.instruction,
                        type: "string"
                    },
                    url: {
                        value: context.pageUrl,
                        type: "string"
                    }
                }
            });
        });
    }
    buildActCacheKey(instruction, url, variables) {
        const payload = JSON.stringify({
            instruction,
            url,
            variables
        });
        return (0, import_crypto.createHash)("sha256").update(payload).digest("hex");
    }
    replayCachedActions(context, entry, page, timeout) {
        return __async(this, null, function*() {
            const handler = this.getActHandler();
            if (!handler) {
                throw new StagehandNotInitializedError("act()");
            }
            const execute = ()=>__async(this, null, function*() {
                    var _a, _b, _c;
                    const actionResults = [];
                    for (const action of entry.actions){
                        const result = yield handler.actFromObserveResult(action, page, this.domSettleTimeoutMs, this.getDefaultLlmClient());
                        actionResults.push(result);
                        if (!result.success) {
                            break;
                        }
                    }
                    if (actionResults.length === 0) {
                        return {
                            success: false,
                            message: "Failed to perform act: cached entry has no actions",
                            actionDescription: (_a = entry.actionDescription) != null ? _a : entry.instruction,
                            actions: []
                        };
                    }
                    const success = actionResults.every((r)=>r.success);
                    const actions = actionResults.flatMap((r)=>{
                        var _a2;
                        return (_a2 = r.actions) != null ? _a2 : [];
                    });
                    const message = actionResults.map((r)=>r.message).filter((m)=>m && m.trim().length > 0).join(" \u2192 ") || entry.message || `Replayed ${entry.actions.length} cached action${entry.actions.length === 1 ? "" : "s"}.`;
                    const actionDescription = entry.actionDescription || ((_b = actionResults[actionResults.length - 1]) == null ? void 0 : _b.actionDescription) || ((_c = entry.actions[entry.actions.length - 1]) == null ? void 0 : _c.description) || entry.instruction;
                    if (success && actions.length > 0 && this.haveActionsChanged(entry.actions, actions)) {
                        yield this.refreshCacheEntry(context, __spreadProps(__spreadValues({}, entry), {
                            actions,
                            message,
                            actionDescription
                        }));
                    }
                    return {
                        success,
                        message,
                        actionDescription,
                        actions
                    };
                });
            return yield this.runWithTimeout(execute, timeout);
        });
    }
    haveActionsChanged(original, updated) {
        var _a, _b, _c, _d;
        if (original.length !== updated.length) {
            return true;
        }
        for(let i = 0; i < original.length; i += 1){
            const orig = original[i];
            const next = updated[i];
            if (!next) {
                return true;
            }
            if (orig.selector !== next.selector) {
                return true;
            }
            if (orig.description !== next.description) {
                return true;
            }
            if (((_a = orig.method) != null ? _a : "") !== ((_b = next.method) != null ? _b : "")) {
                return true;
            }
            const origArgs = (_c = orig.arguments) != null ? _c : [];
            const nextArgs = (_d = next.arguments) != null ? _d : [];
            if (origArgs.length !== nextArgs.length) {
                return true;
            }
            for(let j = 0; j < origArgs.length; j += 1){
                if (origArgs[j] !== nextArgs[j]) {
                    return true;
                }
            }
        }
        return false;
    }
    refreshCacheEntry(context, entry) {
        return __async(this, null, function*() {
            const { error, path: path7 } = yield this.storage.writeJson(`${context.cacheKey}.json`, entry);
            if (error && path7) {
                this.logger({
                    category: "cache",
                    message: "failed to update act cache entry after self-heal",
                    level: 0,
                    auxiliary: {
                        error: {
                            value: String(error),
                            type: "string"
                        }
                    }
                });
                return;
            }
            this.logger({
                category: "cache",
                message: "act cache entry updated after self-heal",
                level: 2,
                auxiliary: {
                    instruction: {
                        value: context.instruction,
                        type: "string"
                    },
                    url: {
                        value: context.pageUrl,
                        type: "string"
                    }
                }
            });
        });
    }
    runWithTimeout(run, timeout) {
        return __async(this, null, function*() {
            if (!timeout) {
                return yield run();
            }
            return yield new Promise((resolve2, reject)=>{
                const timer = setTimeout(()=>{
                    reject(new Error(`act() timed out after ${timeout}ms`));
                }, timeout);
                void run().then((value)=>{
                    clearTimeout(timer);
                    resolve2(value);
                }, (err)=>{
                    clearTimeout(timer);
                    reject(err);
                });
            });
        });
    }
};
// lib/v3/cache/AgentCache.ts
var import_crypto2 = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)");
var SENSITIVE_CONFIG_KEYS = /* @__PURE__ */ new Set([
    "apikey",
    "api_key",
    "api-key"
]);
var AgentCache = class {
    constructor({ storage, logger, getActHandler, getContext, getDefaultLlmClient, getBaseModelName, getSystemPrompt, domSettleTimeoutMs, act: act2 }){
        this.recording = null;
        this.storage = storage;
        this.logger = logger;
        this.getActHandler = getActHandler;
        this.getContext = getContext;
        this.getDefaultLlmClient = getDefaultLlmClient;
        this.getBaseModelName = getBaseModelName;
        this.getSystemPrompt = getSystemPrompt;
        this.domSettleTimeoutMs = domSettleTimeoutMs;
        this.act = act2;
    }
    get enabled() {
        return this.storage.enabled;
    }
    shouldAttemptCache(instruction) {
        return this.enabled && instruction.trim().length > 0;
    }
    sanitizeExecuteOptions(options) {
        if (!options) return {};
        const sanitized = {};
        if (typeof options.maxSteps === "number") {
            sanitized.maxSteps = options.maxSteps;
        }
        if ("highlightCursor" in options && typeof options.highlightCursor === "boolean") {
            sanitized.highlightCursor = options.highlightCursor;
        }
        return sanitized;
    }
    buildConfigSignature(agentOptions) {
        var _a, _b, _c;
        const toolKeys = (agentOptions == null ? void 0 : agentOptions.tools) ? Object.keys(agentOptions.tools).sort() : void 0;
        const integrationSignatures = (agentOptions == null ? void 0 : agentOptions.integrations) ? agentOptions.integrations.map((integration)=>typeof integration === "string" ? integration : "client") : void 0;
        const serializedModel = this.serializeAgentModelForCache(agentOptions == null ? void 0 : agentOptions.model);
        const serializedExecutionModel = this.serializeAgentModelForCache(agentOptions == null ? void 0 : agentOptions.executionModel);
        return JSON.stringify({
            v3Model: this.getBaseModelName(),
            systemPrompt: (_a = this.getSystemPrompt()) != null ? _a : "",
            agent: {
                cua: (_b = agentOptions == null ? void 0 : agentOptions.cua) != null ? _b : false,
                model: serializedModel != null ? serializedModel : null,
                executionModel: (agentOptions == null ? void 0 : agentOptions.cua) ? null : serializedExecutionModel,
                systemPrompt: (_c = agentOptions == null ? void 0 : agentOptions.systemPrompt) != null ? _c : null,
                toolKeys,
                integrations: integrationSignatures
            }
        });
    }
    prepareContext(params) {
        return __async(this, null, function*() {
            if (!this.shouldAttemptCache(params.instruction)) {
                return null;
            }
            const instruction = params.instruction.trim();
            const startUrl = yield safeGetPageUrl(params.page);
            const cacheKey = this.buildAgentCacheKey(instruction, startUrl, params.options, params.configSignature);
            return {
                instruction,
                startUrl,
                options: params.options,
                configSignature: params.configSignature,
                cacheKey
            };
        });
    }
    tryReplay(context) {
        return __async(this, null, function*() {
            if (!this.enabled) return null;
            const { value: entry, error, path: path7 } = yield this.storage.readJson(`agent-${context.cacheKey}.json`);
            if (error && path7) {
                this.logger({
                    category: "cache",
                    message: `failed to read agent cache entry: ${path7}`,
                    level: 1,
                    auxiliary: {
                        error: {
                            value: String(error),
                            type: "string"
                        }
                    }
                });
                return null;
            }
            if (!entry || entry.version !== 1) {
                return null;
            }
            this.logger({
                category: "cache",
                message: "agent cache hit",
                level: 1,
                auxiliary: {
                    instruction: {
                        value: context.instruction,
                        type: "string"
                    },
                    url: {
                        value: context.startUrl,
                        type: "string"
                    }
                }
            });
            return yield this.replayAgentCacheEntry(entry);
        });
    }
    store(context, steps, result) {
        return __async(this, null, function*() {
            if (!this.enabled) return;
            const entry = {
                version: 1,
                instruction: context.instruction,
                startUrl: context.startUrl,
                options: context.options,
                configSignature: context.configSignature,
                steps: cloneForCache(steps),
                result: cloneForCache(result),
                timestamp: /* @__PURE__ */ new Date().toISOString()
            };
            const { error, path: path7 } = yield this.storage.writeJson(`agent-${context.cacheKey}.json`, entry);
            if (error && path7) {
                this.logger({
                    category: "cache",
                    message: "failed to write agent cache entry",
                    level: 1,
                    auxiliary: {
                        error: {
                            value: String(error),
                            type: "string"
                        }
                    }
                });
                return;
            }
            this.logger({
                category: "cache",
                message: "agent cache stored",
                level: 2,
                auxiliary: {
                    instruction: {
                        value: context.instruction,
                        type: "string"
                    },
                    steps: {
                        value: String(steps.length),
                        type: "string"
                    }
                }
            });
        });
    }
    beginRecording() {
        this.recording = [];
    }
    endRecording() {
        if (!this.recording) return [];
        const steps = cloneForCache(this.recording);
        this.recording = null;
        return steps;
    }
    discardRecording() {
        this.recording = null;
    }
    isRecording() {
        return Array.isArray(this.recording);
    }
    recordStep(step) {
        if (!this.isRecording()) return;
        try {
            this.recording.push(cloneForCache(step));
        } catch (err) {
            this.logger({
                category: "cache",
                message: "failed to record agent replay step",
                level: 2,
                auxiliary: {
                    error: {
                        value: String(err),
                        type: "string"
                    }
                }
            });
        }
    }
    isReplayActive() {
        return this.isRecording();
    }
    serializeAgentModelForCache(model) {
        if (!model) return null;
        if (typeof model === "string") return model;
        const _a = model, { modelName } = _a, modelOptions = __objRest(_a, [
            "modelName"
        ]);
        const sanitizedOptions = Object.keys(modelOptions).length > 0 ? this.sanitizeModelOptionsForCache(modelOptions) : void 0;
        return sanitizedOptions ? {
            modelName,
            options: sanitizedOptions
        } : modelName;
    }
    buildAgentCacheKey(instruction, startUrl, options, configSignature) {
        const payload = {
            instruction,
            startUrl,
            options,
            configSignature
        };
        return (0, import_crypto2.createHash)("sha256").update(JSON.stringify(payload)).digest("hex");
    }
    sanitizeModelOptionsForCache(value) {
        const sanitizedEntries = {};
        for (const [key, rawValue] of Object.entries(value)){
            if (SENSITIVE_CONFIG_KEYS.has(key.toLowerCase())) {
                continue;
            }
            const sanitizedValue = this.sanitizeModelValueForCache(rawValue);
            if (sanitizedValue !== void 0) {
                sanitizedEntries[key] = sanitizedValue;
            }
        }
        return Object.keys(sanitizedEntries).length > 0 ? sanitizedEntries : void 0;
    }
    sanitizeModelValueForCache(value) {
        if (Array.isArray(value)) {
            const sanitizedArray = value.map((item)=>this.sanitizeModelValueForCache(item)).filter((item)=>item !== void 0);
            return sanitizedArray;
        }
        if (value && typeof value === "object") {
            return this.sanitizeModelOptionsForCache(value);
        }
        return value;
    }
    replayAgentCacheEntry(entry) {
        return __async(this, null, function*() {
            var _a, _b;
            const ctx = this.getContext();
            const handler = this.getActHandler();
            if (!ctx || !handler) return null;
            try {
                for (const step of (_a = entry.steps) != null ? _a : []){
                    yield this.executeAgentReplayStep(step, ctx, handler);
                }
                const result = cloneForCache(entry.result);
                result.usage = {
                    input_tokens: 0,
                    output_tokens: 0,
                    reasoning_tokens: 0,
                    cached_input_tokens: 0,
                    inference_time_ms: 0
                };
                result.metadata = __spreadProps(__spreadValues({}, (_b = result.metadata) != null ? _b : {}), {
                    cacheHit: true,
                    cacheTimestamp: entry.timestamp
                });
                return result;
            } catch (err) {
                this.logger({
                    category: "cache",
                    message: "agent cache replay failed",
                    level: 1,
                    auxiliary: {
                        error: {
                            value: String(err),
                            type: "string"
                        }
                    }
                });
                return null;
            }
        });
    }
    executeAgentReplayStep(step, ctx, handler) {
        return __async(this, null, function*() {
            switch(step.type){
                case "act":
                    yield this.replayAgentActStep(step, ctx, handler);
                    return;
                case "fillForm":
                    yield this.replayAgentFillFormStep(step, ctx, handler);
                    return;
                case "goto":
                    yield this.replayAgentGotoStep(step, ctx);
                    return;
                case "scroll":
                    yield this.replayAgentScrollStep(step, ctx);
                    return;
                case "wait":
                    yield this.replayAgentWaitStep(step);
                    return;
                case "navback":
                    yield this.replayAgentNavBackStep(step, ctx);
                    return;
                case "close":
                case "extract":
                case "screenshot":
                case "ariaTree":
                    return;
                default:
                    this.logger({
                        category: "cache",
                        message: `agent cache skipping step type: ${step.type}`,
                        level: 2
                    });
            }
        });
    }
    replayAgentActStep(step, ctx, handler) {
        return __async(this, null, function*() {
            const actions = Array.isArray(step.actions) ? step.actions : [];
            if (actions.length > 0) {
                const page = yield ctx.awaitActivePage();
                for (const action of actions){
                    yield handler.actFromObserveResult(action, page, this.domSettleTimeoutMs, this.getDefaultLlmClient());
                }
                return;
            }
            yield this.act(step.instruction, {
                timeout: step.timeout
            });
        });
    }
    replayAgentFillFormStep(step, ctx, handler) {
        return __async(this, null, function*() {
            var _a;
            const actions = Array.isArray(step.actions) && step.actions.length > 0 ? step.actions : (_a = step.observeResults) != null ? _a : [];
            if (!Array.isArray(actions) || actions.length === 0) return;
            const page = yield ctx.awaitActivePage();
            for (const action of actions){
                yield handler.actFromObserveResult(action, page, this.domSettleTimeoutMs, this.getDefaultLlmClient());
            }
        });
    }
    replayAgentGotoStep(step, ctx) {
        return __async(this, null, function*() {
            var _a;
            const page = yield ctx.awaitActivePage();
            yield page.goto(step.url, {
                waitUntil: (_a = step.waitUntil) != null ? _a : "load"
            });
        });
    }
    replayAgentScrollStep(step, ctx) {
        return __async(this, null, function*() {
            var _a, _b, _c, _d;
            const page = yield ctx.awaitActivePage();
            let anchor = step.anchor;
            if (!anchor) {
                anchor = yield page.mainFrame().evaluate(()=>({
                        x: Math.max(0, Math.floor(window.innerWidth / 2)),
                        y: Math.max(0, Math.floor(window.innerHeight / 2))
                    }));
            }
            const deltaX = (_a = step.deltaX) != null ? _a : 0;
            const deltaY = (_b = step.deltaY) != null ? _b : 0;
            yield page.scroll(Math.round((_c = anchor.x) != null ? _c : 0), Math.round((_d = anchor.y) != null ? _d : 0), deltaX, deltaY);
        });
    }
    replayAgentWaitStep(step) {
        return __async(this, null, function*() {
            if (!step.timeMs || step.timeMs <= 0) return;
            yield new Promise((resolve2)=>setTimeout(resolve2, step.timeMs));
        });
    }
    replayAgentNavBackStep(step, ctx) {
        return __async(this, null, function*() {
            var _a;
            const page = yield ctx.awaitActivePage();
            yield page.goBack({
                waitUntil: (_a = step.waitUntil) != null ? _a : "domcontentloaded"
            });
        });
    }
};
// lib/v3/cache/CacheStorage.ts
var import_fs = __toESM(__turbopack_context__.r("[externals]/fs [external] (fs, cjs)"));
var import_path = __toESM(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
var CacheStorage = class _CacheStorage {
    constructor(logger, dir){
        this.logger = logger;
        this.dir = dir;
    }
    static create(cacheDir, logger, options) {
        var _a;
        if (!cacheDir) {
            return new _CacheStorage(logger);
        }
        const resolved = import_path.default.resolve(cacheDir);
        try {
            import_fs.default.mkdirSync(resolved, {
                recursive: true
            });
            return new _CacheStorage(logger, resolved);
        } catch (err) {
            const label = (_a = options == null ? void 0 : options.label) != null ? _a : "cache directory";
            logger({
                category: "cache",
                message: `unable to initialize ${label}: ${resolved}`,
                level: 1,
                auxiliary: {
                    error: {
                        value: String(err),
                        type: "string"
                    }
                }
            });
            return new _CacheStorage(logger);
        }
    }
    get directory() {
        return this.dir;
    }
    get enabled() {
        return !!this.dir;
    }
    resolvePath(fileName) {
        if (!this.dir) return null;
        return import_path.default.join(this.dir, fileName);
    }
    readJson(fileName) {
        return __async(this, null, function*() {
            const filePath = this.resolvePath(fileName);
            if (!filePath) {
                return {
                    value: null
                };
            }
            try {
                const raw = yield import_fs.default.promises.readFile(filePath, "utf8");
                return {
                    value: JSON.parse(raw)
                };
            } catch (err) {
                const code = err == null ? void 0 : err.code;
                if (code === "ENOENT") {
                    return {
                        value: null
                    };
                }
                return {
                    value: null,
                    error: err,
                    path: filePath
                };
            }
        });
    }
    writeJson(fileName, data) {
        return __async(this, null, function*() {
            const filePath = this.resolvePath(fileName);
            if (!filePath) {
                return {};
            }
            try {
                yield import_fs.default.promises.mkdir(import_path.default.dirname(filePath), {
                    recursive: true
                });
                yield import_fs.default.promises.writeFile(filePath, JSON.stringify(data, null, 2), "utf8");
                return {};
            } catch (err) {
                return {
                    error: err,
                    path: filePath
                };
            }
        });
    }
};
// lib/inference.ts
var import_v32 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/index.js [app-route] (ecmascript)");
// lib/prompt.ts
function buildUserInstructionsString(userProvidedInstructions) {
    if (!userProvidedInstructions) {
        return "";
    }
    return `

# Custom Instructions Provided by the User
    
Please keep the user's instructions in mind when performing actions. If the user's instructions are not relevant to the current task, ignore them.

User Instructions:
${userProvidedInstructions}`;
}
function buildExtractSystemPrompt(isUsingPrintExtractedDataTool = false, userProvidedInstructions) {
    const baseContent = `You are extracting content on behalf of a user.
  If a user asks you to extract a 'list' of information, or 'all' information, 
  YOU MUST EXTRACT ALL OF THE INFORMATION THAT THE USER REQUESTS.
   
  You will be given:
1. An instruction
2. `;
    const contentDetail = `A list of DOM elements to extract from.`;
    const instructions = `
Print the exact text from the DOM elements with all symbols, characters, and endlines as is.
Print null or an empty string if no new information is found.
  `.trim();
    const toolInstructions = isUsingPrintExtractedDataTool ? `
ONLY print the content using the print_extracted_data tool provided.
ONLY print the content using the print_extracted_data tool provided.
  `.trim() : "";
    const additionalInstructions = "If a user is attempting to extract links or URLs, you MUST respond with ONLY the IDs of the link elements. \nDo not attempt to extract links directly from the text unless absolutely necessary. ";
    const userInstructions = buildUserInstructionsString(userProvidedInstructions);
    const content = `${baseContent}${contentDetail}

${instructions}
${toolInstructions}${("TURBOPACK compile-time truthy", 1) ? `

${additionalInstructions}` : "TURBOPACK unreachable"}${userInstructions ? `

${userInstructions}` : ""}`.replace(/\s+/g, " ");
    return {
        role: "system",
        content
    };
}
function buildExtractUserPrompt(instruction, domElements, isUsingPrintExtractedDataTool = false) {
    let content = `Instruction: ${instruction}
DOM: ${domElements}`;
    if (isUsingPrintExtractedDataTool) {
        content += `
ONLY print the content using the print_extracted_data tool provided.
ONLY print the content using the print_extracted_data tool provided.`;
    }
    return {
        role: "user",
        content
    };
}
var metadataSystemPrompt = `You are an AI assistant tasked with evaluating the progress and completion status of an extraction task.
Analyze the extraction response and determine if the task is completed or if more information is needed.
Strictly abide by the following criteria:
1. Once the instruction has been satisfied by the current extraction response, ALWAYS set completion status to true and stop processing, regardless of remaining chunks.
2. Only set completion status to false if BOTH of these conditions are true:
   - The instruction has not been satisfied yet
   - There are still chunks left to process (chunksTotal > chunksSeen)`;
function buildMetadataSystemPrompt() {
    return {
        role: "system",
        content: metadataSystemPrompt
    };
}
function buildMetadataPrompt(instruction, extractionResponse) {
    return {
        role: "user",
        content: `Instruction: ${instruction}
Extracted content: ${JSON.stringify(extractionResponse, null, 2)}`
    };
}
function buildObserveSystemPrompt(userProvidedInstructions) {
    const observeSystemPrompt = `
You are helping the user automate the browser by finding elements based on what the user wants to observe in the page.

You will be given:
1. a instruction of elements to observe
2. a hierarchical accessibility tree showing the semantic structure of the page. The tree is a hybrid of the DOM and the accessibility tree.

Return an array of elements that match the instruction if they exist, otherwise return an empty array.`;
    const content = observeSystemPrompt.replace(/\s+/g, " ");
    return {
        role: "system",
        content: [
            content,
            buildUserInstructionsString(userProvidedInstructions)
        ].filter(Boolean).join("\n\n")
    };
}
function buildObserveUserMessage(instruction, domElements) {
    return {
        role: "user",
        content: `instruction: ${instruction}
Accessibility Tree: 
${domElements}
`
    };
}
function buildActSystemPrompt(userProvidedInstructions) {
    const actSystemPrompt = `
You are helping the user automate the browser by finding elements based on what action the user wants to take on the page

You will be given:
1. a user defined instruction about what action to take
2. a hierarchical accessibility tree showing the semantic structure of the page. The tree is a hybrid of the DOM and the accessibility tree.

Return the element that matches the instruction if it exists. Otherwise, return an empty object.`;
    const content = actSystemPrompt.replace(/\s+/g, " ");
    return {
        role: "system",
        content: [
            content,
            buildUserInstructionsString(userProvidedInstructions)
        ].filter(Boolean).join("\n\n")
    };
}
function buildActPrompt(action, supportedActions, variables) {
    let instruction = `Find the most relevant element to perform an action on given the following action: ${action}.  
  IF AND ONLY IF the action EXPLICITLY includes the word 'dropdown' and implies choosing/selecting an option from a dropdown, ignore the 'General Instructions' section, and follow the 'Dropdown Specific Instructions' section carefully.
  
  General Instructions: 
    Provide an action for this element such as ${supportedActions.join(", ")}. Remember that to users, buttons and links look the same in most cases.
    If the action is completely unrelated to a potential action to be taken on the page, return an empty object. 
    ONLY return one action. If multiple actions are relevant, return the most relevant one. 
    If the user is asking to scroll to a position on the page, e.g., 'halfway' or 0.75, etc, you must return the argument formatted as the correct percentage, e.g., '50%' or '75%', etc.
    If the user is asking to scroll to the next chunk/previous chunk, choose the nextChunk/prevChunk method. No arguments are required here.
    If the action implies a key press, e.g., 'press enter', 'press a', 'press space', etc., always choose the press method with the appropriate key as argument \u2014 e.g. 'a', 'Enter', 'Space'. Do not choose a click action on an on-screen keyboard. Capitalize the first character like 'Enter', 'Tab', 'Escape' only for special keys. 
  
  Dropdown Specific Instructions:
    For interacting with dropdowns, there are two specific cases that you need to handle. 
    
    CASE 1: the element is a 'select' element. 
      - choose the selectOptionFromDropdown method,
      - set the argument to the exact text of the option that should be selected,
      - set twoStep to false.
    CASE 2: the element is NOT a 'select' element:
      - do not attempt to directly choose the element from the dropdown. You will need to click to expand the dropdown first. You will achieve this by following these instructions:
        - choose the node that most closely corresponds to the given instruction EVEN if it is a 'StaticText' element, or otherwise does not appear to be interactable.  
        - choose the 'click' method
        - set twoStep to true.
  `;
    if (variables && Object.keys(variables).length > 0) {
        const variableNames = Object.keys(variables).map((key)=>`%${key}%`).join(", ");
        const variablesPrompt = `The following variables are available to use in the action: ${variableNames}. Fill the argument variables with the variable name.`;
        instruction += ` ${variablesPrompt}`;
    }
    return instruction;
}
function buildStepTwoPrompt(originalUserAction, previousAction, supportedActions, variables) {
    let instruction = `
  The original user action was: ${originalUserAction}.
  You have just taken the following action which completed step 1 of 2: ${previousAction}.
  
  Now, you must find the most relevant element to perform an action on in order to complete step 2 of 2. 
  
  General Instructions: 
  Provide an action for this element such as ${supportedActions.join(", ")}. Remember that to users, buttons and links look the same in most cases.
  If the action is completely unrelated to a potential action to be taken on the page, return an empty object. 
  ONLY return one action. If multiple actions are relevant, return the most relevant one. 
  If the user is asking to scroll to a position on the page, e.g., 'halfway' or 0.75, etc, you must return the argument formatted as the correct percentage, e.g., '50%' or '75%', etc.
  If the user is asking to scroll to the next chunk/previous chunk, choose the nextChunk/prevChunk method. No arguments are required here.
  If the action implies a key press, e.g., 'press enter', 'press a', 'press space', etc., always choose the press method with the appropriate key as argument \u2014 e.g. 'a', 'Enter', 'Space'. Do not choose a click action on an on-screen keyboard. Capitalize the first character like 'Enter', 'Tab', 'Escape' only for special keys. 
  `;
    if (variables && Object.keys(variables).length > 0) {
        const variableNames = Object.keys(variables).map((key)=>`%${key}%`).join(", ");
        const variablesPrompt = `The following variables are available to use in the action: ${variableNames}. Fill the argument variables with the variable name.`;
        instruction += ` ${variablesPrompt}`;
    }
    return instruction;
}
function buildGoogleCUASystemPrompt() {
    return {
        role: "system",
        content: `You are a general-purpose browser agent whose job is to accomplish the user's goal.
Today's date is ${/* @__PURE__ */ new Date().toISOString().split("T")[0]}.
You have access to a search tool; however, in most cases you should operate within the page/url the user has provided. ONLY use the search tool if you're stuck or the task is impossible to complete within the current page.
You will be given a goal and a list of steps that have been taken so far. Avoid requesting the user for input as much as possible. Good luck!
`
    };
}
// lib/inferenceLogUtils.ts
var import_fs2 = __toESM(__turbopack_context__.r("[externals]/fs [external] (fs, cjs)"));
var import_path2 = __toESM(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
function ensureInferenceSummaryDir() {
    const inferenceDir = import_path2.default.join(process.cwd(), "inference_summary");
    if (!import_fs2.default.existsSync(inferenceDir)) {
        import_fs2.default.mkdirSync(inferenceDir, {
            recursive: true
        });
    }
    return inferenceDir;
}
function appendSummary(inferenceType, entry) {
    const summaryPath = getSummaryJsonPath(inferenceType);
    const arrayKey = `${inferenceType}_summary`;
    const existingData = readSummaryFile(inferenceType);
    existingData[arrayKey].push(entry);
    import_fs2.default.writeFileSync(summaryPath, JSON.stringify(existingData, null, 2));
}
function getTimestamp() {
    return /* @__PURE__ */ new Date().toISOString().replace(/[^0-9T]/g, "").replace("T", "_");
}
function writeTimestampedTxtFile(directory, prefix, data) {
    const baseDir = ensureInferenceSummaryDir();
    const subDir = import_path2.default.join(baseDir, directory);
    if (!import_fs2.default.existsSync(subDir)) {
        import_fs2.default.mkdirSync(subDir, {
            recursive: true
        });
    }
    const timestamp = getTimestamp();
    const fileName = `${timestamp}_${prefix}.txt`;
    const filePath = import_path2.default.join(subDir, fileName);
    import_fs2.default.writeFileSync(filePath, JSON.stringify(data, null, 2).replace(/\\n/g, "\n"));
    return {
        fileName,
        timestamp
    };
}
function getSummaryJsonPath(inferenceType) {
    const baseDir = ensureInferenceSummaryDir();
    const subDir = import_path2.default.join(baseDir, `${inferenceType}_summary`);
    if (!import_fs2.default.existsSync(subDir)) {
        import_fs2.default.mkdirSync(subDir, {
            recursive: true
        });
    }
    return import_path2.default.join(subDir, `${inferenceType}_summary.json`);
}
function readSummaryFile(inferenceType) {
    const summaryPath = getSummaryJsonPath(inferenceType);
    const arrayKey = `${inferenceType}_summary`;
    if (!import_fs2.default.existsSync(summaryPath)) {
        return {
            [arrayKey]: []
        };
    }
    try {
        const raw = import_fs2.default.readFileSync(summaryPath, "utf8");
        const parsed = JSON.parse(raw);
        if (parsed && typeof parsed === "object" && Array.isArray(parsed[arrayKey])) {
            return parsed;
        }
    } catch (e) {}
    return {
        [arrayKey]: []
    };
}
// lib/inference.ts
function extract(_0) {
    return __async(this, arguments, function*({ instruction, domElements, schema, llmClient, logger, userProvidedInstructions, logInferenceToFile = false }) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
        const metadataSchema = import_v32.z.object({
            progress: import_v32.z.string().describe("progress of what has been extracted so far, as concise as possible"),
            completed: import_v32.z.boolean().describe("true if the goal is now accomplished. Use this conservatively, only when sure that the goal has been completed.")
        });
        const isUsingAnthropic = llmClient.type === "anthropic";
        const isGPT5 = llmClient.modelName.includes("gpt-5");
        const extractCallMessages = [
            buildExtractSystemPrompt(isUsingAnthropic, userProvidedInstructions),
            buildExtractUserPrompt(instruction, domElements, isUsingAnthropic)
        ];
        let extractCallFile = "";
        let extractCallTimestamp = "";
        if (logInferenceToFile) {
            const { fileName, timestamp } = writeTimestampedTxtFile("extract_summary", "extract_call", {
                modelCall: "extract",
                messages: extractCallMessages
            });
            extractCallFile = fileName;
            extractCallTimestamp = timestamp;
        }
        const extractStartTime = Date.now();
        const extractionResponse = yield llmClient.createChatCompletion({
            options: {
                messages: extractCallMessages,
                response_model: {
                    schema,
                    name: "Extraction"
                },
                temperature: isGPT5 ? 1 : 0.1,
                top_p: 1,
                frequency_penalty: 0,
                presence_penalty: 0
            },
            logger
        });
        const extractEndTime = Date.now();
        const { data: extractedData, usage: extractUsage } = extractionResponse;
        let extractResponseFile = "";
        if (logInferenceToFile) {
            const { fileName } = writeTimestampedTxtFile("extract_summary", "extract_response", {
                modelResponse: "extract",
                rawResponse: extractedData
            });
            extractResponseFile = fileName;
            appendSummary("extract", {
                extract_inference_type: "extract",
                timestamp: extractCallTimestamp,
                LLM_input_file: extractCallFile,
                LLM_output_file: extractResponseFile,
                prompt_tokens: (_a = extractUsage == null ? void 0 : extractUsage.prompt_tokens) != null ? _a : 0,
                completion_tokens: (_b = extractUsage == null ? void 0 : extractUsage.completion_tokens) != null ? _b : 0,
                reasoning_tokens: (_c = extractUsage == null ? void 0 : extractUsage.reasoning_tokens) != null ? _c : 0,
                cached_input_tokens: (_d = extractUsage == null ? void 0 : extractUsage.cached_input_tokens) != null ? _d : 0,
                inference_time_ms: extractEndTime - extractStartTime
            });
        }
        const metadataCallMessages = [
            buildMetadataSystemPrompt(),
            buildMetadataPrompt(instruction, extractedData)
        ];
        let metadataCallFile = "";
        let metadataCallTimestamp = "";
        if (logInferenceToFile) {
            const { fileName, timestamp } = writeTimestampedTxtFile("extract_summary", "metadata_call", {
                modelCall: "metadata",
                messages: metadataCallMessages
            });
            metadataCallFile = fileName;
            metadataCallTimestamp = timestamp;
        }
        const metadataStartTime = Date.now();
        const metadataResponse = yield llmClient.createChatCompletion({
            options: {
                messages: metadataCallMessages,
                response_model: {
                    name: "Metadata",
                    schema: metadataSchema
                },
                temperature: isGPT5 ? 1 : 0.1,
                top_p: 1,
                frequency_penalty: 0,
                presence_penalty: 0
            },
            logger
        });
        const metadataEndTime = Date.now();
        const { data: { completed: metadataResponseCompleted, progress: metadataResponseProgress }, usage: metadataResponseUsage } = metadataResponse;
        let metadataResponseFile = "";
        if (logInferenceToFile) {
            const { fileName } = writeTimestampedTxtFile("extract_summary", "metadata_response", {
                modelResponse: "metadata",
                completed: metadataResponseCompleted,
                progress: metadataResponseProgress
            });
            metadataResponseFile = fileName;
            appendSummary("extract", {
                extract_inference_type: "metadata",
                timestamp: metadataCallTimestamp,
                LLM_input_file: metadataCallFile,
                LLM_output_file: metadataResponseFile,
                prompt_tokens: (_e = metadataResponseUsage == null ? void 0 : metadataResponseUsage.prompt_tokens) != null ? _e : 0,
                completion_tokens: (_f = metadataResponseUsage == null ? void 0 : metadataResponseUsage.completion_tokens) != null ? _f : 0,
                reasoning_tokens: (_g = metadataResponseUsage == null ? void 0 : metadataResponseUsage.reasoning_tokens) != null ? _g : 0,
                cached_input_tokens: (_h = metadataResponseUsage == null ? void 0 : metadataResponseUsage.cached_input_tokens) != null ? _h : 0,
                inference_time_ms: metadataEndTime - metadataStartTime
            });
        }
        const totalPromptTokens = ((_i = extractUsage == null ? void 0 : extractUsage.prompt_tokens) != null ? _i : 0) + ((_j = metadataResponseUsage == null ? void 0 : metadataResponseUsage.prompt_tokens) != null ? _j : 0);
        const totalCompletionTokens = ((_k = extractUsage == null ? void 0 : extractUsage.completion_tokens) != null ? _k : 0) + ((_l = metadataResponseUsage == null ? void 0 : metadataResponseUsage.completion_tokens) != null ? _l : 0);
        const totalInferenceTimeMs = extractEndTime - extractStartTime + (metadataEndTime - metadataStartTime);
        const totalReasoningTokens = ((_m = extractUsage == null ? void 0 : extractUsage.reasoning_tokens) != null ? _m : 0) + ((_n = metadataResponseUsage == null ? void 0 : metadataResponseUsage.reasoning_tokens) != null ? _n : 0);
        const totalCachedInputTokens = ((_o = extractUsage == null ? void 0 : extractUsage.cached_input_tokens) != null ? _o : 0) + ((_p = metadataResponseUsage == null ? void 0 : metadataResponseUsage.cached_input_tokens) != null ? _p : 0);
        return __spreadProps(__spreadValues({}, extractedData), {
            metadata: {
                completed: metadataResponseCompleted,
                progress: metadataResponseProgress
            },
            prompt_tokens: totalPromptTokens,
            completion_tokens: totalCompletionTokens,
            reasoning_tokens: totalReasoningTokens,
            cached_input_tokens: totalCachedInputTokens,
            inference_time_ms: totalInferenceTimeMs
        });
    });
}
function observe(_0) {
    return __async(this, arguments, function*({ instruction, domElements, llmClient, userProvidedInstructions, logger, logInferenceToFile = false }) {
        var _a, _b, _c, _d, _e, _f;
        const isGPT5 = llmClient.modelName.includes("gpt-5");
        const observeSchema = import_v32.z.object({
            elements: import_v32.z.array(import_v32.z.object({
                elementId: import_v32.z.string().describe("the ID string associated with the element. Never include surrounding square brackets. This field must follow the format of 'number-number'."),
                description: import_v32.z.string().describe("a description of the accessible element and its purpose"),
                method: import_v32.z.string().describe("the candidate method/action to interact with the element. Select one of the available Playwright interaction methods."),
                arguments: import_v32.z.array(import_v32.z.string().describe("the arguments to pass to the method. For example, for a click, the arguments are empty, but for a fill, the arguments are the value to fill in."))
            })).describe("an array of accessible elements that match the instruction")
        });
        const messages = [
            buildObserveSystemPrompt(userProvidedInstructions),
            buildObserveUserMessage(instruction, domElements)
        ];
        let callTimestamp = "";
        let callFile = "";
        if (logInferenceToFile) {
            const { fileName, timestamp } = writeTimestampedTxtFile(`observe_summary`, `observe_call`, {
                modelCall: "observe",
                messages
            });
            callFile = fileName;
            callTimestamp = timestamp;
        }
        const start = Date.now();
        const rawResponse = yield llmClient.createChatCompletion({
            options: {
                messages,
                response_model: {
                    schema: observeSchema,
                    name: "Observation"
                },
                temperature: isGPT5 ? 1 : 0.1,
                top_p: 1,
                frequency_penalty: 0,
                presence_penalty: 0
            },
            logger
        });
        const end = Date.now();
        const usageTimeMs = end - start;
        const { data: observeData, usage: observeUsage } = rawResponse;
        const promptTokens = (_a = observeUsage == null ? void 0 : observeUsage.prompt_tokens) != null ? _a : 0;
        const completionTokens = (_b = observeUsage == null ? void 0 : observeUsage.completion_tokens) != null ? _b : 0;
        const reasoningTokens = (_c = observeUsage == null ? void 0 : observeUsage.reasoning_tokens) != null ? _c : 0;
        const cachedInputTokens = (_d = observeUsage == null ? void 0 : observeUsage.cached_input_tokens) != null ? _d : 0;
        let responseFile = "";
        if (logInferenceToFile) {
            const { fileName: responseFileName } = writeTimestampedTxtFile(`observe_summary`, `observe_response`, {
                modelResponse: "observe",
                rawResponse: observeData
            });
            responseFile = responseFileName;
            appendSummary("observe", {
                [`observe_inference_type`]: "observe",
                timestamp: callTimestamp,
                LLM_input_file: callFile,
                LLM_output_file: responseFile,
                prompt_tokens: promptTokens,
                completion_tokens: completionTokens,
                reasoning_tokens: reasoningTokens,
                cached_input_tokens: cachedInputTokens,
                inference_time_ms: usageTimeMs
            });
        }
        const parsedElements = (_f = (_e = observeData.elements) == null ? void 0 : _e.map((el)=>{
            const base = {
                elementId: el.elementId,
                description: String(el.description),
                method: String(el.method),
                arguments: el.arguments
            };
            return base;
        })) != null ? _f : [];
        return {
            elements: parsedElements,
            prompt_tokens: promptTokens,
            completion_tokens: completionTokens,
            reasoning_tokens: reasoningTokens,
            cached_input_tokens: cachedInputTokens,
            inference_time_ms: usageTimeMs
        };
    });
}
function act(_0) {
    return __async(this, arguments, function*({ instruction, domElements, llmClient, userProvidedInstructions, logger, logInferenceToFile = false }) {
        var _a, _b, _c, _d;
        const isGPT5 = llmClient.modelName.includes("gpt-5");
        const actSchema = import_v32.z.object({
            elementId: import_v32.z.string().describe("the ID string associated with the element. Never include surrounding square brackets. This field must follow the format of 'number-number'."),
            description: import_v32.z.string().describe("a description of the accessible element and its purpose"),
            method: import_v32.z.string().describe("the candidate method/action to interact with the element. Select one of the available Playwright interaction methods."),
            arguments: import_v32.z.array(import_v32.z.string().describe("the arguments to pass to the method. For example, for a click, the arguments are empty, but for a fill, the arguments are the value to fill in.")),
            twoStep: import_v32.z.boolean()
        });
        const messages = [
            buildActSystemPrompt(userProvidedInstructions),
            buildObserveUserMessage(instruction, domElements)
        ];
        let callTimestamp = "";
        let callFile = "";
        if (logInferenceToFile) {
            const { fileName, timestamp } = writeTimestampedTxtFile(`act_summary`, `act_call`, {
                modelCall: "act",
                messages
            });
            callFile = fileName;
            callTimestamp = timestamp;
        }
        const start = Date.now();
        const rawResponse = yield llmClient.createChatCompletion({
            options: {
                messages,
                response_model: {
                    schema: actSchema,
                    name: "act"
                },
                temperature: isGPT5 ? 1 : 0.1,
                top_p: 1,
                frequency_penalty: 0,
                presence_penalty: 0
            },
            logger
        });
        const end = Date.now();
        const usageTimeMs = end - start;
        const { data: actData, usage: actUsage } = rawResponse;
        const promptTokens = (_a = actUsage == null ? void 0 : actUsage.prompt_tokens) != null ? _a : 0;
        const completionTokens = (_b = actUsage == null ? void 0 : actUsage.completion_tokens) != null ? _b : 0;
        const reasoningTokens = (_c = actUsage == null ? void 0 : actUsage.reasoning_tokens) != null ? _c : 0;
        const cachedInputTokens = (_d = actUsage == null ? void 0 : actUsage.cached_input_tokens) != null ? _d : 0;
        let responseFile = "";
        if (logInferenceToFile) {
            const { fileName: responseFileName } = writeTimestampedTxtFile(`act_summary`, `act_response`, {
                modelResponse: "act",
                rawResponse: actData
            });
            responseFile = responseFileName;
            appendSummary("act", {
                [`act_inference_type`]: "act",
                timestamp: callTimestamp,
                LLM_input_file: callFile,
                LLM_output_file: responseFile,
                prompt_tokens: promptTokens,
                completion_tokens: completionTokens,
                reasoning_tokens: reasoningTokens,
                cached_input_tokens: cachedInputTokens,
                inference_time_ms: usageTimeMs
            });
        }
        const parsedElement = {
            elementId: actData.elementId,
            description: String(actData.description),
            method: String(actData.method),
            arguments: actData.arguments
        };
        return {
            element: parsedElement,
            prompt_tokens: promptTokens,
            completion_tokens: completionTokens,
            reasoning_tokens: reasoningTokens,
            cached_input_tokens: cachedInputTokens,
            inference_time_ms: usageTimeMs,
            twoStep: actData.twoStep
        };
    });
}
// lib/v3/handlers/actHandler.ts
init_logger();
// lib/v3/types/public/methods.ts
var import_v33 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/index.js [app-route] (ecmascript)");
var defaultExtractSchema = import_v33.z.object({
    extraction: import_v33.z.string()
});
var pageTextSchema = import_v33.z.object({
    pageText: import_v33.z.string()
});
var V3FunctionName = /* @__PURE__ */ ((V3FunctionName2)=>{
    V3FunctionName2["ACT"] = "ACT";
    V3FunctionName2["EXTRACT"] = "EXTRACT";
    V3FunctionName2["OBSERVE"] = "OBSERVE";
    V3FunctionName2["AGENT"] = "AGENT";
    return V3FunctionName2;
})(V3FunctionName || {});
// lib/v3/handlers/actHandler.ts
init_snapshot();
// lib/v3/types/private/handlers.ts
var SupportedPlaywrightAction = /* @__PURE__ */ ((SupportedPlaywrightAction2)=>{
    SupportedPlaywrightAction2["CLICK"] = "click";
    SupportedPlaywrightAction2["FILL"] = "fill";
    SupportedPlaywrightAction2["TYPE"] = "type";
    SupportedPlaywrightAction2["PRESS"] = "press";
    SupportedPlaywrightAction2["SCROLL"] = "scrollTo";
    SupportedPlaywrightAction2["NEXT_CHUNK"] = "nextChunk";
    SupportedPlaywrightAction2["PREV_CHUNK"] = "prevChunk";
    SupportedPlaywrightAction2["SELECT_OPTION_FROM_DROPDOWN"] = "selectOptionFromDropdown";
    SupportedPlaywrightAction2["HOVER"] = "hover";
    return SupportedPlaywrightAction2;
})(SupportedPlaywrightAction || {});
// lib/v3/handlers/handlerUtils/actHandlerUtils.ts
init_deepLocator();
init_logger();
init_sdkErrors();
var UnderstudyCommandException = class extends Error {
    constructor(message){
        super(message);
        this.name = "UnderstudyCommandException";
    }
};
function normalizeRootXPath(input) {
    const s = String(input != null ? input : "").trim();
    if (s === "/") return "/html";
    if (/^xpath=\/$/i.test(s)) return "xpath=/html";
    return s;
}
function performUnderstudyMethod(page, frame, method, rawXPath, args, domSettleTimeoutMs) {
    return __async(this, null, function*() {
        var _a;
        const selectorRaw = normalizeRootXPath(rawXPath);
        const locator = yield resolveLocatorWithHops(page, frame, selectorRaw);
        const initialUrl = yield getFrameUrl(frame);
        v3Logger({
            category: "action",
            message: "performing understudy method",
            level: 2,
            auxiliary: {
                xpath: {
                    value: selectorRaw,
                    type: "string"
                },
                method: {
                    value: method,
                    type: "string"
                },
                url: {
                    value: initialUrl,
                    type: "string"
                }
            }
        });
        const ctx = {
            method,
            locator,
            xpath: selectorRaw,
            args: args.map((a)=>a == null ? "" : String(a)),
            frame,
            page,
            initialUrl,
            domSettleTimeoutMs
        };
        try {
            const handler = (_a = METHOD_HANDLER_MAP[method]) != null ? _a : null;
            if (handler) {
                yield handler(ctx);
            } else {
                switch(method){
                    case "click":
                        yield clickElement(ctx);
                        break;
                    case "fill":
                        yield fillOrType(ctx);
                        break;
                    case "type":
                        yield typeText(ctx);
                        break;
                    default:
                        v3Logger({
                            category: "action",
                            message: "chosen method is invalid",
                            level: 1,
                            auxiliary: {
                                method: {
                                    value: method,
                                    type: "string"
                                }
                            }
                        });
                        throw new UnderstudyCommandException(`Method ${method} not supported`);
                }
            }
            yield handlePossibleNavigation("action", selectorRaw, initialUrl, frame);
        } catch (e) {
            const msg = e instanceof Error ? e.message : String(e);
            const stack = e instanceof Error ? e.stack : void 0;
            v3Logger({
                category: "action",
                message: "error performing method",
                level: 1,
                auxiliary: {
                    error: {
                        value: msg,
                        type: "string"
                    },
                    trace: {
                        value: stack != null ? stack : "",
                        type: "string"
                    },
                    method: {
                        value: method,
                        type: "string"
                    },
                    xpath: {
                        value: selectorRaw,
                        type: "string"
                    },
                    args: {
                        value: JSON.stringify(args),
                        type: "object"
                    }
                }
            });
            throw new UnderstudyCommandException(msg);
        }
    });
}
var METHOD_HANDLER_MAP = {
    scrollIntoView,
    scrollByPixelOffset,
    scrollTo: scrollElementToPercentage,
    scroll: scrollElementToPercentage,
    "mouse.wheel": wheelScroll,
    fill: fillOrType,
    type: typeText,
    press: pressKey,
    click: clickElement,
    doubleClick,
    dragAndDrop,
    nextChunk: scrollToNextChunk,
    prevChunk: scrollToPreviousChunk,
    selectOptionFromDropdown: selectOption,
    selectOption,
    hover
};
function selectOption(ctx) {
    return __async(this, null, function*() {
        var _a;
        const { locator, xpath, args } = ctx;
        try {
            const text = ((_a = args[0]) == null ? void 0 : _a.toString()) || "";
            yield locator.selectOption(text);
        } catch (e) {
            v3Logger({
                category: "action",
                message: "error selecting option",
                level: 0,
                auxiliary: {
                    error: {
                        value: e.message,
                        type: "string"
                    },
                    trace: {
                        value: e.stack,
                        type: "string"
                    },
                    xpath: {
                        value: xpath,
                        type: "string"
                    }
                }
            });
            throw new UnderstudyCommandException(e.message);
        }
    });
}
function scrollIntoView(ctx) {
    return __async(this, null, function*() {
        const { locator, xpath } = ctx;
        v3Logger({
            category: "action",
            message: "scrolling element into view",
            level: 2,
            auxiliary: {
                xpath: {
                    value: xpath,
                    type: "string"
                }
            }
        });
        const { objectId } = yield locator.resolveNode();
        const ownerSession2 = locator.getFrame().session;
        yield ownerSession2.send("DOM.scrollIntoViewIfNeeded", {
            objectId
        });
        yield ownerSession2.send("Runtime.releaseObject", {
            objectId
        }).catch(()=>{});
    });
}
function scrollElementToPercentage(ctx) {
    return __async(this, null, function*() {
        const { locator, xpath, args } = ctx;
        v3Logger({
            category: "action",
            message: "scrolling element vertically to specified percentage",
            level: 2,
            auxiliary: {
                xpath: {
                    value: xpath,
                    type: "string"
                },
                coordinate: {
                    value: JSON.stringify(args),
                    type: "string"
                }
            }
        });
        const [yArg = "0%"] = args;
        yield locator.scrollTo(yArg);
    });
}
function scrollByPixelOffset(ctx) {
    return __async(this, null, function*() {
        var _a, _b;
        const { locator, page, args } = ctx;
        const dx = Number((_a = args[0]) != null ? _a : 0);
        const dy = Number((_b = args[1]) != null ? _b : 0);
        try {
            const { x, y } = yield locator.centroid();
            yield page.scroll(x, y, dx, dy);
        } catch (e) {
            throw new UnderstudyCommandException(e.message);
        }
    });
}
function wheelScroll(ctx) {
    return __async(this, null, function*() {
        var _a;
        const { frame, args } = ctx;
        const deltaY = Number((_a = args[0]) != null ? _a : 200);
        v3Logger({
            category: "action",
            message: "dispatching mouse wheel",
            level: 2,
            auxiliary: {
                deltaY: {
                    value: String(deltaY),
                    type: "string"
                }
            }
        });
        yield frame.session.send("Input.dispatchMouseEvent", {
            type: "mouseWheel",
            x: 0,
            y: 0,
            deltaY,
            deltaX: 0
        });
    });
}
function fillOrType(ctx) {
    return __async(this, null, function*() {
        var _a;
        const { locator, xpath, args } = ctx;
        try {
            yield locator.fill("");
            yield locator.fill((_a = args[0]) != null ? _a : "");
        } catch (e) {
            const msg = e instanceof Error ? e.message : String(e);
            v3Logger({
                category: "action",
                message: "error filling element",
                level: 1,
                auxiliary: {
                    error: {
                        value: msg,
                        type: "string"
                    },
                    xpath: {
                        value: xpath,
                        type: "string"
                    }
                }
            });
            throw new UnderstudyCommandException(msg);
        }
    });
}
function typeText(ctx) {
    return __async(this, null, function*() {
        var _a;
        const { locator, xpath, args } = ctx;
        try {
            yield locator.type((_a = args[0]) != null ? _a : "");
        } catch (e) {
            const msg = e instanceof Error ? e.message : String(e);
            v3Logger({
                category: "action",
                message: "error typing into element",
                level: 1,
                auxiliary: {
                    error: {
                        value: msg,
                        type: "string"
                    },
                    xpath: {
                        value: xpath,
                        type: "string"
                    }
                }
            });
            throw new UnderstudyCommandException(msg);
        }
    });
}
function pressKey(ctx) {
    return __async(this, null, function*() {
        var _a;
        const { args, xpath, page } = ctx;
        const key = (_a = args[0]) != null ? _a : "";
        try {
            v3Logger({
                category: "action",
                message: "pressing key",
                level: 1,
                auxiliary: {
                    key: {
                        value: key,
                        type: "string"
                    },
                    xpath: {
                        value: xpath,
                        type: "string"
                    }
                }
            });
            yield page.keyPress(key);
        } catch (e) {
            const msg = e instanceof Error ? e.message : String(e);
            v3Logger({
                category: "action",
                message: "error pressing key",
                level: 1,
                auxiliary: {
                    error: {
                        value: msg,
                        type: "string"
                    },
                    key: {
                        value: key,
                        type: "string"
                    },
                    xpath: {
                        value: xpath,
                        type: "string"
                    }
                }
            });
            throw new UnderstudyCommandException(msg);
        }
    });
}
function clickElement(ctx) {
    return __async(this, null, function*() {
        const { locator, xpath } = ctx;
        try {
            yield locator.click();
        } catch (e) {
            const msg = e instanceof Error ? e.message : String(e);
            v3Logger({
                category: "action",
                message: "error performing click",
                level: 0,
                auxiliary: {
                    error: {
                        value: msg,
                        type: "string"
                    },
                    xpath: {
                        value: xpath,
                        type: "string"
                    }
                }
            });
            throw new StagehandClickError(ctx.xpath, msg);
        }
    });
}
function doubleClick(ctx) {
    return __async(this, null, function*() {
        const { locator, xpath } = ctx;
        try {
            yield locator.click({
                clickCount: 2
            });
        } catch (e) {
            const msg = e instanceof Error ? e.message : String(e);
            v3Logger({
                category: "action",
                message: "error performing doubleClick",
                level: 0,
                auxiliary: {
                    error: {
                        value: msg,
                        type: "string"
                    },
                    xpath: {
                        value: xpath,
                        type: "string"
                    }
                }
            });
            throw new UnderstudyCommandException(msg);
        }
    });
}
function dragAndDrop(ctx) {
    return __async(this, null, function*() {
        var _a;
        const { page, frame, locator, args, xpath } = ctx;
        const toXPath = String((_a = args[0]) != null ? _a : "").trim();
        if (!toXPath) throw new UnderstudyCommandException("dragAndDrop requires a target XPath arg");
        const targetLocator = yield resolveLocatorWithHops(page, frame, toXPath);
        try {
            const { x: fromLocalX, y: fromLocalY } = yield locator.centroid();
            const { x: toLocalX, y: toLocalY } = yield targetLocator.centroid();
            const fromAbs = yield locator.getFrame().evaluate(({ x, y })=>{
                let X = x;
                let Y = y;
                let w = window;
                while(w !== w.top){
                    const fe = w.frameElement;
                    if (!fe) break;
                    const r = fe.getBoundingClientRect();
                    X += r.left;
                    Y += r.top;
                    w = w.parent;
                }
                return {
                    x: Math.round(X),
                    y: Math.round(Y)
                };
            }, {
                x: fromLocalX,
                y: fromLocalY
            });
            const toAbs = yield targetLocator.getFrame().evaluate(({ x, y })=>{
                let X = x;
                let Y = y;
                let w = window;
                while(w !== w.top){
                    const fe = w.frameElement;
                    if (!fe) break;
                    const r = fe.getBoundingClientRect();
                    X += r.left;
                    Y += r.top;
                    w = w.parent;
                }
                return {
                    x: Math.round(X),
                    y: Math.round(Y)
                };
            }, {
                x: toLocalX,
                y: toLocalY
            });
            yield page.dragAndDrop(fromAbs.x, fromAbs.y, toAbs.x, toAbs.y, {
                steps: 10,
                delay: 5
            });
        } catch (e) {
            const msg = e instanceof Error ? e.message : String(e);
            v3Logger({
                category: "action",
                message: "error performing dragAndDrop",
                level: 0,
                auxiliary: {
                    error: {
                        value: msg,
                        type: "string"
                    },
                    from: {
                        value: xpath,
                        type: "string"
                    },
                    to: {
                        value: toXPath,
                        type: "string"
                    }
                }
            });
            throw new UnderstudyCommandException(msg);
        }
    });
}
function scrollToNextChunk(ctx) {
    return __async(this, null, function*() {
        yield scrollByElementHeight(ctx, /*dir=*/ 1);
    });
}
function scrollToPreviousChunk(ctx) {
    return __async(this, null, function*() {
        yield scrollByElementHeight(ctx, /*dir=*/ -1);
    });
}
function scrollByElementHeight(ctx, direction) {
    return __async(this, null, function*() {
        const { locator, xpath } = ctx;
        v3Logger({
            category: "action",
            message: direction > 0 ? "scrolling to next chunk" : "scrolling to previous chunk",
            level: 2,
            auxiliary: {
                xpath: {
                    value: xpath,
                    type: "string"
                }
            }
        });
        const { objectId } = yield locator.resolveNode();
        try {
            const ownerSession2 = locator.getFrame().session;
            yield ownerSession2.send("Runtime.callFunctionOn", {
                objectId,
                functionDeclaration: `
          function(dir) {
            const waitForScrollEnd = (el) => new Promise((resolve) => {
              let last = el.scrollTop ?? 0;
              const check = () => {
                const cur = el.scrollTop ?? 0;
                if (cur === last) return resolve();
                last = cur;
                requestAnimationFrame(check);
              };
              requestAnimationFrame(check);
            });

            const tag = this.tagName?.toLowerCase();
            if (tag === "html" || tag === "body") {
              const h = window.visualViewport?.height ?? window.innerHeight;
              window.scrollBy({ top: h * dir, left: 0, behavior: "smooth" });
              const root = document.scrollingElement ?? document.documentElement;
              return waitForScrollEnd(root);
            }
            const h = this.getBoundingClientRect().height;
            this.scrollBy({ top: h * dir, left: 0, behavior: "smooth" });
            return waitForScrollEnd(this);
          }
        `,
                arguments: [
                    {
                        value: direction
                    }
                ],
                awaitPromise: true,
                returnByValue: true
            });
        } finally{
            const ownerSession2 = locator.getFrame().session;
            yield ownerSession2.send("Runtime.releaseObject", {
                objectId
            }).catch(()=>{});
        }
    });
}
function hover(ctx) {
    return __async(this, null, function*() {
        const { locator, xpath } = ctx;
        try {
            yield locator.hover();
        } catch (e) {
            v3Logger({
                category: "action",
                message: "error attempting to hover",
                level: 0,
                auxiliary: {
                    error: {
                        value: e.message,
                        type: "string"
                    },
                    trace: {
                        value: e.stack,
                        type: "string"
                    },
                    xpath: {
                        value: xpath,
                        type: "string"
                    }
                }
            });
            throw new UnderstudyCommandException(e.message);
        }
    });
}
function getFrameUrl(frame) {
    return __async(this, null, function*() {
        const url = yield frame.evaluate("location.href");
        return url;
    });
}
function waitForDomNetworkQuiet(frame, timeoutMs) {
    return __async(this, null, function*() {
        const timeout = typeof timeoutMs === "number" ? timeoutMs : 5e3;
        const client = frame.session;
        let hasDoc;
        try {
            const rs = yield frame.evaluate("document.readyState");
            hasDoc = rs === "interactive" || rs === "complete";
        } catch (e) {
            hasDoc = false;
        }
        if (!hasDoc) {
            yield frame.waitForLoadState("domcontentloaded").catch(()=>{});
        }
        yield client.send("Network.enable").catch(()=>{});
        yield client.send("Page.enable").catch(()=>{});
        yield client.send("Target.setAutoAttach", {
            autoAttach: true,
            waitForDebuggerOnStart: false,
            flatten: true,
            filter: [
                {
                    type: "worker",
                    exclude: true
                },
                {
                    type: "shared_worker",
                    exclude: true
                }
            ]
        }).catch(()=>{});
        return new Promise((resolve2)=>{
            const inflight = /* @__PURE__ */ new Set();
            const meta = /* @__PURE__ */ new Map();
            const docByFrame = /* @__PURE__ */ new Map();
            let quietTimer = null;
            let stalledRequestSweepTimer = null;
            const clearQuiet = ()=>{
                if (quietTimer) {
                    clearTimeout(quietTimer);
                    quietTimer = null;
                }
            };
            const maybeQuiet = ()=>{
                if (inflight.size === 0 && !quietTimer) quietTimer = setTimeout(()=>resolveDone(), 500);
            };
            const finishReq = (id)=>{
                if (!inflight.delete(id)) return;
                meta.delete(id);
                for (const [fid, rid] of docByFrame)if (rid === id) docByFrame.delete(fid);
                clearQuiet();
                maybeQuiet();
            };
            const onRequest = (p)=>{
                if (p.type === "WebSocket" || p.type === "EventSource") return;
                inflight.add(p.requestId);
                meta.set(p.requestId, {
                    url: p.request.url,
                    start: Date.now()
                });
                if (p.type === "Document" && p.frameId) docByFrame.set(p.frameId, p.requestId);
                clearQuiet();
            };
            const onFinish = (p)=>finishReq(p.requestId);
            const onCached = (p)=>finishReq(p.requestId);
            const onDataUrl = (p)=>{
                var _a;
                if ((_a = p.response.url) == null ? void 0 : _a.startsWith("data:")) finishReq(p.requestId);
            };
            const onFrameStop = (f)=>{
                const id = docByFrame.get(f.frameId);
                if (id) finishReq(id);
            };
            client.on("Network.requestWillBeSent", onRequest);
            client.on("Network.loadingFinished", onFinish);
            client.on("Network.loadingFailed", onFinish);
            client.on("Network.requestServedFromCache", onCached);
            client.on("Network.responseReceived", onDataUrl);
            client.on("Page.frameStoppedLoading", onFrameStop);
            stalledRequestSweepTimer = setInterval(()=>{
                var _a;
                const now2 = Date.now();
                for (const [id, m] of meta){
                    if (now2 - m.start > 2e3) {
                        inflight.delete(id);
                        meta.delete(id);
                        v3Logger({
                            category: "dom",
                            message: "\u23F3 forcing completion of stalled iframe document",
                            level: 1,
                            auxiliary: {
                                url: {
                                    value: ((_a = m.url) != null ? _a : "").slice(0, 120),
                                    type: "string"
                                }
                            }
                        });
                    }
                }
                maybeQuiet();
            }, 500);
            maybeQuiet();
            const guard = setTimeout(()=>{
                if (inflight.size) {
                    v3Logger({
                        category: "dom",
                        message: "\u26A0\uFE0F DOM-settle timeout reached \u2013 network requests still pending",
                        level: 1,
                        auxiliary: {
                            count: {
                                value: String(inflight.size),
                                type: "integer"
                            }
                        }
                    });
                }
                resolveDone();
            }, timeout);
            const resolveDone = ()=>{
                client.off("Network.requestWillBeSent", onRequest);
                client.off("Network.loadingFinished", onFinish);
                client.off("Network.loadingFailed", onFinish);
                client.off("Network.requestServedFromCache", onCached);
                client.off("Network.responseReceived", onDataUrl);
                client.off("Page.frameStoppedLoading", onFrameStop);
                if (quietTimer) clearTimeout(quietTimer);
                if (stalledRequestSweepTimer) clearInterval(stalledRequestSweepTimer);
                clearTimeout(guard);
                resolve2();
            };
        });
    });
}
function handlePossibleNavigation(actionDescription, xpath, initialUrl, frame) {
    return __async(this, null, function*() {
        v3Logger({
            category: "action",
            message: `${actionDescription}, checking for page navigation`,
            level: 1,
            auxiliary: {
                xpath: {
                    value: xpath,
                    type: "string"
                }
            }
        });
        const afterUrl = yield getFrameUrl(frame);
        if (afterUrl !== initialUrl) {
            v3Logger({
                category: "action",
                message: "new page (frame) URL detected",
                level: 1,
                auxiliary: {
                    url: {
                        value: afterUrl,
                        type: "string"
                    }
                }
            });
        } else {
            v3Logger({
                category: "action",
                message: "no new (frame) URL detected",
                level: 1,
                auxiliary: {
                    url: {
                        value: afterUrl,
                        type: "string"
                    }
                }
            });
        }
    });
}
// lib/v3/handlers/actHandler.ts
var ActHandler = class {
    constructor(llmClient, defaultModelName, defaultClientOptions, resolveLlmClient, systemPrompt, logInferenceToFile, selfHeal, onMetrics, defaultDomSettleTimeoutMs){
        this.llmClient = llmClient;
        this.defaultModelName = defaultModelName;
        this.defaultClientOptions = defaultClientOptions;
        this.resolveLlmClient = resolveLlmClient;
        this.systemPrompt = systemPrompt != null ? systemPrompt : "";
        this.logInferenceToFile = logInferenceToFile != null ? logInferenceToFile : false;
        this.selfHeal = !!selfHeal;
        this.onMetrics = onMetrics;
        this.defaultDomSettleTimeoutMs = defaultDomSettleTimeoutMs;
    }
    act(params) {
        return __async(this, null, function*() {
            const { instruction, page, variables, timeout, model } = params;
            const llmClient = this.resolveLlmClient(model);
            const doObserveAndAct = ()=>__async(this, null, function*() {
                    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
                    yield waitForDomNetworkQuiet(page.mainFrame(), this.defaultDomSettleTimeoutMs);
                    const snapshot = yield captureHybridSnapshot(page, {
                        experimental: true
                    });
                    const combinedTree = snapshot.combinedTree;
                    const combinedXpathMap = (_a = snapshot.combinedXpathMap) != null ? _a : {};
                    const observeActInstruction = buildActPrompt(instruction, Object.values(SupportedPlaywrightAction), variables);
                    const actInferenceResponse = yield act({
                        instruction: observeActInstruction,
                        domElements: combinedTree,
                        llmClient,
                        userProvidedInstructions: this.systemPrompt,
                        logger: v3Logger,
                        logInferenceToFile: this.logInferenceToFile
                    });
                    const actPromptTokens = (_b = actInferenceResponse.prompt_tokens) != null ? _b : 0;
                    const actCompletionTokens = (_c = actInferenceResponse.completion_tokens) != null ? _c : 0;
                    const actReasoningTokens = (_d = actInferenceResponse.reasoning_tokens) != null ? _d : 0;
                    const actCachedInputTokens = (_e = actInferenceResponse.cached_input_tokens) != null ? _e : 0;
                    const actInferenceTimeMs = (_f = actInferenceResponse.inference_time_ms) != null ? _f : 0;
                    (_g = this.onMetrics) == null ? void 0 : _g.call(this, "ACT" /* ACT */ , actPromptTokens, actCompletionTokens, actReasoningTokens, actCachedInputTokens, actInferenceTimeMs);
                    const raw = actInferenceResponse.element;
                    const result = (()=>{
                        if (!raw) return void 0;
                        const { elementId, description, method, arguments: args } = raw;
                        if (!method || method === "not-supported" || !Array.isArray(args)) {
                            return void 0;
                        }
                        if (typeof elementId === "string" && elementId.includes("-")) {
                            const xp = combinedXpathMap[elementId];
                            const trimmed = trimTrailingTextNode(xp);
                            if (!trimmed) return void 0;
                            return {
                                description,
                                method,
                                arguments: args,
                                selector: `xpath=${trimmed}`
                            };
                        }
                        return void 0;
                    })();
                    if (!result) {
                        v3Logger({
                            category: "action",
                            message: "no actionable element returned by LLM",
                            level: 1
                        });
                        return {
                            success: false,
                            message: "Failed to perform act: No action found",
                            actionDescription: instruction,
                            actions: []
                        };
                    }
                    const chosen = __spreadValues({}, result);
                    if (variables && Array.isArray(chosen.arguments)) {
                        chosen.arguments = chosen.arguments.map((arg)=>{
                            let out = arg;
                            for (const [k, v] of Object.entries(variables)){
                                const token = `%${k}%`;
                                out = out.split(token).join(String(v));
                            }
                            return out;
                        });
                    }
                    const firstResult = yield this.actFromObserveResult(chosen, page, this.defaultDomSettleTimeoutMs, llmClient);
                    const twoStep = !!actInferenceResponse.twoStep;
                    if (!twoStep) {
                        return firstResult;
                    }
                    const secondSnapshot = yield captureHybridSnapshot(page, {
                        experimental: true
                    });
                    const combinedTree2 = secondSnapshot.combinedTree;
                    let diffedTree = diffCombinedTrees(combinedTree, combinedTree2);
                    if (!diffedTree.trim()) {
                        diffedTree = combinedTree2;
                    }
                    const combinedXpathMap2 = (_h = secondSnapshot.combinedXpathMap) != null ? _h : {};
                    const previousAction = `method: ${chosen.method}, description: ${chosen.description}, arguments: ${chosen.arguments}`;
                    const stepTwoInstructions = buildStepTwoPrompt(instruction, previousAction, Object.values(SupportedPlaywrightAction).filter((action)=>action !== "selectOptionFromDropdown" /* SELECT_OPTION_FROM_DROPDOWN */ ), variables);
                    const action2 = yield act({
                        instruction: stepTwoInstructions,
                        domElements: diffedTree,
                        llmClient,
                        userProvidedInstructions: this.systemPrompt,
                        logger: v3Logger,
                        logInferenceToFile: this.logInferenceToFile
                    });
                    (_n = this.onMetrics) == null ? void 0 : _n.call(this, "ACT" /* ACT */ , (_i = action2.prompt_tokens) != null ? _i : 0, (_j = action2.completion_tokens) != null ? _j : 0, (_k = action2.reasoning_tokens) != null ? _k : 0, (_l = action2.cached_input_tokens) != null ? _l : 0, (_m = action2.inference_time_ms) != null ? _m : 0);
                    const raw2 = action2.element;
                    const result2 = (()=>{
                        if (!raw2) return void 0;
                        const { elementId, description, method, arguments: args } = raw2;
                        if (!method || method === "not-supported" || !Array.isArray(args)) {
                            return void 0;
                        }
                        if (typeof elementId === "string" && elementId.includes("-")) {
                            const xp = combinedXpathMap2[elementId];
                            const trimmed = trimTrailingTextNode(xp);
                            if (!trimmed) return void 0;
                            return {
                                description,
                                method,
                                arguments: args,
                                selector: `xpath=${trimmed}`
                            };
                        }
                        return void 0;
                    })();
                    if (!result2) {
                        return firstResult;
                    }
                    const chosen2 = __spreadValues({}, result2);
                    if (variables && Array.isArray(chosen2.arguments)) {
                        chosen2.arguments = chosen2.arguments.map((arg)=>{
                            let out = arg;
                            for (const [k, v] of Object.entries(variables)){
                                const token = `%${k}%`;
                                out = out.split(token).join(String(v));
                            }
                            return out;
                        });
                    }
                    const secondResult = yield this.actFromObserveResult(chosen2, page, this.defaultDomSettleTimeoutMs, llmClient);
                    return {
                        success: firstResult.success && secondResult.success,
                        message: secondResult.success ? `${firstResult.message} \u2192 ${secondResult.message}` : `${firstResult.message} \u2192 ${secondResult.message}`,
                        actionDescription: firstResult.actionDescription,
                        actions: [
                            ...firstResult.actions || [],
                            ...secondResult.actions || []
                        ]
                    };
                });
            if (!timeout) {
                return doObserveAndAct();
            }
            return yield Promise.race([
                doObserveAndAct(),
                new Promise((_, reject)=>{
                    setTimeout(()=>reject(new Error(`act() timed out after ${timeout}ms`)), timeout);
                })
            ]);
        });
    }
    actFromObserveResult(action, page, domSettleTimeoutMs, llmClientOverride) {
        return __async(this, null, function*() {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            const settleTimeout = domSettleTimeoutMs != null ? domSettleTimeoutMs : this.defaultDomSettleTimeoutMs;
            const effectiveClient = llmClientOverride != null ? llmClientOverride : this.llmClient;
            const method = (_a = action.method) == null ? void 0 : _a.trim();
            if (!method || method === "not-supported") {
                v3Logger({
                    category: "action",
                    message: "action has no supported method",
                    level: 0,
                    auxiliary: {
                        act: {
                            value: JSON.stringify(action),
                            type: "object"
                        }
                    }
                });
                return {
                    success: false,
                    message: `Unable to perform action: The method '${method != null ? method : ""}' is not supported in Action. Please use a supported Playwright locator method.`,
                    actionDescription: action.description || `Action (${method != null ? method : "unknown"})`,
                    actions: []
                };
            }
            const args = Array.isArray(action.arguments) ? action.arguments : [];
            try {
                yield performUnderstudyMethod(page, page.mainFrame(), method, action.selector, args, settleTimeout);
                return {
                    success: true,
                    message: `Action [${method}] performed successfully on selector: ${action.selector}`,
                    actionDescription: action.description || `action (${method})`,
                    actions: [
                        {
                            selector: action.selector,
                            description: action.description || `action (${method})`,
                            method,
                            arguments: args
                        }
                    ]
                };
            } catch (err) {
                const msg = err instanceof Error ? err.message : String(err);
                if (this.selfHeal) {
                    v3Logger({
                        category: "action",
                        message: "Error performing action. Reprocessing the page and trying again",
                        level: 1,
                        auxiliary: {
                            error: {
                                value: msg,
                                type: "string"
                            },
                            action: {
                                value: JSON.stringify(action),
                                type: "object"
                            }
                        }
                    });
                    try {
                        const actCommand = action.description ? action.description.toLowerCase().startsWith(method.toLowerCase()) ? action.description : `${method} ${action.description}` : method;
                        const snapshot = yield captureHybridSnapshot(page, {
                            experimental: true
                        });
                        const combinedTree = snapshot.combinedTree;
                        const instruction = buildActPrompt(actCommand, Object.values(SupportedPlaywrightAction), {});
                        const actInferenceResponse = yield act({
                            instruction,
                            domElements: combinedTree,
                            llmClient: effectiveClient,
                            userProvidedInstructions: this.systemPrompt,
                            logger: v3Logger,
                            logInferenceToFile: this.logInferenceToFile
                        });
                        (_g = this.onMetrics) == null ? void 0 : _g.call(this, "ACT" /* ACT */ , (_b = actInferenceResponse.prompt_tokens) != null ? _b : 0, (_c = actInferenceResponse.completion_tokens) != null ? _c : 0, (_d = actInferenceResponse.reasoning_tokens) != null ? _d : 0, (_e = actInferenceResponse.cached_input_tokens) != null ? _e : 0, (_f = actInferenceResponse.inference_time_ms) != null ? _f : 0);
                        const fallback = actInferenceResponse.element;
                        if (!fallback) {
                            return {
                                success: false,
                                message: "Failed to self-heal act: No observe results found for action",
                                actionDescription: actCommand,
                                actions: []
                            };
                        }
                        let newSelector = action.selector;
                        if (typeof fallback.elementId === "string") {
                            const enc = fallback.elementId;
                            const rawXp = ((_h = snapshot.combinedXpathMap) != null ? _h : {})[enc];
                            const trimmed = trimTrailingTextNode(rawXp);
                            if (trimmed) newSelector = `xpath=${trimmed}`;
                        }
                        yield performUnderstudyMethod(page, page.mainFrame(), method, newSelector, args, settleTimeout);
                        return {
                            success: true,
                            message: `Action [${method}] performed successfully on selector: ${newSelector}`,
                            actionDescription: action.description || `action (${method})`,
                            actions: [
                                {
                                    selector: newSelector,
                                    description: action.description || `action (${method})`,
                                    method,
                                    arguments: args
                                }
                            ]
                        };
                    } catch (retryErr) {
                        const retryMsg = retryErr instanceof Error ? retryErr.message : String(retryErr);
                        return {
                            success: false,
                            message: `Failed to perform act after self-heal: ${retryMsg}`,
                            actionDescription: action.description || `action (${method})`,
                            actions: []
                        };
                    }
                }
                return {
                    success: false,
                    message: `Failed to perform act: ${msg}`,
                    actionDescription: action.description || `action (${method})`,
                    actions: []
                };
            }
        });
    }
};
// lib/v3/handlers/extractHandler.ts
init_logger();
init_snapshot();
var import_v34 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/index.js [app-route] (ecmascript)");
init_sdkErrors();
function transformUrlStringsToNumericIds(schema) {
    const [finalSchema, urlPaths] = transformSchema(schema, []);
    return [
        finalSchema,
        urlPaths
    ];
}
var ExtractHandler = class {
    constructor(llmClient, defaultModelName, defaultClientOptions, resolveLlmClient, systemPrompt, logInferenceToFile, experimental, onMetrics){
        this.llmClient = llmClient;
        this.defaultModelName = defaultModelName;
        this.defaultClientOptions = defaultClientOptions;
        this.resolveLlmClient = resolveLlmClient;
        this.systemPrompt = systemPrompt != null ? systemPrompt : "";
        this.logInferenceToFile = logInferenceToFile != null ? logInferenceToFile : false;
        this.experimental = experimental != null ? experimental : false;
        this.onMetrics = onMetrics;
    }
    extract(params) {
        return __async(this, null, function*() {
            const { instruction, schema, page, selector, timeout, model } = params;
            const llmClient = this.resolveLlmClient(model);
            const doExtract = ()=>__async(this, null, function*() {
                    var _a, _b, _c, _e;
                    const noArgs = !instruction && !schema;
                    if (noArgs) {
                        const focusSelector2 = (_a = selector == null ? void 0 : selector.replace(/^xpath=/i, "")) != null ? _a : "";
                        const snap = yield captureHybridSnapshot(page, {
                            experimental: this.experimental,
                            focusSelector: focusSelector2 || void 0
                        });
                        const result = {
                            pageText: snap.combinedTree
                        };
                        return pageTextSchema.parse(result);
                    }
                    if (!instruction && schema) {
                        throw new StagehandInvalidArgumentError("extract() requires an instruction when a schema is provided.");
                    }
                    const focusSelector = (_b = selector == null ? void 0 : selector.replace(/^xpath=/, "")) != null ? _b : "";
                    const { combinedTree, combinedUrlMap } = yield captureHybridSnapshot(page, {
                        experimental: this.experimental,
                        focusSelector
                    });
                    v3Logger({
                        category: "extraction",
                        message: "Starting extraction using a11y snapshot",
                        level: 1,
                        auxiliary: instruction ? {
                            instruction: {
                                value: instruction,
                                type: "string"
                            }
                        } : void 0
                    });
                    const baseSchema = schema != null ? schema : defaultExtractSchema;
                    const isObjectSchema = !!((_c = baseSchema._def) == null ? void 0 : _c.shape);
                    const WRAP_KEY = "value";
                    const objectSchema = isObjectSchema ? baseSchema : import_v34.z.object({
                        [WRAP_KEY]: baseSchema
                    });
                    const [transformedSchema, urlFieldPaths] = transformUrlStringsToNumericIds(objectSchema);
                    const extractionResponse = yield extract({
                        instruction,
                        domElements: combinedTree,
                        schema: transformedSchema,
                        llmClient,
                        userProvidedInstructions: this.systemPrompt,
                        logger: v3Logger,
                        logInferenceToFile: this.logInferenceToFile
                    });
                    const _d = extractionResponse, { metadata: { completed }, prompt_tokens, completion_tokens, reasoning_tokens = 0, cached_input_tokens = 0, inference_time_ms } = _d, rest = __objRest(_d, [
                        "metadata",
                        "prompt_tokens",
                        "completion_tokens",
                        "reasoning_tokens",
                        "cached_input_tokens",
                        "inference_time_ms"
                    ]);
                    let output = rest;
                    v3Logger({
                        category: "extraction",
                        message: completed ? "Extraction completed successfully" : "Extraction incomplete after processing all data",
                        level: 1,
                        auxiliary: {
                            prompt_tokens: {
                                value: String(prompt_tokens),
                                type: "string"
                            },
                            completion_tokens: {
                                value: String(completion_tokens),
                                type: "string"
                            },
                            inference_time_ms: {
                                value: String(inference_time_ms),
                                type: "string"
                            }
                        }
                    });
                    (_e = this.onMetrics) == null ? void 0 : _e.call(this, "EXTRACT" /* EXTRACT */ , prompt_tokens, completion_tokens, reasoning_tokens, cached_input_tokens, inference_time_ms);
                    const idToUrl = combinedUrlMap != null ? combinedUrlMap : {};
                    for (const { segments } of urlFieldPaths){
                        injectUrls(output, segments, idToUrl);
                    }
                    if (!isObjectSchema && output && typeof output === "object") {
                        output = output[WRAP_KEY];
                    }
                    return output;
                });
            if (!timeout) return doExtract();
            return yield Promise.race([
                doExtract(),
                new Promise((_, reject)=>{
                    setTimeout(()=>reject(new Error(`extract() timed out after ${timeout}ms`)), timeout);
                })
            ]);
        });
    }
};
// lib/v3/handlers/observeHandler.ts
init_logger();
init_snapshot();
var ObserveHandler = class {
    constructor(llmClient, defaultModelName, defaultClientOptions, resolveLlmClient, systemPrompt, logInferenceToFile, experimental, onMetrics){
        this.llmClient = llmClient;
        this.defaultModelName = defaultModelName;
        this.defaultClientOptions = defaultClientOptions;
        this.resolveLlmClient = resolveLlmClient;
        this.systemPrompt = systemPrompt != null ? systemPrompt : "";
        this.logInferenceToFile = logInferenceToFile != null ? logInferenceToFile : false;
        this.experimental = experimental != null ? experimental : false;
        this.onMetrics = onMetrics;
    }
    observe(params) {
        return __async(this, null, function*() {
            const { instruction, page, timeout, selector, model } = params;
            const llmClient = this.resolveLlmClient(model);
            const effectiveInstruction = instruction != null ? instruction : "Find elements that can be used for any future actions in the page. These may be navigation links, related pages, section/subsection links, buttons, or other interactive elements. Be comprehensive: if there are multiple elements that may be relevant for future actions, return all of them.";
            const doObserve = ()=>__async(this, null, function*() {
                    var _a, _b, _c;
                    v3Logger({
                        category: "observation",
                        message: "starting observation",
                        level: 1,
                        auxiliary: {
                            instruction: {
                                value: effectiveInstruction,
                                type: "string"
                            }
                        }
                    });
                    const focusSelector = (_a = selector == null ? void 0 : selector.replace(/^xpath=/i, "")) != null ? _a : "";
                    const snapshot = yield captureHybridSnapshot(page, {
                        experimental: this.experimental,
                        focusSelector: focusSelector || void 0
                    });
                    const combinedTree = snapshot.combinedTree;
                    const combinedXpathMap = (_b = snapshot.combinedXpathMap) != null ? _b : {};
                    v3Logger({
                        category: "observation",
                        message: "Got accessibility tree data",
                        level: 1
                    });
                    const observationResponse = yield observe({
                        instruction: effectiveInstruction,
                        domElements: combinedTree,
                        llmClient,
                        userProvidedInstructions: this.systemPrompt,
                        logger: v3Logger,
                        logInferenceToFile: this.logInferenceToFile
                    });
                    const { prompt_tokens = 0, completion_tokens = 0, reasoning_tokens = 0, cached_input_tokens = 0, inference_time_ms = 0 } = observationResponse;
                    (_c = this.onMetrics) == null ? void 0 : _c.call(this, "OBSERVE" /* OBSERVE */ , prompt_tokens, completion_tokens, reasoning_tokens, cached_input_tokens, inference_time_ms);
                    const elementsWithSelectors = (yield Promise.all(observationResponse.elements.map((element)=>__async(this, null, function*() {
                            const _a2 = element, { elementId } = _a2, rest = __objRest(_a2, [
                                "elementId"
                            ]);
                            if (typeof elementId === "string" && elementId.includes("-")) {
                                const lookUpIndex = elementId;
                                const xpath = combinedXpathMap[lookUpIndex];
                                const trimmedXpath = trimTrailingTextNode(xpath);
                                if (!trimmedXpath) return void 0;
                                return __spreadProps(__spreadValues({}, rest), {
                                    // if method/arguments exist, theyre preserved; otherwise theyre absent
                                    selector: `xpath=${trimmedXpath}`
                                });
                            }
                            return {
                                description: "an element inside a shadow DOM",
                                method: "not-supported",
                                arguments: [],
                                selector: "not-supported"
                            };
                        })))).filter((e)=>e !== void 0);
                    v3Logger({
                        category: "observation",
                        message: "found elements",
                        level: 1,
                        auxiliary: {
                            elements: {
                                value: JSON.stringify(elementsWithSelectors),
                                type: "object"
                            }
                        }
                    });
                    return elementsWithSelectors;
                });
            if (!timeout) return doObserve();
            return yield Promise.race([
                doObserve(),
                new Promise((_, reject)=>{
                    setTimeout(()=>reject(new Error(`observe() timed out after ${timeout}ms`)), timeout);
                })
            ]);
        });
    }
};
// lib/v3/agent/tools/v3-goto.ts
var import_ai = __turbopack_context__.r("[project]/node_modules/ai/dist/index.js [app-route] (ecmascript)");
var import_v35 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/index.js [app-route] (ecmascript)");
var createGotoTool = (v3)=>(0, import_ai.tool)({
        description: "Navigate to a specific URL",
        inputSchema: import_v35.z.object({
            url: import_v35.z.string().describe("The URL to navigate to")
        }),
        execute: (_0)=>__async(null, [
                _0
            ], function*({ url }) {
                var _a;
                try {
                    v3.logger({
                        category: "agent",
                        message: `Agent calling tool: goto`,
                        level: 1,
                        auxiliary: {
                            arguments: {
                                value: url,
                                type: "string"
                            }
                        }
                    });
                    const page = yield v3.context.awaitActivePage();
                    yield page.goto(url, {
                        waitUntil: "load"
                    });
                    v3.recordAgentReplayStep({
                        type: "goto",
                        url,
                        waitUntil: "load"
                    });
                    return {
                        success: true,
                        url
                    };
                } catch (error) {
                    return {
                        success: false,
                        error: (_a = error == null ? void 0 : error.message) != null ? _a : String(error)
                    };
                }
            })
    });
// lib/v3/agent/tools/v3-act.ts
var import_ai2 = __turbopack_context__.r("[project]/node_modules/ai/dist/index.js [app-route] (ecmascript)");
var import_v36 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/index.js [app-route] (ecmascript)");
var createActTool = (v3, executionModel)=>(0, import_ai2.tool)({
        description: "Perform an action on the page (click, type). Provide a short, specific phrase that mentions the element type.",
        inputSchema: import_v36.z.object({
            action: import_v36.z.string().describe('Describe what to click or type, e.g. "click the Login button" or "type "John" into the first name input"')
        }),
        execute: (_0)=>__async(null, [
                _0
            ], function*({ action }) {
                var _a, _b, _c, _d;
                try {
                    v3.logger({
                        category: "agent",
                        message: `Agent calling tool: act`,
                        level: 1,
                        auxiliary: {
                            arguments: {
                                value: action,
                                type: "string"
                            }
                        }
                    });
                    const options = executionModel ? {
                        model: executionModel
                    } : void 0;
                    const result = yield v3.act(action, options);
                    const actions = (_a = result.actions) != null ? _a : [];
                    v3.recordAgentReplayStep({
                        type: "act",
                        instruction: action,
                        actions,
                        actionDescription: result.actionDescription,
                        message: result.message
                    });
                    return {
                        success: (_b = result.success) != null ? _b : true,
                        action: (_c = result == null ? void 0 : result.actionDescription) != null ? _c : action,
                        playwrightArguments: actions.length > 0 ? actions[0] : void 0
                    };
                } catch (error) {
                    return {
                        success: false,
                        error: (_d = error == null ? void 0 : error.message) != null ? _d : String(error)
                    };
                }
            })
    });
// lib/v3/agent/tools/v3-screenshot.ts
var import_ai3 = __turbopack_context__.r("[project]/node_modules/ai/dist/index.js [app-route] (ecmascript)");
var import_v37 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/index.js [app-route] (ecmascript)");
var createScreenshotTool = (v3)=>(0, import_ai3.tool)({
        description: "Takes a screenshot (PNG) of the current page. Use this to quickly verify page state.",
        inputSchema: import_v37.z.object({}),
        execute: ()=>__async(null, null, function*() {
                v3.logger({
                    category: "agent",
                    message: `Agent calling tool: screenshot`,
                    level: 1
                });
                const page = yield v3.context.awaitActivePage();
                const buffer = yield page.screenshot({
                    fullPage: false
                });
                const pageUrl = page.url();
                return {
                    base64: buffer.toString("base64"),
                    timestamp: Date.now(),
                    pageUrl
                };
            }),
        toModelOutput: (result)=>({
                type: "content",
                value: [
                    {
                        type: "media",
                        mediaType: "image/png",
                        data: result.base64
                    }
                ]
            })
    });
// lib/v3/agent/tools/v3-wait.ts
var import_ai4 = __turbopack_context__.r("[project]/node_modules/ai/dist/index.js [app-route] (ecmascript)");
var import_v38 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/index.js [app-route] (ecmascript)");
var createWaitTool = (v3)=>(0, import_ai4.tool)({
        description: "Wait for a specified time",
        inputSchema: import_v38.z.object({
            timeMs: import_v38.z.number().describe("Time in milliseconds")
        }),
        execute: (_0)=>__async(null, [
                _0
            ], function*({ timeMs }) {
                v3.logger({
                    category: "agent",
                    message: `Agent calling tool: wait`,
                    level: 1,
                    auxiliary: {
                        arguments: {
                            value: `Waiting for ${timeMs} milliseconds`,
                            type: "string"
                        }
                    }
                });
                yield new Promise((resolve2)=>setTimeout(resolve2, timeMs));
                if (timeMs > 0) {
                    v3.recordAgentReplayStep({
                        type: "wait",
                        timeMs
                    });
                }
                return {
                    success: true,
                    waited: timeMs
                };
            })
    });
// lib/v3/agent/tools/v3-navback.ts
var import_ai5 = __turbopack_context__.r("[project]/node_modules/ai/dist/index.js [app-route] (ecmascript)");
var import_v39 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/index.js [app-route] (ecmascript)");
var createNavBackTool = (v3)=>(0, import_ai5.tool)({
        description: "Navigate back to the previous page",
        inputSchema: import_v39.z.object({
            reasoningText: import_v39.z.string().describe("Why you're going back")
        }),
        execute: ()=>__async(null, null, function*() {
                v3.logger({
                    category: "agent",
                    message: `Agent calling tool: navback`,
                    level: 1
                });
                const page = yield v3.context.awaitActivePage();
                yield page.goBack({
                    waitUntil: "domcontentloaded"
                });
                v3.recordAgentReplayStep({
                    type: "navback",
                    waitUntil: "domcontentloaded"
                });
                return {
                    success: true
                };
            })
    });
// lib/v3/agent/tools/v3-close.ts
var import_ai6 = __turbopack_context__.r("[project]/node_modules/ai/dist/index.js [app-route] (ecmascript)");
var import_v310 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/index.js [app-route] (ecmascript)");
var createCloseTool = ()=>(0, import_ai6.tool)({
        description: "Complete the task and close",
        inputSchema: import_v310.z.object({
            reasoning: import_v310.z.string().describe("Summary of what was accomplished"),
            taskComplete: import_v310.z.boolean().describe("Whether the task was completed successfully")
        }),
        execute: (_0)=>__async(null, [
                _0
            ], function*({ reasoning, taskComplete }) {
                return {
                    success: true,
                    reasoning,
                    taskComplete
                };
            })
    });
// lib/v3/agent/tools/v3-ariaTree.ts
var import_ai7 = __turbopack_context__.r("[project]/node_modules/ai/dist/index.js [app-route] (ecmascript)");
var import_v311 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/index.js [app-route] (ecmascript)");
var createAriaTreeTool = (v3)=>(0, import_ai7.tool)({
        description: "gets the accessibility (ARIA) hybrid tree text for the current page. use this to understand structure and content.",
        inputSchema: import_v311.z.object({}),
        execute: ()=>__async(null, null, function*() {
                v3.logger({
                    category: "agent",
                    message: `Agent calling tool: ariaTree`,
                    level: 1
                });
                const page = yield v3.context.awaitActivePage();
                const { pageText } = yield v3.extract();
                const pageUrl = page.url();
                let content = pageText;
                const MAX_TOKENS = 7e4;
                const estimatedTokens = Math.ceil(content.length / 4);
                if (estimatedTokens > MAX_TOKENS) {
                    const maxChars = MAX_TOKENS * 4;
                    content = content.substring(0, maxChars) + "\n\n[CONTENT TRUNCATED: Exceeded 70,000 token limit]";
                }
                return {
                    content,
                    pageUrl
                };
            }),
        toModelOutput: (result)=>({
                type: "content",
                value: [
                    {
                        type: "text",
                        text: `Accessibility Tree:
${result.content}`
                    }
                ]
            })
    });
// lib/v3/agent/tools/v3-fillform.ts
var import_ai8 = __turbopack_context__.r("[project]/node_modules/ai/dist/index.js [app-route] (ecmascript)");
var import_v312 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/index.js [app-route] (ecmascript)");
var createFillFormTool = (v3, executionModel)=>(0, import_ai8.tool)({
        description: `\u{1F4DD} FORM FILL - MULTI-FIELD INPUT TOOL
For any form with 2+ inputs/textareas. Faster than individual typing.`,
        inputSchema: import_v312.z.object({
            fields: import_v312.z.array(import_v312.z.object({
                action: import_v312.z.string().describe('Description of typing action, e.g. "type foo into the email field"'),
                value: import_v312.z.string().describe("Text to type into the target")
            })).min(1, "Provide at least one field to fill")
        }),
        execute: (_0)=>__async(null, [
                _0
            ], function*({ fields }) {
                v3.logger({
                    category: "agent",
                    message: `Agent calling tool: fillForm`,
                    level: 1,
                    auxiliary: {
                        arguments: {
                            value: JSON.stringify(fields),
                            type: "object"
                        }
                    }
                });
                const instruction = `Return observation results for the following actions: ${fields.map((f)=>f.action).join(", ")}`;
                const observeOptions = executionModel ? {
                    model: executionModel
                } : void 0;
                const observeResults = yield v3.observe(instruction, observeOptions);
                const completed = [];
                const replayableActions = [];
                for (const res of observeResults){
                    const actResult = yield v3.act(res);
                    completed.push(actResult);
                    if (Array.isArray(actResult.actions)) {
                        replayableActions.push(...actResult.actions);
                    }
                }
                v3.recordAgentReplayStep({
                    type: "fillForm",
                    fields,
                    observeResults,
                    actions: replayableActions
                });
                return {
                    success: true,
                    actions: completed,
                    playwrightArguments: replayableActions
                };
            })
    });
// lib/v3/agent/tools/v3-scroll.ts
var import_ai9 = __turbopack_context__.r("[project]/node_modules/ai/dist/index.js [app-route] (ecmascript)");
var import_v313 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/index.js [app-route] (ecmascript)");
var createScrollTool = (v3)=>(0, import_ai9.tool)({
        description: "Scroll the page",
        inputSchema: import_v313.z.object({
            pixels: import_v313.z.number().describe("Number of pixels to scroll up or down"),
            direction: import_v313.z.enum([
                "up",
                "down"
            ]).describe("Direction to scroll")
        }),
        execute: (_0)=>__async(null, [
                _0
            ], function*({ pixels, direction }) {
                v3.logger({
                    category: "agent",
                    message: `Agent calling tool: scroll`,
                    level: 1,
                    auxiliary: {
                        arguments: {
                            value: JSON.stringify({
                                pixels,
                                direction
                            }),
                            type: "object"
                        }
                    }
                });
                const page = yield v3.context.awaitActivePage();
                const { w, h } = yield page.mainFrame().evaluate("({ w: window.innerWidth, h: window.innerHeight })");
                const cx = Math.max(0, Math.floor(w / 2));
                const cy = Math.max(0, Math.floor(h / 2));
                const deltaY = direction === "up" ? -Math.abs(pixels) : Math.abs(pixels);
                yield page.scroll(cx, cy, 0, deltaY);
                v3.recordAgentReplayStep({
                    type: "scroll",
                    deltaX: 0,
                    deltaY,
                    anchor: {
                        x: cx,
                        y: cy
                    }
                });
                return {
                    success: true,
                    pixels
                };
            })
    });
// lib/v3/agent/tools/v3-extract.ts
var import_ai10 = __turbopack_context__.r("[project]/node_modules/ai/dist/index.js [app-route] (ecmascript)");
var import_v314 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/index.js [app-route] (ecmascript)");
function evaluateZodSchema(schemaStr, logger) {
    var _a;
    try {
        const fn = new Function("z", `return ${schemaStr}`);
        return fn(import_v314.z);
    } catch (e) {
        logger == null ? void 0 : logger({
            category: "agent",
            message: `Failed to evaluate schema: ${(_a = e == null ? void 0 : e.message) != null ? _a : String(e)}`,
            level: 0
        });
        return import_v314.z.any();
    }
}
var createExtractTool = (v3, executionModel, logger)=>(0, import_ai10.tool)({
        description: `Extract structured data from the current page based on a provided schema.
    
    USAGE GUIDELINES:
    - Keep schemas MINIMAL - only include fields essential for the task
    - IMPORANT: only use this if explicitly asked for structured output. In most scenarios, you should use the aria tree tool over this. 
    - If you need to extract a link, make sure the type defintion follows the format of z.string().url()
    EXAMPLES:
    1. Extract a single value:
       instruction: "extract the product price"
       schema: "z.object({ price: z.number()})"
    
    2. Extract multiple fields:
       instruction: "extract product name and price"
       schema: "z.object({ name: z.string(), price: z.number() })"
    
    3. Extract arrays:
       instruction: "extract all product names and prices"
       schema: "z.object({ products: z.array(z.object({ name: z.string(), price: z.number() })) })"`,
        inputSchema: import_v314.z.object({
            instruction: import_v314.z.string(),
            schema: import_v314.z.string().optional().describe("Zod schema as code, e.g. z.object({ title: z.string() })")
        }),
        execute: (_0)=>__async(null, [
                _0
            ], function*({ instruction, schema }) {
                var _a;
                try {
                    const parsedSchema = schema ? evaluateZodSchema(schema, logger) : void 0;
                    const result = yield v3.extract(instruction, parsedSchema, __spreadValues({}, executionModel ? {
                        model: executionModel
                    } : {}));
                    return {
                        success: true,
                        result
                    };
                } catch (error) {
                    return {
                        success: false,
                        error: (_a = error == null ? void 0 : error.message) != null ? _a : String(error)
                    };
                }
            })
    });
// lib/v3/agent/tools/index.ts
function createAgentTools(v3, options) {
    const executionModel = options == null ? void 0 : options.executionModel;
    return {
        act: createActTool(v3, executionModel),
        ariaTree: createAriaTreeTool(v3),
        close: createCloseTool(),
        extract: createExtractTool(v3, executionModel, options == null ? void 0 : options.logger),
        fillForm: createFillFormTool(v3, executionModel),
        goto: createGotoTool(v3),
        navback: createNavBackTool(v3),
        screenshot: createScreenshotTool(v3),
        scroll: createScrollTool(v3),
        wait: createWaitTool(v3)
    };
}
// lib/v3/handlers/v3AgentHandler.ts
var import_ai11 = __turbopack_context__.r("[project]/node_modules/ai/dist/index.js [app-route] (ecmascript)");
// lib/v3/agent/utils/messageProcessing.ts
function isToolMessage(message) {
    return !!message && typeof message === "object" && message.role === "tool" && Array.isArray(message.content);
}
function isScreenshotPart(part) {
    return !!part && typeof part === "object" && part.toolName === "screenshot";
}
function isAriaTreePart(part) {
    return !!part && typeof part === "object" && part.toolName === "ariaTree";
}
function processMessages(params) {
    const originalContentSize = JSON.stringify(params.prompt).length;
    const screenshotIndices = findToolIndices(params.prompt, "screenshot");
    const ariaTreeIndices = findToolIndices(params.prompt, "ariaTree");
    const processedPrompt = params.prompt.map((message, index)=>{
        if (isToolMessage(message)) {
            if (message.content.some((part)=>isScreenshotPart(part))) {
                const shouldCompress = shouldCompressScreenshot(index, screenshotIndices);
                if (shouldCompress) {
                    return compressScreenshotMessage(message);
                }
            }
            if (message.content.some((part)=>isAriaTreePart(part))) {
                const shouldCompress = shouldCompressAriaTree(index, ariaTreeIndices);
                if (shouldCompress) {
                    return compressAriaTreeMessage(message);
                }
            }
        }
        return message;
    });
    const compressedContentSize = JSON.stringify(processedPrompt).length;
    const stats = calculateCompressionStats(originalContentSize, compressedContentSize, screenshotIndices.length, ariaTreeIndices.length);
    return {
        processedPrompt,
        stats
    };
}
function findToolIndices(prompt, toolName) {
    const screenshotIndices = [];
    prompt.forEach((message, index)=>{
        if (isToolMessage(message)) {
            const hasMatch = message.content.some((part)=>toolName === "screenshot" ? isScreenshotPart(part) : isAriaTreePart(part));
            if (hasMatch) {
                screenshotIndices.push(index);
            }
        }
    });
    return screenshotIndices;
}
function shouldCompressScreenshot(index, screenshotIndices) {
    const isNewestScreenshot = index === Math.max(...screenshotIndices);
    const isSecondNewestScreenshot = screenshotIndices.length > 1 && index === screenshotIndices.sort((a, b)=>b - a)[1];
    return !isNewestScreenshot && !isSecondNewestScreenshot;
}
function shouldCompressAriaTree(index, ariaTreeIndices) {
    const isNewestAriaTree = index === Math.max(...ariaTreeIndices);
    return !isNewestAriaTree;
}
function compressScreenshotMessage(message) {
    const updatedContent = message.content.map((part)=>{
        if (isScreenshotPart(part)) {
            return __spreadProps(__spreadValues({}, part), {
                result: [
                    {
                        type: "text",
                        text: "screenshot taken"
                    }
                ]
            });
        }
        return part;
    });
    return __spreadProps(__spreadValues({}, message), {
        content: updatedContent
    });
}
function compressAriaTreeMessage(message) {
    const updatedContent = message.content.map((part)=>{
        if (isAriaTreePart(part)) {
            return __spreadProps(__spreadValues({}, part), {
                result: [
                    {
                        type: "text",
                        text: "ARIA tree extracted for context of page elements"
                    }
                ]
            });
        }
        return part;
    });
    return __spreadProps(__spreadValues({}, message), {
        content: updatedContent
    });
}
function calculateCompressionStats(originalSize, compressedSize, screenshotCount, ariaTreeCount) {
    const savedChars = originalSize - compressedSize;
    const compressionRatio = originalSize > 0 ? (originalSize - compressedSize) / originalSize * 100 : 0;
    return {
        originalSize,
        compressedSize,
        savedChars,
        compressionRatio,
        screenshotCount,
        ariaTreeCount
    };
}
// lib/v3/agent/utils/actionMapping.ts
function mapToolResultToActions({ toolCallName, toolResult, args, reasoning }) {
    switch(toolCallName){
        case "act":
            return mapActToolResult(toolResult, args, reasoning);
        case "fillForm":
            return mapFillFormToolResult(toolResult, args, reasoning);
        default:
            return [
                createStandardAction(toolCallName, toolResult, args, reasoning)
            ];
    }
}
function mapActToolResult(toolResult, args, reasoning) {
    if (!toolResult || typeof toolResult !== "object") {
        return [
            createStandardAction("act", toolResult, args, reasoning)
        ];
    }
    const result = toolResult;
    const output = result.output || result;
    const action = __spreadValues({
        type: "act",
        reasoning,
        taskCompleted: false
    }, args);
    if (output.playwrightArguments) {
        action.playwrightArguments = output.playwrightArguments;
    }
    return [
        action
    ];
}
function mapFillFormToolResult(toolResult, args, reasoning) {
    if (!toolResult || typeof toolResult !== "object") {
        return [
            createStandardAction("fillForm", toolResult, args, reasoning)
        ];
    }
    const result = toolResult;
    const output = result.output || result;
    const observeResults = Array.isArray(output == null ? void 0 : output.playwrightArguments) ? output.playwrightArguments : [];
    const actions = [];
    actions.push(__spreadValues({
        type: "fillForm",
        reasoning,
        taskCompleted: false
    }, args));
    for (const observeResult of observeResults){
        actions.push({
            type: "act",
            reasoning: "acting from fillform tool",
            taskCompleted: false,
            playwrightArguments: observeResult
        });
    }
    return actions;
}
function createStandardAction(toolCallName, toolResult, args, reasoning) {
    const action = __spreadValues({
        type: toolCallName,
        reasoning,
        taskCompleted: toolCallName === "close" ? args == null ? void 0 : args.taskComplete : false
    }, args);
    if (toolCallName !== "ariaTree" && toolResult) {
        const { output } = toolResult;
        Object.assign(action, output);
    }
    return action;
}
// lib/v3/handlers/v3AgentHandler.ts
init_sdkErrors();
var V3AgentHandler = class {
    constructor(v3, logger, llmClient, executionModel, systemInstructions, mcpTools){
        this.v3 = v3;
        this.logger = logger;
        this.llmClient = llmClient;
        this.executionModel = executionModel;
        this.systemInstructions = systemInstructions;
        this.mcpTools = mcpTools;
    }
    execute(instructionOrOptions) {
        return __async(this, null, function*() {
            var _a, _b;
            const startTime = Date.now();
            const options = typeof instructionOrOptions === "string" ? {
                instruction: instructionOrOptions
            } : instructionOrOptions;
            const maxSteps = options.maxSteps || 10;
            const actions = [];
            let finalMessage = "";
            let completed = false;
            const collectedReasoning = [];
            let currentPageUrl = (yield this.v3.context.awaitActivePage()).url();
            try {
                const systemPrompt = this.buildSystemPrompt(options.instruction, this.systemInstructions);
                const tools = this.createTools();
                const allTools = __spreadValues(__spreadValues({}, tools), this.mcpTools);
                const messages = [
                    {
                        role: "user",
                        content: options.instruction
                    }
                ];
                if (!((_a = this.llmClient) == null ? void 0 : _a.getLanguageModel)) {
                    throw new MissingLLMConfigurationError();
                }
                const baseModel = this.llmClient.getLanguageModel();
                const wrappedModel = (0, import_ai11.wrapLanguageModel)({
                    model: baseModel,
                    middleware: {
                        transformParams: (_0)=>__async(this, [
                                _0
                            ], function*({ params }) {
                                const { processedPrompt } = processMessages(params);
                                return __spreadProps(__spreadValues({}, params), {
                                    prompt: processedPrompt
                                });
                            })
                    }
                });
                const result = yield this.llmClient.generateText({
                    model: wrappedModel,
                    system: systemPrompt,
                    messages,
                    tools: allTools,
                    stopWhen: (0, import_ai11.stepCountIs)(maxSteps),
                    temperature: 1,
                    toolChoice: "auto",
                    onStepFinish: (event)=>__async(this, null, function*() {
                            var _a2;
                            this.logger({
                                category: "agent",
                                message: `Step finished: ${event.finishReason}`,
                                level: 2
                            });
                            if (event.toolCalls && event.toolCalls.length > 0) {
                                for(let i = 0; i < event.toolCalls.length; i++){
                                    const toolCall = event.toolCalls[i];
                                    const args = toolCall.input;
                                    const toolResult = (_a2 = event.toolResults) == null ? void 0 : _a2[i];
                                    if (event.text.length > 0) {
                                        collectedReasoning.push(event.text);
                                        this.logger({
                                            category: "agent",
                                            message: `reasoning: ${event.text}`,
                                            level: 1
                                        });
                                    }
                                    if (toolCall.toolName === "close") {
                                        completed = true;
                                        if (args == null ? void 0 : args.taskComplete) {
                                            const closeReasoning = args.reasoning;
                                            const allReasoning = collectedReasoning.join(" ");
                                            finalMessage = closeReasoning ? `${allReasoning} ${closeReasoning}`.trim() : allReasoning || "Task completed successfully";
                                        }
                                    }
                                    const mappedActions = mapToolResultToActions({
                                        toolCallName: toolCall.toolName,
                                        toolResult,
                                        args,
                                        reasoning: event.text || void 0
                                    });
                                    for (const action of mappedActions){
                                        action.pageUrl = currentPageUrl;
                                        action.timestamp = Date.now();
                                        actions.push(action);
                                    }
                                }
                                currentPageUrl = (yield this.v3.context.awaitActivePage()).url();
                            }
                        })
                });
                if (!finalMessage) {
                    const allReasoning = collectedReasoning.join(" ").trim();
                    finalMessage = allReasoning || result.text;
                }
                const endTime = Date.now();
                const inferenceTimeMs = endTime - startTime;
                if (result.usage) {
                    this.v3.updateMetrics("AGENT" /* AGENT */ , result.usage.inputTokens || 0, result.usage.outputTokens || 0, result.usage.reasoningTokens || 0, result.usage.cachedInputTokens || 0, inferenceTimeMs);
                }
                return {
                    success: completed,
                    message: finalMessage || "Task execution completed",
                    actions,
                    completed,
                    usage: result.usage ? {
                        input_tokens: result.usage.inputTokens || 0,
                        output_tokens: result.usage.outputTokens || 0,
                        reasoning_tokens: result.usage.reasoningTokens || 0,
                        cached_input_tokens: result.usage.cachedInputTokens || 0,
                        inference_time_ms: inferenceTimeMs
                    } : void 0
                };
            } catch (error) {
                const errorMessage = (_b = error == null ? void 0 : error.message) != null ? _b : String(error);
                this.logger({
                    category: "agent",
                    message: `Error executing agent task: ${errorMessage}`,
                    level: 0
                });
                return {
                    success: false,
                    actions,
                    message: `Failed to execute task: ${errorMessage}`,
                    completed: false
                };
            }
        });
    }
    buildSystemPrompt(executionInstruction, systemInstructions) {
        if (systemInstructions) {
            return `${systemInstructions}
Your current goal: ${executionInstruction} when the task is complete, use the "close" tool with taskComplete: true`;
        }
        return `You are a web automation assistant using browser automation tools to accomplish the user's goal.

Your task: ${executionInstruction}

You have access to various browser automation tools. Use them step by step to complete the task.

IMPORTANT GUIDELINES:
1. Always start by understanding the current page state
2. Use the screenshot tool to verify page state when needed
3. Use appropriate tools for each action
4. When the task is complete, use the "close" tool with taskComplete: true
5. If the task cannot be completed, use "close" with taskComplete: false

TOOLS OVERVIEW:
- screenshot: Take a PNG screenshot for quick visual context (use sparingly)
- ariaTree: Get an accessibility (ARIA) hybrid tree for full page context
- act: Perform a specific atomic action (click, type, etc.)
- extract: Extract structured data
- goto: Navigate to a URL
- wait/navback/refresh: Control timing and navigation
- scroll: Scroll the page x pixels up or down

STRATEGY:
- Prefer ariaTree to understand the page before acting; use screenshot for confirmation.
- Keep actions atomic and verify outcomes before proceeding.`;
    }
    createTools() {
        return createAgentTools(this.v3, {
            executionModel: this.executionModel,
            logger: this.logger
        });
    }
};
// lib/v3/handlers/v3CuaAgentHandler.ts
init_snapshot();
// lib/v3/agent/AgentProvider.ts
init_sdkErrors();
// lib/v3/agent/AnthropicCUAClient.ts
init_sdkErrors();
var import_sdk = __toESM(__turbopack_context__.r("[project]/node_modules/@anthropic-ai/sdk/index.js [app-route] (ecmascript)"));
var import_zod_to_json_schema = __turbopack_context__.r("[project]/node_modules/zod-to-json-schema/dist/cjs/index.js [app-route] (ecmascript)");
// lib/v3/agent/AgentClient.ts
var AgentClient = class {
    constructor(type, modelName, userProvidedInstructions){
        this.type = type;
        this.modelName = modelName;
        this.userProvidedInstructions = userProvidedInstructions;
        this.clientOptions = {};
    }
};
// lib/v3/agent/utils/cuaKeyMapping.ts
var KEY_MAP = {
    ENTER: "Enter",
    RETURN: "Enter",
    ESCAPE: "Escape",
    ESC: "Escape",
    BACKSPACE: "Backspace",
    TAB: "Tab",
    SPACE: " ",
    DELETE: "Delete",
    DEL: "Delete",
    ARROWUP: "ArrowUp",
    ARROWDOWN: "ArrowDown",
    ARROWLEFT: "ArrowLeft",
    ARROWRIGHT: "ArrowRight",
    ARROW_UP: "ArrowUp",
    ARROW_DOWN: "ArrowDown",
    ARROW_LEFT: "ArrowLeft",
    ARROW_RIGHT: "ArrowRight",
    UP: "ArrowUp",
    DOWN: "ArrowDown",
    LEFT: "ArrowLeft",
    RIGHT: "ArrowRight",
    SHIFT: "Shift",
    CONTROL: "Control",
    CTRL: "Control",
    ALT: "Alt",
    OPTION: "Alt",
    // macOS alternative name
    META: "Meta",
    COMMAND: "Meta",
    // macOS
    CMD: "Meta",
    // macOS shorthand
    SUPER: "Meta",
    // Linux
    WINDOWS: "Meta",
    // Windows
    WIN: "Meta",
    // Windows shorthand
    HOME: "Home",
    END: "End",
    PAGEUP: "PageUp",
    PAGEDOWN: "PageDown",
    PAGE_UP: "PageUp",
    PAGE_DOWN: "PageDown",
    PGUP: "PageUp",
    PGDN: "PageDown"
};
function mapKeyToPlaywright(key) {
    if (!key) return key;
    const upperKey = key.toUpperCase();
    return KEY_MAP[upperKey] || key;
}
// lib/v3/agent/utils/imageCompression.ts
function findItemsWithImages(items) {
    const itemsWithImages = [];
    items.forEach((item, index)=>{
        let hasImage = false;
        if (Array.isArray(item.content)) {
            hasImage = item.content.some((contentItem)=>contentItem.type === "tool_result" && "content" in contentItem && Array.isArray(contentItem.content) && contentItem.content.some((nestedItem)=>nestedItem.type === "image"));
        }
        if (hasImage) {
            itemsWithImages.push(index);
        }
    });
    return itemsWithImages;
}
function compressConversationImages(items, keepMostRecentCount = 2) {
    const itemsWithImages = findItemsWithImages(items);
    items.forEach((item, index)=>{
        const imageIndex = itemsWithImages.indexOf(index);
        const shouldCompress = imageIndex >= 0 && imageIndex < itemsWithImages.length - keepMostRecentCount;
        if (shouldCompress) {
            if (Array.isArray(item.content)) {
                item.content = item.content.map((contentItem)=>{
                    if (contentItem.type === "tool_result" && "content" in contentItem && Array.isArray(contentItem.content) && contentItem.content.some((nestedItem)=>nestedItem.type === "image")) {
                        return __spreadProps(__spreadValues({}, contentItem), {
                            content: "screenshot taken"
                        });
                    }
                    return contentItem;
                });
            }
        }
    });
    return {
        items
    };
}
function findGoogleItemsWithImages(items) {
    const itemsWithImages = [];
    items.forEach((item, index)=>{
        let hasImage = false;
        if (item.parts && Array.isArray(item.parts)) {
            hasImage = item.parts.some((part)=>{
                var _a, _b, _c, _d, _e;
                if ((_b = (_a = part.functionResponse) == null ? void 0 : _a.response) == null ? void 0 : _b.data) {
                    const data = part.functionResponse.response.data;
                    return data.some((dataItem)=>{
                        var _a2, _b2;
                        return (_b2 = (_a2 = dataItem.inlineData) == null ? void 0 : _a2.mimeType) == null ? void 0 : _b2.startsWith("image/");
                    });
                }
                if ((_c = part.functionResponse) == null ? void 0 : _c.parts) {
                    return part.functionResponse.parts.some((responsePart)=>{
                        var _a2, _b2;
                        return (_b2 = (_a2 = responsePart.inlineData) == null ? void 0 : _a2.mimeType) == null ? void 0 : _b2.startsWith("image/");
                    });
                }
                return (_e = (_d = part.inlineData) == null ? void 0 : _d.mimeType) == null ? void 0 : _e.startsWith("image/");
            });
        }
        if (hasImage) {
            itemsWithImages.push(index);
        }
    });
    return itemsWithImages;
}
function compressGoogleConversationImages(items, keepMostRecentCount = 2) {
    const itemsWithImages = findGoogleItemsWithImages(items);
    items.forEach((item, index)=>{
        const imageIndex = itemsWithImages.indexOf(index);
        const shouldCompress = imageIndex >= 0 && imageIndex < itemsWithImages.length - keepMostRecentCount;
        if (shouldCompress && item.parts && Array.isArray(item.parts)) {
            item.parts = item.parts.map((part)=>{
                var _a, _b, _c, _d, _e;
                if ((_b = (_a = part.functionResponse) == null ? void 0 : _a.response) == null ? void 0 : _b.data) {
                    const data = part.functionResponse.response.data;
                    const hasImage = data.some((dataItem)=>{
                        var _a2, _b2;
                        return (_b2 = (_a2 = dataItem.inlineData) == null ? void 0 : _a2.mimeType) == null ? void 0 : _b2.startsWith("image/");
                    });
                    if (hasImage) {
                        return __spreadProps(__spreadValues({}, part), {
                            functionResponse: __spreadProps(__spreadValues({}, part.functionResponse), {
                                data: [],
                                response: __spreadProps(__spreadValues({}, part.functionResponse.response), {
                                    compressed: "screenshot taken"
                                })
                            })
                        });
                    }
                }
                if ((_c = part.functionResponse) == null ? void 0 : _c.parts) {
                    const hasImageInParts = part.functionResponse.parts.some((responsePart)=>{
                        var _a2, _b2;
                        return (_b2 = (_a2 = responsePart.inlineData) == null ? void 0 : _a2.mimeType) == null ? void 0 : _b2.startsWith("image/");
                    });
                    if (hasImageInParts) {
                        return __spreadProps(__spreadValues({}, part), {
                            functionResponse: __spreadProps(__spreadValues({}, part.functionResponse), {
                                parts: part.functionResponse.parts.filter((responsePart)=>{
                                    var _a2, _b2;
                                    return !((_b2 = (_a2 = responsePart.inlineData) == null ? void 0 : _a2.mimeType) == null ? void 0 : _b2.startsWith("image/"));
                                }),
                                response: __spreadProps(__spreadValues({}, part.functionResponse.response), {
                                    compressed: "screenshot taken"
                                })
                            })
                        });
                    }
                }
                if ((_e = (_d = part.inlineData) == null ? void 0 : _d.mimeType) == null ? void 0 : _e.startsWith("image/")) {
                    return {
                        text: "screenshot taken"
                    };
                }
                return part;
            });
        }
    });
    return {
        items
    };
}
// lib/v3/agent/AnthropicCUAClient.ts
var AnthropicCUAClient = class extends AgentClient {
    constructor(type, modelName, userProvidedInstructions, clientOptions, tools){
        super(type, modelName, userProvidedInstructions);
        this.currentViewport = {
            width: 1288,
            height: 711
        };
        this.thinkingBudget = null;
        this.apiKey = (clientOptions == null ? void 0 : clientOptions.apiKey) || process.env.ANTHROPIC_API_KEY || "";
        this.baseURL = (clientOptions == null ? void 0 : clientOptions.baseURL) || void 0;
        if ((clientOptions == null ? void 0 : clientOptions.thinkingBudget) && typeof clientOptions.thinkingBudget === "number") {
            this.thinkingBudget = clientOptions.thinkingBudget;
        }
        this.clientOptions = {
            apiKey: this.apiKey
        };
        if (this.baseURL) {
            this.clientOptions.baseUrl = this.baseURL;
        }
        this.client = new import_sdk.default(this.clientOptions);
        this.tools = tools;
    }
    setViewport(width, height) {
        this.currentViewport = {
            width,
            height
        };
    }
    setCurrentUrl(url) {
        this.currentUrl = url;
    }
    setScreenshotProvider(provider) {
        this.screenshotProvider = provider;
    }
    setActionHandler(handler) {
        this.actionHandler = handler;
    }
    setTools(tools) {
        this.tools = tools;
    }
    /**
   * Execute a task with the Anthropic CUA
   * This is the main entry point for the agent
   * @implements AgentClient.execute
   */ execute(executionOptions) {
        return __async(this, null, function*() {
            const { options, logger } = executionOptions;
            const { instruction } = options;
            const maxSteps = options.maxSteps || 10;
            let currentStep = 0;
            let completed = false;
            const actions = [];
            const messageList = [];
            let finalMessage = "";
            let inputItems = this.createInitialInputItems(instruction);
            logger({
                category: "agent",
                message: `Starting Anthropic agent execution with instruction: ${instruction}`,
                level: 1
            });
            let totalInputTokens = 0;
            let totalOutputTokens = 0;
            let totalInferenceTime = 0;
            try {
                while(!completed && currentStep < maxSteps){
                    logger({
                        category: "agent",
                        message: `Executing step ${currentStep + 1}/${maxSteps}`,
                        level: 1
                    });
                    const result = yield this.executeStep(inputItems, logger);
                    totalInputTokens += result.usage.input_tokens;
                    totalOutputTokens += result.usage.output_tokens;
                    totalInferenceTime += result.usage.inference_time_ms;
                    if (result.actions.length > 0) {
                        logger({
                            category: "agent",
                            message: `Step ${currentStep + 1} performed ${result.actions.length} actions`,
                            level: 2
                        });
                        actions.push(...result.actions);
                    }
                    completed = result.completed;
                    if (!completed) {
                        inputItems = result.nextInputItems;
                    }
                    if (result.message) {
                        messageList.push(result.message);
                        finalMessage = result.message;
                    }
                    currentStep++;
                }
                logger({
                    category: "agent",
                    message: `Anthropic agent execution completed: ${completed}, with ${actions.length} total actions performed`,
                    level: 1
                });
                return {
                    success: completed,
                    actions,
                    message: finalMessage,
                    completed,
                    usage: {
                        input_tokens: totalInputTokens,
                        output_tokens: totalOutputTokens,
                        inference_time_ms: totalInferenceTime
                    }
                };
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                logger({
                    category: "agent",
                    message: `Error executing agent task: ${errorMessage}`,
                    level: 0
                });
                return {
                    success: false,
                    actions,
                    message: `Failed to execute task: ${errorMessage}`,
                    completed: false,
                    usage: {
                        input_tokens: totalInputTokens,
                        output_tokens: totalOutputTokens,
                        inference_time_ms: totalInferenceTime
                    }
                };
            }
        });
    }
    executeStep(inputItems, logger) {
        return __async(this, null, function*() {
            try {
                const result = yield this.getAction(inputItems);
                const content = result.content;
                const usage = {
                    input_tokens: result.usage.input_tokens,
                    output_tokens: result.usage.output_tokens,
                    inference_time_ms: result.usage.inference_time_ms
                };
                logger({
                    category: "agent",
                    message: `Received response with ${content.length} content blocks`,
                    level: 2
                });
                const stepActions = [];
                const toolUseItems = [];
                let message = "";
                for (const block of content){
                    logger({
                        category: "agent",
                        message: `Processing block type: ${block.type}, id: ${block.id || "unknown"}`,
                        level: 2
                    });
                    if (block.type === "tool_use") {
                        logger({
                            category: "agent",
                            message: `Found tool_use block: ${JSON.stringify(block)}`,
                            level: 2
                        });
                        const toolUseItem = block;
                        toolUseItems.push(toolUseItem);
                        logger({
                            category: "agent",
                            message: `Added tool_use item: ${toolUseItem.name}, action: ${JSON.stringify(toolUseItem.input)}`,
                            level: 2
                        });
                        const action = this.convertToolUseToAction(toolUseItem);
                        if (action) {
                            logger({
                                category: "agent",
                                message: `Created action from tool_use: ${toolUseItem.name}, action: ${action.type}`,
                                level: 2
                            });
                            stepActions.push(action);
                        } else if (this.tools && toolUseItem.name in this.tools) {
                            stepActions.push({
                                type: "custom_tool",
                                tool: toolUseItem.name,
                                input: toolUseItem.input
                            });
                        }
                    } else if (block.type === "text") {
                        const textBlock = block;
                        message += textBlock.text + "\n";
                        logger({
                            category: "agent",
                            message: `Found text block: ${textBlock.text}`,
                            level: 2
                        });
                    } else {
                        logger({
                            category: "agent",
                            message: `Found unknown block type: ${block.type}`,
                            level: 2
                        });
                    }
                }
                if (this.actionHandler && stepActions.length > 0) {
                    for (const action of stepActions){
                        try {
                            logger({
                                category: "agent",
                                message: `Executing action: ${action.type}`,
                                level: 1
                            });
                            yield this.actionHandler(action);
                        } catch (error) {
                            const errorMessage = error instanceof Error ? error.message : String(error);
                            logger({
                                category: "agent",
                                message: `Error executing action ${action.type}: ${errorMessage}`,
                                level: 0
                            });
                        }
                    }
                }
                const assistantMessage = {
                    role: "assistant",
                    content
                };
                const nextInputItems = [
                    ...inputItems
                ];
                compressConversationImages(nextInputItems);
                nextInputItems.push(assistantMessage);
                if (toolUseItems.length > 0) {
                    const toolResults = yield this.takeAction(toolUseItems, logger);
                    if (toolResults.length > 0) {
                        const userToolResultsMessage = {
                            role: "user",
                            content: toolResults
                        };
                        nextInputItems.push(userToolResultsMessage);
                    }
                }
                const completed = toolUseItems.length === 0;
                logger({
                    category: "agent",
                    message: `Step processed ${toolUseItems.length} tool use items, completed: ${completed}`,
                    level: 2
                });
                return {
                    actions: stepActions,
                    message: message.trim(),
                    completed,
                    nextInputItems,
                    usage
                };
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                logger({
                    category: "agent",
                    message: `Error executing step: ${errorMessage}`,
                    level: 0
                });
                throw error;
            }
        });
    }
    createInitialInputItems(instruction) {
        return [
            {
                role: "system",
                content: this.userProvidedInstructions
            },
            {
                role: "user",
                content: instruction
            }
        ];
    }
    getAction(inputItems) {
        return __async(this, null, function*() {
            try {
                const messages = [];
                for (const item of inputItems){
                    if ("role" in item) {
                        if (item.role !== "system") {
                            messages.push(item);
                        }
                    }
                }
                const thinking = this.thinkingBudget ? {
                    type: "enabled",
                    budget_tokens: this.thinkingBudget
                } : void 0;
                const requestParams = {
                    model: this.modelName,
                    max_tokens: 4096,
                    messages,
                    tools: [
                        {
                            type: "computer_20250124",
                            // Use the latest version for Claude 3.7 Sonnet
                            name: "computer",
                            display_width_px: this.currentViewport.width,
                            display_height_px: this.currentViewport.height,
                            display_number: 1
                        }
                    ],
                    betas: [
                        "computer-use-2025-01-24"
                    ]
                };
                if (this.tools && Object.keys(this.tools).length > 0) {
                    const customTools = Object.entries(this.tools).map(([name, tool12])=>{
                        const jsonSchema2 = (0, import_zod_to_json_schema.zodToJsonSchema)(tool12.inputSchema);
                        const inputSchema = {
                            type: "object",
                            properties: jsonSchema2.properties || {},
                            required: jsonSchema2.required || []
                        };
                        return {
                            name,
                            description: tool12.description,
                            input_schema: inputSchema
                        };
                    });
                    requestParams.tools = [
                        ...requestParams.tools,
                        ...customTools
                    ];
                }
                if (this.userProvidedInstructions) {
                    requestParams.system = this.userProvidedInstructions;
                }
                if (thinking) {
                    requestParams.thinking = thinking;
                }
                const startTime = Date.now();
                const response = yield this.client.beta.messages.create(requestParams);
                const endTime = Date.now();
                const elapsedMs = endTime - startTime;
                const usage = {
                    input_tokens: response.usage.input_tokens,
                    output_tokens: response.usage.output_tokens,
                    inference_time_ms: elapsedMs
                };
                this.lastMessageId = response.id;
                return {
                    // Cast the response content to our internal type
                    content: response.content,
                    id: response.id,
                    usage
                };
            } catch (error) {
                console.error("Error getting action from Anthropic:", error);
                throw error;
            }
        });
    }
    takeAction(toolUseItems, logger) {
        return __async(this, null, function*() {
            const toolResults = [];
            logger({
                category: "agent",
                message: `Taking action on ${toolUseItems.length} tool use items`,
                level: 2
            });
            for (const item of toolUseItems){
                try {
                    logger({
                        category: "agent",
                        message: `Processing tool use: ${item.name}, id: ${item.id}, action: ${JSON.stringify(item.input)}`,
                        level: 2
                    });
                    if (item.name === "computer") {
                        const action = item.input.action;
                        logger({
                            category: "agent",
                            message: `Computer action type: ${action}`,
                            level: 2
                        });
                        const screenshot = yield this.captureScreenshot();
                        logger({
                            category: "agent",
                            message: `Screenshot captured, length: ${screenshot.length}`,
                            level: 2
                        });
                        const imageContent = [
                            {
                                type: "image",
                                source: {
                                    type: "base64",
                                    media_type: "image/png",
                                    data: screenshot.replace(/^data:image\/png;base64,/, "")
                                }
                            }
                        ];
                        if (this.currentUrl) {
                            toolResults.push({
                                type: "tool_result",
                                tool_use_id: item.id,
                                content: [
                                    ...imageContent,
                                    {
                                        type: "text",
                                        text: `Current URL: ${this.currentUrl}`
                                    }
                                ]
                            });
                        } else {
                            toolResults.push({
                                type: "tool_result",
                                tool_use_id: item.id,
                                content: imageContent
                            });
                        }
                        logger({
                            category: "agent",
                            message: `Added computer tool result for tool_use_id: ${item.id}`,
                            level: 2
                        });
                    } else {
                        let toolResult = "Tool executed successfully";
                        if (this.tools && item.name in this.tools) {
                            try {
                                const tool12 = this.tools[item.name];
                                logger({
                                    category: "agent",
                                    message: `Executing tool call: ${item.name} with args: ${JSON.stringify(item.input)}`,
                                    level: 1
                                });
                                const result = yield tool12.execute(item.input, {
                                    toolCallId: item.id,
                                    messages: []
                                });
                                toolResult = JSON.stringify(result);
                                logger({
                                    category: "agent",
                                    message: `Tool ${item.name} completed successfully. Result: ${toolResult}`,
                                    level: 1
                                });
                            } catch (toolError) {
                                const errorMessage = toolError instanceof Error ? toolError.message : String(toolError);
                                toolResult = `Error executing tool: ${errorMessage}`;
                                logger({
                                    category: "agent",
                                    message: `Error executing tool ${item.name}: ${errorMessage}`,
                                    level: 0
                                });
                            }
                        }
                        toolResults.push({
                            type: "tool_result",
                            tool_use_id: item.id,
                            content: [
                                {
                                    type: "text",
                                    text: toolResult
                                }
                            ]
                        });
                        logger({
                            category: "agent",
                            message: `Added custom tool result for tool ${item.name}, tool_use_id: ${item.id}`,
                            level: 2
                        });
                    }
                } catch (error) {
                    const errorMessage = error instanceof Error ? error.message : String(error);
                    logger({
                        category: "agent",
                        message: `Error executing tool use: ${errorMessage}`,
                        level: 0
                    });
                    try {
                        if (item.name === "computer") {
                            const screenshot = yield this.captureScreenshot();
                            toolResults.push({
                                type: "tool_result",
                                tool_use_id: item.id,
                                content: [
                                    {
                                        type: "image",
                                        source: {
                                            type: "base64",
                                            media_type: "image/png",
                                            data: screenshot.replace(/^data:image\/png;base64,/, "")
                                        }
                                    },
                                    {
                                        type: "text",
                                        text: `Error: ${errorMessage}`
                                    }
                                ]
                            });
                            logger({
                                category: "agent",
                                message: `Added error tool result with screenshot for tool_use_id: ${item.id}`,
                                level: 1
                            });
                        } else {
                            toolResults.push({
                                type: "tool_result",
                                tool_use_id: item.id,
                                content: [
                                    {
                                        type: "text",
                                        text: `Error: ${errorMessage}`
                                    }
                                ]
                            });
                            logger({
                                category: "agent",
                                message: `Added error tool result for tool_use_id: ${item.id}`,
                                level: 1
                            });
                        }
                    } catch (screenshotError) {
                        logger({
                            category: "agent",
                            message: `Error capturing screenshot: ${String(screenshotError)}`,
                            level: 0
                        });
                        toolResults.push({
                            type: "tool_result",
                            tool_use_id: item.id,
                            content: [
                                {
                                    type: "text",
                                    text: `Error: ${errorMessage}`
                                }
                            ]
                        });
                        logger({
                            category: "agent",
                            message: `Added text error tool result for tool_use_id: ${item.id}`,
                            level: 1
                        });
                    }
                }
            }
            logger({
                category: "agent",
                message: `Prepared ${toolResults.length} tool results for next request`,
                level: 2
            });
            return toolResults;
        });
    }
    convertToolUseToAction(item) {
        try {
            const { name, input } = item;
            if (name === "computer") {
                const action = input.action;
                if (!action) {
                    console.warn("Missing action in tool use item:", item);
                    return null;
                }
                if (action === "screenshot") {
                    return __spreadValues({
                        type: "screenshot"
                    }, input);
                } else if (action === "click") {
                    return __spreadValues({
                        type: "click",
                        x: input.x,
                        y: input.y,
                        button: input.button || "left"
                    }, input);
                } else if (action === "type") {
                    return __spreadValues({
                        type: "type",
                        text: input.text
                    }, input);
                } else if (action === "keypress") {
                    return __spreadValues({
                        type: "keypress",
                        keys: input.keys
                    }, input);
                } else if (action === "double_click" || action === "doubleClick") {
                    return __spreadValues({
                        type: action,
                        x: input.x,
                        y: input.y
                    }, input);
                } else if (action === "scroll") {
                    const x = input.x || (input.coordinate ? input.coordinate[0] : 0);
                    const y = input.y || (input.coordinate ? input.coordinate[1] : 0);
                    let scroll_x = 0;
                    let scroll_y = 0;
                    const scrollAmount = input.scroll_amount || 5;
                    const scrollMultiplier = 100;
                    if (input.scroll_direction) {
                        const direction = input.scroll_direction;
                        if (direction === "down") {
                            scroll_y = scrollAmount * scrollMultiplier;
                        } else if (direction === "up") {
                            scroll_y = -scrollAmount * scrollMultiplier;
                        } else if (direction === "right") {
                            scroll_x = scrollAmount * scrollMultiplier;
                        } else if (direction === "left") {
                            scroll_x = -scrollAmount * scrollMultiplier;
                        }
                    } else {
                        scroll_x = input.scroll_x || 0;
                        scroll_y = input.scroll_y || 0;
                    }
                    return __spreadValues({
                        type: "scroll",
                        x,
                        y,
                        scroll_x,
                        scroll_y
                    }, input);
                } else if (action === "move") {
                    const coordinates = input.coordinate;
                    const x = coordinates ? coordinates[0] : input.x || 0;
                    const y = coordinates ? coordinates[1] : input.y || 0;
                    return __spreadValues({
                        type: "move",
                        x,
                        y
                    }, input);
                } else if (action === "drag" || action === "left_click_drag") {
                    const path7 = input.path || (input.coordinate ? [
                        {
                            x: input.start_coordinate[0],
                            y: input.start_coordinate[1]
                        },
                        {
                            x: input.coordinate[0],
                            y: input.coordinate[1]
                        }
                    ] : []);
                    return __spreadValues({
                        type: "drag",
                        path: path7
                    }, input);
                } else if (action === "wait") {
                    return __spreadValues({
                        type: "wait"
                    }, input);
                } else if (action === "key") {
                    const text = input.text;
                    const mappedKey = mapKeyToPlaywright(text);
                    return __spreadValues({
                        type: "key",
                        text: mappedKey
                    }, input);
                } else if (action === "left_click") {
                    const coordinates = input.coordinate;
                    const x = coordinates ? coordinates[0] : input.x || 0;
                    const y = coordinates ? coordinates[1] : input.y || 0;
                    return __spreadValues({
                        type: "click",
                        x,
                        y,
                        button: "left"
                    }, input);
                } else {
                    return __spreadValues({
                        type: action
                    }, input);
                }
            } else if (name === "str_replace_editor" || name === "bash") {
                return {
                    type: name,
                    params: input
                };
            } else if (this.tools && name in this.tools) {
                return null;
            }
            console.warn(`Unknown tool name: ${name}`);
            return null;
        } catch (error) {
            console.error("Error converting tool use to action:", error);
            return null;
        }
    }
    captureScreenshot(options) {
        return __async(this, null, function*() {
            if (options == null ? void 0 : options.base64Image) {
                return `data:image/png;base64,${options.base64Image}`;
            }
            if (this.screenshotProvider) {
                try {
                    const base64Image = yield this.screenshotProvider();
                    return `data:image/png;base64,${base64Image}`;
                } catch (error) {
                    console.error("Error capturing screenshot:", error);
                    throw error;
                }
            }
            throw new AgentScreenshotProviderError("`screenshotProvider` has not been set. Please call `setScreenshotProvider()` with a valid function that returns a base64-encoded image");
        });
    }
};
// lib/v3/agent/OpenAICUAClient.ts
var import_openai = __toESM(__turbopack_context__.r("[project]/node_modules/openai/index.js [app-route] (ecmascript)"));
init_sdkErrors();
var OpenAICUAClient = class extends AgentClient {
    constructor(type, modelName, userProvidedInstructions, clientOptions, tools){
        super(type, modelName, userProvidedInstructions);
        this.currentViewport = {
            width: 1288,
            height: 711
        };
        this.reasoningItems = /* @__PURE__ */ new Map();
        this.environment = "browser";
        this.apiKey = (clientOptions == null ? void 0 : clientOptions.apiKey) || process.env.OPENAI_API_KEY || "";
        this.baseURL = (clientOptions == null ? void 0 : clientOptions.baseURL) || void 0;
        this.organization = (clientOptions == null ? void 0 : clientOptions.organization) || process.env.OPENAI_ORG;
        if ((clientOptions == null ? void 0 : clientOptions.environment) && typeof clientOptions.environment === "string") {
            this.environment = clientOptions.environment;
        }
        this.clientOptions = {
            apiKey: this.apiKey
        };
        if (this.baseURL) {
            this.clientOptions.baseURL = this.baseURL;
        }
        this.client = new import_openai.default(this.clientOptions);
        this.tools = tools;
    }
    setViewport(width, height) {
        this.currentViewport = {
            width,
            height
        };
    }
    setCurrentUrl(url) {
        this.currentUrl = url;
    }
    setScreenshotProvider(provider) {
        this.screenshotProvider = provider;
    }
    setActionHandler(handler) {
        this.actionHandler = handler;
    }
    setTools(tools) {
        this.tools = tools;
    }
    /**
   * Execute a task with the OpenAI CUA
   * This is the main entry point for the agent
   * @implements AgentClient.execute
   */ execute(executionOptions) {
        return __async(this, null, function*() {
            const { options, logger } = executionOptions;
            const { instruction } = options;
            const maxSteps = options.maxSteps || 10;
            let currentStep = 0;
            let completed = false;
            const actions = [];
            const messageList = [];
            let finalMessage = "";
            this.reasoningItems.clear();
            let inputItems = this.createInitialInputItems(instruction);
            let previousResponseId = void 0;
            let totalInputTokens = 0;
            let totalOutputTokens = 0;
            let totalInferenceTime = 0;
            try {
                while(!completed && currentStep < maxSteps){
                    logger({
                        category: "agent",
                        message: `Executing step ${currentStep + 1}/${maxSteps}`,
                        level: 1
                    });
                    const result = yield this.executeStep(inputItems, previousResponseId, logger);
                    totalInputTokens += result.usage.input_tokens;
                    totalOutputTokens += result.usage.output_tokens;
                    totalInferenceTime += result.usage.inference_time_ms;
                    actions.push(...result.actions);
                    completed = result.completed;
                    previousResponseId = result.responseId;
                    if (!completed) {
                        inputItems = result.nextInputItems;
                    }
                    if (result.message) {
                        messageList.push(result.message);
                        finalMessage = result.message;
                    }
                    currentStep++;
                }
                return {
                    success: completed,
                    actions,
                    message: finalMessage,
                    completed,
                    usage: {
                        input_tokens: totalInputTokens,
                        output_tokens: totalOutputTokens,
                        inference_time_ms: totalInferenceTime
                    }
                };
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                logger({
                    category: "agent",
                    message: `Error executing agent task: ${errorMessage}`,
                    level: 0
                });
                return {
                    success: false,
                    actions,
                    message: `Failed to execute task: ${errorMessage}`,
                    completed: false,
                    usage: {
                        input_tokens: totalInputTokens,
                        output_tokens: totalOutputTokens,
                        inference_time_ms: totalInferenceTime
                    }
                };
            }
        });
    }
    /**
   * Execute a single step of the agent
   * This coordinates the flow: Request  Get Action  Execute Action
   */ executeStep(inputItems, previousResponseId, logger) {
        return __async(this, null, function*() {
            try {
                const result = yield this.getAction(inputItems, previousResponseId);
                const output = result.output;
                const responseId = result.responseId;
                const usage = {
                    input_tokens: result.usage.input_tokens,
                    output_tokens: result.usage.output_tokens,
                    inference_time_ms: result.usage.inference_time_ms
                };
                for (const item of output){
                    if (item.type === "reasoning") {
                        this.reasoningItems.set(item.id, item);
                        logger({
                            category: "agent",
                            message: `Reasoning: ${String(item.content || "")}`,
                            level: 1
                        });
                    }
                }
                const stepActions = [];
                for (const item of output){
                    if (item.type === "computer_call" && this.isComputerCallItem(item)) {
                        logger({
                            category: "agent",
                            message: `Found computer_call: ${item.action.type}, call_id: ${item.call_id}`,
                            level: 2
                        });
                        const action = this.convertComputerCallToAction(item);
                        if (action) {
                            stepActions.push(action);
                            logger({
                                category: "agent",
                                message: `Converted computer_call to action: ${action.type}`,
                                level: 2
                            });
                        }
                    } else if (item.type === "function_call" && this.isFunctionCallItem(item)) {
                        logger({
                            category: "agent",
                            message: `Found function_call: ${item.name}, call_id: ${item.call_id}`,
                            level: 2
                        });
                        const action = this.convertFunctionCallToAction(item);
                        if (action) {
                            stepActions.push(action);
                            logger({
                                category: "agent",
                                message: `Converted function_call to action: ${action.type}`,
                                level: 2
                            });
                        }
                    }
                }
                let message = "";
                for (const item of output){
                    if (item.type === "message") {
                        logger({
                            category: "agent",
                            message: `Found message block`,
                            level: 2
                        });
                        if (item.content && Array.isArray(item.content)) {
                            for (const content of item.content){
                                if (content.type === "output_text" && content.text) {
                                    message += content.text + "\n";
                                    logger({
                                        category: "agent",
                                        message: `Message text: ${String(content.text || "")}`,
                                        level: 1
                                    });
                                }
                            }
                        }
                    }
                }
                const nextInputItems = yield this.takeAction(output, logger);
                const completed = output.length === 0 || output.every((item)=>item.type === "message" || item.type === "reasoning");
                return {
                    actions: stepActions,
                    message: message.trim(),
                    completed,
                    nextInputItems,
                    responseId,
                    usage
                };
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                logger({
                    category: "agent",
                    message: `Error executing step: ${errorMessage}`,
                    level: 0
                });
                throw error;
            }
        });
    }
    isComputerCallItem(item) {
        return item.type === "computer_call" && "call_id" in item && "action" in item && typeof item.action === "object";
    }
    isFunctionCallItem(item) {
        return item.type === "function_call" && "call_id" in item && "name" in item && "arguments" in item;
    }
    createInitialInputItems(instruction) {
        return [
            {
                role: "system",
                content: this.userProvidedInstructions
            },
            {
                role: "user",
                content: instruction
            }
        ];
    }
    getAction(inputItems, previousResponseId) {
        return __async(this, null, function*() {
            try {
                const requestParams = {
                    model: this.modelName,
                    tools: [
                        {
                            type: "computer_use_preview",
                            display_width: this.currentViewport.width,
                            display_height: this.currentViewport.height,
                            environment: this.environment
                        }
                    ],
                    input: inputItems,
                    truncation: "auto"
                };
                if (this.tools && Object.keys(this.tools).length > 0) {
                    const customTools = Object.entries(this.tools).map(([name, tool12])=>({
                            type: "function",
                            name,
                            function: {
                                name,
                                description: tool12.description,
                                parameters: tool12.inputSchema
                            }
                        }));
                    requestParams.tools = [
                        ...requestParams.tools,
                        ...customTools
                    ];
                }
                if (previousResponseId) {
                    requestParams.previous_response_id = previousResponseId;
                }
                const startTime = Date.now();
                const response = yield this.client.responses.create(requestParams);
                const endTime = Date.now();
                const elapsedMs = endTime - startTime;
                const usage = {
                    input_tokens: response.usage.input_tokens,
                    output_tokens: response.usage.output_tokens,
                    inference_time_ms: elapsedMs
                };
                this.lastResponseId = response.id;
                return {
                    output: response.output,
                    responseId: response.id,
                    usage
                };
            } catch (error) {
                console.error("Error getting action from OpenAI:", error);
                throw error;
            }
        });
    }
    takeAction(output, logger) {
        return __async(this, null, function*() {
            const nextInputItems = [];
            for (const item of output){
                if (item.type === "computer_call" && this.isComputerCallItem(item)) {
                    try {
                        const action = this.convertComputerCallToAction(item);
                        if (action && this.actionHandler) {
                            logger({
                                category: "agent",
                                message: `Executing computer action: ${action.type}`,
                                level: 1
                            });
                            yield this.actionHandler(action);
                        }
                        const screenshot = yield this.captureScreenshot();
                        const outputItem = {
                            type: "computer_call_output",
                            call_id: item.call_id,
                            output: {
                                type: "input_image",
                                image_url: screenshot
                            }
                        };
                        logger({
                            category: "agent",
                            message: `Added computer_call_output for call_id: ${item.call_id}`,
                            level: 2
                        });
                        if (this.currentUrl) {
                            const computerCallOutput = outputItem;
                            computerCallOutput.output.current_url = this.currentUrl;
                        }
                        if (item.pending_safety_checks && item.pending_safety_checks.length > 0) {
                            const computerCallOutput = outputItem;
                            computerCallOutput.acknowledged_safety_checks = item.pending_safety_checks;
                        }
                        nextInputItems.push(outputItem);
                    } catch (error) {
                        const errorMessage = error instanceof Error ? error.message : String(error);
                        logger({
                            category: "agent",
                            message: `Error executing computer call: ${errorMessage}`,
                            level: 0
                        });
                        try {
                            const screenshot = yield this.captureScreenshot();
                            const errorOutputItem = {
                                type: "computer_call_output",
                                call_id: item.call_id,
                                output: {
                                    type: "input_image",
                                    image_url: screenshot,
                                    error: errorMessage
                                }
                            };
                            if (this.currentUrl) {
                                const computerCallOutput = errorOutputItem;
                                computerCallOutput.output.current_url = this.currentUrl;
                            }
                            if (item.pending_safety_checks && item.pending_safety_checks.length > 0) {
                                const computerCallOutput = errorOutputItem;
                                computerCallOutput.acknowledged_safety_checks = item.pending_safety_checks;
                            }
                            nextInputItems.push(errorOutputItem);
                        } catch (screenshotError) {
                            logger({
                                category: "agent",
                                message: `Error capturing screenshot: ${String(screenshotError)}`,
                                level: 0
                            });
                            nextInputItems.push({
                                type: "computer_call_output",
                                call_id: item.call_id,
                                output: `Error: ${errorMessage}`
                            });
                        }
                    }
                } else if (item.type === "function_call" && this.isFunctionCallItem(item)) {
                    try {
                        const action = this.convertFunctionCallToAction(item);
                        if (action && this.actionHandler) {
                            yield this.actionHandler(action);
                        }
                        let toolResult = "Tool executed successfully";
                        if (this.tools && item.name in this.tools) {
                            try {
                                const tool12 = this.tools[item.name];
                                const args = JSON.parse(item.arguments);
                                logger({
                                    category: "agent",
                                    message: `Executing tool call: ${item.name} with args: ${item.arguments}`,
                                    level: 1
                                });
                                const result = yield tool12.execute(args, {
                                    toolCallId: item.call_id,
                                    messages: []
                                });
                                toolResult = JSON.stringify(result);
                                logger({
                                    category: "agent",
                                    message: `Tool ${item.name} completed successfully. Result: ${toolResult}`,
                                    level: 1
                                });
                            } catch (toolError) {
                                const errorMessage = toolError instanceof Error ? toolError.message : String(toolError);
                                toolResult = `Error executing tool: ${errorMessage}`;
                                logger({
                                    category: "agent",
                                    message: `Error executing tool ${item.name}: ${errorMessage}`,
                                    level: 0
                                });
                            }
                        }
                        const outputItem = {
                            type: "function_call_output",
                            call_id: item.call_id,
                            output: toolResult
                        };
                        nextInputItems.push(outputItem);
                    } catch (error) {
                        const errorMessage = error instanceof Error ? error.message : String(error);
                        logger({
                            category: "agent",
                            message: `Error executing function call: ${errorMessage}`,
                            level: 0
                        });
                        const errorOutputItem = {
                            type: "function_call_output",
                            call_id: item.call_id,
                            output: `Error: ${errorMessage}`
                        };
                        nextInputItems.push(errorOutputItem);
                    }
                }
            }
            return nextInputItems;
        });
    }
    convertComputerCallToAction(call) {
        const { action } = call;
        return __spreadValues({
            type: action.type
        }, action);
    }
    convertFunctionCallToAction(call) {
        try {
            const args = JSON.parse(call.arguments);
            return {
                type: call.name,
                params: args
            };
        } catch (error) {
            console.error("Error parsing function call arguments:", error);
            return null;
        }
    }
    captureScreenshot(options) {
        return __async(this, null, function*() {
            if (options == null ? void 0 : options.base64Image) {
                return `data:image/png;base64,${options.base64Image}`;
            }
            if (this.screenshotProvider) {
                try {
                    const base64Image = yield this.screenshotProvider();
                    return `data:image/png;base64,${base64Image}`;
                } catch (error) {
                    console.error("Error capturing screenshot:", error);
                    throw error;
                }
            }
            throw new AgentScreenshotProviderError("`screenshotProvider` has not been set. Please call `setScreenshotProvider()` with a valid function that returns a base64-encoded image");
        });
    }
};
// lib/v3/agent/GoogleCUAClient.ts
var import_genai3 = __turbopack_context__.r("[project]/node_modules/@google/genai/dist/node/index.cjs [app-route] (ecmascript)");
init_sdkErrors();
// lib/v3/agent/utils/googleCustomToolHandler.ts
var import_genai2 = __turbopack_context__.r("[project]/node_modules/@google/genai/dist/node/index.cjs [app-route] (ecmascript)");
var import_zod_to_json_schema2 = __turbopack_context__.r("[project]/node_modules/zod-to-json-schema/dist/cjs/index.js [app-route] (ecmascript)");
function executeGoogleCustomTool(toolName, toolArgs, tools, functionCall, logger) {
    return __async(this, null, function*() {
        try {
            logger({
                category: "agent",
                message: `Executing custom tool: ${toolName} with args: ${JSON.stringify(toolArgs)}`,
                level: 1
            });
            const tool12 = tools[toolName];
            const toolResult = yield tool12.execute(toolArgs, {
                toolCallId: `tool_${Date.now()}`,
                messages: []
            });
            logger({
                category: "agent",
                message: `Tool ${toolName} completed successfully. Result: ${JSON.stringify(toolResult)}`,
                level: 1
            });
            const functionResponsePart = {
                functionResponse: {
                    name: toolName,
                    response: {
                        result: JSON.stringify(toolResult)
                    }
                }
            };
            return {
                functionResponse: functionResponsePart,
                success: true
            };
        } catch (toolError) {
            const errorMessage = toolError instanceof Error ? toolError.message : String(toolError);
            logger({
                category: "agent",
                message: `Error executing custom tool ${toolName}: ${errorMessage}`,
                level: 0
            });
            const functionResponsePart = {
                functionResponse: {
                    name: toolName,
                    response: {
                        error: errorMessage
                    }
                }
            };
            return {
                functionResponse: functionResponsePart,
                success: false
            };
        }
    });
}
function isCustomTool(functionCall, tools) {
    return !!(tools && functionCall.name && functionCall.name in tools);
}
function convertToolSetToFunctionDeclarations(tools) {
    const functionDeclarations = [];
    for (const [name, tool12] of Object.entries(tools)){
        const functionDeclaration = convertToolToFunctionDeclaration(name, tool12);
        if (functionDeclaration) {
            functionDeclarations.push(functionDeclaration);
        }
    }
    return functionDeclarations;
}
function convertToolToFunctionDeclaration(name, tool12) {
    try {
        const jsonSchema2 = (0, import_zod_to_json_schema2.zodToJsonSchema)(tool12.inputSchema);
        const parameters = convertJsonSchemaToGoogleParameters(jsonSchema2);
        return {
            name,
            description: tool12.description || `Execute ${name}`,
            parameters
        };
    } catch (error) {
        console.error(`Error converting tool ${name} to function declaration:`, error);
        return null;
    }
}
function convertJsonSchemaToGoogleParameters(schema) {
    const properties = {};
    if (schema.properties) {
        for (const [key, value] of Object.entries(schema.properties)){
            const propSchema = value;
            properties[key] = __spreadValues({
                type: mapJsonTypeToGoogleType(propSchema.type || "string")
            }, propSchema.description ? {
                description: propSchema.description
            } : {});
        }
    }
    return __spreadValues({
        type: import_genai2.Type.OBJECT,
        properties
    }, schema.required && schema.required.length > 0 ? {
        required: schema.required
    } : {});
}
function mapJsonTypeToGoogleType(jsonType) {
    switch(jsonType.toLowerCase()){
        case "string":
            return import_genai2.Type.STRING;
        case "number":
        case "integer":
            return import_genai2.Type.NUMBER;
        case "boolean":
            return import_genai2.Type.BOOLEAN;
        case "array":
            return import_genai2.Type.ARRAY;
        case "object":
            return import_genai2.Type.OBJECT;
        default:
            return import_genai2.Type.STRING;
    }
}
// lib/v3/agent/GoogleCUAClient.ts
var GoogleCUAClient = class extends AgentClient {
    constructor(type, modelName, userProvidedInstructions, clientOptions, tools){
        super(type, modelName, userProvidedInstructions);
        this.currentViewport = {
            width: 1288,
            height: 711
        };
        this.history = [];
        this.environment = "ENVIRONMENT_BROWSER";
        this.tools = tools;
        this.apiKey = (clientOptions == null ? void 0 : clientOptions.apiKey) || process.env.GEMINI_API_KEY || process.env.GOOGLE_GENERATIVE_AI_API_KEY || "";
        this.baseURL = clientOptions == null ? void 0 : clientOptions.baseURL;
        const genAIOptions = __spreadValues({
            apiKey: this.apiKey
        }, this.baseURL ? {
            httpOptions: {
                baseUrl: this.baseURL
            }
        } : {});
        this.client = new import_genai3.GoogleGenAI(genAIOptions);
        if ((clientOptions == null ? void 0 : clientOptions.environment) && typeof clientOptions.environment === "string") {
            this.environment = clientOptions.environment;
        }
        this.generateContentConfig = {
            temperature: 1,
            topP: 0.95,
            topK: 40,
            maxOutputTokens: 8192,
            // systemInstruction: this.userProvidedInstructions
            //   ? { parts: [{ text: this.userProvidedInstructions }] }
            //   : { parts: [{ text: buildGoogleCUASystemPrompt() }] },
            tools: [
                {
                    computerUse: {
                        environment: this.environment
                    }
                }
            ]
        };
        this.clientOptions = __spreadValues({
            apiKey: this.apiKey
        }, this.baseURL ? {
            baseURL: this.baseURL
        } : {});
        if (this.tools && Object.keys(this.tools).length > 0) {
            this.updateGenerateContentConfig();
        }
    }
    setViewport(width, height) {
        this.currentViewport = {
            width,
            height
        };
    }
    setCurrentUrl(url) {
        this.currentUrl = url;
    }
    setScreenshotProvider(provider) {
        this.screenshotProvider = provider;
    }
    setActionHandler(handler) {
        this.actionHandler = handler;
    }
    setTools(tools) {
        this.tools = tools;
        this.updateGenerateContentConfig();
    }
    /**
   * Update the generateContentConfig with current tools
   */ updateGenerateContentConfig() {
        const functionDeclarations = this.tools && Object.keys(this.tools).length > 0 ? convertToolSetToFunctionDeclarations(this.tools) : [];
        this.generateContentConfig = __spreadProps(__spreadValues({}, this.generateContentConfig), {
            tools: [
                __spreadValues({
                    computerUse: {
                        environment: this.environment
                    }
                }, functionDeclarations.length > 0 ? {
                    functionDeclarations
                } : {})
            ]
        });
    }
    /**
   * Execute a task with the Google CUA
   * This is the main entry point for the agent
   * @implements AgentClient.execute
   */ execute(executionOptions) {
        return __async(this, null, function*() {
            const { options, logger } = executionOptions;
            const { instruction } = options;
            const maxSteps = options.maxSteps || 10;
            let currentStep = 0;
            let completed = false;
            const actions = [];
            const messageList = [];
            let finalMessage = "";
            this.history = [];
            yield this.initializeHistory(instruction);
            let totalInputTokens = 0;
            let totalOutputTokens = 0;
            let totalInferenceTime = 0;
            try {
                while(!completed && currentStep < maxSteps){
                    logger({
                        category: "agent",
                        message: `Executing step ${currentStep + 1}/${maxSteps}`,
                        level: 1
                    });
                    const result = yield this.executeStep(logger);
                    totalInputTokens += result.usage.input_tokens;
                    totalOutputTokens += result.usage.output_tokens;
                    totalInferenceTime += result.usage.inference_time_ms;
                    actions.push(...result.actions);
                    completed = result.completed;
                    if (result.message) {
                        messageList.push(result.message);
                        finalMessage = result.message;
                    }
                    currentStep++;
                }
                return {
                    success: completed,
                    actions,
                    message: finalMessage,
                    completed,
                    usage: {
                        input_tokens: totalInputTokens,
                        output_tokens: totalOutputTokens,
                        inference_time_ms: totalInferenceTime
                    }
                };
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                logger({
                    category: "agent",
                    message: `Error executing agent task: ${errorMessage}`,
                    level: 0
                });
                return {
                    success: false,
                    actions,
                    message: `Failed to execute task: ${errorMessage}`,
                    completed: false,
                    usage: {
                        input_tokens: totalInputTokens,
                        output_tokens: totalOutputTokens,
                        inference_time_ms: totalInferenceTime
                    }
                };
            }
        });
    }
    /**
   * Initialize conversation history with the initial instruction
   */ initializeHistory(instruction) {
        return __async(this, null, function*() {
            const parts = [
                {
                    text: instruction
                }
            ];
            const systemPromptContent = this.userProvidedInstructions ? this.userProvidedInstructions : buildGoogleCUASystemPrompt().content;
            this.history = [
                {
                    role: "user",
                    parts: [
                        {
                            text: "System prompt: " + systemPromptContent
                        }
                    ]
                },
                {
                    role: "user",
                    parts
                }
            ];
        });
    }
    /**
   * Execute a single step of the agent
   */ executeStep(logger) {
        return __async(this, null, function*() {
            var _a, _b;
            try {
                const startTime = Date.now();
                const compressedResult = compressGoogleConversationImages(this.history, 2);
                const compressedHistory = compressedResult.items;
                const maxRetries = 5;
                const baseDelayS = 1;
                let lastError = null;
                let response = null;
                for(let attempt = 0; attempt < maxRetries; attempt++){
                    try {
                        if (attempt > 0) {
                            const delay2 = baseDelayS * Math.pow(2, attempt) * 1e3;
                            logger({
                                category: "agent",
                                message: `Generating content failed on attempt ${attempt + 1}. Retrying in ${delay2 / 1e3} seconds...`,
                                level: 2
                            });
                            yield new Promise((resolve2)=>setTimeout(resolve2, delay2));
                        }
                        response = yield this.client.models.generateContent({
                            model: this.modelName,
                            contents: compressedHistory,
                            config: this.generateContentConfig
                        });
                        if (!response.candidates || response.candidates.length === 0) {
                            throw new LLMResponseError("agent", "Response has no candidates!");
                        }
                        break;
                    } catch (error) {
                        lastError = error instanceof Error ? error : new Error(String(error));
                        logger({
                            category: "agent",
                            message: `API call error: ${lastError.message}`,
                            level: 2
                        });
                        if (attempt === maxRetries - 1) {
                            logger({
                                category: "agent",
                                message: `Generating content failed after ${maxRetries} attempts.`,
                                level: 0
                            });
                            throw lastError;
                        }
                    }
                }
                if (!response) {
                    throw lastError || new Error("Failed to get response after all retries");
                }
                const endTime = Date.now();
                const elapsedMs = endTime - startTime;
                const { usageMetadata } = response;
                const result = yield this.processResponse(response, logger);
                if (response.candidates && response.candidates[0]) {
                    const sanitizedContent = JSON.parse(JSON.stringify(response.candidates[0].content));
                    if (sanitizedContent.parts) {
                        for (const part of sanitizedContent.parts){
                            if ((_a = part.functionCall) == null ? void 0 : _a.args) {
                                if (typeof part.functionCall.args.x === "number" && part.functionCall.args.x > 999) {
                                    part.functionCall.args.x = 999;
                                }
                                if (typeof part.functionCall.args.y === "number" && part.functionCall.args.y > 999) {
                                    part.functionCall.args.y = 999;
                                }
                            }
                        }
                    }
                    this.history.push(sanitizedContent);
                }
                const functionResponses = [];
                if (result.actions.length > 0) {
                    let hasError = false;
                    for(let i = 0; i < result.actions.length; i++){
                        const action = result.actions[i];
                        logger({
                            category: "agent",
                            message: `Executing action ${i + 1}/${result.actions.length}: ${action.type}`,
                            level: 2
                        });
                        if (action.type === "open_web_browser") {
                            action.pageUrl = this.currentUrl;
                            logger({
                                category: "agent",
                                message: "Skipping open_web_browser action",
                                level: 2
                            });
                        } else if (action.type === "custom_tool") {
                            const toolName = action.name;
                            const toolArgs = action.arguments;
                            if (this.tools && toolName in this.tools) {
                                const correspondingFunctionCall = result.functionCalls.find((fc)=>fc.name === toolName);
                                if (correspondingFunctionCall) {
                                    const executionResult = yield executeGoogleCustomTool(toolName, toolArgs, this.tools, correspondingFunctionCall, logger);
                                    functionResponses.push(executionResult.functionResponse);
                                    if (!executionResult.success) {
                                        hasError = true;
                                    }
                                }
                            }
                        } else if (this.actionHandler) {
                            try {
                                yield this.actionHandler(action);
                                if (i < result.actions.length - 1) {
                                    const nextAction = result.actions[i + 1];
                                    const isTypingAction = action.type === "type" || nextAction.type === "type";
                                    const delay2 = isTypingAction ? 500 : 200;
                                    yield new Promise((resolve2)=>setTimeout(resolve2, delay2));
                                }
                            } catch (actionError) {
                                logger({
                                    category: "agent",
                                    message: `Error executing action ${action.type}: ${actionError}`,
                                    level: 0
                                });
                                hasError = true;
                            }
                        }
                    }
                    if (result.functionCalls.length > 0 || hasError) {
                        const computerUseFunctionCalls = result.functionCalls.filter((fc)=>!isCustomTool(fc, this.tools));
                        if (computerUseFunctionCalls.length > 0) {
                            try {
                                logger({
                                    category: "agent",
                                    message: `Taking screenshot after executing ${result.actions.length} actions${hasError ? " (with errors)" : ""}`,
                                    level: 2
                                });
                                const screenshot = yield this.captureScreenshot();
                                const base64Data = screenshot.replace(/^data:image\/png;base64,/, "");
                                for (const functionCall of computerUseFunctionCalls){
                                    const functionResponsePart = {
                                        functionResponse: {
                                            name: functionCall.name,
                                            response: __spreadValues({
                                                url: this.currentUrl || ""
                                            }, ((_b = functionCall.args) == null ? void 0 : _b.safety_decision) ? {
                                                safety_acknowledgement: "true"
                                            } : {}),
                                            parts: [
                                                {
                                                    inlineData: {
                                                        mimeType: "image/png",
                                                        data: base64Data
                                                    }
                                                }
                                            ]
                                        }
                                    };
                                    functionResponses.push(functionResponsePart);
                                }
                            } catch (error) {
                                logger({
                                    category: "agent",
                                    message: `Error capturing screenshot: ${error}`,
                                    level: 0
                                });
                            }
                        }
                    }
                    if (functionResponses.length > 0) {
                        logger({
                            category: "agent",
                            message: `Adding ${functionResponses.length} function responses to history`,
                            level: 2
                        });
                        this.history.push({
                            role: "user",
                            parts: functionResponses
                        });
                    }
                }
                return {
                    actions: result.actions,
                    message: result.message,
                    completed: result.completed,
                    usage: {
                        input_tokens: (usageMetadata == null ? void 0 : usageMetadata.promptTokenCount) || 0,
                        output_tokens: (usageMetadata == null ? void 0 : usageMetadata.candidatesTokenCount) || 0,
                        inference_time_ms: elapsedMs
                    }
                };
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                logger({
                    category: "agent",
                    message: `Error executing step: ${errorMessage}`,
                    level: 0
                });
                throw error;
            }
        });
    }
    /**
   * Process the response from Google's API
   */ processResponse(response, logger) {
        return __async(this, null, function*() {
            const actions = [];
            let message = "";
            const functionCalls = [];
            if (!response.candidates || response.candidates.length === 0) {
                return {
                    actions: [],
                    message: "No candidates in response",
                    completed: true,
                    functionCalls: []
                };
            }
            const candidate = response.candidates[0];
            logger({
                category: "agent",
                message: `Raw response from Google: ${JSON.stringify(candidate.content, null, 2)}`,
                level: 2
            });
            for (const part of candidate.content.parts){
                if (part.text) {
                    message += part.text + "\n";
                    logger({
                        category: "agent",
                        message: `Reasoning: ${part.text}`,
                        level: 1
                    });
                }
                if (part.functionCall) {
                    functionCalls.push(part.functionCall);
                    logger({
                        category: "agent",
                        message: `Found function call: ${part.functionCall.name} with args: ${JSON.stringify(part.functionCall.args)}`,
                        level: 2
                    });
                    const action = this.convertFunctionCallToAction(part.functionCall);
                    if (action) {
                        if (part.functionCall.name === "type_text_at" && action.type === "type") {
                            logger({
                                category: "agent",
                                message: `Adding action: ${JSON.stringify(action)}`,
                                level: 2
                            });
                            actions.push({
                                type: "click",
                                x: action.x,
                                y: action.y,
                                button: "left"
                            });
                            if (action.clearBeforeTyping) {
                                actions.push({
                                    type: "keypress",
                                    keys: [
                                        "ControlOrMeta+A"
                                    ]
                                });
                                actions.push({
                                    type: "keypress",
                                    keys: [
                                        "Backspace"
                                    ]
                                });
                            }
                            actions.push(action);
                            if (action.pressEnter) {
                                actions.push({
                                    type: "keypress",
                                    keys: [
                                        "Enter"
                                    ]
                                });
                            }
                        } else {
                            actions.push(action);
                        }
                    } else {
                        logger({
                            category: "agent",
                            message: `Warning: Could not convert function call ${part.functionCall.name} to action`,
                            level: 1
                        });
                    }
                }
            }
            logger({
                category: "agent",
                message: `Found ${functionCalls.length} function calls, converted to ${actions.length} actions`,
                level: 2
            });
            const completed = functionCalls.length === 0 || candidate.finishReason && candidate.finishReason !== "STOP";
            return {
                actions,
                message: message.trim(),
                completed,
                functionCalls
            };
        });
    }
    /**
   * Convert Google function call to Stagehand action
   */ convertFunctionCallToAction(functionCall) {
        var _a, _b;
        const { name, args } = functionCall;
        if (!name || !args) {
            return null;
        }
        switch(name){
            case "open_web_browser":
                return {
                    type: "open_web_browser",
                    timestamp: Date.now()
                };
            case "click_at":
                {
                    const { x, y } = this.normalizeCoordinates(args.x, args.y);
                    return {
                        type: "click",
                        x,
                        y,
                        button: args.button || "left"
                    };
                }
            case "type_text_at":
                {
                    const { x, y } = this.normalizeCoordinates(args.x, args.y);
                    const pressEnter = (_a = args.press_enter) != null ? _a : false;
                    const clearBeforeTyping = (_b = args.clear_before_typing) != null ? _b : true;
                    return {
                        type: "type",
                        text: args.text,
                        x,
                        y,
                        pressEnter,
                        clearBeforeTyping
                    };
                }
            case "key_combination":
                {
                    const keys = args.keys.split("+").map((key)=>key.trim()).map((key)=>mapKeyToPlaywright(key));
                    return {
                        type: "keypress",
                        keys
                    };
                }
            case "scroll_document":
                {
                    const direction = args.direction.toLowerCase();
                    return {
                        type: "keypress",
                        keys: [
                            direction === "up" ? "PageUp" : "PageDown"
                        ]
                    };
                }
            case "scroll_at":
                {
                    const { x, y } = this.normalizeCoordinates(args.x, args.y);
                    const direction = (args.direction || "down").toLowerCase();
                    const magnitude = typeof args.magnitude === "number" ? args.magnitude : 800;
                    let scroll_x = 0;
                    let scroll_y = 0;
                    if (direction === "up") {
                        scroll_y = -magnitude;
                    } else if (direction === "down") {
                        scroll_y = magnitude;
                    } else if (direction === "left") {
                        scroll_x = -magnitude;
                    } else if (direction === "right") {
                        scroll_x = magnitude;
                    } else {
                        scroll_y = magnitude;
                    }
                    return {
                        type: "scroll",
                        x,
                        y,
                        scroll_x,
                        scroll_y
                    };
                }
            case "navigate":
                return {
                    type: "goto",
                    url: args.url
                };
            case "go_back":
                return {
                    type: "back"
                };
            case "go_forward":
                return {
                    type: "forward"
                };
            case "wait_5_seconds":
                return {
                    type: "wait",
                    timeMs: 5e3
                };
            case "hover_at":
                {
                    const { x, y } = this.normalizeCoordinates(args.x, args.y);
                    return {
                        type: "move",
                        x,
                        y
                    };
                }
            case "search":
                return {
                    type: "goto",
                    url: "https://www.google.com"
                };
            case "drag_and_drop":
                {
                    const startPoint = this.normalizeCoordinates(args.x, args.y);
                    const endPoint = this.normalizeCoordinates(args.destination_x, args.destination_y);
                    return {
                        type: "drag",
                        path: [
                            {
                                x: startPoint.x,
                                y: startPoint.y
                            },
                            {
                                x: endPoint.x,
                                y: endPoint.y
                            }
                        ]
                    };
                }
            default:
                if (isCustomTool(functionCall, this.tools)) {
                    return {
                        type: "custom_tool",
                        name,
                        arguments: args,
                        timestamp: Date.now(),
                        pageUrl: this.currentUrl
                    };
                }
                console.warn(`Unsupported Google CUA function: ${name}`);
                return null;
        }
    }
    /**
   * Normalize coordinates from Google's 0-1000 range to actual viewport dimensions
   */ normalizeCoordinates(x, y) {
        x = Math.min(999, Math.max(0, x));
        y = Math.min(999, Math.max(0, y));
        return {
            x: Math.floor(x / 1e3 * this.currentViewport.width),
            y: Math.floor(y / 1e3 * this.currentViewport.height)
        };
    }
    captureScreenshot(options) {
        return __async(this, null, function*() {
            if (options == null ? void 0 : options.currentUrl) {
                this.currentUrl = options.currentUrl;
            }
            if (options == null ? void 0 : options.base64Image) {
                return `data:image/png;base64,${options.base64Image}`;
            }
            if (this.screenshotProvider) {
                try {
                    const base64Image = yield this.screenshotProvider();
                    return `data:image/png;base64,${base64Image}`;
                } catch (error) {
                    console.error("Error capturing screenshot:", error);
                    throw error;
                }
            }
            throw new AgentScreenshotProviderError("`screenshotProvider` has not been set. Please call `setScreenshotProvider()` with a valid function that returns a base64-encoded image");
        });
    }
};
// lib/v3/agent/AgentProvider.ts
var modelToAgentProviderMap = {
    "computer-use-preview": "openai",
    "computer-use-preview-2025-03-11": "openai",
    "claude-3-7-sonnet-latest": "anthropic",
    "claude-sonnet-4-20250514": "anthropic",
    "claude-sonnet-4-5-20250929": "anthropic",
    "claude-haiku-4-5-20251001": "anthropic",
    "gemini-2.5-computer-use-preview-10-2025": "google"
};
var AgentProvider = class _AgentProvider {
    /**
   * Create a new agent provider
   */ constructor(logger){
        this.logger = logger;
    }
    getClient(modelName, clientOptions, userProvidedInstructions, tools) {
        const type = _AgentProvider.getAgentProvider(modelName);
        this.logger({
            category: "agent",
            message: `Getting agent client for type: ${type}, model: ${modelName}`,
            level: 2
        });
        try {
            switch(type){
                case "openai":
                    return new OpenAICUAClient(type, modelName, userProvidedInstructions, clientOptions, tools);
                case "anthropic":
                    return new AnthropicCUAClient(type, modelName, userProvidedInstructions, clientOptions, tools);
                case "google":
                    return new GoogleCUAClient(type, modelName, userProvidedInstructions, clientOptions, tools);
                default:
                    throw new UnsupportedModelProviderError([
                        "openai",
                        "anthropic",
                        "google"
                    ], "Computer Use Agent");
            }
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger({
                category: "agent",
                message: `Error creating agent client: ${errorMessage}`,
                level: 0
            });
            throw error;
        }
    }
    static getAgentProvider(modelName) {
        const normalized = modelName.includes("/") ? modelName.split("/")[1] : modelName;
        if (normalized in modelToAgentProviderMap) {
            return modelToAgentProviderMap[normalized];
        }
        throw new UnsupportedModelError(Object.keys(modelToAgentProviderMap), "Computer Use Agent");
    }
};
// lib/v3/handlers/v3CuaAgentHandler.ts
var V3CuaAgentHandler = class {
    constructor(v3, logger, options, tools){
        this.v3 = v3;
        this.logger = logger;
        this.options = options;
        this.provider = new AgentProvider(logger);
        const client = this.provider.getClient(options.modelName, options.clientOptions || {}, options.userProvidedInstructions, tools);
        this.agentClient = client;
        this.setupAgentClient();
        this.agent = client;
    }
    setupAgentClient() {
        this.agentClient.setScreenshotProvider(()=>__async(this, null, function*() {
                const page = yield this.v3.context.awaitActivePage();
                const base64 = yield page.screenshot({
                    fullPage: false
                });
                return base64.toString("base64");
            }));
        this.agentClient.setActionHandler((action)=>__async(this, null, function*() {
                var _a, _b, _c;
                action.pageUrl = (yield this.v3.context.awaitActivePage()).url();
                const defaultDelay = 1e3;
                const waitBetween = ((_a = this.options.clientOptions) == null ? void 0 : _a.waitBetweenActions) || defaultDelay;
                try {
                    if (this.highlightCursor) {
                        try {
                            yield this.injectCursor();
                        } catch (e) {}
                    }
                    yield new Promise((r)=>setTimeout(r, 300));
                    yield this.executeAction(action);
                    action.timestamp = Date.now();
                    yield new Promise((r)=>setTimeout(r, waitBetween));
                    try {
                        yield this.captureAndSendScreenshot();
                    } catch (e) {
                        this.logger({
                            category: "agent",
                            message: `Warning: Failed to take screenshot after action: ${String((_b = e == null ? void 0 : e.message) != null ? _b : e)}`,
                            level: 1
                        });
                    }
                } catch (error) {
                    const msg = (_c = error == null ? void 0 : error.message) != null ? _c : String(error);
                    this.logger({
                        category: "agent",
                        message: `Error executing action ${action.type}: ${msg}`,
                        level: 0
                    });
                    throw error;
                }
            }));
        void this.updateClientViewport();
        void this.updateClientUrl();
    }
    execute(optionsOrInstruction) {
        return __async(this, null, function*() {
            var _a, _b;
            const options = typeof optionsOrInstruction === "string" ? {
                instruction: optionsOrInstruction
            } : optionsOrInstruction;
            this.highlightCursor = options.highlightCursor !== false;
            const page = yield this.v3.context.awaitActivePage();
            const currentUrl = page.url();
            if (!currentUrl || currentUrl === "about:blank") {
                this.logger({
                    category: "agent",
                    message: `Page URL is empty. Navigating to https://www.google.com ...`,
                    level: 1
                });
                yield page.goto("https://www.google.com", {
                    waitUntil: "load"
                });
            }
            if (this.highlightCursor) {
                try {
                    yield this.injectCursor();
                } catch (error) {
                    const errorMessage = error instanceof Error ? error.message : String(error);
                    this.logger({
                        category: "agent",
                        message: `Warning: Failed to inject cursor: ${errorMessage}. Continuing with execution.`,
                        level: 1
                    });
                }
            }
            const start = Date.now();
            const result = yield this.agent.execute({
                options,
                logger: this.logger
            });
            const inferenceTimeMs = Date.now() - start;
            if (result.usage) {
                this.v3.updateMetrics("AGENT" /* AGENT */ , result.usage.input_tokens, result.usage.output_tokens, (_a = result.usage.reasoning_tokens) != null ? _a : 0, (_b = result.usage.cached_input_tokens) != null ? _b : 0, inferenceTimeMs);
            }
            return result;
        });
    }
    executeAction(action) {
        return __async(this, null, function*() {
            var _a;
            const page = yield this.v3.context.awaitActivePage();
            const recording = this.v3.isAgentReplayActive();
            switch(action.type){
                case "click":
                    {
                        const { x, y, button = "left", clickCount } = action;
                        if (recording) {
                            const xpath = yield page.click(x, y, {
                                button: button != null ? button : "left",
                                clickCount: clickCount != null ? clickCount : 1,
                                returnXpath: true
                            });
                            const normalized = this.ensureXPath(xpath);
                            if (normalized) {
                                const stagehandAction = {
                                    selector: normalized,
                                    description: this.describePointerAction("click", x, y),
                                    method: "click",
                                    arguments: []
                                };
                                this.recordCuaActStep(action, [
                                    stagehandAction
                                ], stagehandAction.description);
                            }
                        } else {
                            yield page.click(x, y, {
                                button: button != null ? button : "left",
                                clickCount: clickCount != null ? clickCount : 1
                            });
                        }
                        return {
                            success: true
                        };
                    }
                case "double_click":
                case "doubleClick":
                    {
                        const { x, y } = action;
                        if (recording) {
                            const xpath = yield page.click(x, y, {
                                button: "left",
                                clickCount: 2,
                                returnXpath: true
                            });
                            const normalized = this.ensureXPath(xpath);
                            if (normalized) {
                                const stagehandAction = {
                                    selector: normalized,
                                    description: this.describePointerAction("double click", x, y),
                                    method: "doubleClick",
                                    arguments: []
                                };
                                this.recordCuaActStep(action, [
                                    stagehandAction
                                ], stagehandAction.description);
                            }
                        } else {
                            yield page.click(x, y, {
                                button: "left",
                                clickCount: 2
                            });
                        }
                        return {
                            success: true
                        };
                    }
                case "tripleClick":
                    {
                        const { x, y } = action;
                        if (recording) {
                            const xpath = yield page.click(x, y, {
                                button: "left",
                                clickCount: 3,
                                returnXpath: true
                            });
                            const normalized = this.ensureXPath(xpath);
                            if (normalized) {
                                const stagehandAction = {
                                    selector: normalized,
                                    description: this.describePointerAction("triple click", x, y),
                                    method: "tripleClick",
                                    arguments: []
                                };
                                this.recordCuaActStep(action, [
                                    stagehandAction
                                ], stagehandAction.description);
                            }
                        } else {
                            yield page.click(x, y, {
                                clickCount: 3
                            });
                        }
                        return {
                            success: true
                        };
                    }
                case "type":
                    {
                        const { text } = action;
                        yield page.type(String(text != null ? text : ""));
                        if (recording) {
                            const xpath = yield computeActiveElementXpath(page);
                            const normalized = this.ensureXPath(xpath);
                            if (normalized) {
                                const stagehandAction = {
                                    selector: normalized,
                                    description: this.describeTypeAction(String(text != null ? text : "")),
                                    method: "type",
                                    arguments: [
                                        String(text != null ? text : "")
                                    ]
                                };
                                this.recordCuaActStep(action, [
                                    stagehandAction
                                ], stagehandAction.description);
                            }
                        }
                        return {
                            success: true
                        };
                    }
                case "keypress":
                    {
                        const { keys } = action;
                        const keyList = Array.isArray(keys) ? keys : [
                            keys
                        ];
                        const stagehandActions = [];
                        for (const rawKey of keyList){
                            const mapped = mapKeyToPlaywright(String(rawKey != null ? rawKey : ""));
                            yield page.keyPress(mapped);
                            if (recording) {
                                stagehandActions.push({
                                    selector: "xpath=/html",
                                    description: `press ${mapped}`,
                                    method: "press",
                                    arguments: [
                                        mapped
                                    ]
                                });
                            }
                        }
                        if (recording && stagehandActions.length > 0) {
                            this.recordCuaActStep(action, stagehandActions, stagehandActions.map((a)=>a.description).filter(Boolean).join(", ") || "keypress");
                        }
                        return {
                            success: true
                        };
                    }
                case "scroll":
                    {
                        const { x, y, scroll_x = 0, scroll_y = 0 } = action;
                        yield page.scroll(x != null ? x : 0, y != null ? y : 0, scroll_x != null ? scroll_x : 0, scroll_y != null ? scroll_y : 0);
                        this.v3.recordAgentReplayStep({
                            type: "scroll",
                            deltaX: Number(scroll_x != null ? scroll_x : 0),
                            deltaY: Number(scroll_y != null ? scroll_y : 0),
                            anchor: typeof x === "number" && typeof y === "number" ? {
                                x: Math.round(x),
                                y: Math.round(y)
                            } : void 0
                        });
                        return {
                            success: true
                        };
                    }
                case "drag":
                    {
                        const { path: path7 } = action;
                        if (Array.isArray(path7) && path7.length >= 2) {
                            const start = path7[0];
                            const end = path7[path7.length - 1];
                            if (recording) {
                                const xps = yield page.dragAndDrop(start.x, start.y, end.x, end.y, {
                                    steps: Math.min(20, Math.max(5, path7.length)),
                                    delay: 10,
                                    returnXpath: true
                                });
                                const [fromXpath, toXpath] = xps || [
                                    "",
                                    ""
                                ];
                                const from = this.ensureXPath(fromXpath);
                                const to = this.ensureXPath(toXpath);
                                if (from && to) {
                                    const stagehandAction = {
                                        selector: from,
                                        description: this.describeDragAction(),
                                        method: "dragAndDrop",
                                        arguments: [
                                            to
                                        ]
                                    };
                                    this.recordCuaActStep(action, [
                                        stagehandAction
                                    ], stagehandAction.description);
                                }
                            } else {
                                yield page.dragAndDrop(start.x, start.y, end.x, end.y, {
                                    steps: Math.min(20, Math.max(5, path7.length)),
                                    delay: 10
                                });
                            }
                        }
                        return {
                            success: true
                        };
                    }
                case "move":
                    {
                        return {
                            success: true
                        };
                    }
                case "wait":
                    {
                        const time = (_a = action == null ? void 0 : action.timeMs) != null ? _a : 1e3;
                        yield new Promise((r)=>setTimeout(r, time));
                        if (time > 0 && recording) {
                            this.v3.recordAgentReplayStep({
                                type: "wait",
                                timeMs: Number(time)
                            });
                        }
                        return {
                            success: true
                        };
                    }
                case "screenshot":
                    {
                        return {
                            success: true
                        };
                    }
                case "goto":
                    {
                        const { url } = action;
                        yield page.goto(String(url != null ? url : ""), {
                            waitUntil: "load"
                        });
                        if (recording) {
                            this.v3.recordAgentReplayStep({
                                type: "goto",
                                url: String(url != null ? url : "")
                            });
                        }
                        return {
                            success: true
                        };
                    }
                case "back":
                    {
                        yield page.goBack();
                        if (recording) {
                            this.v3.recordAgentReplayStep({
                                type: "back"
                            });
                        }
                        return {
                            success: true
                        };
                    }
                case "forward":
                    {
                        yield page.goForward();
                        if (recording) {
                            this.v3.recordAgentReplayStep({
                                type: "forward"
                            });
                        }
                        return {
                            success: true
                        };
                    }
                case "open_web_browser":
                    {
                        return {
                            success: true
                        };
                    }
                case "custom_tool":
                    {
                        return {
                            success: true
                        };
                    }
                default:
                    this.logger({
                        category: "agent",
                        message: `Unknown action type: ${String(action.type)}`,
                        level: 1
                    });
                    return {
                        success: false,
                        error: `Unknown action ${String(action.type)}`
                    };
            }
        });
    }
    ensureXPath(value) {
        if (typeof value !== "string") return null;
        const trimmed = value.trim();
        if (!trimmed) return null;
        return trimmed.startsWith("xpath=") ? trimmed : `xpath=${trimmed}`;
    }
    describePointerAction(kind, x, y) {
        const nx = Number(x);
        const ny = Number(y);
        if (Number.isFinite(nx) && Number.isFinite(ny)) {
            return `${kind} at (${Math.round(nx)}, ${Math.round(ny)})`;
        }
        return kind;
    }
    describeTypeAction(text) {
        const snippet = text.length > 30 ? `${text.slice(0, 27)}...` : text;
        return `type "${snippet}"`;
    }
    describeDragAction() {
        return "drag and drop";
    }
    buildInstructionFallback(agentAction, fallback) {
        const raw = typeof agentAction.action === "string" && agentAction.action.trim() || typeof agentAction.reasoning === "string" && agentAction.reasoning.trim();
        return raw && raw.length > 0 ? raw : fallback;
    }
    recordCuaActStep(agentAction, stagehandActions, fallback) {
        var _a;
        if (!stagehandActions.length) return;
        const instruction = this.buildInstructionFallback(agentAction, fallback);
        const description = ((_a = stagehandActions[0]) == null ? void 0 : _a.description) || instruction;
        const actions = stagehandActions.map((act2)=>__spreadProps(__spreadValues({}, act2), {
                description: act2.description || description
            }));
        this.v3.recordAgentReplayStep({
            type: "act",
            instruction,
            actions,
            actionDescription: description,
            message: typeof agentAction.reasoning === "string" && agentAction.reasoning.trim().length > 0 ? agentAction.reasoning.trim() : void 0
        });
    }
    updateClientViewport() {
        return __async(this, null, function*() {
            try {
                const page = yield this.v3.context.awaitActivePage();
                const { w, h } = yield page.mainFrame().evaluate("({ w: window.innerWidth, h: window.innerHeight })");
                if (w && h) this.agentClient.setViewport(w, h);
            } catch (e) {}
        });
    }
    updateClientUrl() {
        return __async(this, null, function*() {
            try {
                const page = yield this.v3.context.awaitActivePage();
                const url = page.url();
                this.agentClient.setCurrentUrl(url);
            } catch (e) {}
        });
    }
    captureAndSendScreenshot() {
        return __async(this, null, function*() {
            var _a;
            this.logger({
                category: "agent",
                message: "Capturing screenshot",
                level: 1
            });
            try {
                const page = yield this.v3.context.awaitActivePage();
                const base64Image = yield page.screenshot({
                    fullPage: false
                });
                const currentUrl = page.url();
                return yield this.agentClient.captureScreenshot({
                    base64Image,
                    currentUrl
                });
            } catch (e) {
                this.logger({
                    category: "agent",
                    message: `Error capturing screenshot: ${String((_a = e == null ? void 0 : e.message) != null ? _a : e)}`,
                    level: 0
                });
                return null;
            }
        });
    }
    injectCursor() {
        return __async(this, null, function*() {
            try {
                const page = yield this.v3.context.awaitActivePage();
                yield page.enableCursorOverlay();
            } catch (e) {}
        });
    }
};
// lib/v3/launch/browserbase.ts
var import_sdk2 = __toESM(__turbopack_context__.r("[project]/node_modules/@browserbasehq/sdk/index.js [app-route] (ecmascript)"));
init_sdkErrors();
function createBrowserbaseSession(apiKey, projectId, params, resumeSessionId) {
    return __async(this, null, function*() {
        var _b;
        const bb = new import_sdk2.default({
            apiKey
        });
        if (resumeSessionId) {
            const existing = yield bb.sessions.retrieve(resumeSessionId);
            if (!(existing == null ? void 0 : existing.id)) {
                throw new BrowserbaseSessionNotFoundError();
            }
            const ws = existing.connectUrl;
            if (!ws) {
                throw new StagehandInitError(`Browserbase session resume missing connectUrl for ${resumeSessionId}`);
            }
            return {
                ws,
                sessionId: resumeSessionId,
                bb
            };
        }
        const _a = params != null ? params : {}, { projectId: overrideProjectId, browserSettings, userMetadata } = _a, rest = __objRest(_a, [
            "projectId",
            "browserSettings",
            "userMetadata"
        ]);
        const createPayload = __spreadProps(__spreadValues({
            projectId: overrideProjectId != null ? overrideProjectId : projectId
        }, rest), {
            browserSettings: __spreadProps(__spreadValues({}, browserSettings != null ? browserSettings : {}), {
                viewport: (_b = browserSettings == null ? void 0 : browserSettings.viewport) != null ? _b : {
                    width: 1288,
                    height: 711
                }
            }),
            userMetadata: __spreadProps(__spreadValues({}, userMetadata != null ? userMetadata : {}), {
                stagehand: "true"
            })
        });
        const created = yield bb.sessions.create(createPayload);
        if (!(created == null ? void 0 : created.connectUrl) || !(created == null ? void 0 : created.id)) {
            throw new StagehandInitError("Browserbase session creation returned an unexpected shape.");
        }
        return {
            ws: created.connectUrl,
            sessionId: created.id,
            bb
        };
    });
}
// ../../node_modules/.pnpm/chrome-launcher@1.2.0/node_modules/chrome-launcher/dist/chrome-launcher.js
var fs6 = __toESM(__turbopack_context__.r("[externals]/fs [external] (fs, cjs)"), 1);
var net = __toESM(__turbopack_context__.r("[externals]/net [external] (net, cjs)"), 1);
// ../../node_modules/.pnpm/chrome-launcher@1.2.0/node_modules/chrome-launcher/dist/chrome-finder.js
var chrome_finder_exports = {};
__export(chrome_finder_exports, {
    darwin: ()=>darwin,
    darwinFast: ()=>darwinFast,
    linux: ()=>linux,
    win32: ()=>win32,
    wsl: ()=>wsl
});
var import_fs5 = __toESM(__turbopack_context__.r("[externals]/fs [external] (fs, cjs)"), 1);
var import_path5 = __toESM(__turbopack_context__.r("[externals]/path [external] (path, cjs)"), 1);
var import_os = __turbopack_context__.r("[externals]/os [external] (os, cjs)");
var import_child_process2 = __turbopack_context__.r("[externals]/child_process [external] (child_process, cjs)");
var import_escape_string_regexp = __toESM(require_escape_string_regexp(), 1);
// ../../node_modules/.pnpm/lighthouse-logger@2.0.2/node_modules/lighthouse-logger/index.js
var import_process = __toESM(__turbopack_context__.r("[externals]/process [external] (process, cjs)"), 1);
var import_events = __turbopack_context__.r("[externals]/events [external] (events, cjs)");
var import_debug = __toESM(require_src(), 1);
// ../../node_modules/.pnpm/marky@1.3.0/node_modules/marky/lib/marky.es.js
var perf = typeof performance !== "undefined" && performance;
var nowPolyfillForNode;
{
    hrtime = process.hrtime;
    getNanoSeconds = function() {
        var hr = hrtime();
        return hr[0] * 1e9 + hr[1];
    };
    loadTime = getNanoSeconds();
    nowPolyfillForNode = function() {
        return (getNanoSeconds() - loadTime) / 1e6;
    };
}var hrtime;
var getNanoSeconds;
var loadTime;
var now = perf && perf.now ? function() {
    return perf.now();
} : nowPolyfillForNode;
function throwIfEmpty(name) {
    if (!name) {
        throw new Error("name must be non-empty");
    }
}
function insertSorted(arr, item) {
    var low = 0;
    var high = arr.length;
    var mid;
    while(low < high){
        mid = low + high >>> 1;
        if (arr[mid].startTime < item.startTime) {
            low = mid + 1;
        } else {
            high = mid;
        }
    }
    arr.splice(low, 0, item);
}
var mark;
var stop;
var getEntries;
var clear;
if (perf && perf.mark && perf.measure && perf.getEntriesByName && perf.getEntriesByType && perf.clearMarks && perf.clearMeasures && // In Node, we want to detect that this perf/correctness fix [1] is available, which
// landed in Node 16.15.0, 17.6.0, and 18.0.0. However, it's not observable, and
// we don't want to rely on fragile version checks.
// So we can rely on this observable change [2] to add clearResourceTimings, which
// landed a bit later (18.2.0), but is close enough for our purposes.
// [1]: https://github.com/nodejs/node/pull/42032
// [2]: https://github.com/nodejs/node/pull/42725
perf.clearResourceTimings) {
    mark = function(name) {
        throwIfEmpty(name);
        perf.mark("start " + name);
    };
    stop = function(name) {
        throwIfEmpty(name);
        perf.mark("end " + name);
        var measure = perf.measure(name, "start " + name, "end " + name);
        if (measure) {
            return measure;
        }
        var entries = perf.getEntriesByName(name);
        return entries[entries.length - 1];
    };
    getEntries = function() {
        return perf.getEntriesByType("measure");
    };
    clear = function() {
        perf.clearMarks();
        perf.clearMeasures();
    };
} else {
    marks = {};
    entries = [];
    mark = function(name) {
        throwIfEmpty(name);
        var startTime = now();
        marks["$" + name] = startTime;
    };
    stop = function(name) {
        throwIfEmpty(name);
        var endTime = now();
        var startTime = marks["$" + name];
        if (!startTime) {
            throw new Error("no known mark: " + name);
        }
        var entry = {
            startTime,
            name,
            duration: endTime - startTime,
            entryType: "measure"
        };
        insertSorted(entries, entry);
        return entry;
    };
    getEntries = function() {
        return entries;
    };
    clear = function() {
        marks = {};
        entries = [];
    };
}
var marks;
var entries;
// ../../node_modules/.pnpm/lighthouse-logger@2.0.2/node_modules/lighthouse-logger/index.js
var isWindows = import_process.default.platform === "win32";
var isBrowser = import_process.default.browser;
var colors = {
    red: isBrowser ? "crimson" : 1,
    yellow: isBrowser ? "gold" : 3,
    cyan: isBrowser ? "darkturquoise" : 6,
    green: isBrowser ? "forestgreen" : 2,
    blue: isBrowser ? "steelblue" : 4,
    magenta: isBrowser ? "palevioletred" : 5
};
import_debug.default.colors = [
    colors.cyan,
    colors.green,
    colors.blue,
    colors.magenta
];
var Emitter = class extends import_events.EventEmitter {
    // yarn build-types fails without this!
    // https://github.com/microsoft/TypeScript/issues/41672#issuecomment-2303803072
    constructor(options){
        super(options);
    }
    /**
   * Fires off all status updates. Listen with
   * `require('lib/log').events.addListener('status', callback)`
   * @param {string} title
   * @param {!Array<*>} argsArray
   */ issueStatus(title, argsArray) {
        if (title === "status" || title === "statusEnd") {
            this.emit(title, [
                title,
                ...argsArray
            ]);
        }
    }
    /**
   * Fires off all warnings. Listen with
   * `require('lib/log').events.addListener('warning', callback)`
   * @param {string} title
   * @param {!Array<*>} argsArray
   */ issueWarning(title, argsArray) {
        this.emit("warning", [
            title,
            ...argsArray
        ]);
    }
};
var loggersByTitle = {};
var loggingBufferColumns = 25;
var level_;
var Log = class _Log {
    static _logToStdErr(title, argsArray) {
        const log = _Log.loggerfn(title);
        log(...argsArray);
    }
    /**
   * @param {string} title
   */ static loggerfn(title) {
        title = `LH:${title}`;
        let log = loggersByTitle[title];
        if (!log) {
            log = (0, import_debug.default)(title);
            loggersByTitle[title] = log;
            if (title.endsWith("error")) {
                log.color = colors.red;
            } else if (title.endsWith("warn")) {
                log.color = colors.yellow;
            }
        }
        return log;
    }
    /**
   * @param {string} level
   */ static setLevel(level) {
        level_ = level;
        switch(level){
            case "silent":
                import_debug.default.enable("-LH:*");
                break;
            case "verbose":
                import_debug.default.enable("LH:*");
                break;
            case "warn":
                import_debug.default.enable("-LH:*, LH:*:warn, LH:*:error");
                break;
            case "error":
                import_debug.default.enable("-LH:*, LH:*:error");
                break;
            default:
                import_debug.default.enable("LH:*, -LH:*:verbose");
        }
    }
    /**
   * A simple formatting utility for event logging.
   * @param {string} prefix
   * @param {!Object} data A JSON-serializable object of event data to log.
   * @param {string=} level Optional logging level. Defaults to 'log'.
   */ static formatProtocol(prefix, data, level) {
        const columns = !import_process.default || import_process.default.browser ? Infinity : import_process.default.stdout.columns;
        const method = data.method || "?????";
        const maxLength = columns - method.length - prefix.length - loggingBufferColumns;
        const snippet = data.params && method !== "IO.read" ? JSON.stringify(data.params).substr(0, maxLength) : "";
        _Log._logToStdErr(`${prefix}:${level || ""}`, [
            method,
            snippet
        ]);
    }
    /**
   * @return {boolean}
   */ static isVerbose() {
        return level_ === "verbose";
    }
    /**
   * @param {{msg: string, id: string, args?: any[]}} status
   * @param {string} level
   */ static time({ msg, id, args = [] }, level = "log") {
        mark(id);
        _Log[level]("status", msg, ...args);
    }
    /**
   * @param {{msg: string, id: string, args?: any[]}} status
   * @param {string} level
   */ static timeEnd({ msg, id, args = [] }, level = "verbose") {
        _Log[level]("statusEnd", msg, ...args);
        stop(id);
    }
    /**
   * @param {string} title
   * @param {...any} args
   */ static log(title, ...args) {
        _Log.events.issueStatus(title, args);
        return _Log._logToStdErr(title, args);
    }
    /**
   * @param {string} title
   * @param {...any} args
   */ static warn(title, ...args) {
        _Log.events.issueWarning(title, args);
        return _Log._logToStdErr(`${title}:warn`, args);
    }
    /**
   * @param {string} title
   * @param {...any} args
   */ static error(title, ...args) {
        return _Log._logToStdErr(`${title}:error`, args);
    }
    /**
   * @param {string} title
   * @param {...any} args
   */ static verbose(title, ...args) {
        _Log.events.issueStatus(title, args);
        return _Log._logToStdErr(`${title}:verbose`, args);
    }
    /**
   * Add surrounding escape sequences to turn a string green when logged.
   * @param {string} str
   * @return {string}
   */ static greenify(str) {
        return `${_Log.green}${str}${_Log.reset}`;
    }
    /**
   * Add surrounding escape sequences to turn a string red when logged.
   * @param {string} str
   * @return {string}
   */ static redify(str) {
        return `${_Log.red}${str}${_Log.reset}`;
    }
    static get green() {
        return "\x1B[32m";
    }
    static get red() {
        return "\x1B[31m";
    }
    static get yellow() {
        return "\x1B[33m";
    }
    static get purple() {
        return "\x1B[95m";
    }
    static get reset() {
        return "\x1B[0m";
    }
    static get bold() {
        return "\x1B[1m";
    }
    static get dim() {
        return "\x1B[2m";
    }
    static get tick() {
        return isWindows ? "\u221A" : "\u2713";
    }
    static get cross() {
        return isWindows ? "\xD7" : "\u2718";
    }
    static get whiteSmallSquare() {
        return isWindows ? "\u0387" : "\u25AB";
    }
    static get heavyHorizontal() {
        return isWindows ? "\u2500" : "\u2501";
    }
    static get heavyVertical() {
        return isWindows ? "\u2502 " : "\u2503 ";
    }
    static get heavyUpAndRight() {
        return isWindows ? "\u2514" : "\u2517";
    }
    static get heavyVerticalAndRight() {
        return isWindows ? "\u251C" : "\u2523";
    }
    static get heavyDownAndHorizontal() {
        return isWindows ? "\u252C" : "\u2533";
    }
    static get doubleLightHorizontal() {
        return "\u2500\u2500";
    }
};
Log.events = new Emitter();
Log.takeTimeEntries = ()=>{
    const entries = getEntries();
    clear();
    return entries;
};
Log.getTimeEntries = ()=>getEntries();
var lighthouse_logger_default = Log;
// ../../node_modules/.pnpm/chrome-launcher@1.2.0/node_modules/chrome-launcher/dist/utils.js
var import_path4 = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
var import_child_process = __toESM(__turbopack_context__.r("[externals]/child_process [external] (child_process, cjs)"), 1);
var import_fs4 = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
var import_is_wsl = __toESM(require_is_wsl(), 1);
function defaults(val, def) {
    return typeof val === "undefined" ? def : val;
}
function delay(time) {
    return __async(this, null, function*() {
        return new Promise((resolve2)=>setTimeout(resolve2, time));
    });
}
var LauncherError = class extends Error {
    constructor(message = "Unexpected error", code){
        super();
        this.message = message;
        this.code = code;
        this.stack = new Error().stack;
        return this;
    }
};
var ChromePathNotSetError = class extends LauncherError {
    constructor(){
        super(...arguments);
        this.message = "The CHROME_PATH environment variable must be set to a Chrome/Chromium executable no older than Chrome stable.";
        this.code = "ERR_LAUNCHER_PATH_NOT_SET";
    }
};
var InvalidUserDataDirectoryError = class extends LauncherError {
    constructor(){
        super(...arguments);
        this.message = "userDataDir must be false or a path.";
        this.code = "ERR_LAUNCHER_INVALID_USER_DATA_DIRECTORY";
    }
};
var UnsupportedPlatformError = class extends LauncherError {
    constructor(){
        super(...arguments);
        this.message = `Platform ${getPlatform()} is not supported.`;
        this.code = "ERR_LAUNCHER_UNSUPPORTED_PLATFORM";
    }
};
var ChromeNotInstalledError = class extends LauncherError {
    constructor(){
        super(...arguments);
        this.message = "No Chrome installations found.";
        this.code = "ERR_LAUNCHER_NOT_INSTALLED";
    }
};
function getPlatform() {
    return import_is_wsl.default ? "wsl" : process.platform;
}
function makeTmpDir() {
    switch(getPlatform()){
        case "darwin":
        case "linux":
            return makeUnixTmpDir();
        case "wsl":
            process.env.TEMP = getWSLLocalAppDataPath(`${process.env.PATH}`);
        case "win32":
            return makeWin32TmpDir();
        default:
            throw new UnsupportedPlatformError();
    }
}
function toWinDirFormat(dir = "") {
    const results = /\/mnt\/([a-z])\//.exec(dir);
    if (!results) {
        return dir;
    }
    const driveLetter = results[1];
    return dir.replace(`/mnt/${driveLetter}/`, `${driveLetter.toUpperCase()}:\\`).replace(/\//g, "\\");
}
function toWin32Path(dir = "") {
    if (/[a-z]:\\/iu.test(dir)) {
        return dir;
    }
    try {
        return import_child_process.default.execFileSync("wslpath", [
            "-w",
            dir
        ]).toString().trim();
    } catch (e) {
        return toWinDirFormat(dir);
    }
}
function toWSLPath(dir, fallback) {
    try {
        return import_child_process.default.execFileSync("wslpath", [
            "-u",
            dir
        ]).toString().trim();
    } catch (e) {
        return fallback;
    }
}
function getLocalAppDataPath(path7) {
    const userRegExp = /\/mnt\/([a-z])\/Users\/([^\/:]+)\/AppData\//;
    const results = userRegExp.exec(path7) || [];
    return `/mnt/${results[1]}/Users/${results[2]}/AppData/Local`;
}
function getWSLLocalAppDataPath(path7) {
    const userRegExp = /\/([a-z])\/Users\/([^\/:]+)\/AppData\//;
    const results = userRegExp.exec(path7) || [];
    return toWSLPath(`${results[1]}:\\Users\\${results[2]}\\AppData\\Local`, getLocalAppDataPath(path7));
}
function makeUnixTmpDir() {
    return import_child_process.default.execSync("mktemp -d -t lighthouse.XXXXXXX").toString().trim();
}
function makeWin32TmpDir() {
    const winTmpPath = process.env.TEMP || process.env.TMP || (process.env.SystemRoot || process.env.windir) + "\\temp";
    const randomNumber = Math.floor(Math.random() * 9e7 + 1e7);
    const tmpdir2 = (0, import_path4.join)(winTmpPath, "lighthouse." + randomNumber);
    (0, import_fs4.mkdirSync)(tmpdir2, {
        recursive: true
    });
    return tmpdir2;
}
// ../../node_modules/.pnpm/chrome-launcher@1.2.0/node_modules/chrome-launcher/dist/chrome-finder.js
var newLineRegex = /\r?\n/;
function darwinFast() {
    const priorityOptions = [
        process.env.CHROME_PATH,
        process.env.LIGHTHOUSE_CHROMIUM_PATH,
        "/Applications/Google Chrome Canary.app/Contents/MacOS/Google Chrome Canary",
        "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome"
    ];
    for (const chromePath of priorityOptions){
        if (chromePath && canAccess(chromePath)) return chromePath;
    }
    return darwin()[0];
}
function darwin() {
    const suffixes = [
        "/Contents/MacOS/Google Chrome Canary",
        "/Contents/MacOS/Google Chrome"
    ];
    const LSREGISTER = "/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/LaunchServices.framework/Versions/A/Support/lsregister";
    const installations = [];
    const customChromePath = resolveChromePath();
    if (customChromePath) {
        installations.push(customChromePath);
    }
    (0, import_child_process2.execSync)(`${LSREGISTER} -dump | grep -i 'google chrome\\( canary\\)\\?\\.app' | awk '{$1=""; print $0}'`).toString().split(newLineRegex).forEach((inst)=>{
        suffixes.forEach((suffix)=>{
            const execPath = import_path5.default.join(inst.substring(0, inst.indexOf(".app") + 4).trim(), suffix);
            if (canAccess(execPath) && installations.indexOf(execPath) === -1) {
                installations.push(execPath);
            }
        });
    });
    const home = (0, import_escape_string_regexp.default)(process.env.HOME || (0, import_os.homedir)());
    const priorities = [
        {
            regex: new RegExp(`^${home}/Applications/.*Chrome\\.app`),
            weight: 50
        },
        {
            regex: new RegExp(`^${home}/Applications/.*Chrome Canary\\.app`),
            weight: 51
        },
        {
            regex: /^\/Applications\/.*Chrome.app/,
            weight: 100
        },
        {
            regex: /^\/Applications\/.*Chrome Canary.app/,
            weight: 101
        },
        {
            regex: /^\/Volumes\/.*Chrome.app/,
            weight: -2
        },
        {
            regex: /^\/Volumes\/.*Chrome Canary.app/,
            weight: -1
        }
    ];
    if (process.env.LIGHTHOUSE_CHROMIUM_PATH) {
        priorities.unshift({
            regex: new RegExp((0, import_escape_string_regexp.default)(process.env.LIGHTHOUSE_CHROMIUM_PATH)),
            weight: 150
        });
    }
    if (process.env.CHROME_PATH) {
        priorities.unshift({
            regex: new RegExp((0, import_escape_string_regexp.default)(process.env.CHROME_PATH)),
            weight: 151
        });
    }
    return sort(installations, priorities);
}
function resolveChromePath() {
    if (canAccess(process.env.CHROME_PATH)) {
        return process.env.CHROME_PATH;
    }
    if (canAccess(process.env.LIGHTHOUSE_CHROMIUM_PATH)) {
        lighthouse_logger_default.warn("ChromeLauncher", "LIGHTHOUSE_CHROMIUM_PATH is deprecated, use CHROME_PATH env variable instead.");
        return process.env.LIGHTHOUSE_CHROMIUM_PATH;
    }
    return void 0;
}
function linux() {
    let installations = [];
    const customChromePath = resolveChromePath();
    if (customChromePath) {
        installations.push(customChromePath);
    }
    const desktopInstallationFolders = [
        import_path5.default.join((0, import_os.homedir)(), ".local/share/applications/"),
        "/usr/share/applications/"
    ];
    desktopInstallationFolders.forEach((folder)=>{
        installations = installations.concat(findChromeExecutables(folder));
    });
    const executables = [
        "google-chrome-stable",
        "google-chrome",
        "chromium-browser",
        "chromium"
    ];
    executables.forEach((executable)=>{
        try {
            const chromePath = (0, import_child_process2.execFileSync)("which", [
                executable
            ], {
                stdio: "pipe"
            }).toString().split(newLineRegex)[0];
            if (canAccess(chromePath)) {
                installations.push(chromePath);
            }
        } catch (e) {}
    });
    if (!installations.length) {
        throw new ChromePathNotSetError();
    }
    const priorities = [
        {
            regex: /chrome-wrapper$/,
            weight: 51
        },
        {
            regex: /google-chrome-stable$/,
            weight: 50
        },
        {
            regex: /google-chrome$/,
            weight: 49
        },
        {
            regex: /chromium-browser$/,
            weight: 48
        },
        {
            regex: /chromium$/,
            weight: 47
        }
    ];
    if (process.env.LIGHTHOUSE_CHROMIUM_PATH) {
        priorities.unshift({
            regex: new RegExp((0, import_escape_string_regexp.default)(process.env.LIGHTHOUSE_CHROMIUM_PATH)),
            weight: 100
        });
    }
    if (process.env.CHROME_PATH) {
        priorities.unshift({
            regex: new RegExp((0, import_escape_string_regexp.default)(process.env.CHROME_PATH)),
            weight: 101
        });
    }
    return sort(uniq(installations.filter(Boolean)), priorities);
}
function wsl() {
    process.env.LOCALAPPDATA = getWSLLocalAppDataPath(`${process.env.PATH}`);
    process.env.PROGRAMFILES = toWSLPath("C:/Program Files", "/mnt/c/Program Files");
    process.env["PROGRAMFILES(X86)"] = toWSLPath("C:/Program Files (x86)", "/mnt/c/Program Files (x86)");
    return win32();
}
function win32() {
    const installations = [];
    const suffixes = [
        `${import_path5.default.sep}Google${import_path5.default.sep}Chrome SxS${import_path5.default.sep}Application${import_path5.default.sep}chrome.exe`,
        `${import_path5.default.sep}Google${import_path5.default.sep}Chrome${import_path5.default.sep}Application${import_path5.default.sep}chrome.exe`
    ];
    const prefixes = [
        process.env.LOCALAPPDATA,
        process.env.PROGRAMFILES,
        process.env["PROGRAMFILES(X86)"]
    ].filter(Boolean);
    const customChromePath = resolveChromePath();
    if (customChromePath) {
        installations.push(customChromePath);
    }
    prefixes.forEach((prefix)=>suffixes.forEach((suffix)=>{
            const chromePath = import_path5.default.join(prefix, suffix);
            if (canAccess(chromePath)) {
                installations.push(chromePath);
            }
        }));
    return installations;
}
function sort(installations, priorities) {
    const defaultPriority = 10;
    return installations.map((inst)=>{
        for (const pair of priorities){
            if (pair.regex.test(inst)) {
                return {
                    path: inst,
                    weight: pair.weight
                };
            }
        }
        return {
            path: inst,
            weight: defaultPriority
        };
    }).sort((a, b)=>b.weight - a.weight).map((pair)=>pair.path);
}
function canAccess(file) {
    if (!file) {
        return false;
    }
    try {
        import_fs5.default.accessSync(file);
        return true;
    } catch (e) {
        return false;
    }
}
function uniq(arr) {
    return Array.from(new Set(arr));
}
function findChromeExecutables(folder) {
    const argumentsRegex = /(^[^ ]+).*/;
    const chromeExecRegex = "^Exec=/.*/(google-chrome|chrome|chromium)-.*";
    let installations = [];
    if (canAccess(folder)) {
        let execPaths;
        try {
            execPaths = (0, import_child_process2.execSync)(`grep -ER "${chromeExecRegex}" ${folder} | awk -F '=' '{print $2}'`, {
                stdio: "pipe"
            });
        } catch (e) {
            execPaths = (0, import_child_process2.execSync)(`grep -Er "${chromeExecRegex}" ${folder} | awk -F '=' '{print $2}'`, {
                stdio: "pipe"
            });
        }
        execPaths = execPaths.toString().split(newLineRegex).map((execPath)=>execPath.replace(argumentsRegex, "$1"));
        execPaths.forEach((execPath)=>canAccess(execPath) && installations.push(execPath));
    }
    return installations;
}
// ../../node_modules/.pnpm/chrome-launcher@1.2.0/node_modules/chrome-launcher/dist/random-port.js
var import_http = __turbopack_context__.r("[externals]/http [external] (http, cjs)");
function getRandomPort() {
    return new Promise((resolve2, reject)=>{
        const server = (0, import_http.createServer)();
        server.listen(0);
        server.once("listening", ()=>{
            const { port } = server.address();
            server.close(()=>resolve2(port));
        });
        server.once("error", reject);
    });
}
// ../../node_modules/.pnpm/chrome-launcher@1.2.0/node_modules/chrome-launcher/dist/flags.js
var DEFAULT_FLAGS = [
    "--disable-features=" + [
        // Disable built-in Google Translate service
        "Translate",
        // Disable the Chrome Optimization Guide background networking
        "OptimizationHints",
        //  Disable the Chrome Media Router (cast target discovery) background networking
        "MediaRouter",
        /// Avoid the startup dialog for _Do you want the application Chromium.app to accept incoming network connections?_. This is a sub-component of the MediaRouter.
        "DialMediaRouteProvider",
        // Disable the feature of: Calculate window occlusion on Windows will be used in the future to throttle and potentially unload foreground tabs in occluded windows.
        "CalculateNativeWinOcclusion",
        // Disables the Discover feed on NTP
        "InterestFeedContentSuggestions",
        // Don't update the CT lists
        "CertificateTransparencyComponentUpdater",
        // Disables autofill server communication. This feature isn't disabled via other 'parent' flags.
        "AutofillServerCommunication",
        // Disables "Enhanced ad privacy in Chrome" dialog (though as of 2024-03-20 it shouldn't show up if the profile has no stored country).
        "PrivacySandboxSettings4"
    ].join(","),
    // Disable all chrome extensions
    "--disable-extensions",
    // Disable some extensions that aren't affected by --disable-extensions
    "--disable-component-extensions-with-background-pages",
    // Disable various background network services, including extension updating,
    //   safe browsing service, upgrade detector, translate, UMA
    "--disable-background-networking",
    // Don't update the browser 'components' listed at chrome://components/
    "--disable-component-update",
    // Disables client-side phishing detection.
    "--disable-client-side-phishing-detection",
    // Disable syncing to a Google account
    "--disable-sync",
    // Disable reporting to UMA, but allows for collection
    "--metrics-recording-only",
    // Disable installation of default apps on first run
    "--disable-default-apps",
    // Mute any audio
    "--mute-audio",
    // Disable the default browser check, do not prompt to set it as such
    "--no-default-browser-check",
    // Skip first run wizards
    "--no-first-run",
    // Disable backgrounding renders for occluded windows
    "--disable-backgrounding-occluded-windows",
    // Disable renderer process backgrounding
    "--disable-renderer-backgrounding",
    // Disable task throttling of timer tasks from background pages.
    "--disable-background-timer-throttling",
    // Disable the default throttling of IPC between renderer & browser processes.
    "--disable-ipc-flooding-protection",
    // Avoid potential instability of using Gnome Keyring or KDE wallet. crbug.com/571003 crbug.com/991424
    "--password-store=basic",
    // Use mock keychain on Mac to prevent blocking permissions dialogs
    "--use-mock-keychain",
    // Disable background tracing (aka slow reports & deep reports) to avoid 'Tracing already started'
    "--force-fieldtrials=*BackgroundTracing/default/",
    // Suppresses hang monitor dialogs in renderer processes. This flag may allow slow unload handlers on a page to prevent the tab from closing.
    "--disable-hang-monitor",
    // Reloading a page that came from a POST normally prompts the user.
    "--disable-prompt-on-repost",
    // Disables Domain Reliability Monitoring, which tracks whether the browser has difficulty contacting Google-owned sites and uploads reports to Google.
    "--disable-domain-reliability",
    // Disable the in-product Help (IPH) system.
    "--propagate-iph-for-testing"
];
// ../../node_modules/.pnpm/chrome-launcher@1.2.0/node_modules/chrome-launcher/dist/chrome-launcher.js
var import_child_process3 = __turbopack_context__.r("[externals]/child_process [external] (child_process, cjs)");
var isWsl2 = getPlatform() === "wsl";
var isWindows2 = getPlatform() === "win32";
var _SIGINT = "SIGINT";
var _SIGINT_EXIT_CODE = 130;
var _SUPPORTED_PLATFORMS = /* @__PURE__ */ new Set([
    "darwin",
    "linux",
    "win32",
    "wsl"
]);
var instances = /* @__PURE__ */ new Set();
var sigintListener = ()=>{
    killAll();
    process.exit(_SIGINT_EXIT_CODE);
};
function launch() {
    return __async(this, arguments, function*(opts = {}) {
        opts.handleSIGINT = defaults(opts.handleSIGINT, true);
        const instance = new Launcher(opts);
        if (opts.handleSIGINT && instances.size === 0) {
            process.on(_SIGINT, sigintListener);
        }
        instances.add(instance);
        yield instance.launch();
        const kill = ()=>{
            instances.delete(instance);
            if (instances.size === 0) {
                process.removeListener(_SIGINT, sigintListener);
            }
            instance.kill();
        };
        return {
            pid: instance.pid,
            port: instance.port,
            process: instance.chromeProcess,
            remoteDebuggingPipes: instance.remoteDebuggingPipes,
            kill
        };
    });
}
function killAll() {
    let errors = [];
    for (const instance of instances){
        try {
            instance.kill();
            instances.delete(instance);
        } catch (err) {
            errors.push(err);
        }
    }
    return errors;
}
var Launcher = class _Launcher {
    constructor(opts = {}, moduleOverrides = {}){
        this.opts = opts;
        this.tmpDirandPidFileReady = false;
        this.remoteDebuggingPipes = null;
        this.fs = moduleOverrides.fs || fs6;
        this.spawn = moduleOverrides.spawn || import_child_process3.spawn;
        lighthouse_logger_default.setLevel(defaults(this.opts.logLevel, "silent"));
        this.startingUrl = defaults(this.opts.startingUrl, "about:blank");
        this.chromeFlags = defaults(this.opts.chromeFlags, []);
        this.prefs = defaults(this.opts.prefs, {});
        this.requestedPort = defaults(this.opts.port, 0);
        this.portStrictMode = opts.portStrictMode;
        this.chromePath = this.opts.chromePath;
        this.ignoreDefaultFlags = defaults(this.opts.ignoreDefaultFlags, false);
        this.connectionPollInterval = defaults(this.opts.connectionPollInterval, 500);
        this.maxConnectionRetries = defaults(this.opts.maxConnectionRetries, 50);
        this.envVars = defaults(opts.envVars, Object.assign({}, process.env));
        if (typeof this.opts.userDataDir === "boolean") {
            if (!this.opts.userDataDir) {
                this.useDefaultProfile = true;
                this.userDataDir = void 0;
            } else {
                throw new InvalidUserDataDirectoryError();
            }
        } else {
            this.useDefaultProfile = false;
            this.userDataDir = this.opts.userDataDir;
        }
        this.useRemoteDebuggingPipe = this.chromeFlags.some((f)=>f.startsWith("--remote-debugging-pipe"));
    }
    get flags() {
        const flags = this.ignoreDefaultFlags ? [] : DEFAULT_FLAGS.slice();
        if (this.port) {
            flags.push(`--remote-debugging-port=${this.port}`);
        }
        if (!this.ignoreDefaultFlags && getPlatform() === "linux") {
            flags.push("--disable-setuid-sandbox");
        }
        if (!this.useDefaultProfile) {
            flags.push(`--user-data-dir=${isWsl2 ? toWin32Path(this.userDataDir) : this.userDataDir}`);
        }
        if (process.env.HEADLESS) flags.push("--headless");
        flags.push(...this.chromeFlags);
        flags.push(this.startingUrl);
        return flags;
    }
    static defaultFlags() {
        return DEFAULT_FLAGS.slice();
    }
    /** Returns the highest priority chrome installation. */ static getFirstInstallation() {
        if (getPlatform() === "darwin") return darwinFast();
        return chrome_finder_exports[getPlatform()]()[0];
    }
    /** Returns all available chrome installations in decreasing priority order. */ static getInstallations() {
        return chrome_finder_exports[getPlatform()]();
    }
    // Wrapper function to enable easy testing.
    makeTmpDir() {
        return makeTmpDir();
    }
    prepare() {
        const platform = getPlatform();
        if (!_SUPPORTED_PLATFORMS.has(platform)) {
            throw new UnsupportedPlatformError();
        }
        this.userDataDir = this.userDataDir || this.makeTmpDir();
        this.outFile = this.fs.openSync(`${this.userDataDir}/chrome-out.log`, "a");
        this.errFile = this.fs.openSync(`${this.userDataDir}/chrome-err.log`, "a");
        this.setBrowserPrefs();
        this.pidFile = `${this.userDataDir}/chrome.pid`;
        lighthouse_logger_default.verbose("ChromeLauncher", `created ${this.userDataDir}`);
        this.tmpDirandPidFileReady = true;
    }
    setBrowserPrefs() {
        if (Object.keys(this.prefs).length === 0) {
            return;
        }
        const profileDir = `${this.userDataDir}/Default`;
        if (!this.fs.existsSync(profileDir)) {
            this.fs.mkdirSync(profileDir, {
                recursive: true
            });
        }
        const preferenceFile = `${profileDir}/Preferences`;
        try {
            if (this.fs.existsSync(preferenceFile)) {
                const file = this.fs.readFileSync(preferenceFile, "utf-8");
                const content = JSON.parse(file);
                this.fs.writeFileSync(preferenceFile, JSON.stringify(__spreadValues(__spreadValues({}, content), this.prefs)), "utf-8");
            } else {
                this.fs.writeFileSync(preferenceFile, JSON.stringify(__spreadValues({}, this.prefs)), "utf-8");
            }
        } catch (err) {
            lighthouse_logger_default.log("ChromeLauncher", `Failed to set browser prefs: ${err.message}`);
        }
    }
    launch() {
        return __async(this, null, function*() {
            if (this.requestedPort !== 0) {
                this.port = this.requestedPort;
                try {
                    yield this.isDebuggerReady();
                    lighthouse_logger_default.log("ChromeLauncher", `Found existing Chrome already running using port ${this.port}, using that.`);
                    return;
                } catch (err) {
                    if (this.portStrictMode) {
                        throw new Error(`found no Chrome at port ${this.requestedPort}`);
                    }
                    lighthouse_logger_default.log("ChromeLauncher", `No debugging port found on port ${this.port}, launching a new Chrome.`);
                }
            }
            if (this.chromePath === void 0) {
                const installation = _Launcher.getFirstInstallation();
                if (!installation) {
                    throw new ChromeNotInstalledError();
                }
                this.chromePath = installation;
            }
            if (!this.tmpDirandPidFileReady) {
                this.prepare();
            }
            this.pid = yield this.spawnProcess(this.chromePath);
            return Promise.resolve();
        });
    }
    spawnProcess(execPath) {
        return __async(this, null, function*() {
            const spawnPromise = (()=>__async(this, null, function*() {
                    if (this.chromeProcess) {
                        lighthouse_logger_default.log("ChromeLauncher", `Chrome already running with pid ${this.chromeProcess.pid}.`);
                        return this.chromeProcess.pid;
                    }
                    if (this.requestedPort === 0) {
                        if (this.useRemoteDebuggingPipe) {
                            this.port = 0;
                        } else {
                            this.port = yield getRandomPort();
                        }
                    }
                    lighthouse_logger_default.verbose("ChromeLauncher", `Launching with command:
"${execPath}" ${this.flags.join(" ")}`);
                    this.chromeProcess = this.spawn(execPath, this.flags, {
                        // On non-windows platforms, `detached: true` makes child process a leader of a new
                        // process group, making it possible to kill child process tree with `.kill(-pid)` command.
                        // @see https://nodejs.org/api/child_process.html#child_process_options_detached
                        detached: process.platform !== "win32",
                        stdio: this.useRemoteDebuggingPipe ? [
                            "ignore",
                            this.outFile,
                            this.errFile,
                            "pipe",
                            "pipe"
                        ] : [
                            "ignore",
                            this.outFile,
                            this.errFile
                        ],
                        env: this.envVars
                    });
                    if (this.chromeProcess.pid) {
                        this.fs.writeFileSync(this.pidFile, this.chromeProcess.pid.toString());
                    }
                    if (this.useRemoteDebuggingPipe) {
                        this.remoteDebuggingPipes = {
                            incoming: this.chromeProcess.stdio[4],
                            outgoing: this.chromeProcess.stdio[3]
                        };
                    }
                    lighthouse_logger_default.verbose("ChromeLauncher", `Chrome running with pid ${this.chromeProcess.pid} on port ${this.port}.`);
                    return this.chromeProcess.pid;
                }))();
            const pid = yield spawnPromise;
            if (this.port !== 0) {
                yield this.waitUntilReady();
            }
            return pid;
        });
    }
    cleanup(client) {
        if (client) {
            client.removeAllListeners();
            client.end();
            client.destroy();
            client.unref();
        }
    }
    // resolves if ready, rejects otherwise
    isDebuggerReady() {
        return new Promise((resolve2, reject)=>{
            const client = net.createConnection(this.port, "127.0.0.1");
            client.once("error", (err)=>{
                this.cleanup(client);
                reject(err);
            });
            client.once("connect", ()=>{
                this.cleanup(client);
                resolve2();
            });
        });
    }
    // resolves when debugger is ready, rejects after 10 polls
    waitUntilReady() {
        const launcher = this;
        return new Promise((resolve2, reject)=>{
            let retries = 0;
            let waitStatus = "Waiting for browser.";
            const poll = ()=>{
                if (retries === 0) {
                    lighthouse_logger_default.log("ChromeLauncher", waitStatus);
                }
                retries++;
                waitStatus += "..";
                lighthouse_logger_default.log("ChromeLauncher", waitStatus);
                launcher.isDebuggerReady().then(()=>{
                    lighthouse_logger_default.log("ChromeLauncher", waitStatus + `${lighthouse_logger_default.greenify(lighthouse_logger_default.tick)}`);
                    resolve2();
                }).catch((err)=>{
                    if (retries > launcher.maxConnectionRetries) {
                        lighthouse_logger_default.error("ChromeLauncher", err.message);
                        const stderr = this.fs.readFileSync(`${this.userDataDir}/chrome-err.log`, {
                            encoding: "utf-8"
                        });
                        lighthouse_logger_default.error("ChromeLauncher", `Logging contents of ${this.userDataDir}/chrome-err.log`);
                        lighthouse_logger_default.error("ChromeLauncher", stderr);
                        return reject(err);
                    }
                    delay(launcher.connectionPollInterval).then(poll);
                });
            };
            poll();
        });
    }
    kill() {
        if (!this.chromeProcess) {
            return;
        }
        this.chromeProcess.on("close", ()=>{
            delete this.chromeProcess;
            this.destroyTmp();
        });
        lighthouse_logger_default.log("ChromeLauncher", `Killing Chrome instance ${this.chromeProcess.pid}`);
        try {
            if (isWindows2) {
                const taskkillProc = (0, import_child_process3.spawnSync)(`taskkill /pid ${this.chromeProcess.pid} /T /F`, {
                    shell: true,
                    encoding: "utf-8"
                });
                const { stderr } = taskkillProc;
                if (stderr) lighthouse_logger_default.error("ChromeLauncher", `taskkill stderr`, stderr);
            } else {
                if (this.chromeProcess.pid) {
                    process.kill(-this.chromeProcess.pid, "SIGKILL");
                }
            }
        } catch (err) {
            const message = `Chrome could not be killed ${err.message}`;
            lighthouse_logger_default.warn("ChromeLauncher", message);
        }
        this.destroyTmp();
    }
    destroyTmp() {
        if (this.outFile) {
            this.fs.closeSync(this.outFile);
            delete this.outFile;
        }
        if (this.userDataDir === void 0 || this.opts.userDataDir !== void 0) {
            return;
        }
        if (this.errFile) {
            this.fs.closeSync(this.errFile);
            delete this.errFile;
        }
        const rmSync = this.fs.rmSync || this.fs.rmdirSync;
        rmSync(this.userDataDir, {
            recursive: true,
            force: true,
            maxRetries: 10
        });
    }
};
// lib/v3/launch/local.ts
init_sdkErrors();
function launchLocalChrome(opts) {
    return __async(this, null, function*() {
        var _a, _b, _c;
        const headless = (_a = opts.headless) != null ? _a : false;
        const chromeFlags = [
            headless ? "--headless=new" : void 0,
            "--remote-allow-origins=*",
            "--no-first-run",
            "--no-default-browser-check",
            "--disable-dev-shm-usage",
            "--site-per-process",
            opts.userDataDir ? `--user-data-dir=${opts.userDataDir}` : void 0,
            ...(_b = opts.chromeFlags) != null ? _b : []
        ].filter((f)=>typeof f === "string");
        const chrome = yield launch({
            chromePath: opts.chromePath,
            chromeFlags
        });
        const ws = yield waitForWebSocketDebuggerUrl(chrome.port, (_c = opts.connectTimeoutMs) != null ? _c : 15e3);
        return {
            ws,
            chrome
        };
    });
}
function waitForWebSocketDebuggerUrl(port, timeoutMs) {
    return __async(this, null, function*() {
        const deadline = Date.now() + timeoutMs;
        let lastErrMsg = "";
        while(Date.now() < deadline){
            try {
                const resp = yield fetch(`http://127.0.0.1:${port}/json/version`);
                if (resp.ok) {
                    const json = yield resp.json();
                    const url = json.webSocketDebuggerUrl;
                    if (typeof url === "string") return url;
                } else {
                    lastErrMsg = `${resp.status} ${resp.statusText}`;
                }
            } catch (err) {
                lastErrMsg = err instanceof Error ? err.message : String(err);
            }
            yield new Promise((r)=>setTimeout(r, 250));
        }
        throw new ConnectionTimeoutError(`Timed out waiting for /json/version on port ${port}${lastErrMsg ? ` (last error: ${lastErrMsg})` : ""}`);
    });
}
// lib/v3/llm/LLMProvider.ts
init_sdkErrors();
// lib/v3/llm/aisdk.ts
var import_ai13 = __turbopack_context__.r("[project]/node_modules/ai/dist/index.js [app-route] (ecmascript)");
// lib/v3/llm/LLMClient.ts
var import_ai12 = __turbopack_context__.r("[project]/node_modules/ai/dist/index.js [app-route] (ecmascript)");
var AnnotatedScreenshotText = "This is a screenshot of the current page state with the elements annotated on it. Each element id is annotated with a number to the top left of it. Duplicate annotations at the same location are under each other vertically.";
var LLMClient = class {
    constructor(modelName, userProvidedInstructions){
        this.generateObject = import_ai12.generateObject;
        this.generateText = import_ai12.generateText;
        this.streamText = import_ai12.streamText;
        this.streamObject = import_ai12.streamObject;
        this.generateImage = import_ai12.experimental_generateImage;
        this.embed = import_ai12.embed;
        this.embedMany = import_ai12.embedMany;
        this.transcribe = import_ai12.experimental_transcribe;
        this.generateSpeech = import_ai12.experimental_generateSpeech;
        this.modelName = modelName;
        this.userProvidedInstructions = userProvidedInstructions;
    }
};
// lib/v3/llm/aisdk.ts
var AISdkClient = class extends LLMClient {
    constructor({ model, logger }){
        super(model.modelId);
        this.type = "aisdk";
        this.model = model;
        this.logger = logger;
    }
    getLanguageModel() {
        return this.model;
    }
    createChatCompletion(_0) {
        return __async(this, arguments, function*({ options }) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;
            (_a = this.logger) == null ? void 0 : _a.call(this, {
                category: "aisdk",
                message: "creating chat completion",
                level: 2,
                auxiliary: {
                    options: {
                        value: JSON.stringify(__spreadProps(__spreadValues({}, options), {
                            image: void 0,
                            messages: options.messages.map((msg)=>__spreadProps(__spreadValues({}, msg), {
                                    content: Array.isArray(msg.content) ? msg.content.map((c)=>"image_url" in c ? __spreadProps(__spreadValues({}, c), {
                                            image_url: {
                                                url: "[IMAGE_REDACTED]"
                                            }
                                        }) : c) : msg.content
                                }))
                        })),
                        type: "object"
                    },
                    modelName: {
                        value: this.model.modelId,
                        type: "string"
                    }
                }
            });
            const formattedMessages = options.messages.map((message)=>{
                if (Array.isArray(message.content)) {
                    if (message.role === "system") {
                        const systemMessage = {
                            role: "system",
                            content: message.content.map((c)=>"text" in c ? c.text : "").join("\n")
                        };
                        return systemMessage;
                    }
                    const contentParts = message.content.map((content)=>{
                        if ("image_url" in content) {
                            const imageContent = {
                                type: "image",
                                image: content.image_url.url
                            };
                            return imageContent;
                        } else {
                            const textContent = {
                                type: "text",
                                text: content.text
                            };
                            return textContent;
                        }
                    });
                    if (message.role === "user") {
                        const userMessage = {
                            role: "user",
                            content: contentParts
                        };
                        return userMessage;
                    } else {
                        const textOnlyParts = contentParts.map((part)=>({
                                type: "text",
                                text: part.type === "image" ? "[Image]" : part.text
                            }));
                        const assistantMessage = {
                            role: "assistant",
                            content: textOnlyParts
                        };
                        return assistantMessage;
                    }
                }
                return {
                    role: message.role,
                    content: message.content
                };
            });
            let objectResponse;
            const isGPT5 = this.model.modelId.includes("gpt-5");
            if (options.response_model) {
                try {
                    objectResponse = yield (0, import_ai13.generateObject)({
                        model: this.model,
                        messages: formattedMessages,
                        schema: options.response_model.schema,
                        temperature: options.temperature,
                        providerOptions: isGPT5 ? {
                            openai: {
                                textVerbosity: "low",
                                // Making these the default for gpt-5 for now
                                reasoningEffort: "minimal"
                            }
                        } : void 0
                    });
                } catch (err) {
                    if (import_ai13.NoObjectGeneratedError.isInstance(err)) {
                        (_g = this.logger) == null ? void 0 : _g.call(this, {
                            category: "AISDK error",
                            message: err.message,
                            level: 0,
                            auxiliary: {
                                cause: {
                                    value: JSON.stringify((_b = err.cause) != null ? _b : {}),
                                    type: "object"
                                },
                                text: {
                                    value: (_c = err.text) != null ? _c : "",
                                    type: "string"
                                },
                                response: {
                                    value: JSON.stringify((_d = err.response) != null ? _d : {}),
                                    type: "object"
                                },
                                usage: {
                                    value: JSON.stringify((_e = err.usage) != null ? _e : {}),
                                    type: "object"
                                },
                                finishReason: {
                                    value: (_f = err.finishReason) != null ? _f : "unknown",
                                    type: "string"
                                },
                                requestId: {
                                    value: options.requestId,
                                    type: "string"
                                }
                            }
                        });
                        throw err;
                    }
                    throw err;
                }
                const result2 = {
                    data: objectResponse.object,
                    usage: {
                        prompt_tokens: (_h = objectResponse.usage.inputTokens) != null ? _h : 0,
                        completion_tokens: (_i = objectResponse.usage.outputTokens) != null ? _i : 0,
                        reasoning_tokens: (_j = objectResponse.usage.reasoningTokens) != null ? _j : 0,
                        cached_input_tokens: (_k = objectResponse.usage.cachedInputTokens) != null ? _k : 0,
                        total_tokens: (_l = objectResponse.usage.totalTokens) != null ? _l : 0
                    }
                };
                (_m = this.logger) == null ? void 0 : _m.call(this, {
                    category: "aisdk",
                    message: "response",
                    level: 1,
                    auxiliary: {
                        response: {
                            value: JSON.stringify({
                                object: objectResponse.object,
                                usage: objectResponse.usage,
                                finishReason: objectResponse.finishReason
                            }),
                            type: "object"
                        },
                        requestId: {
                            value: options.requestId,
                            type: "string"
                        }
                    }
                });
                return result2;
            }
            const tools = {};
            if (options.tools && options.tools.length > 0) {
                for (const tool12 of options.tools){
                    tools[tool12.name] = {
                        description: tool12.description,
                        inputSchema: tool12.parameters
                    };
                }
            }
            const textResponse = yield (0, import_ai13.generateText)({
                model: this.model,
                messages: formattedMessages,
                tools: Object.keys(tools).length > 0 ? tools : void 0,
                toolChoice: Object.keys(tools).length > 0 ? options.tool_choice === "required" ? "required" : options.tool_choice === "none" ? "none" : "auto" : void 0,
                temperature: options.temperature
            });
            const transformedToolCalls = (textResponse.toolCalls || []).map((toolCall)=>({
                    id: toolCall.toolCallId || `call_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    type: "function",
                    function: {
                        name: toolCall.toolName,
                        arguments: JSON.stringify(toolCall.input)
                    }
                }));
            const result = {
                id: `chatcmpl_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                object: "chat.completion",
                created: Math.floor(Date.now() / 1e3),
                model: this.model.modelId,
                choices: [
                    {
                        index: 0,
                        message: {
                            role: "assistant",
                            content: textResponse.text || null,
                            tool_calls: transformedToolCalls
                        },
                        finish_reason: textResponse.finishReason || "stop"
                    }
                ],
                usage: {
                    prompt_tokens: (_n = textResponse.usage.inputTokens) != null ? _n : 0,
                    completion_tokens: (_o = textResponse.usage.outputTokens) != null ? _o : 0,
                    reasoning_tokens: (_p = textResponse.usage.reasoningTokens) != null ? _p : 0,
                    cached_input_tokens: (_q = textResponse.usage.cachedInputTokens) != null ? _q : 0,
                    total_tokens: (_r = textResponse.usage.totalTokens) != null ? _r : 0
                }
            };
            (_s = this.logger) == null ? void 0 : _s.call(this, {
                category: "aisdk",
                message: "response",
                level: 2,
                auxiliary: {
                    response: {
                        value: JSON.stringify({
                            text: textResponse.text,
                            usage: textResponse.usage,
                            finishReason: textResponse.finishReason
                        }),
                        type: "object"
                    },
                    requestId: {
                        value: options.requestId,
                        type: "string"
                    }
                }
            });
            return result;
        });
    }
};
// lib/v3/llm/AnthropicClient.ts
var import_sdk3 = __toESM(__turbopack_context__.r("[project]/node_modules/@anthropic-ai/sdk/index.js [app-route] (ecmascript)"));
var import_zod_to_json_schema3 = __turbopack_context__.r("[project]/node_modules/zod-to-json-schema/dist/cjs/index.js [app-route] (ecmascript)");
init_sdkErrors();
var AnthropicClient = class extends LLMClient {
    constructor({ modelName, clientOptions, userProvidedInstructions }){
        super(modelName);
        this.type = "anthropic";
        this.client = new import_sdk3.default(clientOptions);
        this.modelName = modelName;
        this.clientOptions = clientOptions;
        this.userProvidedInstructions = userProvidedInstructions;
    }
    createChatCompletion(_0) {
        return __async(this, arguments, function*({ options, retries, logger }) {
            var _a, _b;
            const optionsWithoutImage = __spreadValues({}, options);
            delete optionsWithoutImage.image;
            logger({
                category: "anthropic",
                message: "creating chat completion",
                level: 2,
                auxiliary: {
                    options: {
                        value: JSON.stringify(optionsWithoutImage),
                        type: "object"
                    }
                }
            });
            const systemMessage = options.messages.find((msg)=>{
                if (msg.role === "system") {
                    if (typeof msg.content === "string") {
                        return true;
                    } else if (Array.isArray(msg.content)) {
                        return msg.content.every((content)=>content.type !== "image_url");
                    }
                }
                return false;
            });
            const userMessages = options.messages.filter((msg)=>msg.role !== "system");
            const formattedMessages = userMessages.map((msg)=>{
                if (typeof msg.content === "string") {
                    return {
                        role: msg.role,
                        // ensure its not checking for system types
                        content: msg.content
                    };
                } else {
                    return {
                        role: msg.role,
                        content: msg.content.map((content)=>{
                            if ("image_url" in content) {
                                const formattedContent = {
                                    type: "image",
                                    source: {
                                        type: "base64",
                                        media_type: "image/jpeg",
                                        data: content.image_url.url
                                    }
                                };
                                return formattedContent;
                            } else {
                                return {
                                    type: "text",
                                    text: content.text
                                };
                            }
                        })
                    };
                }
            });
            if (options.image) {
                const screenshotMessage = {
                    role: "user",
                    content: [
                        {
                            type: "image",
                            source: {
                                type: "base64",
                                media_type: "image/jpeg",
                                data: options.image.buffer.toString("base64")
                            }
                        }
                    ]
                };
                if (options.image.description && Array.isArray(screenshotMessage.content)) {
                    screenshotMessage.content.push({
                        type: "text",
                        text: options.image.description
                    });
                }
                formattedMessages.push(screenshotMessage);
            }
            let anthropicTools2 = (_a = options.tools) == null ? void 0 : _a.map((tool12)=>{
                return {
                    name: tool12.name,
                    description: tool12.description,
                    input_schema: {
                        type: "object",
                        properties: tool12.parameters.properties,
                        required: tool12.parameters.required
                    }
                };
            });
            let toolDefinition;
            if (options.response_model) {
                const jsonSchema2 = (0, import_zod_to_json_schema3.zodToJsonSchema)(options.response_model.schema);
                const { properties: schemaProperties, required: schemaRequired } = extractSchemaProperties(jsonSchema2);
                toolDefinition = {
                    name: "print_extracted_data",
                    description: "Prints the extracted data based on the provided schema.",
                    input_schema: {
                        type: "object",
                        properties: schemaProperties,
                        required: schemaRequired
                    }
                };
            }
            if (toolDefinition) {
                anthropicTools2 = anthropicTools2 != null ? anthropicTools2 : [];
                anthropicTools2.push(toolDefinition);
            }
            const response = yield this.client.messages.create({
                model: this.modelName,
                max_tokens: options.maxOutputTokens || 8192,
                messages: formattedMessages,
                tools: anthropicTools2,
                system: systemMessage ? systemMessage.content : void 0,
                temperature: options.temperature
            });
            logger({
                category: "anthropic",
                message: "response",
                level: 2,
                auxiliary: {
                    response: {
                        value: JSON.stringify(response),
                        type: "object"
                    },
                    requestId: {
                        value: options.requestId,
                        type: "string"
                    }
                }
            });
            const usageData = {
                prompt_tokens: response.usage.input_tokens,
                completion_tokens: response.usage.output_tokens,
                total_tokens: response.usage.input_tokens + response.usage.output_tokens
            };
            const transformedResponse = {
                id: response.id,
                object: "chat.completion",
                created: Date.now(),
                model: response.model,
                choices: [
                    {
                        index: 0,
                        message: {
                            role: "assistant",
                            content: ((_b = response.content.find((c)=>c.type === "text")) == null ? void 0 : _b.text) || null,
                            tool_calls: response.content.filter((c)=>c.type === "tool_use").map((toolUse)=>({
                                    id: toolUse.id,
                                    type: "function",
                                    function: {
                                        name: toolUse.name,
                                        arguments: JSON.stringify(toolUse.input)
                                    }
                                }))
                        },
                        finish_reason: response.stop_reason
                    }
                ],
                usage: usageData
            };
            logger({
                category: "anthropic",
                message: "transformed response",
                level: 2,
                auxiliary: {
                    transformedResponse: {
                        value: JSON.stringify(transformedResponse),
                        type: "object"
                    },
                    requestId: {
                        value: options.requestId,
                        type: "string"
                    }
                }
            });
            if (options.response_model) {
                const toolUse = response.content.find((c)=>c.type === "tool_use");
                if (toolUse && "input" in toolUse) {
                    const result = toolUse.input;
                    const finalParsedResponse = {
                        data: result,
                        usage: usageData
                    };
                    return finalParsedResponse;
                } else {
                    if (!retries || retries < 5) {
                        return this.createChatCompletion({
                            options,
                            logger,
                            retries: (retries != null ? retries : 0) + 1
                        });
                    }
                    logger({
                        category: "anthropic",
                        message: "error creating chat completion",
                        level: 0,
                        auxiliary: {
                            requestId: {
                                value: options.requestId,
                                type: "string"
                            }
                        }
                    });
                    throw new CreateChatCompletionResponseError("No tool use with input in response");
                }
            }
            return transformedResponse;
        });
    }
};
var extractSchemaProperties = (jsonSchema2)=>{
    var _a;
    const schemaRoot = ((_a = jsonSchema2.definitions) == null ? void 0 : _a.MySchema) || jsonSchema2;
    return {
        properties: schemaRoot.properties,
        required: schemaRoot.required
    };
};
// lib/v3/llm/CerebrasClient.ts
var import_openai2 = __toESM(__turbopack_context__.r("[project]/node_modules/openai/index.js [app-route] (ecmascript)"));
var import_zod_to_json_schema4 = __turbopack_context__.r("[project]/node_modules/zod-to-json-schema/dist/cjs/index.js [app-route] (ecmascript)");
init_sdkErrors();
var CerebrasClient = class extends LLMClient {
    constructor({ modelName, clientOptions, userProvidedInstructions }){
        super(modelName, userProvidedInstructions);
        this.type = "cerebras";
        this.hasVision = false;
        this.client = new import_openai2.default(__spreadValues({
            baseURL: "https://api.cerebras.ai/v1",
            apiKey: (clientOptions == null ? void 0 : clientOptions.apiKey) || process.env.CEREBRAS_API_KEY
        }, clientOptions));
        this.modelName = modelName;
        this.clientOptions = clientOptions;
    }
    createChatCompletion(_0) {
        return __async(this, arguments, function*({ options, retries, logger }) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
            const optionsWithoutImage = __spreadValues({}, options);
            delete optionsWithoutImage.image;
            logger({
                category: "cerebras",
                message: "creating chat completion",
                level: 2,
                auxiliary: {
                    options: {
                        value: JSON.stringify(optionsWithoutImage),
                        type: "object"
                    }
                }
            });
            const formattedMessages = options.messages.map((msg)=>{
                const baseMessage = {
                    content: typeof msg.content === "string" ? msg.content : Array.isArray(msg.content) && msg.content.length > 0 && "text" in msg.content[0] ? msg.content[0].text : ""
                };
                if (msg.role === "system") {
                    return __spreadProps(__spreadValues({}, baseMessage), {
                        role: "system"
                    });
                } else if (msg.role === "assistant") {
                    return __spreadProps(__spreadValues({}, baseMessage), {
                        role: "assistant"
                    });
                } else {
                    return __spreadProps(__spreadValues({}, baseMessage), {
                        role: "user"
                    });
                }
            });
            let tools = (_a = options.tools) == null ? void 0 : _a.map((tool12)=>({
                    type: "function",
                    function: {
                        name: tool12.name,
                        description: tool12.description,
                        parameters: {
                            type: "object",
                            properties: tool12.parameters.properties,
                            required: tool12.parameters.required
                        }
                    }
                }));
            if (options.response_model) {
                const jsonSchema2 = (0, import_zod_to_json_schema4.zodToJsonSchema)(options.response_model.schema);
                const schemaProperties = jsonSchema2.properties || {};
                const schemaRequired = jsonSchema2.required || [];
                const responseTool = {
                    type: "function",
                    function: {
                        name: "print_extracted_data",
                        description: "Prints the extracted data based on the provided schema.",
                        parameters: {
                            type: "object",
                            properties: schemaProperties,
                            required: schemaRequired
                        }
                    }
                };
                tools = tools ? [
                    ...tools,
                    responseTool
                ] : [
                    responseTool
                ];
            }
            try {
                const apiResponse = yield this.client.chat.completions.create({
                    model: this.modelName.split("cerebras-")[1],
                    messages: [
                        ...formattedMessages,
                        // Add explicit instruction to return JSON if we have a response model
                        ...options.response_model ? [
                            {
                                role: "system",
                                content: `IMPORTANT: Your response must be valid JSON that matches this schema: ${JSON.stringify(options.response_model.schema)}`
                            }
                        ] : []
                    ],
                    temperature: options.temperature || 0.7,
                    max_tokens: options.maxOutputTokens,
                    tools,
                    tool_choice: options.tool_choice || "auto"
                });
                const response = {
                    id: apiResponse.id,
                    object: "chat.completion",
                    created: Date.now(),
                    model: this.modelName.split("cerebras-")[1],
                    choices: [
                        {
                            index: 0,
                            message: {
                                role: "assistant",
                                content: ((_c = (_b = apiResponse.choices[0]) == null ? void 0 : _b.message) == null ? void 0 : _c.content) || null,
                                tool_calls: ((_e = (_d = apiResponse.choices[0]) == null ? void 0 : _d.message) == null ? void 0 : _e.tool_calls) || []
                            },
                            finish_reason: ((_f = apiResponse.choices[0]) == null ? void 0 : _f.finish_reason) || "stop"
                        }
                    ],
                    usage: {
                        prompt_tokens: ((_g = apiResponse.usage) == null ? void 0 : _g.prompt_tokens) || 0,
                        completion_tokens: ((_h = apiResponse.usage) == null ? void 0 : _h.completion_tokens) || 0,
                        total_tokens: ((_i = apiResponse.usage) == null ? void 0 : _i.total_tokens) || 0
                    }
                };
                logger({
                    category: "cerebras",
                    message: "response",
                    level: 2,
                    auxiliary: {
                        response: {
                            value: JSON.stringify(response),
                            type: "object"
                        },
                        requestId: {
                            value: options.requestId,
                            type: "string"
                        }
                    }
                });
                if (!options.response_model) {
                    return response;
                }
                const toolCall = (_l = (_k = (_j = response.choices[0]) == null ? void 0 : _j.message) == null ? void 0 : _k.tool_calls) == null ? void 0 : _l[0];
                if ((_m = toolCall == null ? void 0 : toolCall.function) == null ? void 0 : _m.arguments) {
                    try {
                        const result = JSON.parse(toolCall.function.arguments);
                        const finalResponse = {
                            data: result,
                            usage: response.usage
                        };
                        return finalResponse;
                    } catch (e) {
                        logger({
                            category: "cerebras",
                            message: "failed to parse tool call arguments as JSON, retrying",
                            level: 0,
                            auxiliary: {
                                error: {
                                    value: e.message,
                                    type: "string"
                                }
                            }
                        });
                    }
                }
                const content = (_o = (_n = response.choices[0]) == null ? void 0 : _n.message) == null ? void 0 : _o.content;
                if (content) {
                    try {
                        const jsonMatch = content.match(/\{[\s\S]*\}/);
                        if (jsonMatch) {
                            const result = JSON.parse(jsonMatch[0]);
                            const finalResponse = {
                                data: result,
                                usage: response.usage
                            };
                            return finalResponse;
                        }
                    } catch (e) {
                        logger({
                            category: "cerebras",
                            message: "failed to parse content as JSON",
                            level: 0,
                            auxiliary: {
                                error: {
                                    value: e.message,
                                    type: "string"
                                }
                            }
                        });
                    }
                }
                if (!retries || retries < 5) {
                    return this.createChatCompletion({
                        options,
                        logger,
                        retries: (retries != null ? retries : 0) + 1
                    });
                }
                throw new CreateChatCompletionResponseError("Invalid response schema");
            } catch (error) {
                logger({
                    category: "cerebras",
                    message: "error creating chat completion",
                    level: 0,
                    auxiliary: {
                        error: {
                            value: error.message,
                            type: "string"
                        },
                        requestId: {
                            value: options.requestId,
                            type: "string"
                        }
                    }
                });
                throw error;
            }
        });
    }
};
// lib/v3/llm/GoogleClient.ts
var import_genai4 = __turbopack_context__.r("[project]/node_modules/@google/genai/dist/node/index.cjs [app-route] (ecmascript)");
init_sdkErrors();
var roleMap = {
    user: "user",
    assistant: "model",
    system: "user"
};
var safetySettings = [
    {
        category: import_genai4.HarmCategory.HARM_CATEGORY_HARASSMENT,
        threshold: import_genai4.HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE
    },
    {
        category: import_genai4.HarmCategory.HARM_CATEGORY_HATE_SPEECH,
        threshold: import_genai4.HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE
    },
    {
        category: import_genai4.HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
        threshold: import_genai4.HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE
    },
    {
        category: import_genai4.HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
        threshold: import_genai4.HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE
    }
];
var GoogleClient = class extends LLMClient {
    constructor({ logger, // Added logger based on other clients
    modelName, clientOptions }){
        super(modelName);
        this.type = "google";
        if (!(clientOptions == null ? void 0 : clientOptions.apiKey)) {
            clientOptions.apiKey = loadApiKeyFromEnv("google_legacy", logger);
        }
        this.clientOptions = clientOptions;
        this.client = new import_genai4.GoogleGenAI({
            apiKey: clientOptions.apiKey
        });
        this.modelName = modelName;
        this.logger = logger;
        this.hasVision = modelName.includes("vision") || modelName.includes("gemini-1.5");
    }
    // Helper to convert project's ChatMessage[] to Gemini's Content[]
    formatMessages(messages, image) {
        const contents = [];
        let systemInstruction = null;
        messages.forEach((msg, index)=>{
            const role = roleMap[msg.role];
            if (!role) {
                this.logger({
                    category: "google",
                    message: `WARNING: Unsupported role: ${msg.role}`,
                    level: 1
                });
                return;
            }
            if (msg.role === "system") {
                if (typeof msg.content === "string") {
                    systemInstruction = (systemInstruction ? systemInstruction + "\n\n" : "") + msg.content;
                }
                return;
            }
            const parts = [];
            if (Array.isArray(msg.content)) {
                msg.content.forEach((partContent)=>{
                    var _a;
                    if (partContent.type === "text") {
                        parts.push({
                            text: partContent.text
                        });
                    } else if (partContent.type === "image_url") {
                        if ("image_url" in partContent && ((_a = partContent.image_url) == null ? void 0 : _a.url)) {
                            const base64Data = partContent.image_url.url.split(",")[1];
                            const mimeTypeMatch = partContent.image_url.url.match(/^data:(image\/\w+);base64,/);
                            if (base64Data && mimeTypeMatch) {
                                parts.push({
                                    inlineData: {
                                        mimeType: mimeTypeMatch[1],
                                        data: base64Data
                                    }
                                });
                            } else {
                                this.logger({
                                    category: "google",
                                    message: "WARNING: Could not parse image data URI format",
                                    level: 1
                                });
                            }
                        }
                    }
                });
            } else if (typeof msg.content === "string") {
                parts.push({
                    text: msg.content
                });
            }
            if (image && index === messages.length - 1 && msg.role === "user") {
                const imageDesc = image.description || AnnotatedScreenshotText;
                parts.push({
                    text: imageDesc
                });
                parts.push({
                    inlineData: {
                        mimeType: "image/jpeg",
                        // Assuming JPEG, adjust if needed
                        data: image.buffer.toString("base64")
                    }
                });
            }
            if (systemInstruction && contents.length === 0 && role === "user") {
                const firstPartText = parts.find((p)=>"text" in p);
                if (firstPartText && "text" in firstPartText) {
                    firstPartText.text = `${systemInstruction}

${firstPartText.text}`;
                } else {
                    parts.unshift({
                        text: systemInstruction
                    });
                }
                systemInstruction = null;
            }
            if (parts.length > 0) {
                contents.push({
                    role,
                    parts
                });
            }
        });
        if (systemInstruction) {
            contents.unshift({
                role: "user",
                parts: [
                    {
                        text: systemInstruction
                    }
                ]
            });
        }
        return contents;
    }
    // Helper to convert LLMTool[] to Gemini's Tool[]
    formatTools(tools) {
        if (!tools || tools.length === 0) {
            return void 0;
        }
        return [
            {
                functionDeclarations: tools.map((tool12)=>{
                    let parameters = void 0;
                    if (tool12.parameters) {
                        parameters = {
                            type: import_genai4.Type.OBJECT,
                            properties: tool12.parameters.properties,
                            required: tool12.parameters.required
                        };
                    }
                    return {
                        name: tool12.name,
                        description: tool12.description,
                        parameters
                    };
                })
            }
        ];
    }
    createChatCompletion(_0) {
        return __async(this, arguments, function*({ // Ensure LLMResponse is compatible
        options, logger, retries = 3 }) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _i;
            const { image, requestId, response_model, tools, temperature, top_p, maxOutputTokens } = options;
            const formattedMessages = this.formatMessages(options.messages, image);
            const formattedTools = this.formatTools(tools);
            const generationConfig = {
                maxOutputTokens,
                temperature,
                topP: top_p,
                responseMimeType: response_model ? "application/json" : void 0,
                responseSchema: response_model ? toGeminiSchema(response_model.schema) : void 0
            };
            logger({
                category: "google",
                message: "creating chat completion",
                level: 2,
                auxiliary: {
                    modelName: {
                        value: this.modelName,
                        type: "string"
                    },
                    requestId: {
                        value: requestId,
                        type: "string"
                    },
                    requestPayloadSummary: {
                        value: `Model: ${this.modelName}, Messages: ${formattedMessages.length}, Config Keys: ${Object.keys(generationConfig).join(", ")}, Tools: ${formattedTools ? formattedTools.length : 0}, Safety Categories: ${safetySettings.map((s)=>s.category).join(", ")}`,
                        type: "string"
                    }
                }
            });
            const requestPayload = {
                model: this.modelName,
                contents: formattedMessages,
                config: __spreadProps(__spreadValues({}, generationConfig), {
                    safetySettings,
                    tools: formattedTools
                })
            };
            try {
                logger({
                    category: "google",
                    message: "Full request payload",
                    level: 2,
                    auxiliary: {
                        requestId: {
                            value: requestId,
                            type: "string"
                        },
                        fullPayload: {
                            value: JSON.stringify(requestPayload),
                            type: "object"
                        }
                    }
                });
            } catch (e) {
                logger({
                    category: "google",
                    message: "Failed to stringify full request payload for logging",
                    level: 0,
                    auxiliary: {
                        requestId: {
                            value: requestId,
                            type: "string"
                        },
                        error: {
                            value: e.message,
                            type: "string"
                        }
                    }
                });
            }
            try {
                const result = yield this.client.models.generateContent(requestPayload);
                logger({
                    category: "google",
                    message: "received response",
                    level: 2,
                    auxiliary: {
                        requestId: {
                            value: requestId,
                            type: "string"
                        },
                        response: {
                            value: JSON.stringify(result),
                            type: "object"
                        }
                    }
                });
                const finishReason = ((_b = (_a = result.candidates) == null ? void 0 : _a[0]) == null ? void 0 : _b.finishReason) || "unknown";
                const toolCalls = (_c = result.functionCalls) == null ? void 0 : _c.map((fc, index)=>({
                        id: `tool_call_${requestId}_${index}`,
                        type: "function",
                        function: {
                            name: fc.name,
                            arguments: JSON.stringify(fc.args)
                        }
                    }));
                let content = null;
                try {
                    content = result.text;
                } catch (e) {
                    logger({
                        category: "google",
                        message: `Could not extract text content: ${e.message}`,
                        level: 1,
                        auxiliary: {
                            requestId: {
                                value: requestId,
                                type: "string"
                            }
                        }
                    });
                    content = null;
                }
                const llmResponse = {
                    id: ((_f = (_e = (_d = result.candidates) == null ? void 0 : _d[0]) == null ? void 0 : _e.index) == null ? void 0 : _f.toString()) || requestId,
                    object: "chat.completion",
                    created: Math.floor(Date.now() / 1e3),
                    model: this.modelName,
                    choices: [
                        {
                            index: 0,
                            message: {
                                role: "assistant",
                                content,
                                tool_calls: toolCalls
                            },
                            finish_reason: finishReason
                        }
                    ],
                    usage: {
                        prompt_tokens: ((_g = result.usageMetadata) == null ? void 0 : _g.promptTokenCount) || 0,
                        completion_tokens: ((_h = result.usageMetadata) == null ? void 0 : _h.candidatesTokenCount) || 0,
                        total_tokens: ((_i = result.usageMetadata) == null ? void 0 : _i.totalTokenCount) || 0
                    }
                };
                if (response_model) {
                    let parsedData;
                    try {
                        const potentialJson = (content == null ? void 0 : content.trim().replace(/^```json\n?|\n?```$/g, "")) || "{}";
                        parsedData = JSON.parse(potentialJson);
                    } catch (e) {
                        logger({
                            category: "google",
                            message: `Failed to parse JSON response: ${e.message}`,
                            level: 0,
                            auxiliary: {
                                content: {
                                    value: content || "null",
                                    type: "string"
                                }
                            }
                        });
                        if (retries > 0) {
                            return this.createChatCompletion({
                                options,
                                logger,
                                retries: retries - 1
                            });
                        }
                        throw new CreateChatCompletionResponseError(`Failed to parse JSON response: ${e.message}`);
                    }
                    try {
                        validateZodSchema(response_model.schema, parsedData);
                    } catch (err) {
                        logger({
                            category: "google",
                            message: "Response failed Zod schema validation",
                            level: 0
                        });
                        if (retries > 0) {
                            return this.createChatCompletion({
                                options,
                                logger,
                                retries: retries - 1
                            });
                        }
                        throw err;
                    }
                    const extractionResult = {
                        data: parsedData,
                        usage: llmResponse.usage
                    };
                    return extractionResult;
                }
                return llmResponse;
            } catch (error) {
                logger({
                    category: "google",
                    message: `Error during Google AI chat completion: ${error.message}`,
                    level: 0,
                    auxiliary: {
                        errorDetails: {
                            value: `Message: ${error.message}${error.stack ? "\nStack: " + error.stack : ""}`,
                            type: "string"
                        },
                        requestId: {
                            value: requestId,
                            type: "string"
                        }
                    }
                });
                if (retries > 0) {
                    logger({
                        category: "google",
                        message: `Retrying... (${retries} attempts left)`,
                        level: 1
                    });
                    yield new Promise((resolve2)=>setTimeout(resolve2, 1e3 * (4 - retries)));
                    return this.createChatCompletion({
                        options,
                        logger,
                        retries: retries - 1
                    });
                }
                if (error instanceof StagehandError) {
                    throw error;
                }
                throw new StagehandError(`Google AI API request failed: ${error.message}`);
            }
        });
    }
};
// lib/v3/llm/GroqClient.ts
var import_openai3 = __toESM(__turbopack_context__.r("[project]/node_modules/openai/index.js [app-route] (ecmascript)"));
var import_zod_to_json_schema5 = __turbopack_context__.r("[project]/node_modules/zod-to-json-schema/dist/cjs/index.js [app-route] (ecmascript)");
init_sdkErrors();
var GroqClient = class extends LLMClient {
    constructor({ modelName, clientOptions, userProvidedInstructions }){
        super(modelName, userProvidedInstructions);
        this.type = "groq";
        this.hasVision = false;
        this.client = new import_openai3.default(__spreadValues({
            baseURL: "https://api.groq.com/openai/v1",
            apiKey: (clientOptions == null ? void 0 : clientOptions.apiKey) || process.env.GROQ_API_KEY
        }, clientOptions));
        this.modelName = modelName;
        this.clientOptions = clientOptions;
    }
    createChatCompletion(_0) {
        return __async(this, arguments, function*({ options, retries, logger }) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
            const optionsWithoutImage = __spreadValues({}, options);
            delete optionsWithoutImage.image;
            logger({
                category: "groq",
                message: "creating chat completion",
                level: 2,
                auxiliary: {
                    options: {
                        value: JSON.stringify(optionsWithoutImage),
                        type: "object"
                    }
                }
            });
            const formattedMessages = options.messages.map((msg)=>{
                const baseMessage = {
                    content: typeof msg.content === "string" ? msg.content : Array.isArray(msg.content) && msg.content.length > 0 && "text" in msg.content[0] ? msg.content[0].text : ""
                };
                if (msg.role === "system") {
                    return __spreadProps(__spreadValues({}, baseMessage), {
                        role: "system"
                    });
                } else if (msg.role === "assistant") {
                    return __spreadProps(__spreadValues({}, baseMessage), {
                        role: "assistant"
                    });
                } else {
                    return __spreadProps(__spreadValues({}, baseMessage), {
                        role: "user"
                    });
                }
            });
            let tools = (_a = options.tools) == null ? void 0 : _a.map((tool12)=>({
                    type: "function",
                    function: {
                        name: tool12.name,
                        description: tool12.description,
                        parameters: {
                            type: "object",
                            properties: tool12.parameters.properties,
                            required: tool12.parameters.required
                        }
                    }
                }));
            if (options.response_model) {
                const jsonSchema2 = (0, import_zod_to_json_schema5.zodToJsonSchema)(options.response_model.schema);
                const schemaProperties = jsonSchema2.properties || {};
                const schemaRequired = jsonSchema2.required || [];
                const responseTool = {
                    type: "function",
                    function: {
                        name: "print_extracted_data",
                        description: "Prints the extracted data based on the provided schema.",
                        parameters: {
                            type: "object",
                            properties: schemaProperties,
                            required: schemaRequired
                        }
                    }
                };
                tools = tools ? [
                    ...tools,
                    responseTool
                ] : [
                    responseTool
                ];
            }
            try {
                const apiResponse = yield this.client.chat.completions.create({
                    model: this.modelName.split("groq-")[1],
                    messages: [
                        ...formattedMessages,
                        // Add explicit instruction to return JSON if we have a response model
                        ...options.response_model ? [
                            {
                                role: "system",
                                content: `IMPORTANT: Your response must be valid JSON that matches this schema: ${JSON.stringify(options.response_model.schema)}`
                            }
                        ] : []
                    ],
                    temperature: options.temperature || 0.7,
                    max_tokens: options.maxOutputTokens,
                    tools,
                    tool_choice: options.tool_choice || "auto"
                });
                const response = {
                    id: apiResponse.id,
                    object: "chat.completion",
                    created: Date.now(),
                    model: this.modelName.split("groq-")[1],
                    choices: [
                        {
                            index: 0,
                            message: {
                                role: "assistant",
                                content: ((_c = (_b = apiResponse.choices[0]) == null ? void 0 : _b.message) == null ? void 0 : _c.content) || null,
                                tool_calls: ((_e = (_d = apiResponse.choices[0]) == null ? void 0 : _d.message) == null ? void 0 : _e.tool_calls) || []
                            },
                            finish_reason: ((_f = apiResponse.choices[0]) == null ? void 0 : _f.finish_reason) || "stop"
                        }
                    ],
                    usage: {
                        prompt_tokens: ((_g = apiResponse.usage) == null ? void 0 : _g.prompt_tokens) || 0,
                        completion_tokens: ((_h = apiResponse.usage) == null ? void 0 : _h.completion_tokens) || 0,
                        total_tokens: ((_i = apiResponse.usage) == null ? void 0 : _i.total_tokens) || 0
                    }
                };
                logger({
                    category: "groq",
                    message: "response",
                    level: 2,
                    auxiliary: {
                        response: {
                            value: JSON.stringify(response),
                            type: "object"
                        },
                        requestId: {
                            value: options.requestId,
                            type: "string"
                        }
                    }
                });
                if (!options.response_model) {
                    return response;
                }
                const toolCall = (_l = (_k = (_j = response.choices[0]) == null ? void 0 : _j.message) == null ? void 0 : _k.tool_calls) == null ? void 0 : _l[0];
                if ((_m = toolCall == null ? void 0 : toolCall.function) == null ? void 0 : _m.arguments) {
                    try {
                        const result = JSON.parse(toolCall.function.arguments);
                        const finalResponse = {
                            data: result,
                            usage: response.usage
                        };
                        return finalResponse;
                    } catch (e) {
                        logger({
                            category: "groq",
                            message: "failed to parse tool call arguments as JSON, retrying",
                            level: 0,
                            auxiliary: {
                                error: {
                                    value: e.message,
                                    type: "string"
                                }
                            }
                        });
                    }
                }
                const content = (_o = (_n = response.choices[0]) == null ? void 0 : _n.message) == null ? void 0 : _o.content;
                if (content) {
                    try {
                        const jsonMatch = content.match(/\{[\s\S]*\}/);
                        if (jsonMatch) {
                            const result = JSON.parse(jsonMatch[0]);
                            const finalResponse = {
                                data: result,
                                usage: response.usage
                            };
                            return finalResponse;
                        }
                    } catch (e) {
                        logger({
                            category: "groq",
                            message: "failed to parse content as JSON",
                            level: 0,
                            auxiliary: {
                                error: {
                                    value: e.message,
                                    type: "string"
                                }
                            }
                        });
                    }
                }
                if (!retries || retries < 5) {
                    return this.createChatCompletion({
                        options,
                        logger,
                        retries: (retries != null ? retries : 0) + 1
                    });
                }
                throw new CreateChatCompletionResponseError("Invalid response schema");
            } catch (error) {
                logger({
                    category: "groq",
                    message: "error creating chat completion",
                    level: 0,
                    auxiliary: {
                        error: {
                            value: error.message,
                            type: "string"
                        },
                        requestId: {
                            value: options.requestId,
                            type: "string"
                        }
                    }
                });
                throw error;
            }
        });
    }
};
// lib/v3/llm/OpenAIClient.ts
var import_openai4 = __toESM(__turbopack_context__.r("[project]/node_modules/openai/index.js [app-route] (ecmascript)"));
var import_zod = __turbopack_context__.r("[project]/node_modules/openai/helpers/zod.js [app-route] (ecmascript)");
var import_zod_to_json_schema6 = __toESM(__turbopack_context__.r("[project]/node_modules/zod-to-json-schema/dist/cjs/index.js [app-route] (ecmascript)"));
init_sdkErrors();
var OpenAIClient = class extends LLMClient {
    constructor({ modelName, clientOptions }){
        super(modelName);
        this.type = "openai";
        this.clientOptions = clientOptions;
        this.client = new import_openai4.default(clientOptions);
        this.modelName = modelName;
    }
    createChatCompletion(_0) {
        return __async(this, arguments, function*({ options: optionsInitial, logger, retries = 3 }) {
            var _a, _b, _e;
            let options = optionsInitial;
            let isToolsOverridedForO1 = false;
            if (this.modelName.startsWith("o1") || this.modelName.startsWith("o3")) {
                let { tool_choice, top_p, frequency_penalty, presence_penalty, temperature } = options;
                _a = options, ({ tool_choice, top_p, frequency_penalty, presence_penalty, temperature } = _a), options = __objRest(_a, [
                    "tool_choice",
                    "top_p",
                    "frequency_penalty",
                    "presence_penalty",
                    "temperature"
                ]);
                options.messages = options.messages.map((message)=>__spreadProps(__spreadValues({}, message), {
                        role: "user"
                    }));
                if (options.tools && options.response_model) {
                    throw new StagehandError("Cannot use both tool and response_model for o1 models");
                }
                if (options.tools) {
                    let { tools } = options;
                    _b = options, ({ tools } = _b), options = __objRest(_b, [
                        "tools"
                    ]);
                    isToolsOverridedForO1 = true;
                    options.messages.push({
                        role: "user",
                        content: `You have the following tools available to you:
${JSON.stringify(tools)}

          Respond with the following zod schema format to use a method: {
            "name": "<tool_name>",
            "arguments": <tool_args>
          }
          
          Do not include any other text or formattings like \`\`\` in your response. Just the JSON object.`
                    });
                }
            }
            if (options.temperature && (this.modelName.startsWith("o1") || this.modelName.startsWith("o3"))) {
                throw new StagehandError("Temperature is not supported for o1 models");
            }
            const _c = options, { requestId } = _c, optionsWithoutImageAndRequestId = __objRest(_c, [
                "requestId"
            ]);
            logger({
                category: "openai",
                message: "creating chat completion",
                level: 2,
                auxiliary: {
                    options: {
                        value: JSON.stringify(__spreadProps(__spreadValues({}, optionsWithoutImageAndRequestId), {
                            requestId
                        })),
                        type: "object"
                    },
                    modelName: {
                        value: this.modelName,
                        type: "string"
                    }
                }
            });
            if (options.image) {
                const screenshotMessage = {
                    role: "user",
                    content: [
                        {
                            type: "image_url",
                            image_url: {
                                url: `data:image/jpeg;base64,${options.image.buffer.toString("base64")}`
                            }
                        },
                        ...options.image.description ? [
                            {
                                type: "text",
                                text: options.image.description
                            }
                        ] : []
                    ]
                };
                options.messages.push(screenshotMessage);
            }
            let responseFormat = void 0;
            if (options.response_model) {
                if (this.modelName.startsWith("o1") || this.modelName.startsWith("o3")) {
                    try {
                        const parsedSchema = JSON.stringify((0, import_zod_to_json_schema6.default)(options.response_model.schema));
                        options.messages.push({
                            role: "user",
                            content: `Respond in this zod schema format:
${parsedSchema}


          Do not include any other text, formatting or markdown in your output. Do not include \`\`\` or \`\`\`json in your response. Only the JSON object itself.`
                        });
                    } catch (error) {
                        logger({
                            category: "openai",
                            message: "Failed to parse response model schema",
                            level: 0
                        });
                        if (retries > 0) {
                            return this.createChatCompletion({
                                options,
                                logger,
                                retries: retries - 1
                            });
                        }
                        throw error;
                    }
                } else {
                    responseFormat = (0, import_zod.zodResponseFormat)(options.response_model.schema, options.response_model.name);
                }
            }
            const _d = __spreadProps(__spreadValues({}, optionsWithoutImageAndRequestId), {
                model: this.modelName
            }), { response_model } = _d, openAiOptions = __objRest(_d, [
                "response_model"
            ]);
            logger({
                category: "openai",
                message: "creating chat completion",
                level: 2,
                auxiliary: {
                    openAiOptions: {
                        value: JSON.stringify(openAiOptions),
                        type: "object"
                    }
                }
            });
            const formattedMessages = options.messages.map((message)=>{
                if (Array.isArray(message.content)) {
                    const contentParts = message.content.map((content)=>{
                        if ("image_url" in content) {
                            const imageContent = {
                                image_url: {
                                    url: content.image_url.url
                                },
                                type: "image_url"
                            };
                            return imageContent;
                        } else {
                            const textContent = {
                                text: content.text,
                                type: "text"
                            };
                            return textContent;
                        }
                    });
                    if (message.role === "system") {
                        const formattedMessage2 = __spreadProps(__spreadValues({}, message), {
                            role: "system",
                            content: contentParts.filter((content)=>content.type === "text")
                        });
                        return formattedMessage2;
                    } else if (message.role === "user") {
                        const formattedMessage2 = __spreadProps(__spreadValues({}, message), {
                            role: "user",
                            content: contentParts
                        });
                        return formattedMessage2;
                    } else {
                        const formattedMessage2 = __spreadProps(__spreadValues({}, message), {
                            role: "assistant",
                            content: contentParts.filter((content)=>content.type === "text")
                        });
                        return formattedMessage2;
                    }
                }
                const formattedMessage = {
                    role: "user",
                    content: message.content
                };
                return formattedMessage;
            });
            const body = __spreadProps(__spreadValues({}, openAiOptions), {
                model: this.modelName,
                messages: formattedMessages,
                response_format: responseFormat,
                stream: false,
                tools: (_e = options.tools) == null ? void 0 : _e.map((tool12)=>({
                        function: {
                            name: tool12.name,
                            description: tool12.description,
                            parameters: tool12.parameters
                        },
                        type: "function"
                    }))
            });
            const response = yield this.client.chat.completions.create(body);
            if (isToolsOverridedForO1) {
                try {
                    const parsedContent = JSON.parse(response.choices[0].message.content);
                    response.choices[0].message.tool_calls = [
                        {
                            function: {
                                name: parsedContent["name"],
                                arguments: JSON.stringify(parsedContent["arguments"])
                            },
                            type: "function",
                            id: "-1"
                        }
                    ];
                    response.choices[0].message.content = null;
                } catch (error) {
                    logger({
                        category: "openai",
                        message: "Failed to parse tool call response",
                        level: 0,
                        auxiliary: {
                            error: {
                                value: error.message,
                                type: "string"
                            },
                            content: {
                                value: response.choices[0].message.content,
                                type: "string"
                            }
                        }
                    });
                    if (retries > 0) {
                        return this.createChatCompletion({
                            options,
                            logger,
                            retries: retries - 1
                        });
                    }
                    throw error;
                }
            }
            logger({
                category: "openai",
                message: "response",
                level: 2,
                auxiliary: {
                    response: {
                        value: JSON.stringify(response),
                        type: "object"
                    },
                    requestId: {
                        value: requestId,
                        type: "string"
                    }
                }
            });
            if (options.response_model) {
                const extractedData = response.choices[0].message.content;
                const parsedData = JSON.parse(extractedData);
                try {
                    validateZodSchema(options.response_model.schema, parsedData);
                } catch (e) {
                    logger({
                        category: "openai",
                        message: "Response failed Zod schema validation",
                        level: 0
                    });
                    if (retries > 0) {
                        return this.createChatCompletion({
                            options,
                            logger,
                            retries: retries - 1
                        });
                    }
                    if (e instanceof ZodSchemaValidationError) {
                        logger({
                            category: "openai",
                            message: `Error during OpenAI chat completion: ${e.message}`,
                            level: 0,
                            auxiliary: {
                                errorDetails: {
                                    value: `Message: ${e.message}${e.stack ? "\nStack: " + e.stack : ""}`,
                                    type: "string"
                                },
                                requestId: {
                                    value: requestId,
                                    type: "string"
                                }
                            }
                        });
                        throw new CreateChatCompletionResponseError(e.message);
                    }
                    throw e;
                }
                return {
                    data: parsedData,
                    usage: response.usage
                };
            }
            return response;
        });
    }
};
// ../../node_modules/.pnpm/@ai-sdk+provider-utils@3.0.12_zod@3.25.67/node_modules/@ai-sdk/provider-utils/dist/index.mjs
var import_provider = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_provider2 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_provider3 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_provider4 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_provider5 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_provider6 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_provider7 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_provider8 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
// ../../node_modules/.pnpm/eventsource-parser@3.0.6/node_modules/eventsource-parser/dist/index.js
var ParseError = class extends Error {
    constructor(message, options){
        super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
    }
};
function noop(_arg) {}
function createParser(callbacks) {
    if (typeof callbacks == "function") throw new TypeError("`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?");
    const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;
    let incompleteLine = "", isFirstChunk = true, id, data = "", eventType = "";
    function feed(newChunk) {
        const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
        for (const line of complete)parseLine(line);
        incompleteLine = incomplete, isFirstChunk = false;
    }
    function parseLine(line) {
        if (line === "") {
            dispatchEvent();
            return;
        }
        if (line.startsWith(":")) {
            onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
            return;
        }
        const fieldSeparatorIndex = line.indexOf(":");
        if (fieldSeparatorIndex !== -1) {
            const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
            processField(field, value, line);
            return;
        }
        processField(line, "", line);
    }
    function processField(field, value, line) {
        switch(field){
            case "event":
                eventType = value;
                break;
            case "data":
                data = `${data}${value}
`;
                break;
            case "id":
                id = value.includes("\0") ? void 0 : value;
                break;
            case "retry":
                /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(new ParseError(`Invalid \`retry\` value: "${value}"`, {
                    type: "invalid-retry",
                    value,
                    line
                }));
                break;
            default:
                onError(new ParseError(`Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`, {
                    type: "unknown-field",
                    field,
                    value,
                    line
                }));
                break;
        }
    }
    function dispatchEvent() {
        data.length > 0 && onEvent({
            id,
            event: eventType || void 0,
            // If the data buffer's last character is a U+000A LINE FEED (LF) character,
            // then remove the last character from the data buffer.
            data: data.endsWith(`
`) ? data.slice(0, -1) : data
        }), id = void 0, data = "", eventType = "";
    }
    function reset(options = {}) {
        incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = "", eventType = "", incompleteLine = "";
    }
    return {
        feed,
        reset
    };
}
function splitLines(chunk) {
    const lines = [];
    let incompleteLine = "", searchIndex = 0;
    for(; searchIndex < chunk.length;){
        const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
        let lineEnd = -1;
        if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
            incompleteLine = chunk.slice(searchIndex);
            break;
        } else {
            const line = chunk.slice(searchIndex, lineEnd);
            lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
        }
    }
    return [
        lines,
        incompleteLine
    ];
}
// ../../node_modules/.pnpm/eventsource-parser@3.0.6/node_modules/eventsource-parser/dist/stream.js
var EventSourceParserStream = class extends TransformStream {
    constructor({ onError, onRetry, onComment } = {}){
        let parser;
        super({
            start (controller) {
                parser = createParser({
                    onEvent: (event)=>{
                        controller.enqueue(event);
                    },
                    onError (error) {
                        onError === "terminate" ? controller.error(error) : typeof onError == "function" && onError(error);
                    },
                    onRetry,
                    onComment
                });
            },
            transform (chunk) {
                parser.feed(chunk);
            }
        });
    }
};
// ../../node_modules/.pnpm/@ai-sdk+provider-utils@3.0.12_zod@3.25.67/node_modules/@ai-sdk/provider-utils/dist/index.mjs
var import_provider9 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_provider10 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_provider11 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var z42 = __toESM(__turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)"), 1);
var import_v315 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/index.js [app-route] (ecmascript)");
var import_v316 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/index.js [app-route] (ecmascript)");
var import_v317 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/index.js [app-route] (ecmascript)");
function combineHeaders(...headers) {
    return headers.reduce((combinedHeaders, currentHeaders)=>__spreadValues(__spreadValues({}, combinedHeaders), currentHeaders != null ? currentHeaders : {}), {});
}
function extractResponseHeaders(response) {
    return Object.fromEntries([
        ...response.headers
    ]);
}
var createIdGenerator = ({ prefix, size = 16, alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", separator = "-" } = {})=>{
    const generator = ()=>{
        const alphabetLength = alphabet.length;
        const chars = new Array(size);
        for(let i = 0; i < size; i++){
            chars[i] = alphabet[Math.random() * alphabetLength | 0];
        }
        return chars.join("");
    };
    if (prefix == null) {
        return generator;
    }
    if (alphabet.includes(separator)) {
        throw new import_provider.InvalidArgumentError({
            argument: "separator",
            message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
        });
    }
    return ()=>`${prefix}${separator}${generator()}`;
};
var generateId = createIdGenerator();
function isAbortError(error) {
    return (error instanceof Error || error instanceof DOMException) && (error.name === "AbortError" || error.name === "ResponseAborted" || // Next.js
    error.name === "TimeoutError");
}
var FETCH_FAILED_ERROR_MESSAGES = [
    "fetch failed",
    "failed to fetch"
];
function handleFetchError({ error, url, requestBodyValues }) {
    if (isAbortError(error)) {
        return error;
    }
    if (error instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES.includes(error.message.toLowerCase())) {
        const cause = error.cause;
        if (cause != null) {
            return new import_provider3.APICallError({
                message: `Cannot connect to API: ${cause.message}`,
                cause,
                url,
                requestBodyValues,
                isRetryable: true
            });
        }
    }
    return error;
}
function getRuntimeEnvironmentUserAgent(globalThisAny = globalThis) {
    var _a, _b, _c;
    if (globalThisAny.window) {
        return `runtime/browser`;
    }
    if ((_a = globalThisAny.navigator) == null ? void 0 : _a.userAgent) {
        return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;
    }
    if ((_c = (_b = globalThisAny.process) == null ? void 0 : _b.versions) == null ? void 0 : _c.node) {
        return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;
    }
    if (globalThisAny.EdgeRuntime) {
        return `runtime/vercel-edge`;
    }
    return "runtime/unknown";
}
function removeUndefinedEntries(record) {
    return Object.fromEntries(Object.entries(record).filter(([_key, value])=>value != null));
}
function withUserAgentSuffix(headers, ...userAgentSuffixParts) {
    const cleanedHeaders = removeUndefinedEntries(headers != null ? headers : {});
    const normalizedHeaders = new Headers(cleanedHeaders);
    const currentUserAgentHeader = normalizedHeaders.get("user-agent") || "";
    normalizedHeaders.set("user-agent", [
        currentUserAgentHeader,
        ...userAgentSuffixParts
    ].filter(Boolean).join(" "));
    return Object.fromEntries(normalizedHeaders);
}
var VERSION = ("TURBOPACK compile-time truthy", 1) ? "3.0.12" : "TURBOPACK unreachable";
var DEFAULT_SCHEMA_PREFIX = "JSON schema:";
var DEFAULT_SCHEMA_SUFFIX = "You MUST answer with a JSON object that matches the JSON schema above.";
var DEFAULT_GENERIC_SUFFIX = "You MUST answer with JSON.";
function injectJsonInstruction({ prompt, schema, schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX : void 0, schemaSuffix = schema != null ? DEFAULT_SCHEMA_SUFFIX : DEFAULT_GENERIC_SUFFIX }) {
    return [
        prompt != null && prompt.length > 0 ? prompt : void 0,
        prompt != null && prompt.length > 0 ? "" : void 0,
        // add a newline if prompt is not null
        schemaPrefix,
        schema != null ? JSON.stringify(schema) : void 0,
        schemaSuffix
    ].filter((line)=>line != null).join("\n");
}
function injectJsonInstructionIntoMessages({ messages, schema, schemaPrefix, schemaSuffix }) {
    var _a, _b;
    const systemMessage = ((_a = messages[0]) == null ? void 0 : _a.role) === "system" ? __spreadValues({}, messages[0]) : {
        role: "system",
        content: ""
    };
    systemMessage.content = injectJsonInstruction({
        prompt: systemMessage.content,
        schema,
        schemaPrefix,
        schemaSuffix
    });
    return [
        systemMessage,
        ...((_b = messages[0]) == null ? void 0 : _b.role) === "system" ? messages.slice(1) : messages
    ];
}
function loadApiKey({ apiKey, environmentVariableName, apiKeyParameterName = "apiKey", description }) {
    if (typeof apiKey === "string") {
        return apiKey;
    }
    if (apiKey != null) {
        throw new import_provider4.LoadAPIKeyError({
            message: `${description} API key must be a string.`
        });
    }
    if (typeof process === "undefined") {
        throw new import_provider4.LoadAPIKeyError({
            message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`
        });
    }
    apiKey = process.env[environmentVariableName];
    if (apiKey == null) {
        throw new import_provider4.LoadAPIKeyError({
            message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`
        });
    }
    if (typeof apiKey !== "string") {
        throw new import_provider4.LoadAPIKeyError({
            message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`
        });
    }
    return apiKey;
}
function loadOptionalSetting({ settingValue, environmentVariableName }) {
    if (typeof settingValue === "string") {
        return settingValue;
    }
    if (settingValue != null || typeof process === "undefined") {
        return void 0;
    }
    settingValue = process.env[environmentVariableName];
    if (settingValue == null || typeof settingValue !== "string") {
        return void 0;
    }
    return settingValue;
}
function loadSetting({ settingValue, environmentVariableName, settingName, description }) {
    if (typeof settingValue === "string") {
        return settingValue;
    }
    if (settingValue != null) {
        throw new import_provider5.LoadSettingError({
            message: `${description} setting must be a string.`
        });
    }
    if (typeof process === "undefined") {
        throw new import_provider5.LoadSettingError({
            message: `${description} setting is missing. Pass it using the '${settingName}' parameter. Environment variables is not supported in this environment.`
        });
    }
    settingValue = process.env[environmentVariableName];
    if (settingValue == null) {
        throw new import_provider5.LoadSettingError({
            message: `${description} setting is missing. Pass it using the '${settingName}' parameter or the ${environmentVariableName} environment variable.`
        });
    }
    if (typeof settingValue !== "string") {
        throw new import_provider5.LoadSettingError({
            message: `${description} setting must be a string. The value of the ${environmentVariableName} environment variable is not a string.`
        });
    }
    return settingValue;
}
function mediaTypeToExtension(mediaType) {
    var _a;
    const [_type, subtype = ""] = mediaType.toLowerCase().split("/");
    return (_a = ({
        mpeg: "mp3",
        "x-wav": "wav",
        opus: "ogg",
        mp4: "m4a",
        "x-m4a": "m4a"
    })[subtype]) != null ? _a : subtype;
}
var suspectProtoRx = /"__proto__"\s*:/;
var suspectConstructorRx = /"constructor"\s*:/;
function _parse(text) {
    const obj = JSON.parse(text);
    if (obj === null || typeof obj !== "object") {
        return obj;
    }
    if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {
        return obj;
    }
    return filter(obj);
}
function filter(obj) {
    let next = [
        obj
    ];
    while(next.length){
        const nodes = next;
        next = [];
        for (const node of nodes){
            if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
                throw new SyntaxError("Object contains forbidden prototype property");
            }
            if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
                throw new SyntaxError("Object contains forbidden prototype property");
            }
            for(const key in node){
                const value = node[key];
                if (value && typeof value === "object") {
                    next.push(value);
                }
            }
        }
    }
    return obj;
}
function secureJsonParse(text) {
    const { stackTraceLimit } = Error;
    Error.stackTraceLimit = 0;
    try {
        return _parse(text);
    } finally{
        Error.stackTraceLimit = stackTraceLimit;
    }
}
var validatorSymbol = Symbol.for("vercel.ai.validator");
function validator(validate) {
    return {
        [validatorSymbol]: true,
        validate
    };
}
function isValidator(value) {
    return typeof value === "object" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && "validate" in value;
}
function lazyValidator(createValidator) {
    let validator2;
    return ()=>{
        if (validator2 == null) {
            validator2 = createValidator();
        }
        return validator2;
    };
}
function asValidator(value) {
    return isValidator(value) ? value : typeof value === "function" ? value() : standardSchemaValidator(value);
}
function standardSchemaValidator(standardSchema) {
    return validator((value)=>__async(null, null, function*() {
            const result = yield standardSchema["~standard"].validate(value);
            return result.issues == null ? {
                success: true,
                value: result.value
            } : {
                success: false,
                error: new import_provider8.TypeValidationError({
                    value,
                    cause: result.issues
                })
            };
        }));
}
function validateTypes(_0) {
    return __async(this, arguments, function*({ value, schema }) {
        const result = yield safeValidateTypes({
            value,
            schema
        });
        if (!result.success) {
            throw import_provider7.TypeValidationError.wrap({
                value,
                cause: result.error
            });
        }
        return result.value;
    });
}
function safeValidateTypes(_0) {
    return __async(this, arguments, function*({ value, schema }) {
        const validator2 = asValidator(schema);
        try {
            if (validator2.validate == null) {
                return {
                    success: true,
                    value,
                    rawValue: value
                };
            }
            const result = yield validator2.validate(value);
            if (result.success) {
                return {
                    success: true,
                    value: result.value,
                    rawValue: value
                };
            }
            return {
                success: false,
                error: import_provider7.TypeValidationError.wrap({
                    value,
                    cause: result.error
                }),
                rawValue: value
            };
        } catch (error) {
            return {
                success: false,
                error: import_provider7.TypeValidationError.wrap({
                    value,
                    cause: error
                }),
                rawValue: value
            };
        }
    });
}
function parseJSON(_0) {
    return __async(this, arguments, function*({ text, schema }) {
        try {
            const value = secureJsonParse(text);
            if (schema == null) {
                return value;
            }
            return validateTypes({
                value,
                schema
            });
        } catch (error) {
            if (import_provider6.JSONParseError.isInstance(error) || import_provider6.TypeValidationError.isInstance(error)) {
                throw error;
            }
            throw new import_provider6.JSONParseError({
                text,
                cause: error
            });
        }
    });
}
function safeParseJSON(_0) {
    return __async(this, arguments, function*({ text, schema }) {
        try {
            const value = secureJsonParse(text);
            if (schema == null) {
                return {
                    success: true,
                    value,
                    rawValue: value
                };
            }
            return yield safeValidateTypes({
                value,
                schema
            });
        } catch (error) {
            return {
                success: false,
                error: import_provider6.JSONParseError.isInstance(error) ? error : new import_provider6.JSONParseError({
                    text,
                    cause: error
                }),
                rawValue: void 0
            };
        }
    });
}
function isParsableJson(input) {
    try {
        secureJsonParse(input);
        return true;
    } catch (e) {
        return false;
    }
}
function parseJsonEventStream({ stream, schema }) {
    return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).pipeThrough(new TransformStream({
        transform (_0, _1) {
            return __async(this, arguments, function*({ data }, controller) {
                if (data === "[DONE]") {
                    return;
                }
                controller.enqueue((yield safeParseJSON({
                    text: data,
                    schema
                })));
            });
        }
    }));
}
function parseProviderOptions(_0) {
    return __async(this, arguments, function*({ provider, providerOptions, schema }) {
        if ((providerOptions == null ? void 0 : providerOptions[provider]) == null) {
            return void 0;
        }
        const parsedProviderOptions = yield safeValidateTypes({
            value: providerOptions[provider],
            schema
        });
        if (!parsedProviderOptions.success) {
            throw new import_provider9.InvalidArgumentError({
                argument: "providerOptions",
                message: `invalid ${provider} provider options`,
                cause: parsedProviderOptions.error
            });
        }
        return parsedProviderOptions.value;
    });
}
var getOriginalFetch2 = ()=>globalThis.fetch;
var postJsonToApi = (_0)=>__async(null, [
        _0
    ], function*({ url, headers, body, failedResponseHandler, successfulResponseHandler, abortSignal, fetch: fetch2 }) {
        return postToApi({
            url,
            headers: __spreadValues({
                "Content-Type": "application/json"
            }, headers),
            body: {
                content: JSON.stringify(body),
                values: body
            },
            failedResponseHandler,
            successfulResponseHandler,
            abortSignal,
            fetch: fetch2
        });
    });
var postFormDataToApi = (_0)=>__async(null, [
        _0
    ], function*({ url, headers, formData, failedResponseHandler, successfulResponseHandler, abortSignal, fetch: fetch2 }) {
        return postToApi({
            url,
            headers,
            body: {
                content: formData,
                values: Object.fromEntries(formData.entries())
            },
            failedResponseHandler,
            successfulResponseHandler,
            abortSignal,
            fetch: fetch2
        });
    });
var postToApi = (_0)=>__async(null, [
        _0
    ], function*({ url, headers = {}, body, successfulResponseHandler, failedResponseHandler, abortSignal, fetch: fetch2 = getOriginalFetch2() }) {
        try {
            const response = yield fetch2(url, {
                method: "POST",
                headers: withUserAgentSuffix(headers, `ai-sdk/provider-utils/${VERSION}`, getRuntimeEnvironmentUserAgent()),
                body: body.content,
                signal: abortSignal
            });
            const responseHeaders = extractResponseHeaders(response);
            if (!response.ok) {
                let errorInformation;
                try {
                    errorInformation = yield failedResponseHandler({
                        response,
                        url,
                        requestBodyValues: body.values
                    });
                } catch (error) {
                    if (isAbortError(error) || import_provider10.APICallError.isInstance(error)) {
                        throw error;
                    }
                    throw new import_provider10.APICallError({
                        message: "Failed to process error response",
                        cause: error,
                        statusCode: response.status,
                        url,
                        responseHeaders,
                        requestBodyValues: body.values
                    });
                }
                throw errorInformation.value;
            }
            try {
                return yield successfulResponseHandler({
                    response,
                    url,
                    requestBodyValues: body.values
                });
            } catch (error) {
                if (error instanceof Error) {
                    if (isAbortError(error) || import_provider10.APICallError.isInstance(error)) {
                        throw error;
                    }
                }
                throw new import_provider10.APICallError({
                    message: "Failed to process successful response",
                    cause: error,
                    statusCode: response.status,
                    url,
                    responseHeaders,
                    requestBodyValues: body.values
                });
            }
        } catch (error) {
            throw handleFetchError({
                error,
                url,
                requestBodyValues: body.values
            });
        }
    });
function tool11(tool22) {
    return tool22;
}
function createProviderDefinedToolFactory({ id, name, inputSchema }) {
    return (_a)=>{
        var _b = _a, { execute, outputSchema, toModelOutput, onInputStart, onInputDelta, onInputAvailable } = _b, args = __objRest(_b, [
            "execute",
            "outputSchema",
            "toModelOutput",
            "onInputStart",
            "onInputDelta",
            "onInputAvailable"
        ]);
        return tool11({
            type: "provider-defined",
            id,
            name,
            args,
            inputSchema,
            outputSchema,
            execute,
            toModelOutput,
            onInputStart,
            onInputDelta,
            onInputAvailable
        });
    };
}
function createProviderDefinedToolFactoryWithOutputSchema({ id, name, inputSchema, outputSchema }) {
    return (_a)=>{
        var _b = _a, { execute, toModelOutput, onInputStart, onInputDelta, onInputAvailable } = _b, args = __objRest(_b, [
            "execute",
            "toModelOutput",
            "onInputStart",
            "onInputDelta",
            "onInputAvailable"
        ]);
        return tool11({
            type: "provider-defined",
            id,
            name,
            args,
            inputSchema,
            outputSchema,
            execute,
            toModelOutput,
            onInputStart,
            onInputDelta,
            onInputAvailable
        });
    };
}
function resolve(value) {
    return __async(this, null, function*() {
        if (typeof value === "function") {
            value = value();
        }
        return Promise.resolve(value);
    });
}
var createJsonErrorResponseHandler = ({ errorSchema, errorToMessage: errorToMessage2, isRetryable })=>(_0)=>__async(null, [
            _0
        ], function*({ response, url, requestBodyValues }) {
            const responseBody = yield response.text();
            const responseHeaders = extractResponseHeaders(response);
            if (responseBody.trim() === "") {
                return {
                    responseHeaders,
                    value: new import_provider11.APICallError({
                        message: response.statusText,
                        url,
                        requestBodyValues,
                        statusCode: response.status,
                        responseHeaders,
                        responseBody,
                        isRetryable: isRetryable == null ? void 0 : isRetryable(response)
                    })
                };
            }
            try {
                const parsedError = yield parseJSON({
                    text: responseBody,
                    schema: errorSchema
                });
                return {
                    responseHeaders,
                    value: new import_provider11.APICallError({
                        message: errorToMessage2(parsedError),
                        url,
                        requestBodyValues,
                        statusCode: response.status,
                        responseHeaders,
                        responseBody,
                        data: parsedError,
                        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
                    })
                };
            } catch (parseError) {
                return {
                    responseHeaders,
                    value: new import_provider11.APICallError({
                        message: response.statusText,
                        url,
                        requestBodyValues,
                        statusCode: response.status,
                        responseHeaders,
                        responseBody,
                        isRetryable: isRetryable == null ? void 0 : isRetryable(response)
                    })
                };
            }
        });
var createEventSourceResponseHandler = (chunkSchema2)=>(_0)=>__async(null, [
            _0
        ], function*({ response }) {
            const responseHeaders = extractResponseHeaders(response);
            if (response.body == null) {
                throw new import_provider11.EmptyResponseBodyError({});
            }
            return {
                responseHeaders,
                value: parseJsonEventStream({
                    stream: response.body,
                    schema: chunkSchema2
                })
            };
        });
var createJsonStreamResponseHandler = (chunkSchema2)=>(_0)=>__async(null, [
            _0
        ], function*({ response }) {
            const responseHeaders = extractResponseHeaders(response);
            if (response.body == null) {
                throw new import_provider11.EmptyResponseBodyError({});
            }
            let buffer = "";
            return {
                responseHeaders,
                value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(new TransformStream({
                    transform (chunkText, controller) {
                        return __async(this, null, function*() {
                            if (chunkText.endsWith("\n")) {
                                controller.enqueue((yield safeParseJSON({
                                    text: buffer + chunkText,
                                    schema: chunkSchema2
                                })));
                                buffer = "";
                            } else {
                                buffer += chunkText;
                            }
                        });
                    }
                }))
            };
        });
var createJsonResponseHandler = (responseSchema2)=>(_0)=>__async(null, [
            _0
        ], function*({ response, url, requestBodyValues }) {
            const responseBody = yield response.text();
            const parsedResult = yield safeParseJSON({
                text: responseBody,
                schema: responseSchema2
            });
            const responseHeaders = extractResponseHeaders(response);
            if (!parsedResult.success) {
                throw new import_provider11.APICallError({
                    message: "Invalid JSON response",
                    cause: parsedResult.error,
                    statusCode: response.status,
                    responseHeaders,
                    responseBody,
                    url,
                    requestBodyValues
                });
            }
            return {
                responseHeaders,
                value: parsedResult.value,
                rawValue: parsedResult.rawValue
            };
        });
var createBinaryResponseHandler = ()=>(_0)=>__async(null, [
            _0
        ], function*({ response, url, requestBodyValues }) {
            const responseHeaders = extractResponseHeaders(response);
            if (!response.body) {
                throw new import_provider11.APICallError({
                    message: "Response body is empty",
                    url,
                    requestBodyValues,
                    statusCode: response.status,
                    responseHeaders,
                    responseBody: void 0
                });
            }
            try {
                const buffer = yield response.arrayBuffer();
                return {
                    responseHeaders,
                    value: new Uint8Array(buffer)
                };
            } catch (error) {
                throw new import_provider11.APICallError({
                    message: "Failed to read response as array buffer",
                    url,
                    requestBodyValues,
                    statusCode: response.status,
                    responseHeaders,
                    responseBody: void 0,
                    cause: error
                });
            }
        });
var getRelativePath = (pathA, pathB)=>{
    let i = 0;
    for(; i < pathA.length && i < pathB.length; i++){
        if (pathA[i] !== pathB[i]) break;
    }
    return [
        (pathA.length - i).toString(),
        ...pathB.slice(i)
    ].join("/");
};
var ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
var defaultOptions = {
    name: void 0,
    $refStrategy: "root",
    basePath: [
        "#"
    ],
    effectStrategy: "input",
    pipeStrategy: "all",
    dateStrategy: "format:date-time",
    mapStrategy: "entries",
    removeAdditionalStrategy: "passthrough",
    allowedAdditionalProperties: true,
    rejectedAdditionalProperties: false,
    definitionPath: "definitions",
    strictUnions: false,
    definitions: {},
    errorMessages: false,
    patternStrategy: "escape",
    applyRegexFlags: false,
    emailStrategy: "format:email",
    base64Strategy: "contentEncoding:base64",
    nameStrategy: "ref"
};
var getDefaultOptions = (options)=>typeof options === "string" ? __spreadProps(__spreadValues({}, defaultOptions), {
        name: options
    }) : __spreadValues(__spreadValues({}, defaultOptions), options);
function parseAnyDef() {
    return {};
}
function parseArrayDef(def, refs) {
    var _a, _b, _c;
    const res = {
        type: "array"
    };
    if (((_a = def.type) == null ? void 0 : _a._def) && ((_c = (_b = def.type) == null ? void 0 : _b._def) == null ? void 0 : _c.typeName) !== import_v316.ZodFirstPartyTypeKind.ZodAny) {
        res.items = parseDef(def.type._def, __spreadProps(__spreadValues({}, refs), {
            currentPath: [
                ...refs.currentPath,
                "items"
            ]
        }));
    }
    if (def.minLength) {
        res.minItems = def.minLength.value;
    }
    if (def.maxLength) {
        res.maxItems = def.maxLength.value;
    }
    if (def.exactLength) {
        res.minItems = def.exactLength.value;
        res.maxItems = def.exactLength.value;
    }
    return res;
}
function parseBigintDef(def) {
    const res = {
        type: "integer",
        format: "int64"
    };
    if (!def.checks) return res;
    for (const check of def.checks){
        switch(check.kind){
            case "min":
                if (check.inclusive) {
                    res.minimum = check.value;
                } else {
                    res.exclusiveMinimum = check.value;
                }
                break;
            case "max":
                if (check.inclusive) {
                    res.maximum = check.value;
                } else {
                    res.exclusiveMaximum = check.value;
                }
                break;
            case "multipleOf":
                res.multipleOf = check.value;
                break;
        }
    }
    return res;
}
function parseBooleanDef() {
    return {
        type: "boolean"
    };
}
function parseBrandedDef(_def, refs) {
    return parseDef(_def.type._def, refs);
}
var parseCatchDef = (def, refs)=>{
    return parseDef(def.innerType._def, refs);
};
function parseDateDef(def, refs, overrideDateStrategy) {
    const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;
    if (Array.isArray(strategy)) {
        return {
            anyOf: strategy.map((item, i)=>parseDateDef(def, refs, item))
        };
    }
    switch(strategy){
        case "string":
        case "format:date-time":
            return {
                type: "string",
                format: "date-time"
            };
        case "format:date":
            return {
                type: "string",
                format: "date"
            };
        case "integer":
            return integerDateParser(def);
    }
}
var integerDateParser = (def)=>{
    const res = {
        type: "integer",
        format: "unix-time"
    };
    for (const check of def.checks){
        switch(check.kind){
            case "min":
                res.minimum = check.value;
                break;
            case "max":
                res.maximum = check.value;
                break;
        }
    }
    return res;
};
function parseDefaultDef(_def, refs) {
    return __spreadProps(__spreadValues({}, parseDef(_def.innerType._def, refs)), {
        default: _def.defaultValue()
    });
}
function parseEffectsDef(_def, refs) {
    return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : parseAnyDef();
}
function parseEnumDef(def) {
    return {
        type: "string",
        enum: Array.from(def.values)
    };
}
var isJsonSchema7AllOfType = (type)=>{
    if ("type" in type && type.type === "string") return false;
    return "allOf" in type;
};
function parseIntersectionDef(def, refs) {
    const allOf = [
        parseDef(def.left._def, __spreadProps(__spreadValues({}, refs), {
            currentPath: [
                ...refs.currentPath,
                "allOf",
                "0"
            ]
        })),
        parseDef(def.right._def, __spreadProps(__spreadValues({}, refs), {
            currentPath: [
                ...refs.currentPath,
                "allOf",
                "1"
            ]
        }))
    ].filter((x)=>!!x);
    const mergedAllOf = [];
    allOf.forEach((schema)=>{
        if (isJsonSchema7AllOfType(schema)) {
            mergedAllOf.push(...schema.allOf);
        } else {
            let nestedSchema = schema;
            if ("additionalProperties" in schema && schema.additionalProperties === false) {
                const _a = schema, { additionalProperties } = _a, rest = __objRest(_a, [
                    "additionalProperties"
                ]);
                nestedSchema = rest;
            }
            mergedAllOf.push(nestedSchema);
        }
    });
    return mergedAllOf.length ? {
        allOf: mergedAllOf
    } : void 0;
}
function parseLiteralDef(def) {
    const parsedType = typeof def.value;
    if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
        return {
            type: Array.isArray(def.value) ? "array" : "object"
        };
    }
    return {
        type: parsedType === "bigint" ? "integer" : parsedType,
        const: def.value
    };
}
var emojiRegex = void 0;
var zodPatterns = {
    /**
   * `c` was changed to `[cC]` to replicate /i flag
   */ cuid: /^[cC][^\s-]{8,}$/,
    cuid2: /^[0-9a-z]+$/,
    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
    /**
   * `a-z` was added to replicate /i flag
   */ email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
    /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */ emoji: ()=>{
        if (emojiRegex === void 0) {
            emojiRegex = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
        }
        return emojiRegex;
    },
    /**
   * Unused
   */ uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
    /**
   * Unused
   */ ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
    ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
    /**
   * Unused
   */ ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
    ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
    base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
    nanoid: /^[a-zA-Z0-9_-]{21}$/,
    jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef(def, refs) {
    const res = {
        type: "string"
    };
    if (def.checks) {
        for (const check of def.checks){
            switch(check.kind){
                case "min":
                    res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
                    break;
                case "max":
                    res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
                    break;
                case "email":
                    switch(refs.emailStrategy){
                        case "format:email":
                            addFormat(res, "email", check.message, refs);
                            break;
                        case "format:idn-email":
                            addFormat(res, "idn-email", check.message, refs);
                            break;
                        case "pattern:zod":
                            addPattern(res, zodPatterns.email, check.message, refs);
                            break;
                    }
                    break;
                case "url":
                    addFormat(res, "uri", check.message, refs);
                    break;
                case "uuid":
                    addFormat(res, "uuid", check.message, refs);
                    break;
                case "regex":
                    addPattern(res, check.regex, check.message, refs);
                    break;
                case "cuid":
                    addPattern(res, zodPatterns.cuid, check.message, refs);
                    break;
                case "cuid2":
                    addPattern(res, zodPatterns.cuid2, check.message, refs);
                    break;
                case "startsWith":
                    addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);
                    break;
                case "endsWith":
                    addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);
                    break;
                case "datetime":
                    addFormat(res, "date-time", check.message, refs);
                    break;
                case "date":
                    addFormat(res, "date", check.message, refs);
                    break;
                case "time":
                    addFormat(res, "time", check.message, refs);
                    break;
                case "duration":
                    addFormat(res, "duration", check.message, refs);
                    break;
                case "length":
                    res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
                    res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
                    break;
                case "includes":
                    {
                        addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);
                        break;
                    }
                case "ip":
                    {
                        if (check.version !== "v6") {
                            addFormat(res, "ipv4", check.message, refs);
                        }
                        if (check.version !== "v4") {
                            addFormat(res, "ipv6", check.message, refs);
                        }
                        break;
                    }
                case "base64url":
                    addPattern(res, zodPatterns.base64url, check.message, refs);
                    break;
                case "jwt":
                    addPattern(res, zodPatterns.jwt, check.message, refs);
                    break;
                case "cidr":
                    {
                        if (check.version !== "v6") {
                            addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);
                        }
                        if (check.version !== "v4") {
                            addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);
                        }
                        break;
                    }
                case "emoji":
                    addPattern(res, zodPatterns.emoji(), check.message, refs);
                    break;
                case "ulid":
                    {
                        addPattern(res, zodPatterns.ulid, check.message, refs);
                        break;
                    }
                case "base64":
                    {
                        switch(refs.base64Strategy){
                            case "format:binary":
                                {
                                    addFormat(res, "binary", check.message, refs);
                                    break;
                                }
                            case "contentEncoding:base64":
                                {
                                    res.contentEncoding = "base64";
                                    break;
                                }
                            case "pattern:zod":
                                {
                                    addPattern(res, zodPatterns.base64, check.message, refs);
                                    break;
                                }
                        }
                        break;
                    }
                case "nanoid":
                    {
                        addPattern(res, zodPatterns.nanoid, check.message, refs);
                    }
                case "toLowerCase":
                case "toUpperCase":
                case "trim":
                    break;
                default:
                    /* @__PURE__ */ ((_)=>{})(check);
            }
        }
    }
    return res;
}
function escapeLiteralCheckValue(literal, refs) {
    return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(literal) : literal;
}
var ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function escapeNonAlphaNumeric(source) {
    let result = "";
    for(let i = 0; i < source.length; i++){
        if (!ALPHA_NUMERIC.has(source[i])) {
            result += "\\";
        }
        result += source[i];
    }
    return result;
}
function addFormat(schema, value, message, refs) {
    var _a;
    if (schema.format || ((_a = schema.anyOf) == null ? void 0 : _a.some((x)=>x.format))) {
        if (!schema.anyOf) {
            schema.anyOf = [];
        }
        if (schema.format) {
            schema.anyOf.push({
                format: schema.format
            });
            delete schema.format;
        }
        schema.anyOf.push(__spreadValues({
            format: value
        }, message && refs.errorMessages && {
            errorMessage: {
                format: message
            }
        }));
    } else {
        schema.format = value;
    }
}
function addPattern(schema, regex, message, refs) {
    var _a;
    if (schema.pattern || ((_a = schema.allOf) == null ? void 0 : _a.some((x)=>x.pattern))) {
        if (!schema.allOf) {
            schema.allOf = [];
        }
        if (schema.pattern) {
            schema.allOf.push({
                pattern: schema.pattern
            });
            delete schema.pattern;
        }
        schema.allOf.push(__spreadValues({
            pattern: stringifyRegExpWithFlags(regex, refs)
        }, message && refs.errorMessages && {
            errorMessage: {
                pattern: message
            }
        }));
    } else {
        schema.pattern = stringifyRegExpWithFlags(regex, refs);
    }
}
function stringifyRegExpWithFlags(regex, refs) {
    var _a;
    if (!refs.applyRegexFlags || !regex.flags) {
        return regex.source;
    }
    const flags = {
        i: regex.flags.includes("i"),
        // Case-insensitive
        m: regex.flags.includes("m"),
        // `^` and `$` matches adjacent to newline characters
        s: regex.flags.includes("s")
    };
    const source = flags.i ? regex.source.toLowerCase() : regex.source;
    let pattern = "";
    let isEscaped = false;
    let inCharGroup = false;
    let inCharRange = false;
    for(let i = 0; i < source.length; i++){
        if (isEscaped) {
            pattern += source[i];
            isEscaped = false;
            continue;
        }
        if (flags.i) {
            if (inCharGroup) {
                if (source[i].match(/[a-z]/)) {
                    if (inCharRange) {
                        pattern += source[i];
                        pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
                        inCharRange = false;
                    } else if (source[i + 1] === "-" && ((_a = source[i + 2]) == null ? void 0 : _a.match(/[a-z]/))) {
                        pattern += source[i];
                        inCharRange = true;
                    } else {
                        pattern += `${source[i]}${source[i].toUpperCase()}`;
                    }
                    continue;
                }
            } else if (source[i].match(/[a-z]/)) {
                pattern += `[${source[i]}${source[i].toUpperCase()}]`;
                continue;
            }
        }
        if (flags.m) {
            if (source[i] === "^") {
                pattern += `(^|(?<=[\r
]))`;
                continue;
            } else if (source[i] === "$") {
                pattern += `($|(?=[\r
]))`;
                continue;
            }
        }
        if (flags.s && source[i] === ".") {
            pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
            continue;
        }
        pattern += source[i];
        if (source[i] === "\\") {
            isEscaped = true;
        } else if (inCharGroup && source[i] === "]") {
            inCharGroup = false;
        } else if (!inCharGroup && source[i] === "[") {
            inCharGroup = true;
        }
    }
    try {
        new RegExp(pattern);
    } catch (e) {
        console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
        return regex.source;
    }
    return pattern;
}
function parseRecordDef(def, refs) {
    var _a, _b, _c, _d, _e, _f;
    const schema = {
        type: "object",
        additionalProperties: (_a = parseDef(def.valueType._def, __spreadProps(__spreadValues({}, refs), {
            currentPath: [
                ...refs.currentPath,
                "additionalProperties"
            ]
        }))) != null ? _a : refs.allowedAdditionalProperties
    };
    if (((_b = def.keyType) == null ? void 0 : _b._def.typeName) === import_v317.ZodFirstPartyTypeKind.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {
        const _a2 = parseStringDef(def.keyType._def, refs), { type } = _a2, keyType = __objRest(_a2, [
            "type"
        ]);
        return __spreadProps(__spreadValues({}, schema), {
            propertyNames: keyType
        });
    } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === import_v317.ZodFirstPartyTypeKind.ZodEnum) {
        return __spreadProps(__spreadValues({}, schema), {
            propertyNames: {
                enum: def.keyType._def.values
            }
        });
    } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === import_v317.ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === import_v317.ZodFirstPartyTypeKind.ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {
        const _b2 = parseBrandedDef(def.keyType._def, refs), { type } = _b2, keyType = __objRest(_b2, [
            "type"
        ]);
        return __spreadProps(__spreadValues({}, schema), {
            propertyNames: keyType
        });
    }
    return schema;
}
function parseMapDef(def, refs) {
    if (refs.mapStrategy === "record") {
        return parseRecordDef(def, refs);
    }
    const keys = parseDef(def.keyType._def, __spreadProps(__spreadValues({}, refs), {
        currentPath: [
            ...refs.currentPath,
            "items",
            "items",
            "0"
        ]
    })) || parseAnyDef();
    const values = parseDef(def.valueType._def, __spreadProps(__spreadValues({}, refs), {
        currentPath: [
            ...refs.currentPath,
            "items",
            "items",
            "1"
        ]
    })) || parseAnyDef();
    return {
        type: "array",
        maxItems: 125,
        items: {
            type: "array",
            items: [
                keys,
                values
            ],
            minItems: 2,
            maxItems: 2
        }
    };
}
function parseNativeEnumDef(def) {
    const object = def.values;
    const actualKeys = Object.keys(def.values).filter((key)=>{
        return typeof object[object[key]] !== "number";
    });
    const actualValues = actualKeys.map((key)=>object[key]);
    const parsedTypes = Array.from(new Set(actualValues.map((values)=>typeof values)));
    return {
        type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : [
            "string",
            "number"
        ],
        enum: actualValues
    };
}
function parseNeverDef() {
    return {
        not: parseAnyDef()
    };
}
function parseNullDef() {
    return {
        type: "null"
    };
}
var primitiveMappings = {
    ZodString: "string",
    ZodNumber: "number",
    ZodBigInt: "integer",
    ZodBoolean: "boolean",
    ZodNull: "null"
};
function parseUnionDef(def, refs) {
    const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
    if (options.every((x)=>x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length))) {
        const types = options.reduce((types2, x)=>{
            const type = primitiveMappings[x._def.typeName];
            return type && !types2.includes(type) ? [
                ...types2,
                type
            ] : types2;
        }, []);
        return {
            type: types.length > 1 ? types : types[0]
        };
    } else if (options.every((x)=>x._def.typeName === "ZodLiteral" && !x.description)) {
        const types = options.reduce((acc, x)=>{
            const type = typeof x._def.value;
            switch(type){
                case "string":
                case "number":
                case "boolean":
                    return [
                        ...acc,
                        type
                    ];
                case "bigint":
                    return [
                        ...acc,
                        "integer"
                    ];
                case "object":
                    if (x._def.value === null) return [
                        ...acc,
                        "null"
                    ];
                case "symbol":
                case "undefined":
                case "function":
                default:
                    return acc;
            }
        }, []);
        if (types.length === options.length) {
            const uniqueTypes = types.filter((x, i, a)=>a.indexOf(x) === i);
            return {
                type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
                enum: options.reduce((acc, x)=>{
                    return acc.includes(x._def.value) ? acc : [
                        ...acc,
                        x._def.value
                    ];
                }, [])
            };
        }
    } else if (options.every((x)=>x._def.typeName === "ZodEnum")) {
        return {
            type: "string",
            enum: options.reduce((acc, x)=>[
                    ...acc,
                    ...x._def.values.filter((x2)=>!acc.includes(x2))
                ], [])
        };
    }
    return asAnyOf(def, refs);
}
var asAnyOf = (def, refs)=>{
    const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i)=>parseDef(x._def, __spreadProps(__spreadValues({}, refs), {
            currentPath: [
                ...refs.currentPath,
                "anyOf",
                `${i}`
            ]
        }))).filter((x)=>!!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
    return anyOf.length ? {
        anyOf
    } : void 0;
};
function parseNullableDef(def, refs) {
    if ([
        "ZodString",
        "ZodNumber",
        "ZodBigInt",
        "ZodBoolean",
        "ZodNull"
    ].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
        return {
            type: [
                primitiveMappings[def.innerType._def.typeName],
                "null"
            ]
        };
    }
    const base = parseDef(def.innerType._def, __spreadProps(__spreadValues({}, refs), {
        currentPath: [
            ...refs.currentPath,
            "anyOf",
            "0"
        ]
    }));
    return base && {
        anyOf: [
            base,
            {
                type: "null"
            }
        ]
    };
}
function parseNumberDef(def) {
    const res = {
        type: "number"
    };
    if (!def.checks) return res;
    for (const check of def.checks){
        switch(check.kind){
            case "int":
                res.type = "integer";
                break;
            case "min":
                if (check.inclusive) {
                    res.minimum = check.value;
                } else {
                    res.exclusiveMinimum = check.value;
                }
                break;
            case "max":
                if (check.inclusive) {
                    res.maximum = check.value;
                } else {
                    res.exclusiveMaximum = check.value;
                }
                break;
            case "multipleOf":
                res.multipleOf = check.value;
                break;
        }
    }
    return res;
}
function parseObjectDef(def, refs) {
    const result = {
        type: "object",
        properties: {}
    };
    const required = [];
    const shape = def.shape();
    for(const propName in shape){
        let propDef = shape[propName];
        if (propDef === void 0 || propDef._def === void 0) {
            continue;
        }
        const propOptional = safeIsOptional(propDef);
        const parsedDef = parseDef(propDef._def, __spreadProps(__spreadValues({}, refs), {
            currentPath: [
                ...refs.currentPath,
                "properties",
                propName
            ],
            propertyPath: [
                ...refs.currentPath,
                "properties",
                propName
            ]
        }));
        if (parsedDef === void 0) {
            continue;
        }
        result.properties[propName] = parsedDef;
        if (!propOptional) {
            required.push(propName);
        }
    }
    if (required.length) {
        result.required = required;
    }
    const additionalProperties = decideAdditionalProperties(def, refs);
    if (additionalProperties !== void 0) {
        result.additionalProperties = additionalProperties;
    }
    return result;
}
function decideAdditionalProperties(def, refs) {
    if (def.catchall._def.typeName !== "ZodNever") {
        return parseDef(def.catchall._def, __spreadProps(__spreadValues({}, refs), {
            currentPath: [
                ...refs.currentPath,
                "additionalProperties"
            ]
        }));
    }
    switch(def.unknownKeys){
        case "passthrough":
            return refs.allowedAdditionalProperties;
        case "strict":
            return refs.rejectedAdditionalProperties;
        case "strip":
            return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
    }
}
function safeIsOptional(schema) {
    try {
        return schema.isOptional();
    } catch (e) {
        return true;
    }
}
var parseOptionalDef = (def, refs)=>{
    var _a;
    if (refs.currentPath.toString() === ((_a = refs.propertyPath) == null ? void 0 : _a.toString())) {
        return parseDef(def.innerType._def, refs);
    }
    const innerSchema = parseDef(def.innerType._def, __spreadProps(__spreadValues({}, refs), {
        currentPath: [
            ...refs.currentPath,
            "anyOf",
            "1"
        ]
    }));
    return innerSchema ? {
        anyOf: [
            {
                not: parseAnyDef()
            },
            innerSchema
        ]
    } : parseAnyDef();
};
var parsePipelineDef = (def, refs)=>{
    if (refs.pipeStrategy === "input") {
        return parseDef(def.in._def, refs);
    } else if (refs.pipeStrategy === "output") {
        return parseDef(def.out._def, refs);
    }
    const a = parseDef(def.in._def, __spreadProps(__spreadValues({}, refs), {
        currentPath: [
            ...refs.currentPath,
            "allOf",
            "0"
        ]
    }));
    const b = parseDef(def.out._def, __spreadProps(__spreadValues({}, refs), {
        currentPath: [
            ...refs.currentPath,
            "allOf",
            a ? "1" : "0"
        ]
    }));
    return {
        allOf: [
            a,
            b
        ].filter((x)=>x !== void 0)
    };
};
function parsePromiseDef(def, refs) {
    return parseDef(def.type._def, refs);
}
function parseSetDef(def, refs) {
    const items = parseDef(def.valueType._def, __spreadProps(__spreadValues({}, refs), {
        currentPath: [
            ...refs.currentPath,
            "items"
        ]
    }));
    const schema = {
        type: "array",
        uniqueItems: true,
        items
    };
    if (def.minSize) {
        schema.minItems = def.minSize.value;
    }
    if (def.maxSize) {
        schema.maxItems = def.maxSize.value;
    }
    return schema;
}
function parseTupleDef(def, refs) {
    if (def.rest) {
        return {
            type: "array",
            minItems: def.items.length,
            items: def.items.map((x, i)=>parseDef(x._def, __spreadProps(__spreadValues({}, refs), {
                    currentPath: [
                        ...refs.currentPath,
                        "items",
                        `${i}`
                    ]
                }))).reduce((acc, x)=>x === void 0 ? acc : [
                    ...acc,
                    x
                ], []),
            additionalItems: parseDef(def.rest._def, __spreadProps(__spreadValues({}, refs), {
                currentPath: [
                    ...refs.currentPath,
                    "additionalItems"
                ]
            }))
        };
    } else {
        return {
            type: "array",
            minItems: def.items.length,
            maxItems: def.items.length,
            items: def.items.map((x, i)=>parseDef(x._def, __spreadProps(__spreadValues({}, refs), {
                    currentPath: [
                        ...refs.currentPath,
                        "items",
                        `${i}`
                    ]
                }))).reduce((acc, x)=>x === void 0 ? acc : [
                    ...acc,
                    x
                ], [])
        };
    }
}
function parseUndefinedDef() {
    return {
        not: parseAnyDef()
    };
}
function parseUnknownDef() {
    return parseAnyDef();
}
var parseReadonlyDef = (def, refs)=>{
    return parseDef(def.innerType._def, refs);
};
var selectParser = (def, typeName, refs)=>{
    switch(typeName){
        case import_v315.ZodFirstPartyTypeKind.ZodString:
            return parseStringDef(def, refs);
        case import_v315.ZodFirstPartyTypeKind.ZodNumber:
            return parseNumberDef(def);
        case import_v315.ZodFirstPartyTypeKind.ZodObject:
            return parseObjectDef(def, refs);
        case import_v315.ZodFirstPartyTypeKind.ZodBigInt:
            return parseBigintDef(def);
        case import_v315.ZodFirstPartyTypeKind.ZodBoolean:
            return parseBooleanDef();
        case import_v315.ZodFirstPartyTypeKind.ZodDate:
            return parseDateDef(def, refs);
        case import_v315.ZodFirstPartyTypeKind.ZodUndefined:
            return parseUndefinedDef();
        case import_v315.ZodFirstPartyTypeKind.ZodNull:
            return parseNullDef();
        case import_v315.ZodFirstPartyTypeKind.ZodArray:
            return parseArrayDef(def, refs);
        case import_v315.ZodFirstPartyTypeKind.ZodUnion:
        case import_v315.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
            return parseUnionDef(def, refs);
        case import_v315.ZodFirstPartyTypeKind.ZodIntersection:
            return parseIntersectionDef(def, refs);
        case import_v315.ZodFirstPartyTypeKind.ZodTuple:
            return parseTupleDef(def, refs);
        case import_v315.ZodFirstPartyTypeKind.ZodRecord:
            return parseRecordDef(def, refs);
        case import_v315.ZodFirstPartyTypeKind.ZodLiteral:
            return parseLiteralDef(def);
        case import_v315.ZodFirstPartyTypeKind.ZodEnum:
            return parseEnumDef(def);
        case import_v315.ZodFirstPartyTypeKind.ZodNativeEnum:
            return parseNativeEnumDef(def);
        case import_v315.ZodFirstPartyTypeKind.ZodNullable:
            return parseNullableDef(def, refs);
        case import_v315.ZodFirstPartyTypeKind.ZodOptional:
            return parseOptionalDef(def, refs);
        case import_v315.ZodFirstPartyTypeKind.ZodMap:
            return parseMapDef(def, refs);
        case import_v315.ZodFirstPartyTypeKind.ZodSet:
            return parseSetDef(def, refs);
        case import_v315.ZodFirstPartyTypeKind.ZodLazy:
            return ()=>def.getter()._def;
        case import_v315.ZodFirstPartyTypeKind.ZodPromise:
            return parsePromiseDef(def, refs);
        case import_v315.ZodFirstPartyTypeKind.ZodNaN:
        case import_v315.ZodFirstPartyTypeKind.ZodNever:
            return parseNeverDef();
        case import_v315.ZodFirstPartyTypeKind.ZodEffects:
            return parseEffectsDef(def, refs);
        case import_v315.ZodFirstPartyTypeKind.ZodAny:
            return parseAnyDef();
        case import_v315.ZodFirstPartyTypeKind.ZodUnknown:
            return parseUnknownDef();
        case import_v315.ZodFirstPartyTypeKind.ZodDefault:
            return parseDefaultDef(def, refs);
        case import_v315.ZodFirstPartyTypeKind.ZodBranded:
            return parseBrandedDef(def, refs);
        case import_v315.ZodFirstPartyTypeKind.ZodReadonly:
            return parseReadonlyDef(def, refs);
        case import_v315.ZodFirstPartyTypeKind.ZodCatch:
            return parseCatchDef(def, refs);
        case import_v315.ZodFirstPartyTypeKind.ZodPipeline:
            return parsePipelineDef(def, refs);
        case import_v315.ZodFirstPartyTypeKind.ZodFunction:
        case import_v315.ZodFirstPartyTypeKind.ZodVoid:
        case import_v315.ZodFirstPartyTypeKind.ZodSymbol:
            return void 0;
        default:
            return /* @__PURE__ */ ((_)=>void 0)(typeName);
    }
};
function parseDef(def, refs, forceResolution = false) {
    var _a;
    const seenItem = refs.seen.get(def);
    if (refs.override) {
        const overrideResult = (_a = refs.override) == null ? void 0 : _a.call(refs, def, refs, seenItem, forceResolution);
        if (overrideResult !== ignoreOverride) {
            return overrideResult;
        }
    }
    if (seenItem && !forceResolution) {
        const seenSchema = get$ref(seenItem, refs);
        if (seenSchema !== void 0) {
            return seenSchema;
        }
    }
    const newItem = {
        def,
        path: refs.currentPath,
        jsonSchema: void 0
    };
    refs.seen.set(def, newItem);
    const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
    const jsonSchema2 = typeof jsonSchemaOrGetter === "function" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
    if (jsonSchema2) {
        addMeta(def, refs, jsonSchema2);
    }
    if (refs.postProcess) {
        const postProcessResult = refs.postProcess(jsonSchema2, def, refs);
        newItem.jsonSchema = jsonSchema2;
        return postProcessResult;
    }
    newItem.jsonSchema = jsonSchema2;
    return jsonSchema2;
}
var get$ref = (item, refs)=>{
    switch(refs.$refStrategy){
        case "root":
            return {
                $ref: item.path.join("/")
            };
        case "relative":
            return {
                $ref: getRelativePath(refs.currentPath, item.path)
            };
        case "none":
        case "seen":
            {
                if (item.path.length < refs.currentPath.length && item.path.every((value, index)=>refs.currentPath[index] === value)) {
                    console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
                    return parseAnyDef();
                }
                return refs.$refStrategy === "seen" ? parseAnyDef() : void 0;
            }
    }
};
var addMeta = (def, refs, jsonSchema2)=>{
    if (def.description) {
        jsonSchema2.description = def.description;
    }
    return jsonSchema2;
};
var getRefs = (options)=>{
    const _options = getDefaultOptions(options);
    const currentPath = _options.name !== void 0 ? [
        ..._options.basePath,
        _options.definitionPath,
        _options.name
    ] : _options.basePath;
    return __spreadProps(__spreadValues({}, _options), {
        currentPath,
        propertyPath: void 0,
        seen: new Map(Object.entries(_options.definitions).map(([name, def])=>[
                def._def,
                {
                    def: def._def,
                    path: [
                        ..._options.basePath,
                        _options.definitionPath,
                        name
                    ],
                    // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
                    jsonSchema: void 0
                }
            ]))
    });
};
var zodToJsonSchema7 = (schema, options)=>{
    var _a;
    const refs = getRefs(options);
    let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name2, schema2])=>{
        var _a2;
        return __spreadProps(__spreadValues({}, acc), {
            [name2]: (_a2 = parseDef(schema2._def, __spreadProps(__spreadValues({}, refs), {
                currentPath: [
                    ...refs.basePath,
                    refs.definitionPath,
                    name2
                ]
            }), true)) != null ? _a2 : parseAnyDef()
        });
    }, {}) : void 0;
    const name = typeof options === "string" ? options : (options == null ? void 0 : options.nameStrategy) === "title" ? void 0 : options == null ? void 0 : options.name;
    const main = (_a = parseDef(schema._def, name === void 0 ? refs : __spreadProps(__spreadValues({}, refs), {
        currentPath: [
            ...refs.basePath,
            refs.definitionPath,
            name
        ]
    }), false)) != null ? _a : parseAnyDef();
    const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
    if (title !== void 0) {
        main.title = title;
    }
    const combined = name === void 0 ? definitions ? __spreadProps(__spreadValues({}, main), {
        [refs.definitionPath]: definitions
    }) : main : {
        $ref: [
            ...refs.$refStrategy === "relative" ? [] : refs.basePath,
            refs.definitionPath,
            name
        ].join("/"),
        [refs.definitionPath]: __spreadProps(__spreadValues({}, definitions), {
            [name]: main
        })
    };
    combined.$schema = "http://json-schema.org/draft-07/schema#";
    return combined;
};
var zod_to_json_schema_default = zodToJsonSchema7;
function zod3Schema(zodSchema2, options) {
    var _a;
    const useReferences = (_a = options == null ? void 0 : options.useReferences) != null ? _a : false;
    return jsonSchema(// defer json schema creation to avoid unnecessary computation when only validation is needed
    ()=>zod_to_json_schema_default(zodSchema2, {
            $refStrategy: useReferences ? "root" : "none"
        }), {
        validate: (value)=>__async(null, null, function*() {
                const result = yield zodSchema2.safeParseAsync(value);
                return result.success ? {
                    success: true,
                    value: result.data
                } : {
                    success: false,
                    error: result.error
                };
            })
    });
}
function zod4Schema(zodSchema2, options) {
    var _a;
    const useReferences = (_a = options == null ? void 0 : options.useReferences) != null ? _a : false;
    return jsonSchema(// defer json schema creation to avoid unnecessary computation when only validation is needed
    ()=>z42.toJSONSchema(zodSchema2, {
            target: "draft-7",
            io: "output",
            reused: useReferences ? "ref" : "inline"
        }), {
        validate: (value)=>__async(null, null, function*() {
                const result = yield z42.safeParseAsync(zodSchema2, value);
                return result.success ? {
                    success: true,
                    value: result.data
                } : {
                    success: false,
                    error: result.error
                };
            })
    });
}
function isZod4Schema(zodSchema2) {
    return "_zod" in zodSchema2;
}
function zodSchema(zodSchema2, options) {
    if (isZod4Schema(zodSchema2)) {
        return zod4Schema(zodSchema2, options);
    } else {
        return zod3Schema(zodSchema2, options);
    }
}
var schemaSymbol = Symbol.for("vercel.ai.schema");
function lazySchema(createSchema) {
    let schema;
    return ()=>{
        if (schema == null) {
            schema = createSchema();
        }
        return schema;
    };
}
function jsonSchema(jsonSchema2, { validate } = {}) {
    return {
        [schemaSymbol]: true,
        _type: void 0,
        // should never be used directly
        [validatorSymbol]: true,
        get jsonSchema () {
            if (typeof jsonSchema2 === "function") {
                jsonSchema2 = jsonSchema2();
            }
            return jsonSchema2;
        },
        validate
    };
}
var { btoa, atob } = globalThis;
function convertBase64ToUint8Array(base64String) {
    const base64Url = base64String.replace(/-/g, "+").replace(/_/g, "/");
    const latin1string = atob(base64Url);
    return Uint8Array.from(latin1string, (byte)=>byte.codePointAt(0));
}
function convertUint8ArrayToBase64(array) {
    let latin1string = "";
    for(let i = 0; i < array.length; i++){
        latin1string += String.fromCodePoint(array[i]);
    }
    return btoa(latin1string);
}
function convertToBase64(value) {
    return value instanceof Uint8Array ? convertUint8ArrayToBase64(value) : value;
}
function withoutTrailingSlash(url) {
    return url == null ? void 0 : url.replace(/\/$/, "");
}
// ../../node_modules/.pnpm/@ai-sdk+openai@2.0.53_zod@3.25.67/node_modules/@ai-sdk/openai/dist/index.mjs
var import_provider12 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v4 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_provider13 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v42 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v43 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_provider14 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_provider15 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v44 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v45 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_provider16 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v46 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v47 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v48 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v49 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v410 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v411 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v412 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v413 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v414 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_provider17 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_provider18 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v415 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v416 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v417 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_provider19 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v418 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v419 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v420 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var openaiErrorDataSchema = import_v4.z.object({
    error: import_v4.z.object({
        message: import_v4.z.string(),
        // The additional information below is handled loosely to support
        // OpenAI-compatible providers that have slightly different error
        // responses:
        type: import_v4.z.string().nullish(),
        param: import_v4.z.any().nullish(),
        code: import_v4.z.union([
            import_v4.z.string(),
            import_v4.z.number()
        ]).nullish()
    })
});
var openaiFailedResponseHandler = createJsonErrorResponseHandler({
    errorSchema: openaiErrorDataSchema,
    errorToMessage: (data)=>data.error.message
});
function convertToOpenAIChatMessages({ prompt, systemMessageMode = "system" }) {
    const messages = [];
    const warnings = [];
    for (const { role, content } of prompt){
        switch(role){
            case "system":
                {
                    switch(systemMessageMode){
                        case "system":
                            {
                                messages.push({
                                    role: "system",
                                    content
                                });
                                break;
                            }
                        case "developer":
                            {
                                messages.push({
                                    role: "developer",
                                    content
                                });
                                break;
                            }
                        case "remove":
                            {
                                warnings.push({
                                    type: "other",
                                    message: "system messages are removed for this model"
                                });
                                break;
                            }
                        default:
                            {
                                const _exhaustiveCheck = systemMessageMode;
                                throw new Error(`Unsupported system message mode: ${_exhaustiveCheck}`);
                            }
                    }
                    break;
                }
            case "user":
                {
                    if (content.length === 1 && content[0].type === "text") {
                        messages.push({
                            role: "user",
                            content: content[0].text
                        });
                        break;
                    }
                    messages.push({
                        role: "user",
                        content: content.map((part, index)=>{
                            var _a, _b, _c;
                            switch(part.type){
                                case "text":
                                    {
                                        return {
                                            type: "text",
                                            text: part.text
                                        };
                                    }
                                case "file":
                                    {
                                        if (part.mediaType.startsWith("image/")) {
                                            const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                                            return {
                                                type: "image_url",
                                                image_url: {
                                                    url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${convertToBase64(part.data)}`,
                                                    // OpenAI specific extension: image detail
                                                    detail: (_b = (_a = part.providerOptions) == null ? void 0 : _a.openai) == null ? void 0 : _b.imageDetail
                                                }
                                            };
                                        } else if (part.mediaType.startsWith("audio/")) {
                                            if (part.data instanceof URL) {
                                                throw new import_provider13.UnsupportedFunctionalityError({
                                                    functionality: "audio file parts with URLs"
                                                });
                                            }
                                            switch(part.mediaType){
                                                case "audio/wav":
                                                    {
                                                        return {
                                                            type: "input_audio",
                                                            input_audio: {
                                                                data: convertToBase64(part.data),
                                                                format: "wav"
                                                            }
                                                        };
                                                    }
                                                case "audio/mp3":
                                                case "audio/mpeg":
                                                    {
                                                        return {
                                                            type: "input_audio",
                                                            input_audio: {
                                                                data: convertToBase64(part.data),
                                                                format: "mp3"
                                                            }
                                                        };
                                                    }
                                                default:
                                                    {
                                                        throw new import_provider13.UnsupportedFunctionalityError({
                                                            functionality: `audio content parts with media type ${part.mediaType}`
                                                        });
                                                    }
                                            }
                                        } else if (part.mediaType === "application/pdf") {
                                            if (part.data instanceof URL) {
                                                throw new import_provider13.UnsupportedFunctionalityError({
                                                    functionality: "PDF file parts with URLs"
                                                });
                                            }
                                            return {
                                                type: "file",
                                                file: typeof part.data === "string" && part.data.startsWith("file-") ? {
                                                    file_id: part.data
                                                } : {
                                                    filename: (_c = part.filename) != null ? _c : `part-${index}.pdf`,
                                                    file_data: `data:application/pdf;base64,${convertToBase64(part.data)}`
                                                }
                                            };
                                        } else {
                                            throw new import_provider13.UnsupportedFunctionalityError({
                                                functionality: `file part media type ${part.mediaType}`
                                            });
                                        }
                                    }
                            }
                        })
                    });
                    break;
                }
            case "assistant":
                {
                    let text = "";
                    const toolCalls = [];
                    for (const part of content){
                        switch(part.type){
                            case "text":
                                {
                                    text += part.text;
                                    break;
                                }
                            case "tool-call":
                                {
                                    toolCalls.push({
                                        id: part.toolCallId,
                                        type: "function",
                                        function: {
                                            name: part.toolName,
                                            arguments: JSON.stringify(part.input)
                                        }
                                    });
                                    break;
                                }
                        }
                    }
                    messages.push({
                        role: "assistant",
                        content: text,
                        tool_calls: toolCalls.length > 0 ? toolCalls : void 0
                    });
                    break;
                }
            case "tool":
                {
                    for (const toolResponse of content){
                        const output = toolResponse.output;
                        let contentValue;
                        switch(output.type){
                            case "text":
                            case "error-text":
                                contentValue = output.value;
                                break;
                            case "content":
                            case "json":
                            case "error-json":
                                contentValue = JSON.stringify(output.value);
                                break;
                        }
                        messages.push({
                            role: "tool",
                            tool_call_id: toolResponse.toolCallId,
                            content: contentValue
                        });
                    }
                    break;
                }
            default:
                {
                    const _exhaustiveCheck = role;
                    throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
                }
        }
    }
    return {
        messages,
        warnings
    };
}
function getResponseMetadata({ id, model, created }) {
    return {
        id: id != null ? id : void 0,
        modelId: model != null ? model : void 0,
        timestamp: created != null ? new Date(created * 1e3) : void 0
    };
}
function mapOpenAIFinishReason(finishReason) {
    switch(finishReason){
        case "stop":
            return "stop";
        case "length":
            return "length";
        case "content_filter":
            return "content-filter";
        case "function_call":
        case "tool_calls":
            return "tool-calls";
        default:
            return "unknown";
    }
}
var openaiChatResponseSchema = lazyValidator(()=>zodSchema(import_v42.z.object({
        id: import_v42.z.string().nullish(),
        created: import_v42.z.number().nullish(),
        model: import_v42.z.string().nullish(),
        choices: import_v42.z.array(import_v42.z.object({
            message: import_v42.z.object({
                role: import_v42.z.literal("assistant").nullish(),
                content: import_v42.z.string().nullish(),
                tool_calls: import_v42.z.array(import_v42.z.object({
                    id: import_v42.z.string().nullish(),
                    type: import_v42.z.literal("function"),
                    function: import_v42.z.object({
                        name: import_v42.z.string(),
                        arguments: import_v42.z.string()
                    })
                })).nullish(),
                annotations: import_v42.z.array(import_v42.z.object({
                    type: import_v42.z.literal("url_citation"),
                    start_index: import_v42.z.number(),
                    end_index: import_v42.z.number(),
                    url: import_v42.z.string(),
                    title: import_v42.z.string()
                })).nullish()
            }),
            index: import_v42.z.number(),
            logprobs: import_v42.z.object({
                content: import_v42.z.array(import_v42.z.object({
                    token: import_v42.z.string(),
                    logprob: import_v42.z.number(),
                    top_logprobs: import_v42.z.array(import_v42.z.object({
                        token: import_v42.z.string(),
                        logprob: import_v42.z.number()
                    }))
                })).nullish()
            }).nullish(),
            finish_reason: import_v42.z.string().nullish()
        })),
        usage: import_v42.z.object({
            prompt_tokens: import_v42.z.number().nullish(),
            completion_tokens: import_v42.z.number().nullish(),
            total_tokens: import_v42.z.number().nullish(),
            prompt_tokens_details: import_v42.z.object({
                cached_tokens: import_v42.z.number().nullish()
            }).nullish(),
            completion_tokens_details: import_v42.z.object({
                reasoning_tokens: import_v42.z.number().nullish(),
                accepted_prediction_tokens: import_v42.z.number().nullish(),
                rejected_prediction_tokens: import_v42.z.number().nullish()
            }).nullish()
        }).nullish()
    })));
var openaiChatChunkSchema = lazyValidator(()=>zodSchema(import_v42.z.union([
        import_v42.z.object({
            id: import_v42.z.string().nullish(),
            created: import_v42.z.number().nullish(),
            model: import_v42.z.string().nullish(),
            choices: import_v42.z.array(import_v42.z.object({
                delta: import_v42.z.object({
                    role: import_v42.z.enum([
                        "assistant"
                    ]).nullish(),
                    content: import_v42.z.string().nullish(),
                    tool_calls: import_v42.z.array(import_v42.z.object({
                        index: import_v42.z.number(),
                        id: import_v42.z.string().nullish(),
                        type: import_v42.z.literal("function").nullish(),
                        function: import_v42.z.object({
                            name: import_v42.z.string().nullish(),
                            arguments: import_v42.z.string().nullish()
                        })
                    })).nullish(),
                    annotations: import_v42.z.array(import_v42.z.object({
                        type: import_v42.z.literal("url_citation"),
                        start_index: import_v42.z.number(),
                        end_index: import_v42.z.number(),
                        url: import_v42.z.string(),
                        title: import_v42.z.string()
                    })).nullish()
                }).nullish(),
                logprobs: import_v42.z.object({
                    content: import_v42.z.array(import_v42.z.object({
                        token: import_v42.z.string(),
                        logprob: import_v42.z.number(),
                        top_logprobs: import_v42.z.array(import_v42.z.object({
                            token: import_v42.z.string(),
                            logprob: import_v42.z.number()
                        }))
                    })).nullish()
                }).nullish(),
                finish_reason: import_v42.z.string().nullish(),
                index: import_v42.z.number()
            })),
            usage: import_v42.z.object({
                prompt_tokens: import_v42.z.number().nullish(),
                completion_tokens: import_v42.z.number().nullish(),
                total_tokens: import_v42.z.number().nullish(),
                prompt_tokens_details: import_v42.z.object({
                    cached_tokens: import_v42.z.number().nullish()
                }).nullish(),
                completion_tokens_details: import_v42.z.object({
                    reasoning_tokens: import_v42.z.number().nullish(),
                    accepted_prediction_tokens: import_v42.z.number().nullish(),
                    rejected_prediction_tokens: import_v42.z.number().nullish()
                }).nullish()
            }).nullish()
        }),
        openaiErrorDataSchema
    ])));
var openaiChatLanguageModelOptions = lazyValidator(()=>zodSchema(import_v43.z.object({
        /**
       * Modify the likelihood of specified tokens appearing in the completion.
       *
       * Accepts a JSON object that maps tokens (specified by their token ID in
       * the GPT tokenizer) to an associated bias value from -100 to 100.
       */ logitBias: import_v43.z.record(import_v43.z.coerce.number(), import_v43.z.number()).optional(),
        /**
       * Return the log probabilities of the tokens.
       *
       * Setting to true will return the log probabilities of the tokens that
       * were generated.
       *
       * Setting to a number will return the log probabilities of the top n
       * tokens that were generated.
       */ logprobs: import_v43.z.union([
            import_v43.z.boolean(),
            import_v43.z.number()
        ]).optional(),
        /**
       * Whether to enable parallel function calling during tool use. Default to true.
       */ parallelToolCalls: import_v43.z.boolean().optional(),
        /**
       * A unique identifier representing your end-user, which can help OpenAI to
       * monitor and detect abuse.
       */ user: import_v43.z.string().optional(),
        /**
       * Reasoning effort for reasoning models. Defaults to `medium`.
       */ reasoningEffort: import_v43.z.enum([
            "minimal",
            "low",
            "medium",
            "high"
        ]).optional(),
        /**
       * Maximum number of completion tokens to generate. Useful for reasoning models.
       */ maxCompletionTokens: import_v43.z.number().optional(),
        /**
       * Whether to enable persistence in responses API.
       */ store: import_v43.z.boolean().optional(),
        /**
       * Metadata to associate with the request.
       */ metadata: import_v43.z.record(import_v43.z.string().max(64), import_v43.z.string().max(512)).optional(),
        /**
       * Parameters for prediction mode.
       */ prediction: import_v43.z.record(import_v43.z.string(), import_v43.z.any()).optional(),
        /**
       * Whether to use structured outputs.
       *
       * @default true
       */ structuredOutputs: import_v43.z.boolean().optional(),
        /**
       * Service tier for the request.
       * - 'auto': Default service tier. The request will be processed with the service tier configured in the
       *           Project settings. Unless otherwise configured, the Project will use 'default'.
       * - 'flex': 50% cheaper processing at the cost of increased latency. Only available for o3 and o4-mini models.
       * - 'priority': Higher-speed processing with predictably low latency at premium cost. Available for Enterprise customers.
       * - 'default': The request will be processed with the standard pricing and performance for the selected model.
       *
       * @default 'auto'
       */ serviceTier: import_v43.z.enum([
            "auto",
            "flex",
            "priority",
            "default"
        ]).optional(),
        /**
       * Whether to use strict JSON schema validation.
       *
       * @default false
       */ strictJsonSchema: import_v43.z.boolean().optional(),
        /**
       * Controls the verbosity of the model's responses.
       * Lower values will result in more concise responses, while higher values will result in more verbose responses.
       */ textVerbosity: import_v43.z.enum([
            "low",
            "medium",
            "high"
        ]).optional(),
        /**
       * A cache key for prompt caching. Allows manual control over prompt caching behavior.
       * Useful for improving cache hit rates and working around automatic caching issues.
       */ promptCacheKey: import_v43.z.string().optional(),
        /**
       * A stable identifier used to help detect users of your application
       * that may be violating OpenAI's usage policies. The IDs should be a
       * string that uniquely identifies each user. We recommend hashing their
       * username or email address, in order to avoid sending us any identifying
       * information.
       */ safetyIdentifier: import_v43.z.string().optional()
    })));
function prepareChatTools({ tools, toolChoice, structuredOutputs, strictJsonSchema }) {
    tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
    const toolWarnings = [];
    if (tools == null) {
        return {
            tools: void 0,
            toolChoice: void 0,
            toolWarnings
        };
    }
    const openaiTools2 = [];
    for (const tool12 of tools){
        switch(tool12.type){
            case "function":
                openaiTools2.push({
                    type: "function",
                    function: {
                        name: tool12.name,
                        description: tool12.description,
                        parameters: tool12.inputSchema,
                        strict: structuredOutputs ? strictJsonSchema : void 0
                    }
                });
                break;
            default:
                toolWarnings.push({
                    type: "unsupported-tool",
                    tool: tool12
                });
                break;
        }
    }
    if (toolChoice == null) {
        return {
            tools: openaiTools2,
            toolChoice: void 0,
            toolWarnings
        };
    }
    const type = toolChoice.type;
    switch(type){
        case "auto":
        case "none":
        case "required":
            return {
                tools: openaiTools2,
                toolChoice: type,
                toolWarnings
            };
        case "tool":
            return {
                tools: openaiTools2,
                toolChoice: {
                    type: "function",
                    function: {
                        name: toolChoice.toolName
                    }
                },
                toolWarnings
            };
        default:
            {
                const _exhaustiveCheck = type;
                throw new import_provider14.UnsupportedFunctionalityError({
                    functionality: `tool choice type: ${_exhaustiveCheck}`
                });
            }
    }
}
var OpenAIChatLanguageModel = class {
    constructor(modelId, config){
        this.specificationVersion = "v2";
        this.supportedUrls = {
            "image/*": [
                /^https?:\/\/.*$/
            ]
        };
        this.modelId = modelId;
        this.config = config;
    }
    get provider() {
        return this.config.provider;
    }
    getArgs(_0) {
        return __async(this, arguments, function*({ prompt, maxOutputTokens, temperature, topP, topK, frequencyPenalty, presencePenalty, stopSequences, responseFormat, seed, tools, toolChoice, providerOptions }) {
            var _a, _b, _c, _d;
            const warnings = [];
            const openaiOptions = (_a = yield parseProviderOptions({
                provider: "openai",
                providerOptions,
                schema: openaiChatLanguageModelOptions
            })) != null ? _a : {};
            const structuredOutputs = (_b = openaiOptions.structuredOutputs) != null ? _b : true;
            if (topK != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "topK"
                });
            }
            if ((responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && !structuredOutputs) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "responseFormat",
                    details: "JSON response format schema is only supported with structuredOutputs"
                });
            }
            const { messages, warnings: messageWarnings } = convertToOpenAIChatMessages({
                prompt,
                systemMessageMode: getSystemMessageMode(this.modelId)
            });
            warnings.push(...messageWarnings);
            const strictJsonSchema = (_c = openaiOptions.strictJsonSchema) != null ? _c : false;
            const baseArgs = {
                // model id:
                model: this.modelId,
                // model specific settings:
                logit_bias: openaiOptions.logitBias,
                logprobs: openaiOptions.logprobs === true || typeof openaiOptions.logprobs === "number" ? true : void 0,
                top_logprobs: typeof openaiOptions.logprobs === "number" ? openaiOptions.logprobs : typeof openaiOptions.logprobs === "boolean" ? openaiOptions.logprobs ? 0 : void 0 : void 0,
                user: openaiOptions.user,
                parallel_tool_calls: openaiOptions.parallelToolCalls,
                // standardized settings:
                max_tokens: maxOutputTokens,
                temperature,
                top_p: topP,
                frequency_penalty: frequencyPenalty,
                presence_penalty: presencePenalty,
                response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? structuredOutputs && responseFormat.schema != null ? {
                    type: "json_schema",
                    json_schema: {
                        schema: responseFormat.schema,
                        strict: strictJsonSchema,
                        name: (_d = responseFormat.name) != null ? _d : "response",
                        description: responseFormat.description
                    }
                } : {
                    type: "json_object"
                } : void 0,
                stop: stopSequences,
                seed,
                verbosity: openaiOptions.textVerbosity,
                // openai specific settings:
                // TODO AI SDK 6: remove, we auto-map maxOutputTokens now
                max_completion_tokens: openaiOptions.maxCompletionTokens,
                store: openaiOptions.store,
                metadata: openaiOptions.metadata,
                prediction: openaiOptions.prediction,
                reasoning_effort: openaiOptions.reasoningEffort,
                service_tier: openaiOptions.serviceTier,
                prompt_cache_key: openaiOptions.promptCacheKey,
                safety_identifier: openaiOptions.safetyIdentifier,
                // messages:
                messages
            };
            if (isReasoningModel(this.modelId)) {
                if (baseArgs.temperature != null) {
                    baseArgs.temperature = void 0;
                    warnings.push({
                        type: "unsupported-setting",
                        setting: "temperature",
                        details: "temperature is not supported for reasoning models"
                    });
                }
                if (baseArgs.top_p != null) {
                    baseArgs.top_p = void 0;
                    warnings.push({
                        type: "unsupported-setting",
                        setting: "topP",
                        details: "topP is not supported for reasoning models"
                    });
                }
                if (baseArgs.frequency_penalty != null) {
                    baseArgs.frequency_penalty = void 0;
                    warnings.push({
                        type: "unsupported-setting",
                        setting: "frequencyPenalty",
                        details: "frequencyPenalty is not supported for reasoning models"
                    });
                }
                if (baseArgs.presence_penalty != null) {
                    baseArgs.presence_penalty = void 0;
                    warnings.push({
                        type: "unsupported-setting",
                        setting: "presencePenalty",
                        details: "presencePenalty is not supported for reasoning models"
                    });
                }
                if (baseArgs.logit_bias != null) {
                    baseArgs.logit_bias = void 0;
                    warnings.push({
                        type: "other",
                        message: "logitBias is not supported for reasoning models"
                    });
                }
                if (baseArgs.logprobs != null) {
                    baseArgs.logprobs = void 0;
                    warnings.push({
                        type: "other",
                        message: "logprobs is not supported for reasoning models"
                    });
                }
                if (baseArgs.top_logprobs != null) {
                    baseArgs.top_logprobs = void 0;
                    warnings.push({
                        type: "other",
                        message: "topLogprobs is not supported for reasoning models"
                    });
                }
                if (baseArgs.max_tokens != null) {
                    if (baseArgs.max_completion_tokens == null) {
                        baseArgs.max_completion_tokens = baseArgs.max_tokens;
                    }
                    baseArgs.max_tokens = void 0;
                }
            } else if (this.modelId.startsWith("gpt-4o-search-preview") || this.modelId.startsWith("gpt-4o-mini-search-preview")) {
                if (baseArgs.temperature != null) {
                    baseArgs.temperature = void 0;
                    warnings.push({
                        type: "unsupported-setting",
                        setting: "temperature",
                        details: "temperature is not supported for the search preview models and has been removed."
                    });
                }
            }
            if (openaiOptions.serviceTier === "flex" && !supportsFlexProcessing(this.modelId)) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "serviceTier",
                    details: "flex processing is only available for o3, o4-mini, and gpt-5 models"
                });
                baseArgs.service_tier = void 0;
            }
            if (openaiOptions.serviceTier === "priority" && !supportsPriorityProcessing(this.modelId)) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "serviceTier",
                    details: "priority processing is only available for supported models (gpt-4, gpt-5, gpt-5-mini, o3, o4-mini) and requires Enterprise access. gpt-5-nano is not supported"
                });
                baseArgs.service_tier = void 0;
            }
            const { tools: openaiTools2, toolChoice: openaiToolChoice, toolWarnings } = prepareChatTools({
                tools,
                toolChoice,
                structuredOutputs,
                strictJsonSchema
            });
            return {
                args: __spreadProps(__spreadValues({}, baseArgs), {
                    tools: openaiTools2,
                    tool_choice: openaiToolChoice
                }),
                warnings: [
                    ...warnings,
                    ...toolWarnings
                ]
            };
        });
    }
    doGenerate(options) {
        return __async(this, null, function*() {
            var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
            const { args: body, warnings } = yield this.getArgs(options);
            const { responseHeaders, value: response, rawValue: rawResponse } = yield postJsonToApi({
                url: this.config.url({
                    path: "/chat/completions",
                    modelId: this.modelId
                }),
                headers: combineHeaders(this.config.headers(), options.headers),
                body,
                failedResponseHandler: openaiFailedResponseHandler,
                successfulResponseHandler: createJsonResponseHandler(openaiChatResponseSchema),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            const choice = response.choices[0];
            const content = [];
            const text = choice.message.content;
            if (text != null && text.length > 0) {
                content.push({
                    type: "text",
                    text
                });
            }
            for (const toolCall of (_a = choice.message.tool_calls) != null ? _a : []){
                content.push({
                    type: "tool-call",
                    toolCallId: (_b = toolCall.id) != null ? _b : generateId(),
                    toolName: toolCall.function.name,
                    input: toolCall.function.arguments
                });
            }
            for (const annotation of (_c = choice.message.annotations) != null ? _c : []){
                content.push({
                    type: "source",
                    sourceType: "url",
                    id: generateId(),
                    url: annotation.url,
                    title: annotation.title
                });
            }
            const completionTokenDetails = (_d = response.usage) == null ? void 0 : _d.completion_tokens_details;
            const promptTokenDetails = (_e = response.usage) == null ? void 0 : _e.prompt_tokens_details;
            const providerMetadata = {
                openai: {}
            };
            if ((completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens) != null) {
                providerMetadata.openai.acceptedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens;
            }
            if ((completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens) != null) {
                providerMetadata.openai.rejectedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens;
            }
            if (((_f = choice.logprobs) == null ? void 0 : _f.content) != null) {
                providerMetadata.openai.logprobs = choice.logprobs.content;
            }
            return {
                content,
                finishReason: mapOpenAIFinishReason(choice.finish_reason),
                usage: {
                    inputTokens: (_h = (_g = response.usage) == null ? void 0 : _g.prompt_tokens) != null ? _h : void 0,
                    outputTokens: (_j = (_i = response.usage) == null ? void 0 : _i.completion_tokens) != null ? _j : void 0,
                    totalTokens: (_l = (_k = response.usage) == null ? void 0 : _k.total_tokens) != null ? _l : void 0,
                    reasoningTokens: (_m = completionTokenDetails == null ? void 0 : completionTokenDetails.reasoning_tokens) != null ? _m : void 0,
                    cachedInputTokens: (_n = promptTokenDetails == null ? void 0 : promptTokenDetails.cached_tokens) != null ? _n : void 0
                },
                request: {
                    body
                },
                response: __spreadProps(__spreadValues({}, getResponseMetadata(response)), {
                    headers: responseHeaders,
                    body: rawResponse
                }),
                warnings,
                providerMetadata
            };
        });
    }
    doStream(options) {
        return __async(this, null, function*() {
            const { args, warnings } = yield this.getArgs(options);
            const body = __spreadProps(__spreadValues({}, args), {
                stream: true,
                stream_options: {
                    include_usage: true
                }
            });
            const { responseHeaders, value: response } = yield postJsonToApi({
                url: this.config.url({
                    path: "/chat/completions",
                    modelId: this.modelId
                }),
                headers: combineHeaders(this.config.headers(), options.headers),
                body,
                failedResponseHandler: openaiFailedResponseHandler,
                successfulResponseHandler: createEventSourceResponseHandler(openaiChatChunkSchema),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            const toolCalls = [];
            let finishReason = "unknown";
            const usage = {
                inputTokens: void 0,
                outputTokens: void 0,
                totalTokens: void 0
            };
            let isFirstChunk = true;
            let isActiveText = false;
            const providerMetadata = {
                openai: {}
            };
            return {
                stream: response.pipeThrough(new TransformStream({
                    start (controller) {
                        controller.enqueue({
                            type: "stream-start",
                            warnings
                        });
                    },
                    transform (chunk, controller) {
                        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
                        if (options.includeRawChunks) {
                            controller.enqueue({
                                type: "raw",
                                rawValue: chunk.rawValue
                            });
                        }
                        if (!chunk.success) {
                            finishReason = "error";
                            controller.enqueue({
                                type: "error",
                                error: chunk.error
                            });
                            return;
                        }
                        const value = chunk.value;
                        if ("error" in value) {
                            finishReason = "error";
                            controller.enqueue({
                                type: "error",
                                error: value.error
                            });
                            return;
                        }
                        if (isFirstChunk) {
                            isFirstChunk = false;
                            controller.enqueue(__spreadValues({
                                type: "response-metadata"
                            }, getResponseMetadata(value)));
                        }
                        if (value.usage != null) {
                            usage.inputTokens = (_a = value.usage.prompt_tokens) != null ? _a : void 0;
                            usage.outputTokens = (_b = value.usage.completion_tokens) != null ? _b : void 0;
                            usage.totalTokens = (_c = value.usage.total_tokens) != null ? _c : void 0;
                            usage.reasoningTokens = (_e = (_d = value.usage.completion_tokens_details) == null ? void 0 : _d.reasoning_tokens) != null ? _e : void 0;
                            usage.cachedInputTokens = (_g = (_f = value.usage.prompt_tokens_details) == null ? void 0 : _f.cached_tokens) != null ? _g : void 0;
                            if (((_h = value.usage.completion_tokens_details) == null ? void 0 : _h.accepted_prediction_tokens) != null) {
                                providerMetadata.openai.acceptedPredictionTokens = (_i = value.usage.completion_tokens_details) == null ? void 0 : _i.accepted_prediction_tokens;
                            }
                            if (((_j = value.usage.completion_tokens_details) == null ? void 0 : _j.rejected_prediction_tokens) != null) {
                                providerMetadata.openai.rejectedPredictionTokens = (_k = value.usage.completion_tokens_details) == null ? void 0 : _k.rejected_prediction_tokens;
                            }
                        }
                        const choice = value.choices[0];
                        if ((choice == null ? void 0 : choice.finish_reason) != null) {
                            finishReason = mapOpenAIFinishReason(choice.finish_reason);
                        }
                        if (((_l = choice == null ? void 0 : choice.logprobs) == null ? void 0 : _l.content) != null) {
                            providerMetadata.openai.logprobs = choice.logprobs.content;
                        }
                        if ((choice == null ? void 0 : choice.delta) == null) {
                            return;
                        }
                        const delta = choice.delta;
                        if (delta.content != null) {
                            if (!isActiveText) {
                                controller.enqueue({
                                    type: "text-start",
                                    id: "0"
                                });
                                isActiveText = true;
                            }
                            controller.enqueue({
                                type: "text-delta",
                                id: "0",
                                delta: delta.content
                            });
                        }
                        if (delta.tool_calls != null) {
                            for (const toolCallDelta of delta.tool_calls){
                                const index = toolCallDelta.index;
                                if (toolCalls[index] == null) {
                                    if (toolCallDelta.type !== "function") {
                                        throw new import_provider12.InvalidResponseDataError({
                                            data: toolCallDelta,
                                            message: `Expected 'function' type.`
                                        });
                                    }
                                    if (toolCallDelta.id == null) {
                                        throw new import_provider12.InvalidResponseDataError({
                                            data: toolCallDelta,
                                            message: `Expected 'id' to be a string.`
                                        });
                                    }
                                    if (((_m = toolCallDelta.function) == null ? void 0 : _m.name) == null) {
                                        throw new import_provider12.InvalidResponseDataError({
                                            data: toolCallDelta,
                                            message: `Expected 'function.name' to be a string.`
                                        });
                                    }
                                    controller.enqueue({
                                        type: "tool-input-start",
                                        id: toolCallDelta.id,
                                        toolName: toolCallDelta.function.name
                                    });
                                    toolCalls[index] = {
                                        id: toolCallDelta.id,
                                        type: "function",
                                        function: {
                                            name: toolCallDelta.function.name,
                                            arguments: (_n = toolCallDelta.function.arguments) != null ? _n : ""
                                        },
                                        hasFinished: false
                                    };
                                    const toolCall2 = toolCalls[index];
                                    if (((_o = toolCall2.function) == null ? void 0 : _o.name) != null && ((_p = toolCall2.function) == null ? void 0 : _p.arguments) != null) {
                                        if (toolCall2.function.arguments.length > 0) {
                                            controller.enqueue({
                                                type: "tool-input-delta",
                                                id: toolCall2.id,
                                                delta: toolCall2.function.arguments
                                            });
                                        }
                                        if (isParsableJson(toolCall2.function.arguments)) {
                                            controller.enqueue({
                                                type: "tool-input-end",
                                                id: toolCall2.id
                                            });
                                            controller.enqueue({
                                                type: "tool-call",
                                                toolCallId: (_q = toolCall2.id) != null ? _q : generateId(),
                                                toolName: toolCall2.function.name,
                                                input: toolCall2.function.arguments
                                            });
                                            toolCall2.hasFinished = true;
                                        }
                                    }
                                    continue;
                                }
                                const toolCall = toolCalls[index];
                                if (toolCall.hasFinished) {
                                    continue;
                                }
                                if (((_r = toolCallDelta.function) == null ? void 0 : _r.arguments) != null) {
                                    toolCall.function.arguments += (_t = (_s = toolCallDelta.function) == null ? void 0 : _s.arguments) != null ? _t : "";
                                }
                                controller.enqueue({
                                    type: "tool-input-delta",
                                    id: toolCall.id,
                                    delta: (_u = toolCallDelta.function.arguments) != null ? _u : ""
                                });
                                if (((_v = toolCall.function) == null ? void 0 : _v.name) != null && ((_w = toolCall.function) == null ? void 0 : _w.arguments) != null && isParsableJson(toolCall.function.arguments)) {
                                    controller.enqueue({
                                        type: "tool-input-end",
                                        id: toolCall.id
                                    });
                                    controller.enqueue({
                                        type: "tool-call",
                                        toolCallId: (_x = toolCall.id) != null ? _x : generateId(),
                                        toolName: toolCall.function.name,
                                        input: toolCall.function.arguments
                                    });
                                    toolCall.hasFinished = true;
                                }
                            }
                        }
                        if (delta.annotations != null) {
                            for (const annotation of delta.annotations){
                                controller.enqueue({
                                    type: "source",
                                    sourceType: "url",
                                    id: generateId(),
                                    url: annotation.url,
                                    title: annotation.title
                                });
                            }
                        }
                    },
                    flush (controller) {
                        if (isActiveText) {
                            controller.enqueue({
                                type: "text-end",
                                id: "0"
                            });
                        }
                        controller.enqueue(__spreadValues({
                            type: "finish",
                            finishReason,
                            usage
                        }, providerMetadata != null ? {
                            providerMetadata
                        } : {}));
                    }
                })),
                request: {
                    body
                },
                response: {
                    headers: responseHeaders
                }
            };
        });
    }
};
function isReasoningModel(modelId) {
    return (modelId.startsWith("o") || modelId.startsWith("gpt-5")) && !modelId.startsWith("gpt-5-chat");
}
function supportsFlexProcessing(modelId) {
    return modelId.startsWith("o3") || modelId.startsWith("o4-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-chat");
}
function supportsPriorityProcessing(modelId) {
    return modelId.startsWith("gpt-4") || modelId.startsWith("gpt-5-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-nano") && !modelId.startsWith("gpt-5-chat") || modelId.startsWith("o3") || modelId.startsWith("o4-mini");
}
function getSystemMessageMode(modelId) {
    var _a, _b;
    if (!isReasoningModel(modelId)) {
        return "system";
    }
    return (_b = (_a = reasoningModels[modelId]) == null ? void 0 : _a.systemMessageMode) != null ? _b : "developer";
}
var reasoningModels = {
    "o1-mini": {
        systemMessageMode: "remove"
    },
    "o1-mini-2024-09-12": {
        systemMessageMode: "remove"
    },
    "o1-preview": {
        systemMessageMode: "remove"
    },
    "o1-preview-2024-09-12": {
        systemMessageMode: "remove"
    },
    o3: {
        systemMessageMode: "developer"
    },
    "o3-2025-04-16": {
        systemMessageMode: "developer"
    },
    "o3-mini": {
        systemMessageMode: "developer"
    },
    "o3-mini-2025-01-31": {
        systemMessageMode: "developer"
    },
    "o4-mini": {
        systemMessageMode: "developer"
    },
    "o4-mini-2025-04-16": {
        systemMessageMode: "developer"
    }
};
function convertToOpenAICompletionPrompt({ prompt, user = "user", assistant = "assistant" }) {
    let text = "";
    if (prompt[0].role === "system") {
        text += `${prompt[0].content}

`;
        prompt = prompt.slice(1);
    }
    for (const { role, content } of prompt){
        switch(role){
            case "system":
                {
                    throw new import_provider15.InvalidPromptError({
                        message: "Unexpected system message in prompt: ${content}",
                        prompt
                    });
                }
            case "user":
                {
                    const userMessage = content.map((part)=>{
                        switch(part.type){
                            case "text":
                                {
                                    return part.text;
                                }
                        }
                    }).filter(Boolean).join("");
                    text += `${user}:
${userMessage}

`;
                    break;
                }
            case "assistant":
                {
                    const assistantMessage = content.map((part)=>{
                        switch(part.type){
                            case "text":
                                {
                                    return part.text;
                                }
                            case "tool-call":
                                {
                                    throw new import_provider15.UnsupportedFunctionalityError({
                                        functionality: "tool-call messages"
                                    });
                                }
                        }
                    }).join("");
                    text += `${assistant}:
${assistantMessage}

`;
                    break;
                }
            case "tool":
                {
                    throw new import_provider15.UnsupportedFunctionalityError({
                        functionality: "tool messages"
                    });
                }
            default:
                {
                    const _exhaustiveCheck = role;
                    throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
                }
        }
    }
    text += `${assistant}:
`;
    return {
        prompt: text,
        stopSequences: [
            `
${user}:`
        ]
    };
}
function getResponseMetadata2({ id, model, created }) {
    return {
        id: id != null ? id : void 0,
        modelId: model != null ? model : void 0,
        timestamp: created != null ? new Date(created * 1e3) : void 0
    };
}
function mapOpenAIFinishReason2(finishReason) {
    switch(finishReason){
        case "stop":
            return "stop";
        case "length":
            return "length";
        case "content_filter":
            return "content-filter";
        case "function_call":
        case "tool_calls":
            return "tool-calls";
        default:
            return "unknown";
    }
}
var openaiCompletionResponseSchema = lazyValidator(()=>zodSchema(import_v44.z.object({
        id: import_v44.z.string().nullish(),
        created: import_v44.z.number().nullish(),
        model: import_v44.z.string().nullish(),
        choices: import_v44.z.array(import_v44.z.object({
            text: import_v44.z.string(),
            finish_reason: import_v44.z.string(),
            logprobs: import_v44.z.object({
                tokens: import_v44.z.array(import_v44.z.string()),
                token_logprobs: import_v44.z.array(import_v44.z.number()),
                top_logprobs: import_v44.z.array(import_v44.z.record(import_v44.z.string(), import_v44.z.number())).nullish()
            }).nullish()
        })),
        usage: import_v44.z.object({
            prompt_tokens: import_v44.z.number(),
            completion_tokens: import_v44.z.number(),
            total_tokens: import_v44.z.number()
        }).nullish()
    })));
var openaiCompletionChunkSchema = lazyValidator(()=>zodSchema(import_v44.z.union([
        import_v44.z.object({
            id: import_v44.z.string().nullish(),
            created: import_v44.z.number().nullish(),
            model: import_v44.z.string().nullish(),
            choices: import_v44.z.array(import_v44.z.object({
                text: import_v44.z.string(),
                finish_reason: import_v44.z.string().nullish(),
                index: import_v44.z.number(),
                logprobs: import_v44.z.object({
                    tokens: import_v44.z.array(import_v44.z.string()),
                    token_logprobs: import_v44.z.array(import_v44.z.number()),
                    top_logprobs: import_v44.z.array(import_v44.z.record(import_v44.z.string(), import_v44.z.number())).nullish()
                }).nullish()
            })),
            usage: import_v44.z.object({
                prompt_tokens: import_v44.z.number(),
                completion_tokens: import_v44.z.number(),
                total_tokens: import_v44.z.number()
            }).nullish()
        }),
        openaiErrorDataSchema
    ])));
var openaiCompletionProviderOptions = lazyValidator(()=>zodSchema(import_v45.z.object({
        /**
      Echo back the prompt in addition to the completion.
         */ echo: import_v45.z.boolean().optional(),
        /**
      Modify the likelihood of specified tokens appearing in the completion.
      
      Accepts a JSON object that maps tokens (specified by their token ID in
      the GPT tokenizer) to an associated bias value from -100 to 100. You
      can use this tokenizer tool to convert text to token IDs. Mathematically,
      the bias is added to the logits generated by the model prior to sampling.
      The exact effect will vary per model, but values between -1 and 1 should
      decrease or increase likelihood of selection; values like -100 or 100
      should result in a ban or exclusive selection of the relevant token.
      
      As an example, you can pass {"50256": -100} to prevent the <|endoftext|>
      token from being generated.
       */ logitBias: import_v45.z.record(import_v45.z.string(), import_v45.z.number()).optional(),
        /**
      The suffix that comes after a completion of inserted text.
       */ suffix: import_v45.z.string().optional(),
        /**
      A unique identifier representing your end-user, which can help OpenAI to
      monitor and detect abuse. Learn more.
       */ user: import_v45.z.string().optional(),
        /**
      Return the log probabilities of the tokens. Including logprobs will increase
      the response size and can slow down response times. However, it can
      be useful to better understand how the model is behaving.
      Setting to true will return the log probabilities of the tokens that
      were generated.
      Setting to a number will return the log probabilities of the top n
      tokens that were generated.
         */ logprobs: import_v45.z.union([
            import_v45.z.boolean(),
            import_v45.z.number()
        ]).optional()
    })));
var OpenAICompletionLanguageModel = class {
    constructor(modelId, config){
        this.specificationVersion = "v2";
        this.supportedUrls = {
        };
        this.modelId = modelId;
        this.config = config;
    }
    get providerOptionsName() {
        return this.config.provider.split(".")[0].trim();
    }
    get provider() {
        return this.config.provider;
    }
    getArgs(_0) {
        return __async(this, arguments, function*({ prompt, maxOutputTokens, temperature, topP, topK, frequencyPenalty, presencePenalty, stopSequences: userStopSequences, responseFormat, tools, toolChoice, seed, providerOptions }) {
            const warnings = [];
            const openaiOptions = __spreadValues(__spreadValues({}, (yield parseProviderOptions({
                provider: "openai",
                providerOptions,
                schema: openaiCompletionProviderOptions
            }))), (yield parseProviderOptions({
                provider: this.providerOptionsName,
                providerOptions,
                schema: openaiCompletionProviderOptions
            })));
            if (topK != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "topK"
                });
            }
            if (tools == null ? void 0 : tools.length) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "tools"
                });
            }
            if (toolChoice != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "toolChoice"
                });
            }
            if (responseFormat != null && responseFormat.type !== "text") {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "responseFormat",
                    details: "JSON response format is not supported."
                });
            }
            const { prompt: completionPrompt, stopSequences } = convertToOpenAICompletionPrompt({
                prompt
            });
            const stop2 = [
                ...stopSequences != null ? stopSequences : [],
                ...userStopSequences != null ? userStopSequences : []
            ];
            return {
                args: {
                    // model id:
                    model: this.modelId,
                    // model specific settings:
                    echo: openaiOptions.echo,
                    logit_bias: openaiOptions.logitBias,
                    logprobs: (openaiOptions == null ? void 0 : openaiOptions.logprobs) === true ? 0 : (openaiOptions == null ? void 0 : openaiOptions.logprobs) === false ? void 0 : openaiOptions == null ? void 0 : openaiOptions.logprobs,
                    suffix: openaiOptions.suffix,
                    user: openaiOptions.user,
                    // standardized settings:
                    max_tokens: maxOutputTokens,
                    temperature,
                    top_p: topP,
                    frequency_penalty: frequencyPenalty,
                    presence_penalty: presencePenalty,
                    seed,
                    // prompt:
                    prompt: completionPrompt,
                    // stop sequences:
                    stop: stop2.length > 0 ? stop2 : void 0
                },
                warnings
            };
        });
    }
    doGenerate(options) {
        return __async(this, null, function*() {
            var _a, _b, _c;
            const { args, warnings } = yield this.getArgs(options);
            const { responseHeaders, value: response, rawValue: rawResponse } = yield postJsonToApi({
                url: this.config.url({
                    path: "/completions",
                    modelId: this.modelId
                }),
                headers: combineHeaders(this.config.headers(), options.headers),
                body: args,
                failedResponseHandler: openaiFailedResponseHandler,
                successfulResponseHandler: createJsonResponseHandler(openaiCompletionResponseSchema),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            const choice = response.choices[0];
            const providerMetadata = {
                openai: {}
            };
            if (choice.logprobs != null) {
                providerMetadata.openai.logprobs = choice.logprobs;
            }
            return {
                content: [
                    {
                        type: "text",
                        text: choice.text
                    }
                ],
                usage: {
                    inputTokens: (_a = response.usage) == null ? void 0 : _a.prompt_tokens,
                    outputTokens: (_b = response.usage) == null ? void 0 : _b.completion_tokens,
                    totalTokens: (_c = response.usage) == null ? void 0 : _c.total_tokens
                },
                finishReason: mapOpenAIFinishReason2(choice.finish_reason),
                request: {
                    body: args
                },
                response: __spreadProps(__spreadValues({}, getResponseMetadata2(response)), {
                    headers: responseHeaders,
                    body: rawResponse
                }),
                providerMetadata,
                warnings
            };
        });
    }
    doStream(options) {
        return __async(this, null, function*() {
            const { args, warnings } = yield this.getArgs(options);
            const body = __spreadProps(__spreadValues({}, args), {
                stream: true,
                stream_options: {
                    include_usage: true
                }
            });
            const { responseHeaders, value: response } = yield postJsonToApi({
                url: this.config.url({
                    path: "/completions",
                    modelId: this.modelId
                }),
                headers: combineHeaders(this.config.headers(), options.headers),
                body,
                failedResponseHandler: openaiFailedResponseHandler,
                successfulResponseHandler: createEventSourceResponseHandler(openaiCompletionChunkSchema),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            let finishReason = "unknown";
            const providerMetadata = {
                openai: {}
            };
            const usage = {
                inputTokens: void 0,
                outputTokens: void 0,
                totalTokens: void 0
            };
            let isFirstChunk = true;
            return {
                stream: response.pipeThrough(new TransformStream({
                    start (controller) {
                        controller.enqueue({
                            type: "stream-start",
                            warnings
                        });
                    },
                    transform (chunk, controller) {
                        if (options.includeRawChunks) {
                            controller.enqueue({
                                type: "raw",
                                rawValue: chunk.rawValue
                            });
                        }
                        if (!chunk.success) {
                            finishReason = "error";
                            controller.enqueue({
                                type: "error",
                                error: chunk.error
                            });
                            return;
                        }
                        const value = chunk.value;
                        if ("error" in value) {
                            finishReason = "error";
                            controller.enqueue({
                                type: "error",
                                error: value.error
                            });
                            return;
                        }
                        if (isFirstChunk) {
                            isFirstChunk = false;
                            controller.enqueue(__spreadValues({
                                type: "response-metadata"
                            }, getResponseMetadata2(value)));
                            controller.enqueue({
                                type: "text-start",
                                id: "0"
                            });
                        }
                        if (value.usage != null) {
                            usage.inputTokens = value.usage.prompt_tokens;
                            usage.outputTokens = value.usage.completion_tokens;
                            usage.totalTokens = value.usage.total_tokens;
                        }
                        const choice = value.choices[0];
                        if ((choice == null ? void 0 : choice.finish_reason) != null) {
                            finishReason = mapOpenAIFinishReason2(choice.finish_reason);
                        }
                        if ((choice == null ? void 0 : choice.logprobs) != null) {
                            providerMetadata.openai.logprobs = choice.logprobs;
                        }
                        if ((choice == null ? void 0 : choice.text) != null && choice.text.length > 0) {
                            controller.enqueue({
                                type: "text-delta",
                                id: "0",
                                delta: choice.text
                            });
                        }
                    },
                    flush (controller) {
                        if (!isFirstChunk) {
                            controller.enqueue({
                                type: "text-end",
                                id: "0"
                            });
                        }
                        controller.enqueue({
                            type: "finish",
                            finishReason,
                            providerMetadata,
                            usage
                        });
                    }
                })),
                request: {
                    body
                },
                response: {
                    headers: responseHeaders
                }
            };
        });
    }
};
var openaiEmbeddingProviderOptions = lazyValidator(()=>zodSchema(import_v46.z.object({
        /**
      The number of dimensions the resulting output embeddings should have.
      Only supported in text-embedding-3 and later models.
         */ dimensions: import_v46.z.number().optional(),
        /**
      A unique identifier representing your end-user, which can help OpenAI to
      monitor and detect abuse. Learn more.
      */ user: import_v46.z.string().optional()
    })));
var openaiTextEmbeddingResponseSchema = lazyValidator(()=>zodSchema(import_v47.z.object({
        data: import_v47.z.array(import_v47.z.object({
            embedding: import_v47.z.array(import_v47.z.number())
        })),
        usage: import_v47.z.object({
            prompt_tokens: import_v47.z.number()
        }).nullish()
    })));
var OpenAIEmbeddingModel = class {
    constructor(modelId, config){
        this.specificationVersion = "v2";
        this.maxEmbeddingsPerCall = 2048;
        this.supportsParallelCalls = true;
        this.modelId = modelId;
        this.config = config;
    }
    get provider() {
        return this.config.provider;
    }
    doEmbed(_0) {
        return __async(this, arguments, function*({ values, headers, abortSignal, providerOptions }) {
            var _a;
            if (values.length > this.maxEmbeddingsPerCall) {
                throw new import_provider16.TooManyEmbeddingValuesForCallError({
                    provider: this.provider,
                    modelId: this.modelId,
                    maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
                    values
                });
            }
            const openaiOptions = (_a = yield parseProviderOptions({
                provider: "openai",
                providerOptions,
                schema: openaiEmbeddingProviderOptions
            })) != null ? _a : {};
            const { responseHeaders, value: response, rawValue } = yield postJsonToApi({
                url: this.config.url({
                    path: "/embeddings",
                    modelId: this.modelId
                }),
                headers: combineHeaders(this.config.headers(), headers),
                body: {
                    model: this.modelId,
                    input: values,
                    encoding_format: "float",
                    dimensions: openaiOptions.dimensions,
                    user: openaiOptions.user
                },
                failedResponseHandler: openaiFailedResponseHandler,
                successfulResponseHandler: createJsonResponseHandler(openaiTextEmbeddingResponseSchema),
                abortSignal,
                fetch: this.config.fetch
            });
            return {
                embeddings: response.data.map((item)=>item.embedding),
                usage: response.usage ? {
                    tokens: response.usage.prompt_tokens
                } : void 0,
                response: {
                    headers: responseHeaders,
                    body: rawValue
                }
            };
        });
    }
};
var openaiImageResponseSchema = lazyValidator(()=>zodSchema(import_v48.z.object({
        data: import_v48.z.array(import_v48.z.object({
            b64_json: import_v48.z.string(),
            revised_prompt: import_v48.z.string().optional()
        }))
    })));
var modelMaxImagesPerCall = {
    "dall-e-3": 1,
    "dall-e-2": 10,
    "gpt-image-1": 10,
    "gpt-image-1-mini": 10
};
var hasDefaultResponseFormat = /* @__PURE__ */ new Set([
    "gpt-image-1",
    "gpt-image-1-mini"
]);
var OpenAIImageModel = class {
    constructor(modelId, config){
        this.modelId = modelId;
        this.config = config;
        this.specificationVersion = "v2";
    }
    get maxImagesPerCall() {
        var _a;
        return (_a = modelMaxImagesPerCall[this.modelId]) != null ? _a : 1;
    }
    get provider() {
        return this.config.provider;
    }
    doGenerate(_0) {
        return __async(this, arguments, function*({ prompt, n, size, aspectRatio, seed, providerOptions, headers, abortSignal }) {
            var _a, _b, _c, _d;
            const warnings = [];
            if (aspectRatio != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "aspectRatio",
                    details: "This model does not support aspect ratio. Use `size` instead."
                });
            }
            if (seed != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "seed"
                });
            }
            const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();
            const { value: response, responseHeaders } = yield postJsonToApi({
                url: this.config.url({
                    path: "/images/generations",
                    modelId: this.modelId
                }),
                headers: combineHeaders(this.config.headers(), headers),
                body: __spreadValues(__spreadValues({
                    model: this.modelId,
                    prompt,
                    n,
                    size
                }, (_d = providerOptions.openai) != null ? _d : {}), !hasDefaultResponseFormat.has(this.modelId) ? {
                    response_format: "b64_json"
                } : {}),
                failedResponseHandler: openaiFailedResponseHandler,
                successfulResponseHandler: createJsonResponseHandler(openaiImageResponseSchema),
                abortSignal,
                fetch: this.config.fetch
            });
            return {
                images: response.data.map((item)=>item.b64_json),
                warnings,
                response: {
                    timestamp: currentDate,
                    modelId: this.modelId,
                    headers: responseHeaders
                },
                providerMetadata: {
                    openai: {
                        images: response.data.map((item)=>item.revised_prompt ? {
                                revisedPrompt: item.revised_prompt
                            } : null)
                    }
                }
            };
        });
    }
};
var codeInterpreterInputSchema = lazySchema(()=>zodSchema(import_v49.z.object({
        code: import_v49.z.string().nullish(),
        containerId: import_v49.z.string()
    })));
var codeInterpreterOutputSchema = lazySchema(()=>zodSchema(import_v49.z.object({
        outputs: import_v49.z.array(import_v49.z.discriminatedUnion("type", [
            import_v49.z.object({
                type: import_v49.z.literal("logs"),
                logs: import_v49.z.string()
            }),
            import_v49.z.object({
                type: import_v49.z.literal("image"),
                url: import_v49.z.string()
            })
        ])).nullish()
    })));
var codeInterpreterArgsSchema = lazySchema(()=>zodSchema(import_v49.z.object({
        container: import_v49.z.union([
            import_v49.z.string(),
            import_v49.z.object({
                fileIds: import_v49.z.array(import_v49.z.string()).optional()
            })
        ]).optional()
    })));
var codeInterpreterToolFactory = createProviderDefinedToolFactoryWithOutputSchema({
    id: "openai.code_interpreter",
    name: "code_interpreter",
    inputSchema: codeInterpreterInputSchema,
    outputSchema: codeInterpreterOutputSchema
});
var codeInterpreter = (args = {})=>{
    return codeInterpreterToolFactory(args);
};
var comparisonFilterSchema = import_v410.z.object({
    key: import_v410.z.string(),
    type: import_v410.z.enum([
        "eq",
        "ne",
        "gt",
        "gte",
        "lt",
        "lte"
    ]),
    value: import_v410.z.union([
        import_v410.z.string(),
        import_v410.z.number(),
        import_v410.z.boolean()
    ])
});
var compoundFilterSchema = import_v410.z.object({
    type: import_v410.z.enum([
        "and",
        "or"
    ]),
    filters: import_v410.z.array(import_v410.z.union([
        comparisonFilterSchema,
        import_v410.z.lazy(()=>compoundFilterSchema)
    ]))
});
var fileSearchArgsSchema = lazySchema(()=>zodSchema(import_v410.z.object({
        vectorStoreIds: import_v410.z.array(import_v410.z.string()),
        maxNumResults: import_v410.z.number().optional(),
        ranking: import_v410.z.object({
            ranker: import_v410.z.string().optional(),
            scoreThreshold: import_v410.z.number().optional()
        }).optional(),
        filters: import_v410.z.union([
            comparisonFilterSchema,
            compoundFilterSchema
        ]).optional()
    })));
var fileSearchOutputSchema = lazySchema(()=>zodSchema(import_v410.z.object({
        queries: import_v410.z.array(import_v410.z.string()),
        results: import_v410.z.array(import_v410.z.object({
            attributes: import_v410.z.record(import_v410.z.string(), import_v410.z.unknown()),
            fileId: import_v410.z.string(),
            filename: import_v410.z.string(),
            score: import_v410.z.number(),
            text: import_v410.z.string()
        })).nullable()
    })));
var fileSearch = createProviderDefinedToolFactoryWithOutputSchema({
    id: "openai.file_search",
    name: "file_search",
    inputSchema: import_v410.z.object({}),
    outputSchema: fileSearchOutputSchema
});
var imageGenerationArgsSchema = lazySchema(()=>zodSchema(import_v411.z.object({
        background: import_v411.z.enum([
            "auto",
            "opaque",
            "transparent"
        ]).optional(),
        inputFidelity: import_v411.z.enum([
            "low",
            "high"
        ]).optional(),
        inputImageMask: import_v411.z.object({
            fileId: import_v411.z.string().optional(),
            imageUrl: import_v411.z.string().optional()
        }).optional(),
        model: import_v411.z.string().optional(),
        moderation: import_v411.z.enum([
            "auto"
        ]).optional(),
        outputCompression: import_v411.z.number().int().min(0).max(100).optional(),
        outputFormat: import_v411.z.enum([
            "png",
            "jpeg",
            "webp"
        ]).optional(),
        partialImages: import_v411.z.number().int().min(0).max(3).optional(),
        quality: import_v411.z.enum([
            "auto",
            "low",
            "medium",
            "high"
        ]).optional(),
        size: import_v411.z.enum([
            "1024x1024",
            "1024x1536",
            "1536x1024",
            "auto"
        ]).optional()
    }).strict()));
var imageGenerationInputSchema = lazySchema(()=>zodSchema(import_v411.z.object({})));
var imageGenerationOutputSchema = lazySchema(()=>zodSchema(import_v411.z.object({
        result: import_v411.z.string()
    })));
var imageGenerationToolFactory = createProviderDefinedToolFactoryWithOutputSchema({
    id: "openai.image_generation",
    name: "image_generation",
    inputSchema: imageGenerationInputSchema,
    outputSchema: imageGenerationOutputSchema
});
var imageGeneration = (args = {})=>{
    return imageGenerationToolFactory(args);
};
var localShellInputSchema = lazySchema(()=>zodSchema(import_v412.z.object({
        action: import_v412.z.object({
            type: import_v412.z.literal("exec"),
            command: import_v412.z.array(import_v412.z.string()),
            timeoutMs: import_v412.z.number().optional(),
            user: import_v412.z.string().optional(),
            workingDirectory: import_v412.z.string().optional(),
            env: import_v412.z.record(import_v412.z.string(), import_v412.z.string()).optional()
        })
    })));
var localShellOutputSchema = lazySchema(()=>zodSchema(import_v412.z.object({
        output: import_v412.z.string()
    })));
var localShell = createProviderDefinedToolFactoryWithOutputSchema({
    id: "openai.local_shell",
    name: "local_shell",
    inputSchema: localShellInputSchema,
    outputSchema: localShellOutputSchema
});
var webSearchArgsSchema = lazySchema(()=>zodSchema(import_v413.z.object({
        filters: import_v413.z.object({
            allowedDomains: import_v413.z.array(import_v413.z.string()).optional()
        }).optional(),
        searchContextSize: import_v413.z.enum([
            "low",
            "medium",
            "high"
        ]).optional(),
        userLocation: import_v413.z.object({
            type: import_v413.z.literal("approximate"),
            country: import_v413.z.string().optional(),
            city: import_v413.z.string().optional(),
            region: import_v413.z.string().optional(),
            timezone: import_v413.z.string().optional()
        }).optional()
    })));
var webSearchInputSchema = lazySchema(()=>zodSchema(import_v413.z.object({})));
var webSearchOutputSchema = lazySchema(()=>zodSchema(import_v413.z.object({
        action: import_v413.z.discriminatedUnion("type", [
            import_v413.z.object({
                type: import_v413.z.literal("search"),
                query: import_v413.z.string().optional()
            }),
            import_v413.z.object({
                type: import_v413.z.literal("openPage"),
                url: import_v413.z.string()
            }),
            import_v413.z.object({
                type: import_v413.z.literal("find"),
                url: import_v413.z.string(),
                pattern: import_v413.z.string()
            })
        ])
    })));
var webSearchToolFactory = createProviderDefinedToolFactoryWithOutputSchema({
    id: "openai.web_search",
    name: "web_search",
    inputSchema: webSearchInputSchema,
    outputSchema: webSearchOutputSchema
});
var webSearch = (args = {})=>webSearchToolFactory(args);
var webSearchPreviewArgsSchema = lazySchema(()=>zodSchema(import_v414.z.object({
        searchContextSize: import_v414.z.enum([
            "low",
            "medium",
            "high"
        ]).optional(),
        userLocation: import_v414.z.object({
            type: import_v414.z.literal("approximate"),
            country: import_v414.z.string().optional(),
            city: import_v414.z.string().optional(),
            region: import_v414.z.string().optional(),
            timezone: import_v414.z.string().optional()
        }).optional()
    })));
var webSearchPreviewInputSchema = lazySchema(()=>zodSchema(import_v414.z.object({})));
var webSearchPreviewOutputSchema = lazySchema(()=>zodSchema(import_v414.z.object({
        action: import_v414.z.discriminatedUnion("type", [
            import_v414.z.object({
                type: import_v414.z.literal("search"),
                query: import_v414.z.string().optional()
            }),
            import_v414.z.object({
                type: import_v414.z.literal("openPage"),
                url: import_v414.z.string()
            }),
            import_v414.z.object({
                type: import_v414.z.literal("find"),
                url: import_v414.z.string(),
                pattern: import_v414.z.string()
            })
        ])
    })));
var webSearchPreview = createProviderDefinedToolFactoryWithOutputSchema({
    id: "openai.web_search_preview",
    name: "web_search_preview",
    inputSchema: webSearchPreviewInputSchema,
    outputSchema: webSearchPreviewOutputSchema
});
var openaiTools = {
    /**
   * The Code Interpreter tool allows models to write and run Python code in a
   * sandboxed environment to solve complex problems in domains like data analysis,
   * coding, and math.
   *
   * @param container - The container to use for the code interpreter.
   *
   * Must have name `code_interpreter`.
   */ codeInterpreter,
    /**
   * File search is a tool available in the Responses API. It enables models to
   * retrieve information in a knowledge base of previously uploaded files through
   * semantic and keyword search.
   *
   * Must have name `file_search`.
   *
   * @param vectorStoreIds - The vector store IDs to use for the file search.
   * @param maxNumResults - The maximum number of results to return.
   * @param ranking - The ranking options to use for the file search.
   * @param filters - The filters to use for the file search.
   */ fileSearch,
    /**
   * The image generation tool allows you to generate images using a text prompt,
   * and optionally image inputs. It leverages the GPT Image model,
   * and automatically optimizes text inputs for improved performance.
   *
   * Must have name `image_generation`.
   *
   * @param size - Image dimensions (e.g., 1024x1024, 1024x1536)
   * @param quality - Rendering quality (e.g. low, medium, high)
   * @param format - File output format
   * @param compression - Compression level (0-100%) for JPEG and WebP formats
   * @param background - Transparent or opaque
   */ imageGeneration,
    /**
   * Local shell is a tool that allows agents to run shell commands locally
   * on a machine you or the user provides.
   *
   * Supported models: `gpt-5-codex` and `codex-mini-latest`
   *
   * Must have name `local_shell`.
   */ localShell,
    /**
   * Web search allows models to access up-to-date information from the internet
   * and provide answers with sourced citations.
   *
   * Must have name `web_search_preview`.
   *
   * @param searchContextSize - The search context size to use for the web search.
   * @param userLocation - The user location to use for the web search.
   *
   * @deprecated Use `webSearch` instead.
   */ webSearchPreview,
    /**
   * Web search allows models to access up-to-date information from the internet
   * and provide answers with sourced citations.
   *
   * Must have name `web_search`.
   *
   * @param filters - The filters to use for the web search.
   * @param searchContextSize - The search context size to use for the web search.
   * @param userLocation - The user location to use for the web search.
   */ webSearch
};
function isFileId(data, prefixes) {
    if (!prefixes) return false;
    return prefixes.some((prefix)=>data.startsWith(prefix));
}
function convertToOpenAIResponsesInput(_0) {
    return __async(this, arguments, function*({ prompt, systemMessageMode, fileIdPrefixes, store, hasLocalShellTool = false }) {
        var _a, _b, _c, _d;
        const input = [];
        const warnings = [];
        for (const { role, content } of prompt){
            switch(role){
                case "system":
                    {
                        switch(systemMessageMode){
                            case "system":
                                {
                                    input.push({
                                        role: "system",
                                        content
                                    });
                                    break;
                                }
                            case "developer":
                                {
                                    input.push({
                                        role: "developer",
                                        content
                                    });
                                    break;
                                }
                            case "remove":
                                {
                                    warnings.push({
                                        type: "other",
                                        message: "system messages are removed for this model"
                                    });
                                    break;
                                }
                            default:
                                {
                                    const _exhaustiveCheck = systemMessageMode;
                                    throw new Error(`Unsupported system message mode: ${_exhaustiveCheck}`);
                                }
                        }
                        break;
                    }
                case "user":
                    {
                        input.push({
                            role: "user",
                            content: content.map((part, index)=>{
                                var _a2, _b2, _c2;
                                switch(part.type){
                                    case "text":
                                        {
                                            return {
                                                type: "input_text",
                                                text: part.text
                                            };
                                        }
                                    case "file":
                                        {
                                            if (part.mediaType.startsWith("image/")) {
                                                const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                                                return __spreadProps(__spreadValues({
                                                    type: "input_image"
                                                }, part.data instanceof URL ? {
                                                    image_url: part.data.toString()
                                                } : typeof part.data === "string" && isFileId(part.data, fileIdPrefixes) ? {
                                                    file_id: part.data
                                                } : {
                                                    image_url: `data:${mediaType};base64,${convertToBase64(part.data)}`
                                                }), {
                                                    detail: (_b2 = (_a2 = part.providerOptions) == null ? void 0 : _a2.openai) == null ? void 0 : _b2.imageDetail
                                                });
                                            } else if (part.mediaType === "application/pdf") {
                                                if (part.data instanceof URL) {
                                                    return {
                                                        type: "input_file",
                                                        file_url: part.data.toString()
                                                    };
                                                }
                                                return __spreadValues({
                                                    type: "input_file"
                                                }, typeof part.data === "string" && isFileId(part.data, fileIdPrefixes) ? {
                                                    file_id: part.data
                                                } : {
                                                    filename: (_c2 = part.filename) != null ? _c2 : `part-${index}.pdf`,
                                                    file_data: `data:application/pdf;base64,${convertToBase64(part.data)}`
                                                });
                                            } else {
                                                throw new import_provider18.UnsupportedFunctionalityError({
                                                    functionality: `file part media type ${part.mediaType}`
                                                });
                                            }
                                        }
                                }
                            })
                        });
                        break;
                    }
                case "assistant":
                    {
                        const reasoningMessages = {};
                        const toolCallParts = {};
                        for (const part of content){
                            switch(part.type){
                                case "text":
                                    {
                                        const id = (_b = (_a = part.providerOptions) == null ? void 0 : _a.openai) == null ? void 0 : _b.itemId;
                                        if (store && id != null) {
                                            input.push({
                                                type: "item_reference",
                                                id
                                            });
                                            break;
                                        }
                                        input.push({
                                            role: "assistant",
                                            content: [
                                                {
                                                    type: "output_text",
                                                    text: part.text
                                                }
                                            ],
                                            id
                                        });
                                        break;
                                    }
                                case "tool-call":
                                    {
                                        toolCallParts[part.toolCallId] = part;
                                        if (part.providerExecuted) {
                                            break;
                                        }
                                        const id = (_d = (_c = part.providerOptions) == null ? void 0 : _c.openai) == null ? void 0 : _d.itemId;
                                        if (store && id != null) {
                                            input.push({
                                                type: "item_reference",
                                                id
                                            });
                                            break;
                                        }
                                        if (hasLocalShellTool && part.toolName === "local_shell") {
                                            const parsedInput = yield validateTypes({
                                                value: part.input,
                                                schema: localShellInputSchema
                                            });
                                            input.push({
                                                type: "local_shell_call",
                                                call_id: part.toolCallId,
                                                id,
                                                action: {
                                                    type: "exec",
                                                    command: parsedInput.action.command,
                                                    timeout_ms: parsedInput.action.timeoutMs,
                                                    user: parsedInput.action.user,
                                                    working_directory: parsedInput.action.workingDirectory,
                                                    env: parsedInput.action.env
                                                }
                                            });
                                            break;
                                        }
                                        input.push({
                                            type: "function_call",
                                            call_id: part.toolCallId,
                                            name: part.toolName,
                                            arguments: JSON.stringify(part.input),
                                            id
                                        });
                                        break;
                                    }
                                // assistant tool result parts are from provider-executed tools:
                                case "tool-result":
                                    {
                                        if (store) {
                                            input.push({
                                                type: "item_reference",
                                                id: part.toolCallId
                                            });
                                        } else {
                                            warnings.push({
                                                type: "other",
                                                message: `Results for OpenAI tool ${part.toolName} are not sent to the API when store is false`
                                            });
                                        }
                                        break;
                                    }
                                case "reasoning":
                                    {
                                        const providerOptions = yield parseProviderOptions({
                                            provider: "openai",
                                            providerOptions: part.providerOptions,
                                            schema: openaiResponsesReasoningProviderOptionsSchema
                                        });
                                        const reasoningId = providerOptions == null ? void 0 : providerOptions.itemId;
                                        if (reasoningId != null) {
                                            const reasoningMessage = reasoningMessages[reasoningId];
                                            if (store) {
                                                if (reasoningMessage === void 0) {
                                                    input.push({
                                                        type: "item_reference",
                                                        id: reasoningId
                                                    });
                                                    reasoningMessages[reasoningId] = {
                                                        type: "reasoning",
                                                        id: reasoningId,
                                                        summary: []
                                                    };
                                                }
                                            } else {
                                                const summaryParts = [];
                                                if (part.text.length > 0) {
                                                    summaryParts.push({
                                                        type: "summary_text",
                                                        text: part.text
                                                    });
                                                } else if (reasoningMessage !== void 0) {
                                                    warnings.push({
                                                        type: "other",
                                                        message: `Cannot append empty reasoning part to existing reasoning sequence. Skipping reasoning part: ${JSON.stringify(part)}.`
                                                    });
                                                }
                                                if (reasoningMessage === void 0) {
                                                    reasoningMessages[reasoningId] = {
                                                        type: "reasoning",
                                                        id: reasoningId,
                                                        encrypted_content: providerOptions == null ? void 0 : providerOptions.reasoningEncryptedContent,
                                                        summary: summaryParts
                                                    };
                                                    input.push(reasoningMessages[reasoningId]);
                                                } else {
                                                    reasoningMessage.summary.push(...summaryParts);
                                                    if ((providerOptions == null ? void 0 : providerOptions.reasoningEncryptedContent) != null) {
                                                        reasoningMessage.encrypted_content = providerOptions.reasoningEncryptedContent;
                                                    }
                                                }
                                            }
                                        } else {
                                            warnings.push({
                                                type: "other",
                                                message: `Non-OpenAI reasoning parts are not supported. Skipping reasoning part: ${JSON.stringify(part)}.`
                                            });
                                        }
                                        break;
                                    }
                            }
                        }
                        break;
                    }
                case "tool":
                    {
                        for (const part of content){
                            const output = part.output;
                            if (hasLocalShellTool && part.toolName === "local_shell" && output.type === "json") {
                                const parsedOutput = yield validateTypes({
                                    value: output.value,
                                    schema: localShellOutputSchema
                                });
                                input.push({
                                    type: "local_shell_call_output",
                                    call_id: part.toolCallId,
                                    output: parsedOutput.output
                                });
                                break;
                            }
                            let contentValue;
                            switch(output.type){
                                case "text":
                                case "error-text":
                                    contentValue = output.value;
                                    break;
                                case "json":
                                case "error-json":
                                    contentValue = JSON.stringify(output.value);
                                    break;
                                case "content":
                                    contentValue = output.value.map((item)=>{
                                        switch(item.type){
                                            case "text":
                                                {
                                                    return {
                                                        type: "input_text",
                                                        text: item.text
                                                    };
                                                }
                                            case "media":
                                                {
                                                    return item.mediaType.startsWith("image/") ? {
                                                        type: "input_image",
                                                        image_url: `data:${item.mediaType};base64,${item.data}`
                                                    } : {
                                                        type: "input_file",
                                                        filename: "data",
                                                        file_data: `data:${item.mediaType};base64,${item.data}`
                                                    };
                                                }
                                        }
                                    });
                                    break;
                            }
                            input.push({
                                type: "function_call_output",
                                call_id: part.toolCallId,
                                output: contentValue
                            });
                        }
                        break;
                    }
                default:
                    {
                        const _exhaustiveCheck = role;
                        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
                    }
            }
        }
        return {
            input,
            warnings
        };
    });
}
var openaiResponsesReasoningProviderOptionsSchema = import_v415.z.object({
    itemId: import_v415.z.string().nullish(),
    reasoningEncryptedContent: import_v415.z.string().nullish()
});
function mapOpenAIResponseFinishReason({ finishReason, hasFunctionCall }) {
    switch(finishReason){
        case void 0:
        case null:
            return hasFunctionCall ? "tool-calls" : "stop";
        case "max_output_tokens":
            return "length";
        case "content_filter":
            return "content-filter";
        default:
            return hasFunctionCall ? "tool-calls" : "unknown";
    }
}
var openaiResponsesChunkSchema = lazyValidator(()=>zodSchema(import_v416.z.union([
        import_v416.z.object({
            type: import_v416.z.literal("response.output_text.delta"),
            item_id: import_v416.z.string(),
            delta: import_v416.z.string(),
            logprobs: import_v416.z.array(import_v416.z.object({
                token: import_v416.z.string(),
                logprob: import_v416.z.number(),
                top_logprobs: import_v416.z.array(import_v416.z.object({
                    token: import_v416.z.string(),
                    logprob: import_v416.z.number()
                }))
            })).nullish()
        }),
        import_v416.z.object({
            type: import_v416.z.enum([
                "response.completed",
                "response.incomplete"
            ]),
            response: import_v416.z.object({
                incomplete_details: import_v416.z.object({
                    reason: import_v416.z.string()
                }).nullish(),
                usage: import_v416.z.object({
                    input_tokens: import_v416.z.number(),
                    input_tokens_details: import_v416.z.object({
                        cached_tokens: import_v416.z.number().nullish()
                    }).nullish(),
                    output_tokens: import_v416.z.number(),
                    output_tokens_details: import_v416.z.object({
                        reasoning_tokens: import_v416.z.number().nullish()
                    }).nullish()
                }),
                service_tier: import_v416.z.string().nullish()
            })
        }),
        import_v416.z.object({
            type: import_v416.z.literal("response.created"),
            response: import_v416.z.object({
                id: import_v416.z.string(),
                created_at: import_v416.z.number(),
                model: import_v416.z.string(),
                service_tier: import_v416.z.string().nullish()
            })
        }),
        import_v416.z.object({
            type: import_v416.z.literal("response.output_item.added"),
            output_index: import_v416.z.number(),
            item: import_v416.z.discriminatedUnion("type", [
                import_v416.z.object({
                    type: import_v416.z.literal("message"),
                    id: import_v416.z.string()
                }),
                import_v416.z.object({
                    type: import_v416.z.literal("reasoning"),
                    id: import_v416.z.string(),
                    encrypted_content: import_v416.z.string().nullish()
                }),
                import_v416.z.object({
                    type: import_v416.z.literal("function_call"),
                    id: import_v416.z.string(),
                    call_id: import_v416.z.string(),
                    name: import_v416.z.string(),
                    arguments: import_v416.z.string()
                }),
                import_v416.z.object({
                    type: import_v416.z.literal("web_search_call"),
                    id: import_v416.z.string(),
                    status: import_v416.z.string()
                }),
                import_v416.z.object({
                    type: import_v416.z.literal("computer_call"),
                    id: import_v416.z.string(),
                    status: import_v416.z.string()
                }),
                import_v416.z.object({
                    type: import_v416.z.literal("file_search_call"),
                    id: import_v416.z.string()
                }),
                import_v416.z.object({
                    type: import_v416.z.literal("image_generation_call"),
                    id: import_v416.z.string()
                }),
                import_v416.z.object({
                    type: import_v416.z.literal("code_interpreter_call"),
                    id: import_v416.z.string(),
                    container_id: import_v416.z.string(),
                    code: import_v416.z.string().nullable(),
                    outputs: import_v416.z.array(import_v416.z.discriminatedUnion("type", [
                        import_v416.z.object({
                            type: import_v416.z.literal("logs"),
                            logs: import_v416.z.string()
                        }),
                        import_v416.z.object({
                            type: import_v416.z.literal("image"),
                            url: import_v416.z.string()
                        })
                    ])).nullable(),
                    status: import_v416.z.string()
                })
            ])
        }),
        import_v416.z.object({
            type: import_v416.z.literal("response.output_item.done"),
            output_index: import_v416.z.number(),
            item: import_v416.z.discriminatedUnion("type", [
                import_v416.z.object({
                    type: import_v416.z.literal("message"),
                    id: import_v416.z.string()
                }),
                import_v416.z.object({
                    type: import_v416.z.literal("reasoning"),
                    id: import_v416.z.string(),
                    encrypted_content: import_v416.z.string().nullish()
                }),
                import_v416.z.object({
                    type: import_v416.z.literal("function_call"),
                    id: import_v416.z.string(),
                    call_id: import_v416.z.string(),
                    name: import_v416.z.string(),
                    arguments: import_v416.z.string(),
                    status: import_v416.z.literal("completed")
                }),
                import_v416.z.object({
                    type: import_v416.z.literal("code_interpreter_call"),
                    id: import_v416.z.string(),
                    code: import_v416.z.string().nullable(),
                    container_id: import_v416.z.string(),
                    outputs: import_v416.z.array(import_v416.z.discriminatedUnion("type", [
                        import_v416.z.object({
                            type: import_v416.z.literal("logs"),
                            logs: import_v416.z.string()
                        }),
                        import_v416.z.object({
                            type: import_v416.z.literal("image"),
                            url: import_v416.z.string()
                        })
                    ])).nullable()
                }),
                import_v416.z.object({
                    type: import_v416.z.literal("image_generation_call"),
                    id: import_v416.z.string(),
                    result: import_v416.z.string()
                }),
                import_v416.z.object({
                    type: import_v416.z.literal("web_search_call"),
                    id: import_v416.z.string(),
                    status: import_v416.z.string(),
                    action: import_v416.z.discriminatedUnion("type", [
                        import_v416.z.object({
                            type: import_v416.z.literal("search"),
                            query: import_v416.z.string().nullish()
                        }),
                        import_v416.z.object({
                            type: import_v416.z.literal("open_page"),
                            url: import_v416.z.string()
                        }),
                        import_v416.z.object({
                            type: import_v416.z.literal("find"),
                            url: import_v416.z.string(),
                            pattern: import_v416.z.string()
                        })
                    ])
                }),
                import_v416.z.object({
                    type: import_v416.z.literal("file_search_call"),
                    id: import_v416.z.string(),
                    queries: import_v416.z.array(import_v416.z.string()),
                    results: import_v416.z.array(import_v416.z.object({
                        attributes: import_v416.z.record(import_v416.z.string(), import_v416.z.unknown()),
                        file_id: import_v416.z.string(),
                        filename: import_v416.z.string(),
                        score: import_v416.z.number(),
                        text: import_v416.z.string()
                    })).nullish()
                }),
                import_v416.z.object({
                    type: import_v416.z.literal("local_shell_call"),
                    id: import_v416.z.string(),
                    call_id: import_v416.z.string(),
                    action: import_v416.z.object({
                        type: import_v416.z.literal("exec"),
                        command: import_v416.z.array(import_v416.z.string()),
                        timeout_ms: import_v416.z.number().optional(),
                        user: import_v416.z.string().optional(),
                        working_directory: import_v416.z.string().optional(),
                        env: import_v416.z.record(import_v416.z.string(), import_v416.z.string()).optional()
                    })
                }),
                import_v416.z.object({
                    type: import_v416.z.literal("computer_call"),
                    id: import_v416.z.string(),
                    status: import_v416.z.literal("completed")
                })
            ])
        }),
        import_v416.z.object({
            type: import_v416.z.literal("response.function_call_arguments.delta"),
            item_id: import_v416.z.string(),
            output_index: import_v416.z.number(),
            delta: import_v416.z.string()
        }),
        import_v416.z.object({
            type: import_v416.z.literal("response.image_generation_call.partial_image"),
            item_id: import_v416.z.string(),
            output_index: import_v416.z.number(),
            partial_image_b64: import_v416.z.string()
        }),
        import_v416.z.object({
            type: import_v416.z.literal("response.code_interpreter_call_code.delta"),
            item_id: import_v416.z.string(),
            output_index: import_v416.z.number(),
            delta: import_v416.z.string()
        }),
        import_v416.z.object({
            type: import_v416.z.literal("response.code_interpreter_call_code.done"),
            item_id: import_v416.z.string(),
            output_index: import_v416.z.number(),
            code: import_v416.z.string()
        }),
        import_v416.z.object({
            type: import_v416.z.literal("response.output_text.annotation.added"),
            annotation: import_v416.z.discriminatedUnion("type", [
                import_v416.z.object({
                    type: import_v416.z.literal("url_citation"),
                    url: import_v416.z.string(),
                    title: import_v416.z.string()
                }),
                import_v416.z.object({
                    type: import_v416.z.literal("file_citation"),
                    file_id: import_v416.z.string(),
                    filename: import_v416.z.string().nullish(),
                    index: import_v416.z.number().nullish(),
                    start_index: import_v416.z.number().nullish(),
                    end_index: import_v416.z.number().nullish(),
                    quote: import_v416.z.string().nullish()
                })
            ])
        }),
        import_v416.z.object({
            type: import_v416.z.literal("response.reasoning_summary_part.added"),
            item_id: import_v416.z.string(),
            summary_index: import_v416.z.number()
        }),
        import_v416.z.object({
            type: import_v416.z.literal("response.reasoning_summary_text.delta"),
            item_id: import_v416.z.string(),
            summary_index: import_v416.z.number(),
            delta: import_v416.z.string()
        }),
        import_v416.z.object({
            type: import_v416.z.literal("response.reasoning_summary_part.done"),
            item_id: import_v416.z.string(),
            summary_index: import_v416.z.number()
        }),
        import_v416.z.object({
            type: import_v416.z.literal("error"),
            code: import_v416.z.string(),
            message: import_v416.z.string(),
            param: import_v416.z.string().nullish(),
            sequence_number: import_v416.z.number()
        }),
        import_v416.z.object({
            type: import_v416.z.string()
        }).loose().transform((value)=>({
                type: "unknown_chunk",
                message: value.type
            }))
    ])));
var openaiResponsesResponseSchema = lazyValidator(()=>zodSchema(import_v416.z.object({
        id: import_v416.z.string(),
        created_at: import_v416.z.number(),
        error: import_v416.z.object({
            code: import_v416.z.string(),
            message: import_v416.z.string()
        }).nullish(),
        model: import_v416.z.string(),
        output: import_v416.z.array(import_v416.z.discriminatedUnion("type", [
            import_v416.z.object({
                type: import_v416.z.literal("message"),
                role: import_v416.z.literal("assistant"),
                id: import_v416.z.string(),
                content: import_v416.z.array(import_v416.z.object({
                    type: import_v416.z.literal("output_text"),
                    text: import_v416.z.string(),
                    logprobs: import_v416.z.array(import_v416.z.object({
                        token: import_v416.z.string(),
                        logprob: import_v416.z.number(),
                        top_logprobs: import_v416.z.array(import_v416.z.object({
                            token: import_v416.z.string(),
                            logprob: import_v416.z.number()
                        }))
                    })).nullish(),
                    annotations: import_v416.z.array(import_v416.z.discriminatedUnion("type", [
                        import_v416.z.object({
                            type: import_v416.z.literal("url_citation"),
                            start_index: import_v416.z.number(),
                            end_index: import_v416.z.number(),
                            url: import_v416.z.string(),
                            title: import_v416.z.string()
                        }),
                        import_v416.z.object({
                            type: import_v416.z.literal("file_citation"),
                            file_id: import_v416.z.string(),
                            filename: import_v416.z.string().nullish(),
                            index: import_v416.z.number().nullish(),
                            start_index: import_v416.z.number().nullish(),
                            end_index: import_v416.z.number().nullish(),
                            quote: import_v416.z.string().nullish()
                        }),
                        import_v416.z.object({
                            type: import_v416.z.literal("container_file_citation")
                        })
                    ]))
                }))
            }),
            import_v416.z.object({
                type: import_v416.z.literal("web_search_call"),
                id: import_v416.z.string(),
                status: import_v416.z.string(),
                action: import_v416.z.discriminatedUnion("type", [
                    import_v416.z.object({
                        type: import_v416.z.literal("search"),
                        query: import_v416.z.string().nullish()
                    }),
                    import_v416.z.object({
                        type: import_v416.z.literal("open_page"),
                        url: import_v416.z.string()
                    }),
                    import_v416.z.object({
                        type: import_v416.z.literal("find"),
                        url: import_v416.z.string(),
                        pattern: import_v416.z.string()
                    })
                ])
            }),
            import_v416.z.object({
                type: import_v416.z.literal("file_search_call"),
                id: import_v416.z.string(),
                queries: import_v416.z.array(import_v416.z.string()),
                results: import_v416.z.array(import_v416.z.object({
                    attributes: import_v416.z.record(import_v416.z.string(), import_v416.z.unknown()),
                    file_id: import_v416.z.string(),
                    filename: import_v416.z.string(),
                    score: import_v416.z.number(),
                    text: import_v416.z.string()
                })).nullish()
            }),
            import_v416.z.object({
                type: import_v416.z.literal("code_interpreter_call"),
                id: import_v416.z.string(),
                code: import_v416.z.string().nullable(),
                container_id: import_v416.z.string(),
                outputs: import_v416.z.array(import_v416.z.discriminatedUnion("type", [
                    import_v416.z.object({
                        type: import_v416.z.literal("logs"),
                        logs: import_v416.z.string()
                    }),
                    import_v416.z.object({
                        type: import_v416.z.literal("image"),
                        url: import_v416.z.string()
                    })
                ])).nullable()
            }),
            import_v416.z.object({
                type: import_v416.z.literal("image_generation_call"),
                id: import_v416.z.string(),
                result: import_v416.z.string()
            }),
            import_v416.z.object({
                type: import_v416.z.literal("local_shell_call"),
                id: import_v416.z.string(),
                call_id: import_v416.z.string(),
                action: import_v416.z.object({
                    type: import_v416.z.literal("exec"),
                    command: import_v416.z.array(import_v416.z.string()),
                    timeout_ms: import_v416.z.number().optional(),
                    user: import_v416.z.string().optional(),
                    working_directory: import_v416.z.string().optional(),
                    env: import_v416.z.record(import_v416.z.string(), import_v416.z.string()).optional()
                })
            }),
            import_v416.z.object({
                type: import_v416.z.literal("function_call"),
                call_id: import_v416.z.string(),
                name: import_v416.z.string(),
                arguments: import_v416.z.string(),
                id: import_v416.z.string()
            }),
            import_v416.z.object({
                type: import_v416.z.literal("computer_call"),
                id: import_v416.z.string(),
                status: import_v416.z.string().optional()
            }),
            import_v416.z.object({
                type: import_v416.z.literal("reasoning"),
                id: import_v416.z.string(),
                encrypted_content: import_v416.z.string().nullish(),
                summary: import_v416.z.array(import_v416.z.object({
                    type: import_v416.z.literal("summary_text"),
                    text: import_v416.z.string()
                }))
            })
        ])),
        service_tier: import_v416.z.string().nullish(),
        incomplete_details: import_v416.z.object({
            reason: import_v416.z.string()
        }).nullish(),
        usage: import_v416.z.object({
            input_tokens: import_v416.z.number(),
            input_tokens_details: import_v416.z.object({
                cached_tokens: import_v416.z.number().nullish()
            }).nullish(),
            output_tokens: import_v416.z.number(),
            output_tokens_details: import_v416.z.object({
                reasoning_tokens: import_v416.z.number().nullish()
            }).nullish()
        })
    })));
var TOP_LOGPROBS_MAX = 20;
var openaiResponsesReasoningModelIds = [
    "o1",
    "o1-2024-12-17",
    "o3-mini",
    "o3-mini-2025-01-31",
    "o3",
    "o3-2025-04-16",
    "o4-mini",
    "o4-mini-2025-04-16",
    "codex-mini-latest",
    "computer-use-preview",
    "gpt-5",
    "gpt-5-2025-08-07",
    "gpt-5-codex",
    "gpt-5-mini",
    "gpt-5-mini-2025-08-07",
    "gpt-5-nano",
    "gpt-5-nano-2025-08-07",
    "gpt-5-pro",
    "gpt-5-pro-2025-10-06"
];
var openaiResponsesModelIds = [
    "gpt-4.1",
    "gpt-4.1-2025-04-14",
    "gpt-4.1-mini",
    "gpt-4.1-mini-2025-04-14",
    "gpt-4.1-nano",
    "gpt-4.1-nano-2025-04-14",
    "gpt-4o",
    "gpt-4o-2024-05-13",
    "gpt-4o-2024-08-06",
    "gpt-4o-2024-11-20",
    "gpt-4o-audio-preview",
    "gpt-4o-audio-preview-2024-10-01",
    "gpt-4o-audio-preview-2024-12-17",
    "gpt-4o-search-preview",
    "gpt-4o-search-preview-2025-03-11",
    "gpt-4o-mini-search-preview",
    "gpt-4o-mini-search-preview-2025-03-11",
    "gpt-4o-mini",
    "gpt-4o-mini-2024-07-18",
    "gpt-4-turbo",
    "gpt-4-turbo-2024-04-09",
    "gpt-4-turbo-preview",
    "gpt-4-0125-preview",
    "gpt-4-1106-preview",
    "gpt-4",
    "gpt-4-0613",
    "gpt-4.5-preview",
    "gpt-4.5-preview-2025-02-27",
    "gpt-3.5-turbo-0125",
    "gpt-3.5-turbo",
    "gpt-3.5-turbo-1106",
    "chatgpt-4o-latest",
    "gpt-5-chat-latest",
    ...openaiResponsesReasoningModelIds
];
var openaiResponsesProviderOptionsSchema = lazyValidator(()=>zodSchema(import_v417.z.object({
        include: import_v417.z.array(import_v417.z.enum([
            "reasoning.encrypted_content",
            // handled internally by default, only needed for unknown reasoning models
            "file_search_call.results",
            "message.output_text.logprobs"
        ])).nullish(),
        instructions: import_v417.z.string().nullish(),
        /**
       * Return the log probabilities of the tokens.
       *
       * Setting to true will return the log probabilities of the tokens that
       * were generated.
       *
       * Setting to a number will return the log probabilities of the top n
       * tokens that were generated.
       *
       * @see https://platform.openai.com/docs/api-reference/responses/create
       * @see https://cookbook.openai.com/examples/using_logprobs
       */ logprobs: import_v417.z.union([
            import_v417.z.boolean(),
            import_v417.z.number().min(1).max(TOP_LOGPROBS_MAX)
        ]).optional(),
        /**
       * The maximum number of total calls to built-in tools that can be processed in a response.
       * This maximum number applies across all built-in tool calls, not per individual tool.
       * Any further attempts to call a tool by the model will be ignored.
       */ maxToolCalls: import_v417.z.number().nullish(),
        metadata: import_v417.z.any().nullish(),
        parallelToolCalls: import_v417.z.boolean().nullish(),
        previousResponseId: import_v417.z.string().nullish(),
        promptCacheKey: import_v417.z.string().nullish(),
        reasoningEffort: import_v417.z.string().nullish(),
        reasoningSummary: import_v417.z.string().nullish(),
        safetyIdentifier: import_v417.z.string().nullish(),
        serviceTier: import_v417.z.enum([
            "auto",
            "flex",
            "priority",
            "default"
        ]).nullish(),
        store: import_v417.z.boolean().nullish(),
        strictJsonSchema: import_v417.z.boolean().nullish(),
        textVerbosity: import_v417.z.enum([
            "low",
            "medium",
            "high"
        ]).nullish(),
        truncation: import_v417.z.enum([
            "auto",
            "disabled"
        ]).nullish(),
        user: import_v417.z.string().nullish()
    })));
function prepareResponsesTools(_0) {
    return __async(this, arguments, function*({ tools, toolChoice, strictJsonSchema }) {
        tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
        const toolWarnings = [];
        if (tools == null) {
            return {
                tools: void 0,
                toolChoice: void 0,
                toolWarnings
            };
        }
        const openaiTools2 = [];
        for (const tool12 of tools){
            switch(tool12.type){
                case "function":
                    openaiTools2.push({
                        type: "function",
                        name: tool12.name,
                        description: tool12.description,
                        parameters: tool12.inputSchema,
                        strict: strictJsonSchema
                    });
                    break;
                case "provider-defined":
                    {
                        switch(tool12.id){
                            case "openai.file_search":
                                {
                                    const args = yield validateTypes({
                                        value: tool12.args,
                                        schema: fileSearchArgsSchema
                                    });
                                    openaiTools2.push({
                                        type: "file_search",
                                        vector_store_ids: args.vectorStoreIds,
                                        max_num_results: args.maxNumResults,
                                        ranking_options: args.ranking ? {
                                            ranker: args.ranking.ranker,
                                            score_threshold: args.ranking.scoreThreshold
                                        } : void 0,
                                        filters: args.filters
                                    });
                                    break;
                                }
                            case "openai.local_shell":
                                {
                                    openaiTools2.push({
                                        type: "local_shell"
                                    });
                                    break;
                                }
                            case "openai.web_search_preview":
                                {
                                    const args = yield validateTypes({
                                        value: tool12.args,
                                        schema: webSearchPreviewArgsSchema
                                    });
                                    openaiTools2.push({
                                        type: "web_search_preview",
                                        search_context_size: args.searchContextSize,
                                        user_location: args.userLocation
                                    });
                                    break;
                                }
                            case "openai.web_search":
                                {
                                    const args = yield validateTypes({
                                        value: tool12.args,
                                        schema: webSearchArgsSchema
                                    });
                                    openaiTools2.push({
                                        type: "web_search",
                                        filters: args.filters != null ? {
                                            allowed_domains: args.filters.allowedDomains
                                        } : void 0,
                                        search_context_size: args.searchContextSize,
                                        user_location: args.userLocation
                                    });
                                    break;
                                }
                            case "openai.code_interpreter":
                                {
                                    const args = yield validateTypes({
                                        value: tool12.args,
                                        schema: codeInterpreterArgsSchema
                                    });
                                    openaiTools2.push({
                                        type: "code_interpreter",
                                        container: args.container == null ? {
                                            type: "auto",
                                            file_ids: void 0
                                        } : typeof args.container === "string" ? args.container : {
                                            type: "auto",
                                            file_ids: args.container.fileIds
                                        }
                                    });
                                    break;
                                }
                            case "openai.image_generation":
                                {
                                    const args = yield validateTypes({
                                        value: tool12.args,
                                        schema: imageGenerationArgsSchema
                                    });
                                    openaiTools2.push({
                                        type: "image_generation",
                                        background: args.background,
                                        input_fidelity: args.inputFidelity,
                                        input_image_mask: args.inputImageMask ? {
                                            file_id: args.inputImageMask.fileId,
                                            image_url: args.inputImageMask.imageUrl
                                        } : void 0,
                                        model: args.model,
                                        size: args.size,
                                        quality: args.quality,
                                        moderation: args.moderation,
                                        output_format: args.outputFormat,
                                        output_compression: args.outputCompression
                                    });
                                    break;
                                }
                        }
                        break;
                    }
                default:
                    toolWarnings.push({
                        type: "unsupported-tool",
                        tool: tool12
                    });
                    break;
            }
        }
        if (toolChoice == null) {
            return {
                tools: openaiTools2,
                toolChoice: void 0,
                toolWarnings
            };
        }
        const type = toolChoice.type;
        switch(type){
            case "auto":
            case "none":
            case "required":
                return {
                    tools: openaiTools2,
                    toolChoice: type,
                    toolWarnings
                };
            case "tool":
                return {
                    tools: openaiTools2,
                    toolChoice: toolChoice.toolName === "code_interpreter" || toolChoice.toolName === "file_search" || toolChoice.toolName === "image_generation" || toolChoice.toolName === "web_search_preview" || toolChoice.toolName === "web_search" ? {
                        type: toolChoice.toolName
                    } : {
                        type: "function",
                        name: toolChoice.toolName
                    },
                    toolWarnings
                };
            default:
                {
                    const _exhaustiveCheck = type;
                    throw new import_provider19.UnsupportedFunctionalityError({
                        functionality: `tool choice type: ${_exhaustiveCheck}`
                    });
                }
        }
    });
}
var OpenAIResponsesLanguageModel = class {
    constructor(modelId, config){
        this.specificationVersion = "v2";
        this.supportedUrls = {
            "image/*": [
                /^https?:\/\/.*$/
            ],
            "application/pdf": [
                /^https?:\/\/.*$/
            ]
        };
        this.modelId = modelId;
        this.config = config;
    }
    get provider() {
        return this.config.provider;
    }
    getArgs(_0) {
        return __async(this, arguments, function*({ maxOutputTokens, temperature, stopSequences, topP, topK, presencePenalty, frequencyPenalty, seed, prompt, providerOptions, tools, toolChoice, responseFormat }) {
            var _a, _b, _c, _d;
            const warnings = [];
            const modelConfig = getResponsesModelConfig(this.modelId);
            if (topK != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "topK"
                });
            }
            if (seed != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "seed"
                });
            }
            if (presencePenalty != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "presencePenalty"
                });
            }
            if (frequencyPenalty != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "frequencyPenalty"
                });
            }
            if (stopSequences != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "stopSequences"
                });
            }
            const openaiOptions = yield parseProviderOptions({
                provider: "openai",
                providerOptions,
                schema: openaiResponsesProviderOptionsSchema
            });
            const { input, warnings: inputWarnings } = yield convertToOpenAIResponsesInput({
                prompt,
                systemMessageMode: modelConfig.systemMessageMode,
                fileIdPrefixes: this.config.fileIdPrefixes,
                store: (_a = openaiOptions == null ? void 0 : openaiOptions.store) != null ? _a : true,
                hasLocalShellTool: hasOpenAITool("openai.local_shell")
            });
            warnings.push(...inputWarnings);
            const strictJsonSchema = (_b = openaiOptions == null ? void 0 : openaiOptions.strictJsonSchema) != null ? _b : false;
            let include = openaiOptions == null ? void 0 : openaiOptions.include;
            function addInclude(key) {
                if (include == null) {
                    include = [
                        key
                    ];
                } else if (!include.includes(key)) {
                    include = [
                        ...include,
                        key
                    ];
                }
            }
            function hasOpenAITool(id) {
                return (tools == null ? void 0 : tools.find((tool12)=>tool12.type === "provider-defined" && tool12.id === id)) != null;
            }
            const topLogprobs = typeof (openaiOptions == null ? void 0 : openaiOptions.logprobs) === "number" ? openaiOptions == null ? void 0 : openaiOptions.logprobs : (openaiOptions == null ? void 0 : openaiOptions.logprobs) === true ? TOP_LOGPROBS_MAX : void 0;
            if (topLogprobs) {
                addInclude("message.output_text.logprobs");
            }
            const webSearchToolName = (_c = tools == null ? void 0 : tools.find((tool12)=>tool12.type === "provider-defined" && (tool12.id === "openai.web_search" || tool12.id === "openai.web_search_preview"))) == null ? void 0 : _c.name;
            if (webSearchToolName) {
                addInclude("web_search_call.action.sources");
            }
            if (hasOpenAITool("openai.code_interpreter")) {
                addInclude("code_interpreter_call.outputs");
            }
            const store = openaiOptions == null ? void 0 : openaiOptions.store;
            if (store === false && modelConfig.isReasoningModel) {
                addInclude("reasoning.encrypted_content");
            }
            const baseArgs = __spreadValues(__spreadProps(__spreadValues({
                model: this.modelId,
                input,
                temperature,
                top_p: topP,
                max_output_tokens: maxOutputTokens
            }, ((responseFormat == null ? void 0 : responseFormat.type) === "json" || (openaiOptions == null ? void 0 : openaiOptions.textVerbosity)) && {
                text: __spreadValues(__spreadValues({}, (responseFormat == null ? void 0 : responseFormat.type) === "json" && {
                    format: responseFormat.schema != null ? {
                        type: "json_schema",
                        strict: strictJsonSchema,
                        name: (_d = responseFormat.name) != null ? _d : "response",
                        description: responseFormat.description,
                        schema: responseFormat.schema
                    } : {
                        type: "json_object"
                    }
                }), (openaiOptions == null ? void 0 : openaiOptions.textVerbosity) && {
                    verbosity: openaiOptions.textVerbosity
                })
            }), {
                // provider options:
                max_tool_calls: openaiOptions == null ? void 0 : openaiOptions.maxToolCalls,
                metadata: openaiOptions == null ? void 0 : openaiOptions.metadata,
                parallel_tool_calls: openaiOptions == null ? void 0 : openaiOptions.parallelToolCalls,
                previous_response_id: openaiOptions == null ? void 0 : openaiOptions.previousResponseId,
                store,
                user: openaiOptions == null ? void 0 : openaiOptions.user,
                instructions: openaiOptions == null ? void 0 : openaiOptions.instructions,
                service_tier: openaiOptions == null ? void 0 : openaiOptions.serviceTier,
                include,
                prompt_cache_key: openaiOptions == null ? void 0 : openaiOptions.promptCacheKey,
                safety_identifier: openaiOptions == null ? void 0 : openaiOptions.safetyIdentifier,
                top_logprobs: topLogprobs,
                truncation: openaiOptions == null ? void 0 : openaiOptions.truncation
            }), modelConfig.isReasoningModel && ((openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null || (openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null) && {
                reasoning: __spreadValues(__spreadValues({}, (openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null && {
                    effort: openaiOptions.reasoningEffort
                }), (openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null && {
                    summary: openaiOptions.reasoningSummary
                })
            });
            if (modelConfig.isReasoningModel) {
                if (baseArgs.temperature != null) {
                    baseArgs.temperature = void 0;
                    warnings.push({
                        type: "unsupported-setting",
                        setting: "temperature",
                        details: "temperature is not supported for reasoning models"
                    });
                }
                if (baseArgs.top_p != null) {
                    baseArgs.top_p = void 0;
                    warnings.push({
                        type: "unsupported-setting",
                        setting: "topP",
                        details: "topP is not supported for reasoning models"
                    });
                }
            } else {
                if ((openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null) {
                    warnings.push({
                        type: "unsupported-setting",
                        setting: "reasoningEffort",
                        details: "reasoningEffort is not supported for non-reasoning models"
                    });
                }
                if ((openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null) {
                    warnings.push({
                        type: "unsupported-setting",
                        setting: "reasoningSummary",
                        details: "reasoningSummary is not supported for non-reasoning models"
                    });
                }
            }
            if ((openaiOptions == null ? void 0 : openaiOptions.serviceTier) === "flex" && !modelConfig.supportsFlexProcessing) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "serviceTier",
                    details: "flex processing is only available for o3, o4-mini, and gpt-5 models"
                });
                delete baseArgs.service_tier;
            }
            if ((openaiOptions == null ? void 0 : openaiOptions.serviceTier) === "priority" && !modelConfig.supportsPriorityProcessing) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "serviceTier",
                    details: "priority processing is only available for supported models (gpt-4, gpt-5, gpt-5-mini, o3, o4-mini) and requires Enterprise access. gpt-5-nano is not supported"
                });
                delete baseArgs.service_tier;
            }
            const { tools: openaiTools2, toolChoice: openaiToolChoice, toolWarnings } = yield prepareResponsesTools({
                tools,
                toolChoice,
                strictJsonSchema
            });
            return {
                webSearchToolName,
                args: __spreadProps(__spreadValues({}, baseArgs), {
                    tools: openaiTools2,
                    tool_choice: openaiToolChoice
                }),
                warnings: [
                    ...warnings,
                    ...toolWarnings
                ],
                store
            };
        });
    }
    doGenerate(options) {
        return __async(this, null, function*() {
            var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;
            const { args: body, warnings, webSearchToolName } = yield this.getArgs(options);
            const url = this.config.url({
                path: "/responses",
                modelId: this.modelId
            });
            const { responseHeaders, value: response, rawValue: rawResponse } = yield postJsonToApi({
                url,
                headers: combineHeaders(this.config.headers(), options.headers),
                body,
                failedResponseHandler: openaiFailedResponseHandler,
                successfulResponseHandler: createJsonResponseHandler(openaiResponsesResponseSchema),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            if (response.error) {
                throw new import_provider17.APICallError({
                    message: response.error.message,
                    url,
                    requestBodyValues: body,
                    statusCode: 400,
                    responseHeaders,
                    responseBody: rawResponse,
                    isRetryable: false
                });
            }
            const content = [];
            const logprobs = [];
            let hasFunctionCall = false;
            for (const part of response.output){
                switch(part.type){
                    case "reasoning":
                        {
                            if (part.summary.length === 0) {
                                part.summary.push({
                                    type: "summary_text",
                                    text: ""
                                });
                            }
                            for (const summary of part.summary){
                                content.push({
                                    type: "reasoning",
                                    text: summary.text,
                                    providerMetadata: {
                                        openai: {
                                            itemId: part.id,
                                            reasoningEncryptedContent: (_a = part.encrypted_content) != null ? _a : null
                                        }
                                    }
                                });
                            }
                            break;
                        }
                    case "image_generation_call":
                        {
                            content.push({
                                type: "tool-call",
                                toolCallId: part.id,
                                toolName: "image_generation",
                                input: "{}",
                                providerExecuted: true
                            });
                            content.push({
                                type: "tool-result",
                                toolCallId: part.id,
                                toolName: "image_generation",
                                result: {
                                    result: part.result
                                },
                                providerExecuted: true
                            });
                            break;
                        }
                    case "local_shell_call":
                        {
                            content.push({
                                type: "tool-call",
                                toolCallId: part.call_id,
                                toolName: "local_shell",
                                input: JSON.stringify({
                                    action: part.action
                                }),
                                providerMetadata: {
                                    openai: {
                                        itemId: part.id
                                    }
                                }
                            });
                            break;
                        }
                    case "message":
                        {
                            for (const contentPart of part.content){
                                if (((_c = (_b = options.providerOptions) == null ? void 0 : _b.openai) == null ? void 0 : _c.logprobs) && contentPart.logprobs) {
                                    logprobs.push(contentPart.logprobs);
                                }
                                content.push({
                                    type: "text",
                                    text: contentPart.text,
                                    providerMetadata: {
                                        openai: {
                                            itemId: part.id
                                        }
                                    }
                                });
                                for (const annotation of contentPart.annotations){
                                    if (annotation.type === "url_citation") {
                                        content.push({
                                            type: "source",
                                            sourceType: "url",
                                            id: (_f = (_e = (_d = this.config).generateId) == null ? void 0 : _e.call(_d)) != null ? _f : generateId(),
                                            url: annotation.url,
                                            title: annotation.title
                                        });
                                    } else if (annotation.type === "file_citation") {
                                        content.push({
                                            type: "source",
                                            sourceType: "document",
                                            id: (_i = (_h = (_g = this.config).generateId) == null ? void 0 : _h.call(_g)) != null ? _i : generateId(),
                                            mediaType: "text/plain",
                                            title: (_k = (_j = annotation.quote) != null ? _j : annotation.filename) != null ? _k : "Document",
                                            filename: (_l = annotation.filename) != null ? _l : annotation.file_id
                                        });
                                    }
                                }
                            }
                            break;
                        }
                    case "function_call":
                        {
                            hasFunctionCall = true;
                            content.push({
                                type: "tool-call",
                                toolCallId: part.call_id,
                                toolName: part.name,
                                input: part.arguments,
                                providerMetadata: {
                                    openai: {
                                        itemId: part.id
                                    }
                                }
                            });
                            break;
                        }
                    case "web_search_call":
                        {
                            content.push({
                                type: "tool-call",
                                toolCallId: part.id,
                                toolName: webSearchToolName != null ? webSearchToolName : "web_search",
                                input: JSON.stringify({}),
                                providerExecuted: true
                            });
                            content.push({
                                type: "tool-result",
                                toolCallId: part.id,
                                toolName: webSearchToolName != null ? webSearchToolName : "web_search",
                                result: mapWebSearchOutput(part.action),
                                providerExecuted: true
                            });
                            break;
                        }
                    case "computer_call":
                        {
                            content.push({
                                type: "tool-call",
                                toolCallId: part.id,
                                toolName: "computer_use",
                                input: "",
                                providerExecuted: true
                            });
                            content.push({
                                type: "tool-result",
                                toolCallId: part.id,
                                toolName: "computer_use",
                                result: {
                                    type: "computer_use_tool_result",
                                    status: part.status || "completed"
                                },
                                providerExecuted: true
                            });
                            break;
                        }
                    case "file_search_call":
                        {
                            content.push({
                                type: "tool-call",
                                toolCallId: part.id,
                                toolName: "file_search",
                                input: "{}",
                                providerExecuted: true
                            });
                            content.push({
                                type: "tool-result",
                                toolCallId: part.id,
                                toolName: "file_search",
                                result: {
                                    queries: part.queries,
                                    results: (_n = (_m = part.results) == null ? void 0 : _m.map((result)=>({
                                            attributes: result.attributes,
                                            fileId: result.file_id,
                                            filename: result.filename,
                                            score: result.score,
                                            text: result.text
                                        }))) != null ? _n : null
                                },
                                providerExecuted: true
                            });
                            break;
                        }
                    case "code_interpreter_call":
                        {
                            content.push({
                                type: "tool-call",
                                toolCallId: part.id,
                                toolName: "code_interpreter",
                                input: JSON.stringify({
                                    code: part.code,
                                    containerId: part.container_id
                                }),
                                providerExecuted: true
                            });
                            content.push({
                                type: "tool-result",
                                toolCallId: part.id,
                                toolName: "code_interpreter",
                                result: {
                                    outputs: part.outputs
                                },
                                providerExecuted: true
                            });
                            break;
                        }
                }
            }
            const providerMetadata = {
                openai: {
                    responseId: response.id
                }
            };
            if (logprobs.length > 0) {
                providerMetadata.openai.logprobs = logprobs;
            }
            if (typeof response.service_tier === "string") {
                providerMetadata.openai.serviceTier = response.service_tier;
            }
            return {
                content,
                finishReason: mapOpenAIResponseFinishReason({
                    finishReason: (_o = response.incomplete_details) == null ? void 0 : _o.reason,
                    hasFunctionCall
                }),
                usage: {
                    inputTokens: response.usage.input_tokens,
                    outputTokens: response.usage.output_tokens,
                    totalTokens: response.usage.input_tokens + response.usage.output_tokens,
                    reasoningTokens: (_q = (_p = response.usage.output_tokens_details) == null ? void 0 : _p.reasoning_tokens) != null ? _q : void 0,
                    cachedInputTokens: (_s = (_r = response.usage.input_tokens_details) == null ? void 0 : _r.cached_tokens) != null ? _s : void 0
                },
                request: {
                    body
                },
                response: {
                    id: response.id,
                    timestamp: new Date(response.created_at * 1e3),
                    modelId: response.model,
                    headers: responseHeaders,
                    body: rawResponse
                },
                providerMetadata,
                warnings
            };
        });
    }
    doStream(options) {
        return __async(this, null, function*() {
            const { args: body, warnings, webSearchToolName, store } = yield this.getArgs(options);
            const { responseHeaders, value: response } = yield postJsonToApi({
                url: this.config.url({
                    path: "/responses",
                    modelId: this.modelId
                }),
                headers: combineHeaders(this.config.headers(), options.headers),
                body: __spreadProps(__spreadValues({}, body), {
                    stream: true
                }),
                failedResponseHandler: openaiFailedResponseHandler,
                successfulResponseHandler: createEventSourceResponseHandler(openaiResponsesChunkSchema),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            const self = this;
            let finishReason = "unknown";
            const usage = {
                inputTokens: void 0,
                outputTokens: void 0,
                totalTokens: void 0
            };
            const logprobs = [];
            let responseId = null;
            const ongoingToolCalls = {};
            let hasFunctionCall = false;
            const activeReasoning = {};
            let serviceTier;
            return {
                stream: response.pipeThrough(new TransformStream({
                    start (controller) {
                        controller.enqueue({
                            type: "stream-start",
                            warnings
                        });
                    },
                    transform (chunk, controller) {
                        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v;
                        if (options.includeRawChunks) {
                            controller.enqueue({
                                type: "raw",
                                rawValue: chunk.rawValue
                            });
                        }
                        if (!chunk.success) {
                            finishReason = "error";
                            controller.enqueue({
                                type: "error",
                                error: chunk.error
                            });
                            return;
                        }
                        const value = chunk.value;
                        if (isResponseOutputItemAddedChunk(value)) {
                            if (value.item.type === "function_call") {
                                ongoingToolCalls[value.output_index] = {
                                    toolName: value.item.name,
                                    toolCallId: value.item.call_id
                                };
                                controller.enqueue({
                                    type: "tool-input-start",
                                    id: value.item.call_id,
                                    toolName: value.item.name
                                });
                            } else if (value.item.type === "web_search_call") {
                                ongoingToolCalls[value.output_index] = {
                                    toolName: webSearchToolName != null ? webSearchToolName : "web_search",
                                    toolCallId: value.item.id
                                };
                                controller.enqueue({
                                    type: "tool-input-start",
                                    id: value.item.id,
                                    toolName: webSearchToolName != null ? webSearchToolName : "web_search",
                                    providerExecuted: true
                                });
                                controller.enqueue({
                                    type: "tool-input-end",
                                    id: value.item.id
                                });
                                controller.enqueue({
                                    type: "tool-call",
                                    toolCallId: value.item.id,
                                    toolName: "web_search",
                                    input: JSON.stringify({}),
                                    providerExecuted: true
                                });
                            } else if (value.item.type === "computer_call") {
                                ongoingToolCalls[value.output_index] = {
                                    toolName: "computer_use",
                                    toolCallId: value.item.id
                                };
                                controller.enqueue({
                                    type: "tool-input-start",
                                    id: value.item.id,
                                    toolName: "computer_use",
                                    providerExecuted: true
                                });
                            } else if (value.item.type === "code_interpreter_call") {
                                ongoingToolCalls[value.output_index] = {
                                    toolName: "code_interpreter",
                                    toolCallId: value.item.id,
                                    codeInterpreter: {
                                        containerId: value.item.container_id
                                    }
                                };
                                controller.enqueue({
                                    type: "tool-input-start",
                                    id: value.item.id,
                                    toolName: "code_interpreter",
                                    providerExecuted: true
                                });
                                controller.enqueue({
                                    type: "tool-input-delta",
                                    id: value.item.id,
                                    delta: `{"containerId":"${value.item.container_id}","code":"`
                                });
                            } else if (value.item.type === "file_search_call") {
                                controller.enqueue({
                                    type: "tool-call",
                                    toolCallId: value.item.id,
                                    toolName: "file_search",
                                    input: "{}",
                                    providerExecuted: true
                                });
                            } else if (value.item.type === "image_generation_call") {
                                controller.enqueue({
                                    type: "tool-call",
                                    toolCallId: value.item.id,
                                    toolName: "image_generation",
                                    input: "{}",
                                    providerExecuted: true
                                });
                            } else if (value.item.type === "message") {
                                controller.enqueue({
                                    type: "text-start",
                                    id: value.item.id,
                                    providerMetadata: {
                                        openai: {
                                            itemId: value.item.id
                                        }
                                    }
                                });
                            } else if (isResponseOutputItemAddedChunk(value) && value.item.type === "reasoning") {
                                activeReasoning[value.item.id] = {
                                    encryptedContent: value.item.encrypted_content,
                                    summaryParts: {
                                        0: "active"
                                    }
                                };
                                controller.enqueue({
                                    type: "reasoning-start",
                                    id: `${value.item.id}:0`,
                                    providerMetadata: {
                                        openai: {
                                            itemId: value.item.id,
                                            reasoningEncryptedContent: (_a = value.item.encrypted_content) != null ? _a : null
                                        }
                                    }
                                });
                            }
                        } else if (isResponseOutputItemDoneChunk(value)) {
                            if (value.item.type === "function_call") {
                                ongoingToolCalls[value.output_index] = void 0;
                                hasFunctionCall = true;
                                controller.enqueue({
                                    type: "tool-input-end",
                                    id: value.item.call_id
                                });
                                controller.enqueue({
                                    type: "tool-call",
                                    toolCallId: value.item.call_id,
                                    toolName: value.item.name,
                                    input: value.item.arguments,
                                    providerMetadata: {
                                        openai: {
                                            itemId: value.item.id
                                        }
                                    }
                                });
                            } else if (value.item.type === "web_search_call") {
                                ongoingToolCalls[value.output_index] = void 0;
                                controller.enqueue({
                                    type: "tool-result",
                                    toolCallId: value.item.id,
                                    toolName: "web_search",
                                    result: mapWebSearchOutput(value.item.action),
                                    providerExecuted: true
                                });
                            } else if (value.item.type === "computer_call") {
                                ongoingToolCalls[value.output_index] = void 0;
                                controller.enqueue({
                                    type: "tool-input-end",
                                    id: value.item.id
                                });
                                controller.enqueue({
                                    type: "tool-call",
                                    toolCallId: value.item.id,
                                    toolName: "computer_use",
                                    input: "",
                                    providerExecuted: true
                                });
                                controller.enqueue({
                                    type: "tool-result",
                                    toolCallId: value.item.id,
                                    toolName: "computer_use",
                                    result: {
                                        type: "computer_use_tool_result",
                                        status: value.item.status || "completed"
                                    },
                                    providerExecuted: true
                                });
                            } else if (value.item.type === "file_search_call") {
                                ongoingToolCalls[value.output_index] = void 0;
                                controller.enqueue({
                                    type: "tool-result",
                                    toolCallId: value.item.id,
                                    toolName: "file_search",
                                    result: {
                                        queries: value.item.queries,
                                        results: (_c = (_b = value.item.results) == null ? void 0 : _b.map((result)=>({
                                                attributes: result.attributes,
                                                fileId: result.file_id,
                                                filename: result.filename,
                                                score: result.score,
                                                text: result.text
                                            }))) != null ? _c : null
                                    },
                                    providerExecuted: true
                                });
                            } else if (value.item.type === "code_interpreter_call") {
                                ongoingToolCalls[value.output_index] = void 0;
                                controller.enqueue({
                                    type: "tool-result",
                                    toolCallId: value.item.id,
                                    toolName: "code_interpreter",
                                    result: {
                                        outputs: value.item.outputs
                                    },
                                    providerExecuted: true
                                });
                            } else if (value.item.type === "image_generation_call") {
                                controller.enqueue({
                                    type: "tool-result",
                                    toolCallId: value.item.id,
                                    toolName: "image_generation",
                                    result: {
                                        result: value.item.result
                                    },
                                    providerExecuted: true
                                });
                            } else if (value.item.type === "local_shell_call") {
                                ongoingToolCalls[value.output_index] = void 0;
                                controller.enqueue({
                                    type: "tool-call",
                                    toolCallId: value.item.call_id,
                                    toolName: "local_shell",
                                    input: JSON.stringify({
                                        action: {
                                            type: "exec",
                                            command: value.item.action.command,
                                            timeoutMs: value.item.action.timeout_ms,
                                            user: value.item.action.user,
                                            workingDirectory: value.item.action.working_directory,
                                            env: value.item.action.env
                                        }
                                    }),
                                    providerMetadata: {
                                        openai: {
                                            itemId: value.item.id
                                        }
                                    }
                                });
                            } else if (value.item.type === "message") {
                                controller.enqueue({
                                    type: "text-end",
                                    id: value.item.id
                                });
                            } else if (value.item.type === "reasoning") {
                                const activeReasoningPart = activeReasoning[value.item.id];
                                const summaryPartIndices = Object.entries(activeReasoningPart.summaryParts).filter(([_, status])=>status === "active" || status === "can-conclude").map(([summaryIndex])=>summaryIndex);
                                for (const summaryIndex of summaryPartIndices){
                                    controller.enqueue({
                                        type: "reasoning-end",
                                        id: `${value.item.id}:${summaryIndex}`,
                                        providerMetadata: {
                                            openai: {
                                                itemId: value.item.id,
                                                reasoningEncryptedContent: (_d = value.item.encrypted_content) != null ? _d : null
                                            }
                                        }
                                    });
                                }
                                delete activeReasoning[value.item.id];
                            }
                        } else if (isResponseFunctionCallArgumentsDeltaChunk(value)) {
                            const toolCall = ongoingToolCalls[value.output_index];
                            if (toolCall != null) {
                                controller.enqueue({
                                    type: "tool-input-delta",
                                    id: toolCall.toolCallId,
                                    delta: value.delta
                                });
                            }
                        } else if (isResponseCodeInterpreterCallCodeDeltaChunk(value)) {
                            const toolCall = ongoingToolCalls[value.output_index];
                            if (toolCall != null) {
                                controller.enqueue({
                                    type: "tool-input-delta",
                                    id: toolCall.toolCallId,
                                    // The delta is code, which is embedding in a JSON string.
                                    // To escape it, we use JSON.stringify and slice to remove the outer quotes.
                                    delta: JSON.stringify(value.delta).slice(1, -1)
                                });
                            }
                        } else if (isResponseCodeInterpreterCallCodeDoneChunk(value)) {
                            const toolCall = ongoingToolCalls[value.output_index];
                            if (toolCall != null) {
                                controller.enqueue({
                                    type: "tool-input-delta",
                                    id: toolCall.toolCallId,
                                    delta: '"}'
                                });
                                controller.enqueue({
                                    type: "tool-input-end",
                                    id: toolCall.toolCallId
                                });
                                controller.enqueue({
                                    type: "tool-call",
                                    toolCallId: toolCall.toolCallId,
                                    toolName: "code_interpreter",
                                    input: JSON.stringify({
                                        code: value.code,
                                        containerId: toolCall.codeInterpreter.containerId
                                    }),
                                    providerExecuted: true
                                });
                            }
                        } else if (isResponseCreatedChunk(value)) {
                            responseId = value.response.id;
                            controller.enqueue({
                                type: "response-metadata",
                                id: value.response.id,
                                timestamp: new Date(value.response.created_at * 1e3),
                                modelId: value.response.model
                            });
                        } else if (isTextDeltaChunk(value)) {
                            controller.enqueue({
                                type: "text-delta",
                                id: value.item_id,
                                delta: value.delta
                            });
                            if (((_f = (_e = options.providerOptions) == null ? void 0 : _e.openai) == null ? void 0 : _f.logprobs) && value.logprobs) {
                                logprobs.push(value.logprobs);
                            }
                        } else if (value.type === "response.reasoning_summary_part.added") {
                            if (value.summary_index > 0) {
                                const activeReasoningPart = activeReasoning[value.item_id];
                                activeReasoningPart.summaryParts[value.summary_index] = "active";
                                for (const summaryIndex of Object.keys(activeReasoningPart.summaryParts)){
                                    if (activeReasoningPart.summaryParts[summaryIndex] === "can-conclude") {
                                        controller.enqueue({
                                            type: "reasoning-end",
                                            id: `${value.item_id}:${summaryIndex}`,
                                            providerMetadata: {
                                                openai: {
                                                    itemId: value.item_id
                                                }
                                            }
                                        });
                                        activeReasoningPart.summaryParts[summaryIndex] = "concluded";
                                    }
                                }
                                controller.enqueue({
                                    type: "reasoning-start",
                                    id: `${value.item_id}:${value.summary_index}`,
                                    providerMetadata: {
                                        openai: {
                                            itemId: value.item_id,
                                            reasoningEncryptedContent: (_h = (_g = activeReasoning[value.item_id]) == null ? void 0 : _g.encryptedContent) != null ? _h : null
                                        }
                                    }
                                });
                            }
                        } else if (value.type === "response.reasoning_summary_text.delta") {
                            controller.enqueue({
                                type: "reasoning-delta",
                                id: `${value.item_id}:${value.summary_index}`,
                                delta: value.delta,
                                providerMetadata: {
                                    openai: {
                                        itemId: value.item_id
                                    }
                                }
                            });
                        } else if (value.type === "response.reasoning_summary_part.done") {
                            if (store) {
                                controller.enqueue({
                                    type: "reasoning-end",
                                    id: `${value.item_id}:${value.summary_index}`,
                                    providerMetadata: {
                                        openai: {
                                            itemId: value.item_id
                                        }
                                    }
                                });
                                activeReasoning[value.item_id].summaryParts[value.summary_index] = "concluded";
                            } else {
                                activeReasoning[value.item_id].summaryParts[value.summary_index] = "can-conclude";
                            }
                        } else if (isResponseFinishedChunk(value)) {
                            finishReason = mapOpenAIResponseFinishReason({
                                finishReason: (_i = value.response.incomplete_details) == null ? void 0 : _i.reason,
                                hasFunctionCall
                            });
                            usage.inputTokens = value.response.usage.input_tokens;
                            usage.outputTokens = value.response.usage.output_tokens;
                            usage.totalTokens = value.response.usage.input_tokens + value.response.usage.output_tokens;
                            usage.reasoningTokens = (_k = (_j = value.response.usage.output_tokens_details) == null ? void 0 : _j.reasoning_tokens) != null ? _k : void 0;
                            usage.cachedInputTokens = (_m = (_l = value.response.usage.input_tokens_details) == null ? void 0 : _l.cached_tokens) != null ? _m : void 0;
                            if (typeof value.response.service_tier === "string") {
                                serviceTier = value.response.service_tier;
                            }
                        } else if (isResponseAnnotationAddedChunk(value)) {
                            if (value.annotation.type === "url_citation") {
                                controller.enqueue({
                                    type: "source",
                                    sourceType: "url",
                                    id: (_p = (_o = (_n = self.config).generateId) == null ? void 0 : _o.call(_n)) != null ? _p : generateId(),
                                    url: value.annotation.url,
                                    title: value.annotation.title
                                });
                            } else if (value.annotation.type === "file_citation") {
                                controller.enqueue({
                                    type: "source",
                                    sourceType: "document",
                                    id: (_s = (_r = (_q = self.config).generateId) == null ? void 0 : _r.call(_q)) != null ? _s : generateId(),
                                    mediaType: "text/plain",
                                    title: (_u = (_t = value.annotation.quote) != null ? _t : value.annotation.filename) != null ? _u : "Document",
                                    filename: (_v = value.annotation.filename) != null ? _v : value.annotation.file_id
                                });
                            }
                        } else if (isErrorChunk(value)) {
                            controller.enqueue({
                                type: "error",
                                error: value
                            });
                        }
                    },
                    flush (controller) {
                        const providerMetadata = {
                            openai: {
                                responseId
                            }
                        };
                        if (logprobs.length > 0) {
                            providerMetadata.openai.logprobs = logprobs;
                        }
                        if (serviceTier !== void 0) {
                            providerMetadata.openai.serviceTier = serviceTier;
                        }
                        controller.enqueue({
                            type: "finish",
                            finishReason,
                            usage,
                            providerMetadata
                        });
                    }
                })),
                request: {
                    body
                },
                response: {
                    headers: responseHeaders
                }
            };
        });
    }
};
function isTextDeltaChunk(chunk) {
    return chunk.type === "response.output_text.delta";
}
function isResponseOutputItemDoneChunk(chunk) {
    return chunk.type === "response.output_item.done";
}
function isResponseFinishedChunk(chunk) {
    return chunk.type === "response.completed" || chunk.type === "response.incomplete";
}
function isResponseCreatedChunk(chunk) {
    return chunk.type === "response.created";
}
function isResponseFunctionCallArgumentsDeltaChunk(chunk) {
    return chunk.type === "response.function_call_arguments.delta";
}
function isResponseCodeInterpreterCallCodeDeltaChunk(chunk) {
    return chunk.type === "response.code_interpreter_call_code.delta";
}
function isResponseCodeInterpreterCallCodeDoneChunk(chunk) {
    return chunk.type === "response.code_interpreter_call_code.done";
}
function isResponseOutputItemAddedChunk(chunk) {
    return chunk.type === "response.output_item.added";
}
function isResponseAnnotationAddedChunk(chunk) {
    return chunk.type === "response.output_text.annotation.added";
}
function isErrorChunk(chunk) {
    return chunk.type === "error";
}
function getResponsesModelConfig(modelId) {
    const supportsFlexProcessing22 = modelId.startsWith("o3") || modelId.startsWith("o4-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-chat");
    const supportsPriorityProcessing22 = modelId.startsWith("gpt-4") || modelId.startsWith("gpt-5-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-nano") && !modelId.startsWith("gpt-5-chat") || modelId.startsWith("o3") || modelId.startsWith("o4-mini");
    const defaults2 = {
        systemMessageMode: "system",
        supportsFlexProcessing: supportsFlexProcessing22,
        supportsPriorityProcessing: supportsPriorityProcessing22
    };
    if (modelId.startsWith("gpt-5-chat")) {
        return __spreadProps(__spreadValues({}, defaults2), {
            isReasoningModel: false
        });
    }
    if (modelId.startsWith("o") || modelId.startsWith("gpt-5") || modelId.startsWith("codex-") || modelId.startsWith("computer-use")) {
        if (modelId.startsWith("o1-mini") || modelId.startsWith("o1-preview")) {
            return __spreadProps(__spreadValues({}, defaults2), {
                isReasoningModel: true,
                systemMessageMode: "remove"
            });
        }
        return __spreadProps(__spreadValues({}, defaults2), {
            isReasoningModel: true,
            systemMessageMode: "developer"
        });
    }
    return __spreadProps(__spreadValues({}, defaults2), {
        isReasoningModel: false
    });
}
function mapWebSearchOutput(action) {
    var _a;
    switch(action.type){
        case "search":
            return {
                action: {
                    type: "search",
                    query: (_a = action.query) != null ? _a : void 0
                }
            };
        case "open_page":
            return {
                action: {
                    type: "openPage",
                    url: action.url
                }
            };
        case "find":
            return {
                action: {
                    type: "find",
                    url: action.url,
                    pattern: action.pattern
                }
            };
    }
}
var openaiSpeechProviderOptionsSchema = lazyValidator(()=>zodSchema(import_v418.z.object({
        instructions: import_v418.z.string().nullish(),
        speed: import_v418.z.number().min(0.25).max(4).default(1).nullish()
    })));
var OpenAISpeechModel = class {
    constructor(modelId, config){
        this.modelId = modelId;
        this.config = config;
        this.specificationVersion = "v2";
    }
    get provider() {
        return this.config.provider;
    }
    getArgs(_0) {
        return __async(this, arguments, function*({ text, voice = "alloy", outputFormat = "mp3", speed, instructions, language, providerOptions }) {
            const warnings = [];
            const openAIOptions = yield parseProviderOptions({
                provider: "openai",
                providerOptions,
                schema: openaiSpeechProviderOptionsSchema
            });
            const requestBody = {
                model: this.modelId,
                input: text,
                voice,
                response_format: "mp3",
                speed,
                instructions
            };
            if (outputFormat) {
                if ([
                    "mp3",
                    "opus",
                    "aac",
                    "flac",
                    "wav",
                    "pcm"
                ].includes(outputFormat)) {
                    requestBody.response_format = outputFormat;
                } else {
                    warnings.push({
                        type: "unsupported-setting",
                        setting: "outputFormat",
                        details: `Unsupported output format: ${outputFormat}. Using mp3 instead.`
                    });
                }
            }
            if (openAIOptions) {
                const speechModelOptions = {};
                for(const key in speechModelOptions){
                    const value = speechModelOptions[key];
                    if (value !== void 0) {
                        requestBody[key] = value;
                    }
                }
            }
            if (language) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "language",
                    details: `OpenAI speech models do not support language selection. Language parameter "${language}" was ignored.`
                });
            }
            return {
                requestBody,
                warnings
            };
        });
    }
    doGenerate(options) {
        return __async(this, null, function*() {
            var _a, _b, _c;
            const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();
            const { requestBody, warnings } = yield this.getArgs(options);
            const { value: audio, responseHeaders, rawValue: rawResponse } = yield postJsonToApi({
                url: this.config.url({
                    path: "/audio/speech",
                    modelId: this.modelId
                }),
                headers: combineHeaders(this.config.headers(), options.headers),
                body: requestBody,
                failedResponseHandler: openaiFailedResponseHandler,
                successfulResponseHandler: createBinaryResponseHandler(),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            return {
                audio,
                warnings,
                request: {
                    body: JSON.stringify(requestBody)
                },
                response: {
                    timestamp: currentDate,
                    modelId: this.modelId,
                    headers: responseHeaders,
                    body: rawResponse
                }
            };
        });
    }
};
var openaiTranscriptionResponseSchema = lazyValidator(()=>zodSchema(import_v419.z.object({
        text: import_v419.z.string(),
        language: import_v419.z.string().nullish(),
        duration: import_v419.z.number().nullish(),
        words: import_v419.z.array(import_v419.z.object({
            word: import_v419.z.string(),
            start: import_v419.z.number(),
            end: import_v419.z.number()
        })).nullish(),
        segments: import_v419.z.array(import_v419.z.object({
            id: import_v419.z.number(),
            seek: import_v419.z.number(),
            start: import_v419.z.number(),
            end: import_v419.z.number(),
            text: import_v419.z.string(),
            tokens: import_v419.z.array(import_v419.z.number()),
            temperature: import_v419.z.number(),
            avg_logprob: import_v419.z.number(),
            compression_ratio: import_v419.z.number(),
            no_speech_prob: import_v419.z.number()
        })).nullish()
    })));
var openAITranscriptionProviderOptions = lazyValidator(()=>zodSchema(import_v420.z.object({
        /**
       * Additional information to include in the transcription response.
       */ include: import_v420.z.array(import_v420.z.string()).optional(),
        /**
       * The language of the input audio in ISO-639-1 format.
       */ language: import_v420.z.string().optional(),
        /**
       * An optional text to guide the model's style or continue a previous audio segment.
       */ prompt: import_v420.z.string().optional(),
        /**
       * The sampling temperature, between 0 and 1.
       * @default 0
       */ temperature: import_v420.z.number().min(0).max(1).default(0).optional(),
        /**
       * The timestamp granularities to populate for this transcription.
       * @default ['segment']
       */ timestampGranularities: import_v420.z.array(import_v420.z.enum([
            "word",
            "segment"
        ])).default([
            "segment"
        ]).optional()
    })));
var languageMap = {
    afrikaans: "af",
    arabic: "ar",
    armenian: "hy",
    azerbaijani: "az",
    belarusian: "be",
    bosnian: "bs",
    bulgarian: "bg",
    catalan: "ca",
    chinese: "zh",
    croatian: "hr",
    czech: "cs",
    danish: "da",
    dutch: "nl",
    english: "en",
    estonian: "et",
    finnish: "fi",
    french: "fr",
    galician: "gl",
    german: "de",
    greek: "el",
    hebrew: "he",
    hindi: "hi",
    hungarian: "hu",
    icelandic: "is",
    indonesian: "id",
    italian: "it",
    japanese: "ja",
    kannada: "kn",
    kazakh: "kk",
    korean: "ko",
    latvian: "lv",
    lithuanian: "lt",
    macedonian: "mk",
    malay: "ms",
    marathi: "mr",
    maori: "mi",
    nepali: "ne",
    norwegian: "no",
    persian: "fa",
    polish: "pl",
    portuguese: "pt",
    romanian: "ro",
    russian: "ru",
    serbian: "sr",
    slovak: "sk",
    slovenian: "sl",
    spanish: "es",
    swahili: "sw",
    swedish: "sv",
    tagalog: "tl",
    tamil: "ta",
    thai: "th",
    turkish: "tr",
    ukrainian: "uk",
    urdu: "ur",
    vietnamese: "vi",
    welsh: "cy"
};
var OpenAITranscriptionModel = class {
    constructor(modelId, config){
        this.modelId = modelId;
        this.config = config;
        this.specificationVersion = "v2";
    }
    get provider() {
        return this.config.provider;
    }
    getArgs(_0) {
        return __async(this, arguments, function*({ audio, mediaType, providerOptions }) {
            const warnings = [];
            const openAIOptions = yield parseProviderOptions({
                provider: "openai",
                providerOptions,
                schema: openAITranscriptionProviderOptions
            });
            const formData = new FormData();
            const blob = audio instanceof Uint8Array ? new Blob([
                audio
            ]) : new Blob([
                convertBase64ToUint8Array(audio)
            ]);
            formData.append("model", this.modelId);
            const fileExtension = mediaTypeToExtension(mediaType);
            formData.append("file", new File([
                blob
            ], "audio", {
                type: mediaType
            }), `audio.${fileExtension}`);
            if (openAIOptions) {
                const transcriptionModelOptions = {
                    include: openAIOptions.include,
                    language: openAIOptions.language,
                    prompt: openAIOptions.prompt,
                    // https://platform.openai.com/docs/api-reference/audio/createTranscription#audio_createtranscription-response_format
                    // prefer verbose_json to get segments for models that support it
                    response_format: [
                        "gpt-4o-transcribe",
                        "gpt-4o-mini-transcribe"
                    ].includes(this.modelId) ? "json" : "verbose_json",
                    temperature: openAIOptions.temperature,
                    timestamp_granularities: openAIOptions.timestampGranularities
                };
                for (const [key, value] of Object.entries(transcriptionModelOptions)){
                    if (value != null) {
                        if (Array.isArray(value)) {
                            for (const item of value){
                                formData.append(`${key}[]`, String(item));
                            }
                        } else {
                            formData.append(key, String(value));
                        }
                    }
                }
            }
            return {
                formData,
                warnings
            };
        });
    }
    doGenerate(options) {
        return __async(this, null, function*() {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();
            const { formData, warnings } = yield this.getArgs(options);
            const { value: response, responseHeaders, rawValue: rawResponse } = yield postFormDataToApi({
                url: this.config.url({
                    path: "/audio/transcriptions",
                    modelId: this.modelId
                }),
                headers: combineHeaders(this.config.headers(), options.headers),
                formData,
                failedResponseHandler: openaiFailedResponseHandler,
                successfulResponseHandler: createJsonResponseHandler(openaiTranscriptionResponseSchema),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            const language = response.language != null && response.language in languageMap ? languageMap[response.language] : void 0;
            return {
                text: response.text,
                segments: (_g = (_f = (_d = response.segments) == null ? void 0 : _d.map((segment)=>({
                        text: segment.text,
                        startSecond: segment.start,
                        endSecond: segment.end
                    }))) != null ? _f : (_e = response.words) == null ? void 0 : _e.map((word)=>({
                        text: word.word,
                        startSecond: word.start,
                        endSecond: word.end
                    }))) != null ? _g : [],
                language,
                durationInSeconds: (_h = response.duration) != null ? _h : void 0,
                warnings,
                response: {
                    timestamp: currentDate,
                    modelId: this.modelId,
                    headers: responseHeaders,
                    body: rawResponse
                }
            };
        });
    }
};
var VERSION2 = ("TURBOPACK compile-time truthy", 1) ? "2.0.53" : "TURBOPACK unreachable";
function createOpenAI(options = {}) {
    var _a, _b;
    const baseURL = (_a = withoutTrailingSlash(loadOptionalSetting({
        settingValue: options.baseURL,
        environmentVariableName: "OPENAI_BASE_URL"
    }))) != null ? _a : "https://api.openai.com/v1";
    const providerName = (_b = options.name) != null ? _b : "openai";
    const getHeaders = ()=>withUserAgentSuffix(__spreadValues({
            Authorization: `Bearer ${loadApiKey({
                apiKey: options.apiKey,
                environmentVariableName: "OPENAI_API_KEY",
                description: "OpenAI"
            })}`,
            "OpenAI-Organization": options.organization,
            "OpenAI-Project": options.project
        }, options.headers), `ai-sdk/openai/${VERSION2}`);
    const createChatModel = (modelId)=>new OpenAIChatLanguageModel(modelId, {
            provider: `${providerName}.chat`,
            url: ({ path: path7 })=>`${baseURL}${path7}`,
            headers: getHeaders,
            fetch: options.fetch
        });
    const createCompletionModel = (modelId)=>new OpenAICompletionLanguageModel(modelId, {
            provider: `${providerName}.completion`,
            url: ({ path: path7 })=>`${baseURL}${path7}`,
            headers: getHeaders,
            fetch: options.fetch
        });
    const createEmbeddingModel = (modelId)=>new OpenAIEmbeddingModel(modelId, {
            provider: `${providerName}.embedding`,
            url: ({ path: path7 })=>`${baseURL}${path7}`,
            headers: getHeaders,
            fetch: options.fetch
        });
    const createImageModel = (modelId)=>new OpenAIImageModel(modelId, {
            provider: `${providerName}.image`,
            url: ({ path: path7 })=>`${baseURL}${path7}`,
            headers: getHeaders,
            fetch: options.fetch
        });
    const createTranscriptionModel = (modelId)=>new OpenAITranscriptionModel(modelId, {
            provider: `${providerName}.transcription`,
            url: ({ path: path7 })=>`${baseURL}${path7}`,
            headers: getHeaders,
            fetch: options.fetch
        });
    const createSpeechModel = (modelId)=>new OpenAISpeechModel(modelId, {
            provider: `${providerName}.speech`,
            url: ({ path: path7 })=>`${baseURL}${path7}`,
            headers: getHeaders,
            fetch: options.fetch
        });
    const createLanguageModel = (modelId)=>{
        if (new.target) {
            throw new Error("The OpenAI model function cannot be called with the new keyword.");
        }
        return createResponsesModel(modelId);
    };
    const createResponsesModel = (modelId)=>{
        return new OpenAIResponsesLanguageModel(modelId, {
            provider: `${providerName}.responses`,
            url: ({ path: path7 })=>`${baseURL}${path7}`,
            headers: getHeaders,
            fetch: options.fetch,
            fileIdPrefixes: [
                "file-"
            ]
        });
    };
    const provider = function(modelId) {
        return createLanguageModel(modelId);
    };
    provider.languageModel = createLanguageModel;
    provider.chat = createChatModel;
    provider.completion = createCompletionModel;
    provider.responses = createResponsesModel;
    provider.embedding = createEmbeddingModel;
    provider.textEmbedding = createEmbeddingModel;
    provider.textEmbeddingModel = createEmbeddingModel;
    provider.image = createImageModel;
    provider.imageModel = createImageModel;
    provider.transcription = createTranscriptionModel;
    provider.transcriptionModel = createTranscriptionModel;
    provider.speech = createSpeechModel;
    provider.speechModel = createSpeechModel;
    provider.tools = openaiTools;
    return provider;
}
var openai = createOpenAI();
// ../../node_modules/.pnpm/@ai-sdk+anthropic@2.0.34_zod@3.25.67/node_modules/@ai-sdk/anthropic/dist/index.mjs
var import_provider20 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_provider21 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v421 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v422 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v423 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_provider22 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v424 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v425 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v426 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_provider23 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v427 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v428 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v429 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v430 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v431 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v432 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v433 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v434 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v435 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v436 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var VERSION3 = ("TURBOPACK compile-time truthy", 1) ? "2.0.34" : "TURBOPACK unreachable";
var anthropicErrorDataSchema = lazySchema(()=>zodSchema(import_v421.z.object({
        type: import_v421.z.literal("error"),
        error: import_v421.z.object({
            type: import_v421.z.string(),
            message: import_v421.z.string()
        })
    })));
var anthropicFailedResponseHandler = createJsonErrorResponseHandler({
    errorSchema: anthropicErrorDataSchema,
    errorToMessage: (data)=>data.error.message
});
var anthropicMessagesResponseSchema = lazySchema(()=>zodSchema(import_v422.z.object({
        type: import_v422.z.literal("message"),
        id: import_v422.z.string().nullish(),
        model: import_v422.z.string().nullish(),
        content: import_v422.z.array(import_v422.z.discriminatedUnion("type", [
            import_v422.z.object({
                type: import_v422.z.literal("text"),
                text: import_v422.z.string(),
                citations: import_v422.z.array(import_v422.z.discriminatedUnion("type", [
                    import_v422.z.object({
                        type: import_v422.z.literal("web_search_result_location"),
                        cited_text: import_v422.z.string(),
                        url: import_v422.z.string(),
                        title: import_v422.z.string(),
                        encrypted_index: import_v422.z.string()
                    }),
                    import_v422.z.object({
                        type: import_v422.z.literal("page_location"),
                        cited_text: import_v422.z.string(),
                        document_index: import_v422.z.number(),
                        document_title: import_v422.z.string().nullable(),
                        start_page_number: import_v422.z.number(),
                        end_page_number: import_v422.z.number()
                    }),
                    import_v422.z.object({
                        type: import_v422.z.literal("char_location"),
                        cited_text: import_v422.z.string(),
                        document_index: import_v422.z.number(),
                        document_title: import_v422.z.string().nullable(),
                        start_char_index: import_v422.z.number(),
                        end_char_index: import_v422.z.number()
                    })
                ])).optional()
            }),
            import_v422.z.object({
                type: import_v422.z.literal("thinking"),
                thinking: import_v422.z.string(),
                signature: import_v422.z.string()
            }),
            import_v422.z.object({
                type: import_v422.z.literal("redacted_thinking"),
                data: import_v422.z.string()
            }),
            import_v422.z.object({
                type: import_v422.z.literal("tool_use"),
                id: import_v422.z.string(),
                name: import_v422.z.string(),
                input: import_v422.z.unknown()
            }),
            import_v422.z.object({
                type: import_v422.z.literal("server_tool_use"),
                id: import_v422.z.string(),
                name: import_v422.z.string(),
                input: import_v422.z.record(import_v422.z.string(), import_v422.z.unknown()).nullish()
            }),
            import_v422.z.object({
                type: import_v422.z.literal("web_fetch_tool_result"),
                tool_use_id: import_v422.z.string(),
                content: import_v422.z.union([
                    import_v422.z.object({
                        type: import_v422.z.literal("web_fetch_result"),
                        url: import_v422.z.string(),
                        retrieved_at: import_v422.z.string(),
                        content: import_v422.z.object({
                            type: import_v422.z.literal("document"),
                            title: import_v422.z.string().nullable(),
                            citations: import_v422.z.object({
                                enabled: import_v422.z.boolean()
                            }).optional(),
                            source: import_v422.z.object({
                                type: import_v422.z.literal("text"),
                                media_type: import_v422.z.string(),
                                data: import_v422.z.string()
                            })
                        })
                    }),
                    import_v422.z.object({
                        type: import_v422.z.literal("web_fetch_tool_result_error"),
                        error_code: import_v422.z.string()
                    })
                ])
            }),
            import_v422.z.object({
                type: import_v422.z.literal("web_search_tool_result"),
                tool_use_id: import_v422.z.string(),
                content: import_v422.z.union([
                    import_v422.z.array(import_v422.z.object({
                        type: import_v422.z.literal("web_search_result"),
                        url: import_v422.z.string(),
                        title: import_v422.z.string(),
                        encrypted_content: import_v422.z.string(),
                        page_age: import_v422.z.string().nullish()
                    })),
                    import_v422.z.object({
                        type: import_v422.z.literal("web_search_tool_result_error"),
                        error_code: import_v422.z.string()
                    })
                ])
            }),
            // code execution results for code_execution_20250522 tool:
            import_v422.z.object({
                type: import_v422.z.literal("code_execution_tool_result"),
                tool_use_id: import_v422.z.string(),
                content: import_v422.z.union([
                    import_v422.z.object({
                        type: import_v422.z.literal("code_execution_result"),
                        stdout: import_v422.z.string(),
                        stderr: import_v422.z.string(),
                        return_code: import_v422.z.number()
                    }),
                    import_v422.z.object({
                        type: import_v422.z.literal("code_execution_tool_result_error"),
                        error_code: import_v422.z.string()
                    })
                ])
            }),
            // bash code execution results for code_execution_20250825 tool:
            import_v422.z.object({
                type: import_v422.z.literal("bash_code_execution_tool_result"),
                tool_use_id: import_v422.z.string(),
                content: import_v422.z.discriminatedUnion("type", [
                    import_v422.z.object({
                        type: import_v422.z.literal("bash_code_execution_result"),
                        content: import_v422.z.array(import_v422.z.object({
                            type: import_v422.z.literal("bash_code_execution_output"),
                            file_id: import_v422.z.string()
                        })),
                        stdout: import_v422.z.string(),
                        stderr: import_v422.z.string(),
                        return_code: import_v422.z.number()
                    }),
                    import_v422.z.object({
                        type: import_v422.z.literal("bash_code_execution_tool_result_error"),
                        error_code: import_v422.z.string()
                    })
                ])
            }),
            // text editor code execution results for code_execution_20250825 tool:
            import_v422.z.object({
                type: import_v422.z.literal("text_editor_code_execution_tool_result"),
                tool_use_id: import_v422.z.string(),
                content: import_v422.z.discriminatedUnion("type", [
                    import_v422.z.object({
                        type: import_v422.z.literal("text_editor_code_execution_tool_result_error"),
                        error_code: import_v422.z.string()
                    }),
                    import_v422.z.object({
                        type: import_v422.z.literal("text_editor_code_execution_view_result"),
                        content: import_v422.z.string(),
                        file_type: import_v422.z.string(),
                        num_lines: import_v422.z.number().nullable(),
                        start_line: import_v422.z.number().nullable(),
                        total_lines: import_v422.z.number().nullable()
                    }),
                    import_v422.z.object({
                        type: import_v422.z.literal("text_editor_code_execution_create_result"),
                        is_file_update: import_v422.z.boolean()
                    }),
                    import_v422.z.object({
                        type: import_v422.z.literal("text_editor_code_execution_str_replace_result"),
                        lines: import_v422.z.array(import_v422.z.string()).nullable(),
                        new_lines: import_v422.z.number().nullable(),
                        new_start: import_v422.z.number().nullable(),
                        old_lines: import_v422.z.number().nullable(),
                        old_start: import_v422.z.number().nullable()
                    })
                ])
            })
        ])),
        stop_reason: import_v422.z.string().nullish(),
        stop_sequence: import_v422.z.string().nullish(),
        usage: import_v422.z.looseObject({
            input_tokens: import_v422.z.number(),
            output_tokens: import_v422.z.number(),
            cache_creation_input_tokens: import_v422.z.number().nullish(),
            cache_read_input_tokens: import_v422.z.number().nullish()
        }),
        container: import_v422.z.object({
            expires_at: import_v422.z.string(),
            id: import_v422.z.string(),
            skills: import_v422.z.array(import_v422.z.object({
                type: import_v422.z.union([
                    import_v422.z.literal("anthropic"),
                    import_v422.z.literal("custom")
                ]),
                skill_id: import_v422.z.string(),
                version: import_v422.z.string()
            })).nullish()
        }).nullish()
    })));
var anthropicMessagesChunkSchema = lazySchema(()=>zodSchema(import_v422.z.discriminatedUnion("type", [
        import_v422.z.object({
            type: import_v422.z.literal("message_start"),
            message: import_v422.z.object({
                id: import_v422.z.string().nullish(),
                model: import_v422.z.string().nullish(),
                usage: import_v422.z.looseObject({
                    input_tokens: import_v422.z.number(),
                    cache_creation_input_tokens: import_v422.z.number().nullish(),
                    cache_read_input_tokens: import_v422.z.number().nullish()
                })
            })
        }),
        import_v422.z.object({
            type: import_v422.z.literal("content_block_start"),
            index: import_v422.z.number(),
            content_block: import_v422.z.discriminatedUnion("type", [
                import_v422.z.object({
                    type: import_v422.z.literal("text"),
                    text: import_v422.z.string()
                }),
                import_v422.z.object({
                    type: import_v422.z.literal("thinking"),
                    thinking: import_v422.z.string()
                }),
                import_v422.z.object({
                    type: import_v422.z.literal("tool_use"),
                    id: import_v422.z.string(),
                    name: import_v422.z.string()
                }),
                import_v422.z.object({
                    type: import_v422.z.literal("redacted_thinking"),
                    data: import_v422.z.string()
                }),
                import_v422.z.object({
                    type: import_v422.z.literal("server_tool_use"),
                    id: import_v422.z.string(),
                    name: import_v422.z.string(),
                    input: import_v422.z.record(import_v422.z.string(), import_v422.z.unknown()).nullish()
                }),
                import_v422.z.object({
                    type: import_v422.z.literal("web_fetch_tool_result"),
                    tool_use_id: import_v422.z.string(),
                    content: import_v422.z.union([
                        import_v422.z.object({
                            type: import_v422.z.literal("web_fetch_result"),
                            url: import_v422.z.string(),
                            retrieved_at: import_v422.z.string(),
                            content: import_v422.z.object({
                                type: import_v422.z.literal("document"),
                                title: import_v422.z.string().nullable(),
                                citations: import_v422.z.object({
                                    enabled: import_v422.z.boolean()
                                }).optional(),
                                source: import_v422.z.object({
                                    type: import_v422.z.literal("text"),
                                    media_type: import_v422.z.string(),
                                    data: import_v422.z.string()
                                })
                            })
                        }),
                        import_v422.z.object({
                            type: import_v422.z.literal("web_fetch_tool_result_error"),
                            error_code: import_v422.z.string()
                        })
                    ])
                }),
                import_v422.z.object({
                    type: import_v422.z.literal("web_search_tool_result"),
                    tool_use_id: import_v422.z.string(),
                    content: import_v422.z.union([
                        import_v422.z.array(import_v422.z.object({
                            type: import_v422.z.literal("web_search_result"),
                            url: import_v422.z.string(),
                            title: import_v422.z.string(),
                            encrypted_content: import_v422.z.string(),
                            page_age: import_v422.z.string().nullish()
                        })),
                        import_v422.z.object({
                            type: import_v422.z.literal("web_search_tool_result_error"),
                            error_code: import_v422.z.string()
                        })
                    ])
                }),
                // code execution results for code_execution_20250522 tool:
                import_v422.z.object({
                    type: import_v422.z.literal("code_execution_tool_result"),
                    tool_use_id: import_v422.z.string(),
                    content: import_v422.z.union([
                        import_v422.z.object({
                            type: import_v422.z.literal("code_execution_result"),
                            stdout: import_v422.z.string(),
                            stderr: import_v422.z.string(),
                            return_code: import_v422.z.number()
                        }),
                        import_v422.z.object({
                            type: import_v422.z.literal("code_execution_tool_result_error"),
                            error_code: import_v422.z.string()
                        })
                    ])
                }),
                // bash code execution results for code_execution_20250825 tool:
                import_v422.z.object({
                    type: import_v422.z.literal("bash_code_execution_tool_result"),
                    tool_use_id: import_v422.z.string(),
                    content: import_v422.z.discriminatedUnion("type", [
                        import_v422.z.object({
                            type: import_v422.z.literal("bash_code_execution_result"),
                            content: import_v422.z.array(import_v422.z.object({
                                type: import_v422.z.literal("bash_code_execution_output"),
                                file_id: import_v422.z.string()
                            })),
                            stdout: import_v422.z.string(),
                            stderr: import_v422.z.string(),
                            return_code: import_v422.z.number()
                        }),
                        import_v422.z.object({
                            type: import_v422.z.literal("bash_code_execution_tool_result_error"),
                            error_code: import_v422.z.string()
                        })
                    ])
                }),
                // text editor code execution results for code_execution_20250825 tool:
                import_v422.z.object({
                    type: import_v422.z.literal("text_editor_code_execution_tool_result"),
                    tool_use_id: import_v422.z.string(),
                    content: import_v422.z.discriminatedUnion("type", [
                        import_v422.z.object({
                            type: import_v422.z.literal("text_editor_code_execution_tool_result_error"),
                            error_code: import_v422.z.string()
                        }),
                        import_v422.z.object({
                            type: import_v422.z.literal("text_editor_code_execution_view_result"),
                            content: import_v422.z.string(),
                            file_type: import_v422.z.string(),
                            num_lines: import_v422.z.number().nullable(),
                            start_line: import_v422.z.number().nullable(),
                            total_lines: import_v422.z.number().nullable()
                        }),
                        import_v422.z.object({
                            type: import_v422.z.literal("text_editor_code_execution_create_result"),
                            is_file_update: import_v422.z.boolean()
                        }),
                        import_v422.z.object({
                            type: import_v422.z.literal("text_editor_code_execution_str_replace_result"),
                            lines: import_v422.z.array(import_v422.z.string()).nullable(),
                            new_lines: import_v422.z.number().nullable(),
                            new_start: import_v422.z.number().nullable(),
                            old_lines: import_v422.z.number().nullable(),
                            old_start: import_v422.z.number().nullable()
                        })
                    ])
                })
            ])
        }),
        import_v422.z.object({
            type: import_v422.z.literal("content_block_delta"),
            index: import_v422.z.number(),
            delta: import_v422.z.discriminatedUnion("type", [
                import_v422.z.object({
                    type: import_v422.z.literal("input_json_delta"),
                    partial_json: import_v422.z.string()
                }),
                import_v422.z.object({
                    type: import_v422.z.literal("text_delta"),
                    text: import_v422.z.string()
                }),
                import_v422.z.object({
                    type: import_v422.z.literal("thinking_delta"),
                    thinking: import_v422.z.string()
                }),
                import_v422.z.object({
                    type: import_v422.z.literal("signature_delta"),
                    signature: import_v422.z.string()
                }),
                import_v422.z.object({
                    type: import_v422.z.literal("citations_delta"),
                    citation: import_v422.z.discriminatedUnion("type", [
                        import_v422.z.object({
                            type: import_v422.z.literal("web_search_result_location"),
                            cited_text: import_v422.z.string(),
                            url: import_v422.z.string(),
                            title: import_v422.z.string(),
                            encrypted_index: import_v422.z.string()
                        }),
                        import_v422.z.object({
                            type: import_v422.z.literal("page_location"),
                            cited_text: import_v422.z.string(),
                            document_index: import_v422.z.number(),
                            document_title: import_v422.z.string().nullable(),
                            start_page_number: import_v422.z.number(),
                            end_page_number: import_v422.z.number()
                        }),
                        import_v422.z.object({
                            type: import_v422.z.literal("char_location"),
                            cited_text: import_v422.z.string(),
                            document_index: import_v422.z.number(),
                            document_title: import_v422.z.string().nullable(),
                            start_char_index: import_v422.z.number(),
                            end_char_index: import_v422.z.number()
                        })
                    ])
                })
            ])
        }),
        import_v422.z.object({
            type: import_v422.z.literal("content_block_stop"),
            index: import_v422.z.number()
        }),
        import_v422.z.object({
            type: import_v422.z.literal("error"),
            error: import_v422.z.object({
                type: import_v422.z.string(),
                message: import_v422.z.string()
            })
        }),
        import_v422.z.object({
            type: import_v422.z.literal("message_delta"),
            delta: import_v422.z.object({
                stop_reason: import_v422.z.string().nullish(),
                stop_sequence: import_v422.z.string().nullish(),
                container: import_v422.z.object({
                    expires_at: import_v422.z.string(),
                    id: import_v422.z.string(),
                    skills: import_v422.z.array(import_v422.z.object({
                        type: import_v422.z.union([
                            import_v422.z.literal("anthropic"),
                            import_v422.z.literal("custom")
                        ]),
                        skill_id: import_v422.z.string(),
                        version: import_v422.z.string()
                    })).nullish()
                }).nullish()
            }),
            usage: import_v422.z.looseObject({
                output_tokens: import_v422.z.number(),
                cache_creation_input_tokens: import_v422.z.number().nullish()
            })
        }),
        import_v422.z.object({
            type: import_v422.z.literal("message_stop")
        }),
        import_v422.z.object({
            type: import_v422.z.literal("ping")
        })
    ])));
var anthropicReasoningMetadataSchema = lazySchema(()=>zodSchema(import_v422.z.object({
        signature: import_v422.z.string().optional(),
        redactedData: import_v422.z.string().optional()
    })));
var anthropicFilePartProviderOptions = import_v423.z.object({
    /**
   * Citation configuration for this document.
   * When enabled, this document will generate citations in the response.
   */ citations: import_v423.z.object({
        /**
     * Enable citations for this document
     */ enabled: import_v423.z.boolean()
    }).optional(),
    /**
   * Custom title for the document.
   * If not provided, the filename will be used.
   */ title: import_v423.z.string().optional(),
    /**
   * Context about the document that will be passed to the model
   * but not used towards cited content.
   * Useful for storing document metadata as text or stringified JSON.
   */ context: import_v423.z.string().optional()
});
var anthropicProviderOptions = import_v423.z.object({
    sendReasoning: import_v423.z.boolean().optional(),
    thinking: import_v423.z.object({
        type: import_v423.z.union([
            import_v423.z.literal("enabled"),
            import_v423.z.literal("disabled")
        ]),
        budgetTokens: import_v423.z.number().optional()
    }).optional(),
    /**
   * Whether to disable parallel function calling during tool use. Default is false.
   * When set to true, Claude will use at most one tool per response.
   */ disableParallelToolUse: import_v423.z.boolean().optional(),
    /**
   * Cache control settings for this message.
   * See https://docs.anthropic.com/en/docs/build-with-claude/prompt-caching
   */ cacheControl: import_v423.z.object({
        type: import_v423.z.literal("ephemeral"),
        ttl: import_v423.z.union([
            import_v423.z.literal("5m"),
            import_v423.z.literal("1h")
        ]).optional()
    }).optional(),
    /**
   * Agent Skills configuration. Skills enable Claude to perform specialized tasks
   * like document processing (PPTX, DOCX, PDF, XLSX) and data analysis.
   * Requires code execution tool to be enabled.
   */ container: import_v423.z.object({
        id: import_v423.z.string().optional(),
        skills: import_v423.z.array(import_v423.z.object({
            type: import_v423.z.union([
                import_v423.z.literal("anthropic"),
                import_v423.z.literal("custom")
            ]),
            skillId: import_v423.z.string(),
            version: import_v423.z.string().optional()
        })).optional()
    }).optional()
});
var MAX_CACHE_BREAKPOINTS = 4;
function getCacheControl(providerMetadata) {
    var _a;
    const anthropic2 = providerMetadata == null ? void 0 : providerMetadata.anthropic;
    const cacheControlValue = (_a = anthropic2 == null ? void 0 : anthropic2.cacheControl) != null ? _a : anthropic2 == null ? void 0 : anthropic2.cache_control;
    return cacheControlValue;
}
var CacheControlValidator = class {
    constructor(){
        this.breakpointCount = 0;
        this.warnings = [];
    }
    getCacheControl(providerMetadata, context) {
        const cacheControlValue = getCacheControl(providerMetadata);
        if (!cacheControlValue) {
            return void 0;
        }
        if (!context.canCache) {
            this.warnings.push({
                type: "unsupported-setting",
                setting: "cacheControl",
                details: `cache_control cannot be set on ${context.type}. It will be ignored.`
            });
            return void 0;
        }
        this.breakpointCount++;
        if (this.breakpointCount > MAX_CACHE_BREAKPOINTS) {
            this.warnings.push({
                type: "unsupported-setting",
                setting: "cacheControl",
                details: `Maximum ${MAX_CACHE_BREAKPOINTS} cache breakpoints exceeded (found ${this.breakpointCount}). This breakpoint will be ignored.`
            });
            return void 0;
        }
        return cacheControlValue;
    }
    getWarnings() {
        return this.warnings;
    }
};
var textEditor_20250728ArgsSchema = lazySchema(()=>zodSchema(import_v424.z.object({
        maxCharacters: import_v424.z.number().optional()
    })));
var textEditor_20250728InputSchema = lazySchema(()=>zodSchema(import_v424.z.object({
        command: import_v424.z.enum([
            "view",
            "create",
            "str_replace",
            "insert"
        ]),
        path: import_v424.z.string(),
        file_text: import_v424.z.string().optional(),
        insert_line: import_v424.z.number().int().optional(),
        new_str: import_v424.z.string().optional(),
        old_str: import_v424.z.string().optional(),
        view_range: import_v424.z.array(import_v424.z.number().int()).optional()
    })));
var factory = createProviderDefinedToolFactory({
    id: "anthropic.text_editor_20250728",
    name: "str_replace_based_edit_tool",
    inputSchema: textEditor_20250728InputSchema
});
var textEditor_20250728 = (args = {})=>{
    return factory(args);
};
var webSearch_20250305ArgsSchema = lazySchema(()=>zodSchema(import_v425.z.object({
        maxUses: import_v425.z.number().optional(),
        allowedDomains: import_v425.z.array(import_v425.z.string()).optional(),
        blockedDomains: import_v425.z.array(import_v425.z.string()).optional(),
        userLocation: import_v425.z.object({
            type: import_v425.z.literal("approximate"),
            city: import_v425.z.string().optional(),
            region: import_v425.z.string().optional(),
            country: import_v425.z.string().optional(),
            timezone: import_v425.z.string().optional()
        }).optional()
    })));
var webSearch_20250305OutputSchema = lazySchema(()=>zodSchema(import_v425.z.array(import_v425.z.object({
        url: import_v425.z.string(),
        title: import_v425.z.string(),
        pageAge: import_v425.z.string().nullable(),
        encryptedContent: import_v425.z.string(),
        type: import_v425.z.literal("web_search_result")
    }))));
var webSearch_20250305InputSchema = lazySchema(()=>zodSchema(import_v425.z.object({
        query: import_v425.z.string()
    })));
var factory2 = createProviderDefinedToolFactoryWithOutputSchema({
    id: "anthropic.web_search_20250305",
    name: "web_search",
    inputSchema: webSearch_20250305InputSchema,
    outputSchema: webSearch_20250305OutputSchema
});
var webSearch_20250305 = (args = {})=>{
    return factory2(args);
};
var webFetch_20250910ArgsSchema = lazySchema(()=>zodSchema(import_v426.z.object({
        maxUses: import_v426.z.number().optional(),
        allowedDomains: import_v426.z.array(import_v426.z.string()).optional(),
        blockedDomains: import_v426.z.array(import_v426.z.string()).optional(),
        citations: import_v426.z.object({
            enabled: import_v426.z.boolean()
        }).optional(),
        maxContentTokens: import_v426.z.number().optional()
    })));
var webFetch_20250910OutputSchema = lazySchema(()=>zodSchema(import_v426.z.object({
        type: import_v426.z.literal("web_fetch_result"),
        url: import_v426.z.string(),
        content: import_v426.z.object({
            type: import_v426.z.literal("document"),
            title: import_v426.z.string(),
            citations: import_v426.z.object({
                enabled: import_v426.z.boolean()
            }).optional(),
            source: import_v426.z.union([
                import_v426.z.object({
                    type: import_v426.z.literal("base64"),
                    mediaType: import_v426.z.literal("application/pdf"),
                    data: import_v426.z.string()
                }),
                import_v426.z.object({
                    type: import_v426.z.literal("text"),
                    mediaType: import_v426.z.literal("text/plain"),
                    data: import_v426.z.string()
                })
            ])
        }),
        retrievedAt: import_v426.z.string().nullable()
    })));
var webFetch_20250910InputSchema = lazySchema(()=>zodSchema(import_v426.z.object({
        url: import_v426.z.string()
    })));
var factory3 = createProviderDefinedToolFactoryWithOutputSchema({
    id: "anthropic.web_fetch_20250910",
    name: "web_fetch",
    inputSchema: webFetch_20250910InputSchema,
    outputSchema: webFetch_20250910OutputSchema
});
var webFetch_20250910 = (args = {})=>{
    return factory3(args);
};
function prepareTools(_0) {
    return __async(this, arguments, function*({ tools, toolChoice, disableParallelToolUse, cacheControlValidator }) {
        tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
        const toolWarnings = [];
        const betas = /* @__PURE__ */ new Set();
        const validator2 = cacheControlValidator || new CacheControlValidator();
        if (tools == null) {
            return {
                tools: void 0,
                toolChoice: void 0,
                toolWarnings,
                betas
            };
        }
        const anthropicTools2 = [];
        for (const tool12 of tools){
            switch(tool12.type){
                case "function":
                    {
                        const cacheControl = validator2.getCacheControl(tool12.providerOptions, {
                            type: "tool definition",
                            canCache: true
                        });
                        anthropicTools2.push({
                            name: tool12.name,
                            description: tool12.description,
                            input_schema: tool12.inputSchema,
                            cache_control: cacheControl
                        });
                        break;
                    }
                case "provider-defined":
                    {
                        switch(tool12.id){
                            case "anthropic.code_execution_20250522":
                                {
                                    betas.add("code-execution-2025-05-22");
                                    anthropicTools2.push({
                                        type: "code_execution_20250522",
                                        name: "code_execution",
                                        cache_control: void 0
                                    });
                                    break;
                                }
                            case "anthropic.code_execution_20250825":
                                {
                                    betas.add("code-execution-2025-08-25");
                                    anthropicTools2.push({
                                        type: "code_execution_20250825",
                                        name: "code_execution"
                                    });
                                    break;
                                }
                            case "anthropic.computer_20250124":
                                {
                                    betas.add("computer-use-2025-01-24");
                                    anthropicTools2.push({
                                        name: "computer",
                                        type: "computer_20250124",
                                        display_width_px: tool12.args.displayWidthPx,
                                        display_height_px: tool12.args.displayHeightPx,
                                        display_number: tool12.args.displayNumber,
                                        cache_control: void 0
                                    });
                                    break;
                                }
                            case "anthropic.computer_20241022":
                                {
                                    betas.add("computer-use-2024-10-22");
                                    anthropicTools2.push({
                                        name: "computer",
                                        type: "computer_20241022",
                                        display_width_px: tool12.args.displayWidthPx,
                                        display_height_px: tool12.args.displayHeightPx,
                                        display_number: tool12.args.displayNumber,
                                        cache_control: void 0
                                    });
                                    break;
                                }
                            case "anthropic.text_editor_20250124":
                                {
                                    betas.add("computer-use-2025-01-24");
                                    anthropicTools2.push({
                                        name: "str_replace_editor",
                                        type: "text_editor_20250124",
                                        cache_control: void 0
                                    });
                                    break;
                                }
                            case "anthropic.text_editor_20241022":
                                {
                                    betas.add("computer-use-2024-10-22");
                                    anthropicTools2.push({
                                        name: "str_replace_editor",
                                        type: "text_editor_20241022",
                                        cache_control: void 0
                                    });
                                    break;
                                }
                            case "anthropic.text_editor_20250429":
                                {
                                    betas.add("computer-use-2025-01-24");
                                    anthropicTools2.push({
                                        name: "str_replace_based_edit_tool",
                                        type: "text_editor_20250429",
                                        cache_control: void 0
                                    });
                                    break;
                                }
                            case "anthropic.text_editor_20250728":
                                {
                                    const args = yield validateTypes({
                                        value: tool12.args,
                                        schema: textEditor_20250728ArgsSchema
                                    });
                                    anthropicTools2.push({
                                        name: "str_replace_based_edit_tool",
                                        type: "text_editor_20250728",
                                        max_characters: args.maxCharacters,
                                        cache_control: void 0
                                    });
                                    break;
                                }
                            case "anthropic.bash_20250124":
                                {
                                    betas.add("computer-use-2025-01-24");
                                    anthropicTools2.push({
                                        name: "bash",
                                        type: "bash_20250124",
                                        cache_control: void 0
                                    });
                                    break;
                                }
                            case "anthropic.bash_20241022":
                                {
                                    betas.add("computer-use-2024-10-22");
                                    anthropicTools2.push({
                                        name: "bash",
                                        type: "bash_20241022",
                                        cache_control: void 0
                                    });
                                    break;
                                }
                            case "anthropic.memory_20250818":
                                {
                                    betas.add("context-management-2025-06-27");
                                    anthropicTools2.push({
                                        name: "memory",
                                        type: "memory_20250818"
                                    });
                                    break;
                                }
                            case "anthropic.web_fetch_20250910":
                                {
                                    betas.add("web-fetch-2025-09-10");
                                    const args = yield validateTypes({
                                        value: tool12.args,
                                        schema: webFetch_20250910ArgsSchema
                                    });
                                    anthropicTools2.push({
                                        type: "web_fetch_20250910",
                                        name: "web_fetch",
                                        max_uses: args.maxUses,
                                        allowed_domains: args.allowedDomains,
                                        blocked_domains: args.blockedDomains,
                                        citations: args.citations,
                                        max_content_tokens: args.maxContentTokens,
                                        cache_control: void 0
                                    });
                                    break;
                                }
                            case "anthropic.web_search_20250305":
                                {
                                    const args = yield validateTypes({
                                        value: tool12.args,
                                        schema: webSearch_20250305ArgsSchema
                                    });
                                    anthropicTools2.push({
                                        type: "web_search_20250305",
                                        name: "web_search",
                                        max_uses: args.maxUses,
                                        allowed_domains: args.allowedDomains,
                                        blocked_domains: args.blockedDomains,
                                        user_location: args.userLocation,
                                        cache_control: void 0
                                    });
                                    break;
                                }
                            default:
                                {
                                    toolWarnings.push({
                                        type: "unsupported-tool",
                                        tool: tool12
                                    });
                                    break;
                                }
                        }
                        break;
                    }
                default:
                    {
                        toolWarnings.push({
                            type: "unsupported-tool",
                            tool: tool12
                        });
                        break;
                    }
            }
        }
        if (toolChoice == null) {
            return {
                tools: anthropicTools2,
                toolChoice: disableParallelToolUse ? {
                    type: "auto",
                    disable_parallel_tool_use: disableParallelToolUse
                } : void 0,
                toolWarnings,
                betas
            };
        }
        const type = toolChoice.type;
        switch(type){
            case "auto":
                return {
                    tools: anthropicTools2,
                    toolChoice: {
                        type: "auto",
                        disable_parallel_tool_use: disableParallelToolUse
                    },
                    toolWarnings,
                    betas
                };
            case "required":
                return {
                    tools: anthropicTools2,
                    toolChoice: {
                        type: "any",
                        disable_parallel_tool_use: disableParallelToolUse
                    },
                    toolWarnings,
                    betas
                };
            case "none":
                return {
                    tools: void 0,
                    toolChoice: void 0,
                    toolWarnings,
                    betas
                };
            case "tool":
                return {
                    tools: anthropicTools2,
                    toolChoice: {
                        type: "tool",
                        name: toolChoice.toolName,
                        disable_parallel_tool_use: disableParallelToolUse
                    },
                    toolWarnings,
                    betas
                };
            default:
                {
                    const _exhaustiveCheck = type;
                    throw new import_provider22.UnsupportedFunctionalityError({
                        functionality: `tool choice type: ${_exhaustiveCheck}`
                    });
                }
        }
    });
}
var codeExecution_20250522OutputSchema = lazySchema(()=>zodSchema(import_v427.z.object({
        type: import_v427.z.literal("code_execution_result"),
        stdout: import_v427.z.string(),
        stderr: import_v427.z.string(),
        return_code: import_v427.z.number()
    })));
var codeExecution_20250522InputSchema = lazySchema(()=>zodSchema(import_v427.z.object({
        code: import_v427.z.string()
    })));
var factory4 = createProviderDefinedToolFactoryWithOutputSchema({
    id: "anthropic.code_execution_20250522",
    name: "code_execution",
    inputSchema: codeExecution_20250522InputSchema,
    outputSchema: codeExecution_20250522OutputSchema
});
var codeExecution_20250522 = (args = {})=>{
    return factory4(args);
};
var codeExecution_20250825OutputSchema = lazySchema(()=>zodSchema(import_v428.z.discriminatedUnion("type", [
        import_v428.z.object({
            type: import_v428.z.literal("bash_code_execution_result"),
            content: import_v428.z.array(import_v428.z.object({
                type: import_v428.z.literal("bash_code_execution_output"),
                file_id: import_v428.z.string()
            })),
            stdout: import_v428.z.string(),
            stderr: import_v428.z.string(),
            return_code: import_v428.z.number()
        }),
        import_v428.z.object({
            type: import_v428.z.literal("bash_code_execution_tool_result_error"),
            error_code: import_v428.z.string()
        }),
        import_v428.z.object({
            type: import_v428.z.literal("text_editor_code_execution_tool_result_error"),
            error_code: import_v428.z.string()
        }),
        import_v428.z.object({
            type: import_v428.z.literal("text_editor_code_execution_view_result"),
            content: import_v428.z.string(),
            file_type: import_v428.z.string(),
            num_lines: import_v428.z.number().nullable(),
            start_line: import_v428.z.number().nullable(),
            total_lines: import_v428.z.number().nullable()
        }),
        import_v428.z.object({
            type: import_v428.z.literal("text_editor_code_execution_create_result"),
            is_file_update: import_v428.z.boolean()
        }),
        import_v428.z.object({
            type: import_v428.z.literal("text_editor_code_execution_str_replace_result"),
            lines: import_v428.z.array(import_v428.z.string()).nullable(),
            new_lines: import_v428.z.number().nullable(),
            new_start: import_v428.z.number().nullable(),
            old_lines: import_v428.z.number().nullable(),
            old_start: import_v428.z.number().nullable()
        })
    ])));
var codeExecution_20250825InputSchema = lazySchema(()=>zodSchema(import_v428.z.discriminatedUnion("type", [
        import_v428.z.object({
            type: import_v428.z.literal("bash_code_execution"),
            command: import_v428.z.string()
        }),
        import_v428.z.discriminatedUnion("command", [
            import_v428.z.object({
                type: import_v428.z.literal("text_editor_code_execution"),
                command: import_v428.z.literal("view"),
                path: import_v428.z.string()
            }),
            import_v428.z.object({
                type: import_v428.z.literal("text_editor_code_execution"),
                command: import_v428.z.literal("create"),
                path: import_v428.z.string(),
                file_text: import_v428.z.string().nullish()
            }),
            import_v428.z.object({
                type: import_v428.z.literal("text_editor_code_execution"),
                command: import_v428.z.literal("str_replace"),
                path: import_v428.z.string(),
                old_str: import_v428.z.string(),
                new_str: import_v428.z.string()
            })
        ])
    ])));
var factory5 = createProviderDefinedToolFactoryWithOutputSchema({
    id: "anthropic.code_execution_20250825",
    name: "code_execution",
    inputSchema: codeExecution_20250825InputSchema,
    outputSchema: codeExecution_20250825OutputSchema
});
var codeExecution_20250825 = (args = {})=>{
    return factory5(args);
};
function convertToString(data) {
    if (typeof data === "string") {
        return Buffer.from(data, "base64").toString("utf-8");
    }
    if (data instanceof Uint8Array) {
        return new TextDecoder().decode(data);
    }
    if (data instanceof URL) {
        throw new import_provider23.UnsupportedFunctionalityError({
            functionality: "URL-based text documents are not supported for citations"
        });
    }
    throw new import_provider23.UnsupportedFunctionalityError({
        functionality: `unsupported data type for text documents: ${typeof data}`
    });
}
function convertToAnthropicMessagesPrompt(_0) {
    return __async(this, arguments, function*({ prompt, sendReasoning, warnings, cacheControlValidator }) {
        var _a, _b, _c, _d, _e;
        const betas = /* @__PURE__ */ new Set();
        const blocks = groupIntoBlocks(prompt);
        const validator2 = cacheControlValidator || new CacheControlValidator();
        let system = void 0;
        const messages = [];
        function shouldEnableCitations(providerMetadata) {
            return __async(this, null, function*() {
                var _a2, _b2;
                const anthropicOptions = yield parseProviderOptions({
                    provider: "anthropic",
                    providerOptions: providerMetadata,
                    schema: anthropicFilePartProviderOptions
                });
                return (_b2 = (_a2 = anthropicOptions == null ? void 0 : anthropicOptions.citations) == null ? void 0 : _a2.enabled) != null ? _b2 : false;
            });
        }
        function getDocumentMetadata(providerMetadata) {
            return __async(this, null, function*() {
                const anthropicOptions = yield parseProviderOptions({
                    provider: "anthropic",
                    providerOptions: providerMetadata,
                    schema: anthropicFilePartProviderOptions
                });
                return {
                    title: anthropicOptions == null ? void 0 : anthropicOptions.title,
                    context: anthropicOptions == null ? void 0 : anthropicOptions.context
                };
            });
        }
        for(let i = 0; i < blocks.length; i++){
            const block = blocks[i];
            const isLastBlock = i === blocks.length - 1;
            const type = block.type;
            switch(type){
                case "system":
                    {
                        if (system != null) {
                            throw new import_provider23.UnsupportedFunctionalityError({
                                functionality: "Multiple system messages that are separated by user/assistant messages"
                            });
                        }
                        system = block.messages.map(({ content, providerOptions })=>({
                                type: "text",
                                text: content,
                                cache_control: validator2.getCacheControl(providerOptions, {
                                    type: "system message",
                                    canCache: true
                                })
                            }));
                        break;
                    }
                case "user":
                    {
                        const anthropicContent = [];
                        for (const message of block.messages){
                            const { role, content } = message;
                            switch(role){
                                case "user":
                                    {
                                        for(let j = 0; j < content.length; j++){
                                            const part = content[j];
                                            const isLastPart = j === content.length - 1;
                                            const cacheControl = (_a = validator2.getCacheControl(part.providerOptions, {
                                                type: "user message part",
                                                canCache: true
                                            })) != null ? _a : isLastPart ? validator2.getCacheControl(message.providerOptions, {
                                                type: "user message",
                                                canCache: true
                                            }) : void 0;
                                            switch(part.type){
                                                case "text":
                                                    {
                                                        anthropicContent.push({
                                                            type: "text",
                                                            text: part.text,
                                                            cache_control: cacheControl
                                                        });
                                                        break;
                                                    }
                                                case "file":
                                                    {
                                                        if (part.mediaType.startsWith("image/")) {
                                                            anthropicContent.push({
                                                                type: "image",
                                                                source: part.data instanceof URL ? {
                                                                    type: "url",
                                                                    url: part.data.toString()
                                                                } : {
                                                                    type: "base64",
                                                                    media_type: part.mediaType === "image/*" ? "image/jpeg" : part.mediaType,
                                                                    data: convertToBase64(part.data)
                                                                },
                                                                cache_control: cacheControl
                                                            });
                                                        } else if (part.mediaType === "application/pdf") {
                                                            betas.add("pdfs-2024-09-25");
                                                            const enableCitations = yield shouldEnableCitations(part.providerOptions);
                                                            const metadata = yield getDocumentMetadata(part.providerOptions);
                                                            anthropicContent.push(__spreadProps(__spreadValues(__spreadValues({
                                                                type: "document",
                                                                source: part.data instanceof URL ? {
                                                                    type: "url",
                                                                    url: part.data.toString()
                                                                } : {
                                                                    type: "base64",
                                                                    media_type: "application/pdf",
                                                                    data: convertToBase64(part.data)
                                                                },
                                                                title: (_b = metadata.title) != null ? _b : part.filename
                                                            }, metadata.context && {
                                                                context: metadata.context
                                                            }), enableCitations && {
                                                                citations: {
                                                                    enabled: true
                                                                }
                                                            }), {
                                                                cache_control: cacheControl
                                                            }));
                                                        } else if (part.mediaType === "text/plain") {
                                                            const enableCitations = yield shouldEnableCitations(part.providerOptions);
                                                            const metadata = yield getDocumentMetadata(part.providerOptions);
                                                            anthropicContent.push(__spreadProps(__spreadValues(__spreadValues({
                                                                type: "document",
                                                                source: part.data instanceof URL ? {
                                                                    type: "url",
                                                                    url: part.data.toString()
                                                                } : {
                                                                    type: "text",
                                                                    media_type: "text/plain",
                                                                    data: convertToString(part.data)
                                                                },
                                                                title: (_c = metadata.title) != null ? _c : part.filename
                                                            }, metadata.context && {
                                                                context: metadata.context
                                                            }), enableCitations && {
                                                                citations: {
                                                                    enabled: true
                                                                }
                                                            }), {
                                                                cache_control: cacheControl
                                                            }));
                                                        } else {
                                                            throw new import_provider23.UnsupportedFunctionalityError({
                                                                functionality: `media type: ${part.mediaType}`
                                                            });
                                                        }
                                                        break;
                                                    }
                                            }
                                        }
                                        break;
                                    }
                                case "tool":
                                    {
                                        for(let i2 = 0; i2 < content.length; i2++){
                                            const part = content[i2];
                                            const isLastPart = i2 === content.length - 1;
                                            const cacheControl = (_d = validator2.getCacheControl(part.providerOptions, {
                                                type: "tool result part",
                                                canCache: true
                                            })) != null ? _d : isLastPart ? validator2.getCacheControl(message.providerOptions, {
                                                type: "tool result message",
                                                canCache: true
                                            }) : void 0;
                                            const output = part.output;
                                            let contentValue;
                                            switch(output.type){
                                                case "content":
                                                    contentValue = output.value.map((contentPart)=>{
                                                        switch(contentPart.type){
                                                            case "text":
                                                                return {
                                                                    type: "text",
                                                                    text: contentPart.text
                                                                };
                                                            case "media":
                                                                {
                                                                    if (contentPart.mediaType.startsWith("image/")) {
                                                                        return {
                                                                            type: "image",
                                                                            source: {
                                                                                type: "base64",
                                                                                media_type: contentPart.mediaType,
                                                                                data: contentPart.data
                                                                            }
                                                                        };
                                                                    }
                                                                    if (contentPart.mediaType === "application/pdf") {
                                                                        betas.add("pdfs-2024-09-25");
                                                                        return {
                                                                            type: "document",
                                                                            source: {
                                                                                type: "base64",
                                                                                media_type: contentPart.mediaType,
                                                                                data: contentPart.data
                                                                            }
                                                                        };
                                                                    }
                                                                    throw new import_provider23.UnsupportedFunctionalityError({
                                                                        functionality: `media type: ${contentPart.mediaType}`
                                                                    });
                                                                }
                                                        }
                                                    });
                                                    break;
                                                case "text":
                                                case "error-text":
                                                    contentValue = output.value;
                                                    break;
                                                case "json":
                                                case "error-json":
                                                default:
                                                    contentValue = JSON.stringify(output.value);
                                                    break;
                                            }
                                            anthropicContent.push({
                                                type: "tool_result",
                                                tool_use_id: part.toolCallId,
                                                content: contentValue,
                                                is_error: output.type === "error-text" || output.type === "error-json" ? true : void 0,
                                                cache_control: cacheControl
                                            });
                                        }
                                        break;
                                    }
                                default:
                                    {
                                        const _exhaustiveCheck = role;
                                        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
                                    }
                            }
                        }
                        messages.push({
                            role: "user",
                            content: anthropicContent
                        });
                        break;
                    }
                case "assistant":
                    {
                        const anthropicContent = [];
                        for(let j = 0; j < block.messages.length; j++){
                            const message = block.messages[j];
                            const isLastMessage = j === block.messages.length - 1;
                            const { content } = message;
                            for(let k = 0; k < content.length; k++){
                                const part = content[k];
                                const isLastContentPart = k === content.length - 1;
                                const cacheControl = (_e = validator2.getCacheControl(part.providerOptions, {
                                    type: "assistant message part",
                                    canCache: true
                                })) != null ? _e : isLastContentPart ? validator2.getCacheControl(message.providerOptions, {
                                    type: "assistant message",
                                    canCache: true
                                }) : void 0;
                                switch(part.type){
                                    case "text":
                                        {
                                            anthropicContent.push({
                                                type: "text",
                                                text: // trim the last text part if it's the last message in the block
                                                // because Anthropic does not allow trailing whitespace
                                                // in pre-filled assistant responses
                                                isLastBlock && isLastMessage && isLastContentPart ? part.text.trim() : part.text,
                                                cache_control: cacheControl
                                            });
                                            break;
                                        }
                                    case "reasoning":
                                        {
                                            if (sendReasoning) {
                                                const reasoningMetadata = yield parseProviderOptions({
                                                    provider: "anthropic",
                                                    providerOptions: part.providerOptions,
                                                    schema: anthropicReasoningMetadataSchema
                                                });
                                                if (reasoningMetadata != null) {
                                                    if (reasoningMetadata.signature != null) {
                                                        validator2.getCacheControl(part.providerOptions, {
                                                            type: "thinking block",
                                                            canCache: false
                                                        });
                                                        anthropicContent.push({
                                                            type: "thinking",
                                                            thinking: part.text,
                                                            signature: reasoningMetadata.signature
                                                        });
                                                    } else if (reasoningMetadata.redactedData != null) {
                                                        validator2.getCacheControl(part.providerOptions, {
                                                            type: "redacted thinking block",
                                                            canCache: false
                                                        });
                                                        anthropicContent.push({
                                                            type: "redacted_thinking",
                                                            data: reasoningMetadata.redactedData
                                                        });
                                                    } else {
                                                        warnings.push({
                                                            type: "other",
                                                            message: "unsupported reasoning metadata"
                                                        });
                                                    }
                                                } else {
                                                    warnings.push({
                                                        type: "other",
                                                        message: "unsupported reasoning metadata"
                                                    });
                                                }
                                            } else {
                                                warnings.push({
                                                    type: "other",
                                                    message: "sending reasoning content is disabled for this model"
                                                });
                                            }
                                            break;
                                        }
                                    case "tool-call":
                                        {
                                            if (part.providerExecuted) {
                                                if (part.toolName === "code_execution" && part.input != null && typeof part.input === "object" && "type" in part.input && typeof part.input.type === "string" && (part.input.type === "bash_code_execution" || part.input.type === "text_editor_code_execution")) {
                                                    anthropicContent.push({
                                                        type: "server_tool_use",
                                                        id: part.toolCallId,
                                                        name: part.input.type,
                                                        // map back to subtool name
                                                        input: part.input,
                                                        cache_control: cacheControl
                                                    });
                                                } else if (part.toolName === "code_execution" || // code execution 20250522
                                                part.toolName === "web_fetch" || part.toolName === "web_search") {
                                                    anthropicContent.push({
                                                        type: "server_tool_use",
                                                        id: part.toolCallId,
                                                        name: part.toolName,
                                                        input: part.input,
                                                        cache_control: cacheControl
                                                    });
                                                } else {
                                                    warnings.push({
                                                        type: "other",
                                                        message: `provider executed tool call for tool ${part.toolName} is not supported`
                                                    });
                                                }
                                                break;
                                            }
                                            anthropicContent.push({
                                                type: "tool_use",
                                                id: part.toolCallId,
                                                name: part.toolName,
                                                input: part.input,
                                                cache_control: cacheControl
                                            });
                                            break;
                                        }
                                    case "tool-result":
                                        {
                                            if (part.toolName === "code_execution") {
                                                const output = part.output;
                                                if (output.type !== "json") {
                                                    warnings.push({
                                                        type: "other",
                                                        message: `provider executed tool result output type ${output.type} for tool ${part.toolName} is not supported`
                                                    });
                                                    break;
                                                }
                                                if (output.value == null || typeof output.value !== "object" || !("type" in output.value) || typeof output.value.type !== "string") {
                                                    warnings.push({
                                                        type: "other",
                                                        message: `provider executed tool result output value is not a valid code execution result for tool ${part.toolName}`
                                                    });
                                                    break;
                                                }
                                                if (output.value.type === "code_execution_result") {
                                                    const codeExecutionOutput = yield validateTypes({
                                                        value: output.value,
                                                        schema: codeExecution_20250522OutputSchema
                                                    });
                                                    anthropicContent.push({
                                                        type: "code_execution_tool_result",
                                                        tool_use_id: part.toolCallId,
                                                        content: {
                                                            type: codeExecutionOutput.type,
                                                            stdout: codeExecutionOutput.stdout,
                                                            stderr: codeExecutionOutput.stderr,
                                                            return_code: codeExecutionOutput.return_code
                                                        },
                                                        cache_control: cacheControl
                                                    });
                                                } else {
                                                    const codeExecutionOutput = yield validateTypes({
                                                        value: output.value,
                                                        schema: codeExecution_20250825OutputSchema
                                                    });
                                                    anthropicContent.push(codeExecutionOutput.type === "bash_code_execution_result" || codeExecutionOutput.type === "bash_code_execution_tool_result_error" ? {
                                                        type: "bash_code_execution_tool_result",
                                                        tool_use_id: part.toolCallId,
                                                        cache_control: cacheControl,
                                                        content: codeExecutionOutput
                                                    } : {
                                                        type: "text_editor_code_execution_tool_result",
                                                        tool_use_id: part.toolCallId,
                                                        cache_control: cacheControl,
                                                        content: codeExecutionOutput
                                                    });
                                                }
                                                break;
                                            }
                                            if (part.toolName === "web_fetch") {
                                                const output = part.output;
                                                if (output.type !== "json") {
                                                    warnings.push({
                                                        type: "other",
                                                        message: `provider executed tool result output type ${output.type} for tool ${part.toolName} is not supported`
                                                    });
                                                    break;
                                                }
                                                const webFetchOutput = yield validateTypes({
                                                    value: output.value,
                                                    schema: webFetch_20250910OutputSchema
                                                });
                                                anthropicContent.push({
                                                    type: "web_fetch_tool_result",
                                                    tool_use_id: part.toolCallId,
                                                    content: {
                                                        type: "web_fetch_result",
                                                        url: webFetchOutput.url,
                                                        retrieved_at: webFetchOutput.retrievedAt,
                                                        content: {
                                                            type: "document",
                                                            title: webFetchOutput.content.title,
                                                            citations: webFetchOutput.content.citations,
                                                            source: {
                                                                type: webFetchOutput.content.source.type,
                                                                media_type: webFetchOutput.content.source.mediaType,
                                                                data: webFetchOutput.content.source.data
                                                            }
                                                        }
                                                    },
                                                    cache_control: cacheControl
                                                });
                                                break;
                                            }
                                            if (part.toolName === "web_search") {
                                                const output = part.output;
                                                if (output.type !== "json") {
                                                    warnings.push({
                                                        type: "other",
                                                        message: `provider executed tool result output type ${output.type} for tool ${part.toolName} is not supported`
                                                    });
                                                    break;
                                                }
                                                const webSearchOutput = yield validateTypes({
                                                    value: output.value,
                                                    schema: webSearch_20250305OutputSchema
                                                });
                                                anthropicContent.push({
                                                    type: "web_search_tool_result",
                                                    tool_use_id: part.toolCallId,
                                                    content: webSearchOutput.map((result)=>({
                                                            url: result.url,
                                                            title: result.title,
                                                            page_age: result.pageAge,
                                                            encrypted_content: result.encryptedContent,
                                                            type: result.type
                                                        })),
                                                    cache_control: cacheControl
                                                });
                                                break;
                                            }
                                            warnings.push({
                                                type: "other",
                                                message: `provider executed tool result for tool ${part.toolName} is not supported`
                                            });
                                            break;
                                        }
                                }
                            }
                        }
                        messages.push({
                            role: "assistant",
                            content: anthropicContent
                        });
                        break;
                    }
                default:
                    {
                        const _exhaustiveCheck = type;
                        throw new Error(`content type: ${_exhaustiveCheck}`);
                    }
            }
        }
        return {
            prompt: {
                system,
                messages
            },
            betas
        };
    });
}
function groupIntoBlocks(prompt) {
    const blocks = [];
    let currentBlock = void 0;
    for (const message of prompt){
        const { role } = message;
        switch(role){
            case "system":
                {
                    if ((currentBlock == null ? void 0 : currentBlock.type) !== "system") {
                        currentBlock = {
                            type: "system",
                            messages: []
                        };
                        blocks.push(currentBlock);
                    }
                    currentBlock.messages.push(message);
                    break;
                }
            case "assistant":
                {
                    if ((currentBlock == null ? void 0 : currentBlock.type) !== "assistant") {
                        currentBlock = {
                            type: "assistant",
                            messages: []
                        };
                        blocks.push(currentBlock);
                    }
                    currentBlock.messages.push(message);
                    break;
                }
            case "user":
                {
                    if ((currentBlock == null ? void 0 : currentBlock.type) !== "user") {
                        currentBlock = {
                            type: "user",
                            messages: []
                        };
                        blocks.push(currentBlock);
                    }
                    currentBlock.messages.push(message);
                    break;
                }
            case "tool":
                {
                    if ((currentBlock == null ? void 0 : currentBlock.type) !== "user") {
                        currentBlock = {
                            type: "user",
                            messages: []
                        };
                        blocks.push(currentBlock);
                    }
                    currentBlock.messages.push(message);
                    break;
                }
            default:
                {
                    const _exhaustiveCheck = role;
                    throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
                }
        }
    }
    return blocks;
}
function mapAnthropicStopReason({ finishReason, isJsonResponseFromTool }) {
    switch(finishReason){
        case "pause_turn":
        case "end_turn":
        case "stop_sequence":
            return "stop";
        case "refusal":
            return "content-filter";
        case "tool_use":
            return isJsonResponseFromTool ? "stop" : "tool-calls";
        case "max_tokens":
            return "length";
        default:
            return "unknown";
    }
}
function createCitationSource(citation, citationDocuments, generateId3) {
    var _a;
    if (citation.type !== "page_location" && citation.type !== "char_location") {
        return;
    }
    const documentInfo = citationDocuments[citation.document_index];
    if (!documentInfo) {
        return;
    }
    return {
        type: "source",
        sourceType: "document",
        id: generateId3(),
        mediaType: documentInfo.mediaType,
        title: (_a = citation.document_title) != null ? _a : documentInfo.title,
        filename: documentInfo.filename,
        providerMetadata: {
            anthropic: citation.type === "page_location" ? {
                citedText: citation.cited_text,
                startPageNumber: citation.start_page_number,
                endPageNumber: citation.end_page_number
            } : {
                citedText: citation.cited_text,
                startCharIndex: citation.start_char_index,
                endCharIndex: citation.end_char_index
            }
        }
    };
}
var AnthropicMessagesLanguageModel = class {
    constructor(modelId, config){
        this.specificationVersion = "v2";
        var _a;
        this.modelId = modelId;
        this.config = config;
        this.generateId = (_a = config.generateId) != null ? _a : generateId;
    }
    supportsUrl(url) {
        return url.protocol === "https:";
    }
    get provider() {
        return this.config.provider;
    }
    get supportedUrls() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.config).supportedUrls) == null ? void 0 : _b.call(_a)) != null ? _c : {};
    }
    getArgs(_0) {
        return __async(this, arguments, function*({ prompt, maxOutputTokens, temperature, topP, topK, frequencyPenalty, presencePenalty, stopSequences, responseFormat, seed, tools, toolChoice, providerOptions }) {
            var _a, _b, _c, _d;
            const warnings = [];
            if (frequencyPenalty != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "frequencyPenalty"
                });
            }
            if (presencePenalty != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "presencePenalty"
                });
            }
            if (seed != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "seed"
                });
            }
            if ((responseFormat == null ? void 0 : responseFormat.type) === "json") {
                if (responseFormat.schema == null) {
                    warnings.push({
                        type: "unsupported-setting",
                        setting: "responseFormat",
                        details: "JSON response format requires a schema. The response format is ignored."
                    });
                } else if (tools != null) {
                    warnings.push({
                        type: "unsupported-setting",
                        setting: "tools",
                        details: "JSON response format does not support tools. The provided tools are ignored."
                    });
                }
            }
            const jsonResponseTool = (responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null ? {
                type: "function",
                name: "json",
                description: "Respond with a JSON object.",
                inputSchema: responseFormat.schema
            } : void 0;
            const anthropicOptions = yield parseProviderOptions({
                provider: "anthropic",
                providerOptions,
                schema: anthropicProviderOptions
            });
            const cacheControlValidator = new CacheControlValidator();
            const { prompt: messagesPrompt, betas } = yield convertToAnthropicMessagesPrompt({
                prompt,
                sendReasoning: (_a = anthropicOptions == null ? void 0 : anthropicOptions.sendReasoning) != null ? _a : true,
                warnings,
                cacheControlValidator
            });
            const isThinking = ((_b = anthropicOptions == null ? void 0 : anthropicOptions.thinking) == null ? void 0 : _b.type) === "enabled";
            const thinkingBudget = (_c = anthropicOptions == null ? void 0 : anthropicOptions.thinking) == null ? void 0 : _c.budgetTokens;
            const maxOutputTokensForModel = getMaxOutputTokensForModel(this.modelId);
            const maxTokens = maxOutputTokens != null ? maxOutputTokens : maxOutputTokensForModel;
            const baseArgs = __spreadProps(__spreadValues(__spreadValues({
                // model id:
                model: this.modelId,
                // standardized settings:
                max_tokens: maxTokens,
                temperature,
                top_k: topK,
                top_p: topP,
                stop_sequences: stopSequences
            }, isThinking && {
                thinking: {
                    type: "enabled",
                    budget_tokens: thinkingBudget
                }
            }), (anthropicOptions == null ? void 0 : anthropicOptions.container) && {
                container: {
                    id: anthropicOptions.container.id,
                    skills: (_d = anthropicOptions.container.skills) == null ? void 0 : _d.map((skill)=>({
                            type: skill.type,
                            skill_id: skill.skillId,
                            version: skill.version
                        }))
                }
            }), {
                // prompt:
                system: messagesPrompt.system,
                messages: messagesPrompt.messages
            });
            if (isThinking) {
                if (thinkingBudget == null) {
                    throw new import_provider21.UnsupportedFunctionalityError({
                        functionality: "thinking requires a budget"
                    });
                }
                if (baseArgs.temperature != null) {
                    baseArgs.temperature = void 0;
                    warnings.push({
                        type: "unsupported-setting",
                        setting: "temperature",
                        details: "temperature is not supported when thinking is enabled"
                    });
                }
                if (topK != null) {
                    baseArgs.top_k = void 0;
                    warnings.push({
                        type: "unsupported-setting",
                        setting: "topK",
                        details: "topK is not supported when thinking is enabled"
                    });
                }
                if (topP != null) {
                    baseArgs.top_p = void 0;
                    warnings.push({
                        type: "unsupported-setting",
                        setting: "topP",
                        details: "topP is not supported when thinking is enabled"
                    });
                }
                baseArgs.max_tokens = maxTokens + thinkingBudget;
            }
            if (baseArgs.max_tokens > maxOutputTokensForModel) {
                if (maxOutputTokens != null) {
                    warnings.push({
                        type: "unsupported-setting",
                        setting: "maxOutputTokens",
                        details: `${baseArgs.max_tokens} (maxOutputTokens + thinkingBudget) is greater than ${this.modelId} ${maxOutputTokensForModel} max output tokens. The max output tokens have been limited to ${maxOutputTokensForModel}.`
                    });
                }
                baseArgs.max_tokens = maxOutputTokensForModel;
            }
            if ((anthropicOptions == null ? void 0 : anthropicOptions.container) && anthropicOptions.container.skills && anthropicOptions.container.skills.length > 0) {
                betas.add("code-execution-2025-08-25");
                betas.add("skills-2025-10-02");
                betas.add("files-api-2025-04-14");
                if (!(tools == null ? void 0 : tools.some((tool12)=>tool12.type === "provider-defined" && tool12.id === "anthropic.code_execution_20250825"))) {
                    warnings.push({
                        type: "other",
                        message: "code execution tool is required when using skills"
                    });
                }
            }
            const { tools: anthropicTools2, toolChoice: anthropicToolChoice, toolWarnings, betas: toolsBetas } = yield prepareTools(jsonResponseTool != null ? {
                tools: [
                    jsonResponseTool
                ],
                toolChoice: {
                    type: "tool",
                    toolName: jsonResponseTool.name
                },
                disableParallelToolUse: true,
                cacheControlValidator
            } : {
                tools: tools != null ? tools : [],
                toolChoice,
                disableParallelToolUse: anthropicOptions == null ? void 0 : anthropicOptions.disableParallelToolUse,
                cacheControlValidator
            });
            const cacheWarnings = cacheControlValidator.getWarnings();
            return {
                args: __spreadProps(__spreadValues({}, baseArgs), {
                    tools: anthropicTools2,
                    tool_choice: anthropicToolChoice
                }),
                warnings: [
                    ...warnings,
                    ...toolWarnings,
                    ...cacheWarnings
                ],
                betas: /* @__PURE__ */ new Set([
                    ...betas,
                    ...toolsBetas
                ]),
                usesJsonResponseTool: jsonResponseTool != null
            };
        });
    }
    getHeaders(_0) {
        return __async(this, arguments, function*({ betas, headers }) {
            return combineHeaders((yield resolve(this.config.headers)), betas.size > 0 ? {
                "anthropic-beta": Array.from(betas).join(",")
            } : {}, headers);
        });
    }
    buildRequestUrl(isStreaming) {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.config).buildRequestUrl) == null ? void 0 : _b.call(_a, this.config.baseURL, isStreaming)) != null ? _c : `${this.config.baseURL}/messages`;
    }
    transformRequestBody(args) {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.config).transformRequestBody) == null ? void 0 : _b.call(_a, args)) != null ? _c : args;
    }
    extractCitationDocuments(prompt) {
        const isCitationPart = (part)=>{
            var _a, _b;
            if (part.type !== "file") {
                return false;
            }
            if (part.mediaType !== "application/pdf" && part.mediaType !== "text/plain") {
                return false;
            }
            const anthropic2 = (_a = part.providerOptions) == null ? void 0 : _a.anthropic;
            const citationsConfig = anthropic2 == null ? void 0 : anthropic2.citations;
            return (_b = citationsConfig == null ? void 0 : citationsConfig.enabled) != null ? _b : false;
        };
        return prompt.filter((message)=>message.role === "user").flatMap((message)=>message.content).filter(isCitationPart).map((part)=>{
            var _a;
            const filePart = part;
            return {
                title: (_a = filePart.filename) != null ? _a : "Untitled Document",
                filename: filePart.filename,
                mediaType: filePart.mediaType
            };
        });
    }
    doGenerate(options) {
        return __async(this, null, function*() {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            const { args, warnings, betas, usesJsonResponseTool } = yield this.getArgs(options);
            const citationDocuments = this.extractCitationDocuments(options.prompt);
            const { responseHeaders, value: response, rawValue: rawResponse } = yield postJsonToApi({
                url: this.buildRequestUrl(false),
                headers: yield this.getHeaders({
                    betas,
                    headers: options.headers
                }),
                body: this.transformRequestBody(args),
                failedResponseHandler: anthropicFailedResponseHandler,
                successfulResponseHandler: createJsonResponseHandler(anthropicMessagesResponseSchema),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            const content = [];
            for (const part of response.content){
                switch(part.type){
                    case "text":
                        {
                            if (!usesJsonResponseTool) {
                                content.push({
                                    type: "text",
                                    text: part.text
                                });
                                if (part.citations) {
                                    for (const citation of part.citations){
                                        const source = createCitationSource(citation, citationDocuments, this.generateId);
                                        if (source) {
                                            content.push(source);
                                        }
                                    }
                                }
                            }
                            break;
                        }
                    case "thinking":
                        {
                            content.push({
                                type: "reasoning",
                                text: part.thinking,
                                providerMetadata: {
                                    anthropic: {
                                        signature: part.signature
                                    }
                                }
                            });
                            break;
                        }
                    case "redacted_thinking":
                        {
                            content.push({
                                type: "reasoning",
                                text: "",
                                providerMetadata: {
                                    anthropic: {
                                        redactedData: part.data
                                    }
                                }
                            });
                            break;
                        }
                    case "tool_use":
                        {
                            content.push(// when a json response tool is used, the tool call becomes the text:
                            usesJsonResponseTool ? {
                                type: "text",
                                text: JSON.stringify(part.input)
                            } : {
                                type: "tool-call",
                                toolCallId: part.id,
                                toolName: part.name,
                                input: JSON.stringify(part.input)
                            });
                            break;
                        }
                    case "server_tool_use":
                        {
                            if (part.name === "text_editor_code_execution" || part.name === "bash_code_execution") {
                                content.push({
                                    type: "tool-call",
                                    toolCallId: part.id,
                                    toolName: "code_execution",
                                    input: JSON.stringify(__spreadValues({
                                        type: part.name
                                    }, part.input)),
                                    providerExecuted: true
                                });
                            } else if (part.name === "web_search" || part.name === "code_execution" || part.name === "web_fetch") {
                                content.push({
                                    type: "tool-call",
                                    toolCallId: part.id,
                                    toolName: part.name,
                                    input: JSON.stringify(part.input),
                                    providerExecuted: true
                                });
                            }
                            break;
                        }
                    case "web_fetch_tool_result":
                        {
                            if (part.content.type === "web_fetch_result") {
                                content.push({
                                    type: "tool-result",
                                    toolCallId: part.tool_use_id,
                                    toolName: "web_fetch",
                                    result: {
                                        type: "web_fetch_result",
                                        url: part.content.url,
                                        retrievedAt: part.content.retrieved_at,
                                        content: {
                                            type: part.content.content.type,
                                            title: part.content.content.title,
                                            citations: part.content.content.citations,
                                            source: {
                                                type: part.content.content.source.type,
                                                mediaType: part.content.content.source.media_type,
                                                data: part.content.content.source.data
                                            }
                                        }
                                    },
                                    providerExecuted: true
                                });
                            } else if (part.content.type === "web_fetch_tool_result_error") {
                                content.push({
                                    type: "tool-result",
                                    toolCallId: part.tool_use_id,
                                    toolName: "web_fetch",
                                    isError: true,
                                    result: {
                                        type: "web_fetch_tool_result_error",
                                        errorCode: part.content.error_code
                                    },
                                    providerExecuted: true
                                });
                            }
                            break;
                        }
                    case "web_search_tool_result":
                        {
                            if (Array.isArray(part.content)) {
                                content.push({
                                    type: "tool-result",
                                    toolCallId: part.tool_use_id,
                                    toolName: "web_search",
                                    result: part.content.map((result)=>{
                                        var _a2;
                                        return {
                                            url: result.url,
                                            title: result.title,
                                            pageAge: (_a2 = result.page_age) != null ? _a2 : null,
                                            encryptedContent: result.encrypted_content,
                                            type: result.type
                                        };
                                    }),
                                    providerExecuted: true
                                });
                                for (const result of part.content){
                                    content.push({
                                        type: "source",
                                        sourceType: "url",
                                        id: this.generateId(),
                                        url: result.url,
                                        title: result.title,
                                        providerMetadata: {
                                            anthropic: {
                                                pageAge: (_a = result.page_age) != null ? _a : null
                                            }
                                        }
                                    });
                                }
                            } else {
                                content.push({
                                    type: "tool-result",
                                    toolCallId: part.tool_use_id,
                                    toolName: "web_search",
                                    isError: true,
                                    result: {
                                        type: "web_search_tool_result_error",
                                        errorCode: part.content.error_code
                                    },
                                    providerExecuted: true
                                });
                            }
                            break;
                        }
                    // code execution 20250522:
                    case "code_execution_tool_result":
                        {
                            if (part.content.type === "code_execution_result") {
                                content.push({
                                    type: "tool-result",
                                    toolCallId: part.tool_use_id,
                                    toolName: "code_execution",
                                    result: {
                                        type: part.content.type,
                                        stdout: part.content.stdout,
                                        stderr: part.content.stderr,
                                        return_code: part.content.return_code
                                    },
                                    providerExecuted: true
                                });
                            } else if (part.content.type === "code_execution_tool_result_error") {
                                content.push({
                                    type: "tool-result",
                                    toolCallId: part.tool_use_id,
                                    toolName: "code_execution",
                                    isError: true,
                                    result: {
                                        type: "code_execution_tool_result_error",
                                        errorCode: part.content.error_code
                                    },
                                    providerExecuted: true
                                });
                            }
                            break;
                        }
                    // code execution 20250825:
                    case "bash_code_execution_tool_result":
                    case "text_editor_code_execution_tool_result":
                        {
                            content.push({
                                type: "tool-result",
                                toolCallId: part.tool_use_id,
                                toolName: "code_execution",
                                result: part.content,
                                providerExecuted: true
                            });
                            break;
                        }
                }
            }
            return {
                content,
                finishReason: mapAnthropicStopReason({
                    finishReason: response.stop_reason,
                    isJsonResponseFromTool: usesJsonResponseTool
                }),
                usage: {
                    inputTokens: response.usage.input_tokens,
                    outputTokens: response.usage.output_tokens,
                    totalTokens: response.usage.input_tokens + response.usage.output_tokens,
                    cachedInputTokens: (_b = response.usage.cache_read_input_tokens) != null ? _b : void 0
                },
                request: {
                    body: args
                },
                response: {
                    id: (_c = response.id) != null ? _c : void 0,
                    modelId: (_d = response.model) != null ? _d : void 0,
                    headers: responseHeaders,
                    body: rawResponse
                },
                warnings,
                providerMetadata: {
                    anthropic: {
                        usage: response.usage,
                        cacheCreationInputTokens: (_e = response.usage.cache_creation_input_tokens) != null ? _e : null,
                        stopSequence: (_f = response.stop_sequence) != null ? _f : null,
                        container: response.container ? {
                            expiresAt: response.container.expires_at,
                            id: response.container.id,
                            skills: (_h = (_g = response.container.skills) == null ? void 0 : _g.map((skill)=>({
                                    type: skill.type,
                                    skillId: skill.skill_id,
                                    version: skill.version
                                }))) != null ? _h : null
                        } : null
                    }
                }
            };
        });
    }
    doStream(options) {
        return __async(this, null, function*() {
            const { args, warnings, betas, usesJsonResponseTool } = yield this.getArgs(options);
            const citationDocuments = this.extractCitationDocuments(options.prompt);
            const body = __spreadProps(__spreadValues({}, args), {
                stream: true
            });
            const { responseHeaders, value: response } = yield postJsonToApi({
                url: this.buildRequestUrl(true),
                headers: yield this.getHeaders({
                    betas,
                    headers: options.headers
                }),
                body: this.transformRequestBody(body),
                failedResponseHandler: anthropicFailedResponseHandler,
                successfulResponseHandler: createEventSourceResponseHandler(anthropicMessagesChunkSchema),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            let finishReason = "unknown";
            const usage = {
                inputTokens: void 0,
                outputTokens: void 0,
                totalTokens: void 0
            };
            const contentBlocks = {};
            let rawUsage = void 0;
            let cacheCreationInputTokens = null;
            let stopSequence = null;
            let container = null;
            let blockType = void 0;
            const generateId3 = this.generateId;
            return {
                stream: response.pipeThrough(new TransformStream({
                    start (controller) {
                        controller.enqueue({
                            type: "stream-start",
                            warnings
                        });
                    },
                    transform (chunk, controller) {
                        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
                        if (options.includeRawChunks) {
                            controller.enqueue({
                                type: "raw",
                                rawValue: chunk.rawValue
                            });
                        }
                        if (!chunk.success) {
                            controller.enqueue({
                                type: "error",
                                error: chunk.error
                            });
                            return;
                        }
                        const value = chunk.value;
                        switch(value.type){
                            case "ping":
                                {
                                    return;
                                }
                            case "content_block_start":
                                {
                                    const contentBlockType = value.content_block.type;
                                    blockType = contentBlockType;
                                    switch(contentBlockType){
                                        case "text":
                                            {
                                                contentBlocks[value.index] = {
                                                    type: "text"
                                                };
                                                controller.enqueue({
                                                    type: "text-start",
                                                    id: String(value.index)
                                                });
                                                return;
                                            }
                                        case "thinking":
                                            {
                                                contentBlocks[value.index] = {
                                                    type: "reasoning"
                                                };
                                                controller.enqueue({
                                                    type: "reasoning-start",
                                                    id: String(value.index)
                                                });
                                                return;
                                            }
                                        case "redacted_thinking":
                                            {
                                                contentBlocks[value.index] = {
                                                    type: "reasoning"
                                                };
                                                controller.enqueue({
                                                    type: "reasoning-start",
                                                    id: String(value.index),
                                                    providerMetadata: {
                                                        anthropic: {
                                                            redactedData: value.content_block.data
                                                        }
                                                    }
                                                });
                                                return;
                                            }
                                        case "tool_use":
                                            {
                                                contentBlocks[value.index] = usesJsonResponseTool ? {
                                                    type: "text"
                                                } : {
                                                    type: "tool-call",
                                                    toolCallId: value.content_block.id,
                                                    toolName: value.content_block.name,
                                                    input: "",
                                                    firstDelta: true
                                                };
                                                controller.enqueue(usesJsonResponseTool ? {
                                                    type: "text-start",
                                                    id: String(value.index)
                                                } : {
                                                    type: "tool-input-start",
                                                    id: value.content_block.id,
                                                    toolName: value.content_block.name
                                                });
                                                return;
                                            }
                                        case "server_tool_use":
                                            {
                                                if ([
                                                    "web_fetch",
                                                    "web_search",
                                                    // code execution 20250825:
                                                    "code_execution",
                                                    // code execution 20250825 text editor:
                                                    "text_editor_code_execution",
                                                    // code execution 20250825 bash:
                                                    "bash_code_execution"
                                                ].includes(value.content_block.name)) {
                                                    contentBlocks[value.index] = {
                                                        type: "tool-call",
                                                        toolCallId: value.content_block.id,
                                                        toolName: value.content_block.name,
                                                        input: "",
                                                        providerExecuted: true,
                                                        firstDelta: true
                                                    };
                                                    const mappedToolName = value.content_block.name === "text_editor_code_execution" || value.content_block.name === "bash_code_execution" ? "code_execution" : value.content_block.name;
                                                    controller.enqueue({
                                                        type: "tool-input-start",
                                                        id: value.content_block.id,
                                                        toolName: mappedToolName,
                                                        providerExecuted: true
                                                    });
                                                }
                                                return;
                                            }
                                        case "web_fetch_tool_result":
                                            {
                                                const part = value.content_block;
                                                if (part.content.type === "web_fetch_result") {
                                                    controller.enqueue({
                                                        type: "tool-result",
                                                        toolCallId: part.tool_use_id,
                                                        toolName: "web_fetch",
                                                        result: {
                                                            type: "web_fetch_result",
                                                            url: part.content.url,
                                                            retrievedAt: part.content.retrieved_at,
                                                            content: {
                                                                type: part.content.content.type,
                                                                title: part.content.content.title,
                                                                citations: part.content.content.citations,
                                                                source: {
                                                                    type: part.content.content.source.type,
                                                                    mediaType: part.content.content.source.media_type,
                                                                    data: part.content.content.source.data
                                                                }
                                                            }
                                                        }
                                                    });
                                                } else if (part.content.type === "web_fetch_tool_result_error") {
                                                    controller.enqueue({
                                                        type: "tool-result",
                                                        toolCallId: part.tool_use_id,
                                                        toolName: "web_fetch",
                                                        isError: true,
                                                        result: {
                                                            type: "web_fetch_tool_result_error",
                                                            errorCode: part.content.error_code
                                                        },
                                                        providerExecuted: true
                                                    });
                                                }
                                                return;
                                            }
                                        case "web_search_tool_result":
                                            {
                                                const part = value.content_block;
                                                if (Array.isArray(part.content)) {
                                                    controller.enqueue({
                                                        type: "tool-result",
                                                        toolCallId: part.tool_use_id,
                                                        toolName: "web_search",
                                                        result: part.content.map((result)=>{
                                                            var _a2;
                                                            return {
                                                                url: result.url,
                                                                title: result.title,
                                                                pageAge: (_a2 = result.page_age) != null ? _a2 : null,
                                                                encryptedContent: result.encrypted_content,
                                                                type: result.type
                                                            };
                                                        }),
                                                        providerExecuted: true
                                                    });
                                                    for (const result of part.content){
                                                        controller.enqueue({
                                                            type: "source",
                                                            sourceType: "url",
                                                            id: generateId3(),
                                                            url: result.url,
                                                            title: result.title,
                                                            providerMetadata: {
                                                                anthropic: {
                                                                    pageAge: (_a = result.page_age) != null ? _a : null
                                                                }
                                                            }
                                                        });
                                                    }
                                                } else {
                                                    controller.enqueue({
                                                        type: "tool-result",
                                                        toolCallId: part.tool_use_id,
                                                        toolName: "web_search",
                                                        isError: true,
                                                        result: {
                                                            type: "web_search_tool_result_error",
                                                            errorCode: part.content.error_code
                                                        },
                                                        providerExecuted: true
                                                    });
                                                }
                                                return;
                                            }
                                        // code execution 20250522:
                                        case "code_execution_tool_result":
                                            {
                                                const part = value.content_block;
                                                if (part.content.type === "code_execution_result") {
                                                    controller.enqueue({
                                                        type: "tool-result",
                                                        toolCallId: part.tool_use_id,
                                                        toolName: "code_execution",
                                                        result: {
                                                            type: part.content.type,
                                                            stdout: part.content.stdout,
                                                            stderr: part.content.stderr,
                                                            return_code: part.content.return_code
                                                        },
                                                        providerExecuted: true
                                                    });
                                                } else if (part.content.type === "code_execution_tool_result_error") {
                                                    controller.enqueue({
                                                        type: "tool-result",
                                                        toolCallId: part.tool_use_id,
                                                        toolName: "code_execution",
                                                        isError: true,
                                                        result: {
                                                            type: "code_execution_tool_result_error",
                                                            errorCode: part.content.error_code
                                                        },
                                                        providerExecuted: true
                                                    });
                                                }
                                                return;
                                            }
                                        // code execution 20250825:
                                        case "bash_code_execution_tool_result":
                                        case "text_editor_code_execution_tool_result":
                                            {
                                                const part = value.content_block;
                                                controller.enqueue({
                                                    type: "tool-result",
                                                    toolCallId: part.tool_use_id,
                                                    toolName: "code_execution",
                                                    result: part.content,
                                                    providerExecuted: true
                                                });
                                                return;
                                            }
                                        default:
                                            {
                                                const _exhaustiveCheck = contentBlockType;
                                                throw new Error(`Unsupported content block type: ${_exhaustiveCheck}`);
                                            }
                                    }
                                }
                            case "content_block_stop":
                                {
                                    if (contentBlocks[value.index] != null) {
                                        const contentBlock = contentBlocks[value.index];
                                        switch(contentBlock.type){
                                            case "text":
                                                {
                                                    controller.enqueue({
                                                        type: "text-end",
                                                        id: String(value.index)
                                                    });
                                                    break;
                                                }
                                            case "reasoning":
                                                {
                                                    controller.enqueue({
                                                        type: "reasoning-end",
                                                        id: String(value.index)
                                                    });
                                                    break;
                                                }
                                            case "tool-call":
                                                if (!usesJsonResponseTool) {
                                                    controller.enqueue({
                                                        type: "tool-input-end",
                                                        id: contentBlock.toolCallId
                                                    });
                                                    const toolName = contentBlock.toolName === "text_editor_code_execution" || contentBlock.toolName === "bash_code_execution" ? "code_execution" : contentBlock.toolName;
                                                    controller.enqueue({
                                                        type: "tool-call",
                                                        toolCallId: contentBlock.toolCallId,
                                                        toolName,
                                                        input: contentBlock.input,
                                                        providerExecuted: contentBlock.providerExecuted
                                                    });
                                                }
                                                break;
                                        }
                                        delete contentBlocks[value.index];
                                    }
                                    blockType = void 0;
                                    return;
                                }
                            case "content_block_delta":
                                {
                                    const deltaType = value.delta.type;
                                    switch(deltaType){
                                        case "text_delta":
                                            {
                                                if (usesJsonResponseTool) {
                                                    return;
                                                }
                                                controller.enqueue({
                                                    type: "text-delta",
                                                    id: String(value.index),
                                                    delta: value.delta.text
                                                });
                                                return;
                                            }
                                        case "thinking_delta":
                                            {
                                                controller.enqueue({
                                                    type: "reasoning-delta",
                                                    id: String(value.index),
                                                    delta: value.delta.thinking
                                                });
                                                return;
                                            }
                                        case "signature_delta":
                                            {
                                                if (blockType === "thinking") {
                                                    controller.enqueue({
                                                        type: "reasoning-delta",
                                                        id: String(value.index),
                                                        delta: "",
                                                        providerMetadata: {
                                                            anthropic: {
                                                                signature: value.delta.signature
                                                            }
                                                        }
                                                    });
                                                }
                                                return;
                                            }
                                        case "input_json_delta":
                                            {
                                                const contentBlock = contentBlocks[value.index];
                                                let delta = value.delta.partial_json;
                                                if (delta.length === 0) {
                                                    return;
                                                }
                                                if (usesJsonResponseTool) {
                                                    if ((contentBlock == null ? void 0 : contentBlock.type) !== "text") {
                                                        return;
                                                    }
                                                    controller.enqueue({
                                                        type: "text-delta",
                                                        id: String(value.index),
                                                        delta
                                                    });
                                                } else {
                                                    if ((contentBlock == null ? void 0 : contentBlock.type) !== "tool-call") {
                                                        return;
                                                    }
                                                    if (contentBlock.firstDelta && (contentBlock.toolName === "bash_code_execution" || contentBlock.toolName === "text_editor_code_execution")) {
                                                        delta = `{"type": "${contentBlock.toolName}",${delta.substring(1)}`;
                                                    }
                                                    controller.enqueue({
                                                        type: "tool-input-delta",
                                                        id: contentBlock.toolCallId,
                                                        delta
                                                    });
                                                    contentBlock.input += delta;
                                                    contentBlock.firstDelta = false;
                                                }
                                                return;
                                            }
                                        case "citations_delta":
                                            {
                                                const citation = value.delta.citation;
                                                const source = createCitationSource(citation, citationDocuments, generateId3);
                                                if (source) {
                                                    controller.enqueue(source);
                                                }
                                                return;
                                            }
                                        default:
                                            {
                                                const _exhaustiveCheck = deltaType;
                                                throw new Error(`Unsupported delta type: ${_exhaustiveCheck}`);
                                            }
                                    }
                                }
                            case "message_start":
                                {
                                    usage.inputTokens = value.message.usage.input_tokens;
                                    usage.cachedInputTokens = (_b = value.message.usage.cache_read_input_tokens) != null ? _b : void 0;
                                    rawUsage = __spreadValues({}, value.message.usage);
                                    cacheCreationInputTokens = (_c = value.message.usage.cache_creation_input_tokens) != null ? _c : null;
                                    controller.enqueue({
                                        type: "response-metadata",
                                        id: (_d = value.message.id) != null ? _d : void 0,
                                        modelId: (_e = value.message.model) != null ? _e : void 0
                                    });
                                    return;
                                }
                            case "message_delta":
                                {
                                    usage.outputTokens = value.usage.output_tokens;
                                    usage.totalTokens = ((_f = usage.inputTokens) != null ? _f : 0) + ((_g = value.usage.output_tokens) != null ? _g : 0);
                                    finishReason = mapAnthropicStopReason({
                                        finishReason: value.delta.stop_reason,
                                        isJsonResponseFromTool: usesJsonResponseTool
                                    });
                                    stopSequence = (_h = value.delta.stop_sequence) != null ? _h : null;
                                    container = value.delta.container != null ? {
                                        expiresAt: value.delta.container.expires_at,
                                        id: value.delta.container.id,
                                        skills: (_j = (_i = value.delta.container.skills) == null ? void 0 : _i.map((skill)=>({
                                                type: skill.type,
                                                skillId: skill.skill_id,
                                                version: skill.version
                                            }))) != null ? _j : null
                                    } : null;
                                    rawUsage = __spreadValues(__spreadValues({}, rawUsage), value.usage);
                                    return;
                                }
                            case "message_stop":
                                {
                                    controller.enqueue({
                                        type: "finish",
                                        finishReason,
                                        usage,
                                        providerMetadata: {
                                            anthropic: {
                                                usage: rawUsage != null ? rawUsage : null,
                                                cacheCreationInputTokens,
                                                stopSequence,
                                                container
                                            }
                                        }
                                    });
                                    return;
                                }
                            case "error":
                                {
                                    controller.enqueue({
                                        type: "error",
                                        error: value.error
                                    });
                                    return;
                                }
                            default:
                                {
                                    const _exhaustiveCheck = value;
                                    throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);
                                }
                        }
                    }
                })),
                request: {
                    body
                },
                response: {
                    headers: responseHeaders
                }
            };
        });
    }
};
function getMaxOutputTokensForModel(modelId) {
    if (modelId.includes("claude-sonnet-4-") || modelId.includes("claude-3-7-sonnet") || modelId.includes("claude-haiku-4-5")) {
        return 64e3;
    } else if (modelId.includes("claude-opus-4-")) {
        return 32e3;
    } else if (modelId.includes("claude-3-5-haiku")) {
        return 8192;
    } else {
        return 4096;
    }
}
var bash_20241022InputSchema = lazySchema(()=>zodSchema(import_v429.z.object({
        command: import_v429.z.string(),
        restart: import_v429.z.boolean().optional()
    })));
var bash_20241022 = createProviderDefinedToolFactory({
    id: "anthropic.bash_20241022",
    name: "bash",
    inputSchema: bash_20241022InputSchema
});
var bash_20250124InputSchema = lazySchema(()=>zodSchema(import_v430.z.object({
        command: import_v430.z.string(),
        restart: import_v430.z.boolean().optional()
    })));
var bash_20250124 = createProviderDefinedToolFactory({
    id: "anthropic.bash_20250124",
    name: "bash",
    inputSchema: bash_20250124InputSchema
});
var computer_20241022InputSchema = lazySchema(()=>zodSchema(import_v431.z.object({
        action: import_v431.z.enum([
            "key",
            "type",
            "mouse_move",
            "left_click",
            "left_click_drag",
            "right_click",
            "middle_click",
            "double_click",
            "screenshot",
            "cursor_position"
        ]),
        coordinate: import_v431.z.array(import_v431.z.number().int()).optional(),
        text: import_v431.z.string().optional()
    })));
var computer_20241022 = createProviderDefinedToolFactory({
    id: "anthropic.computer_20241022",
    name: "computer",
    inputSchema: computer_20241022InputSchema
});
var computer_20250124InputSchema = lazySchema(()=>zodSchema(import_v432.z.object({
        action: import_v432.z.enum([
            "key",
            "hold_key",
            "type",
            "cursor_position",
            "mouse_move",
            "left_mouse_down",
            "left_mouse_up",
            "left_click",
            "left_click_drag",
            "right_click",
            "middle_click",
            "double_click",
            "triple_click",
            "scroll",
            "wait",
            "screenshot"
        ]),
        coordinate: import_v432.z.tuple([
            import_v432.z.number().int(),
            import_v432.z.number().int()
        ]).optional(),
        duration: import_v432.z.number().optional(),
        scroll_amount: import_v432.z.number().optional(),
        scroll_direction: import_v432.z.enum([
            "up",
            "down",
            "left",
            "right"
        ]).optional(),
        start_coordinate: import_v432.z.tuple([
            import_v432.z.number().int(),
            import_v432.z.number().int()
        ]).optional(),
        text: import_v432.z.string().optional()
    })));
var computer_20250124 = createProviderDefinedToolFactory({
    id: "anthropic.computer_20250124",
    name: "computer",
    inputSchema: computer_20250124InputSchema
});
var memory_20250818InputSchema = lazySchema(()=>zodSchema(import_v433.z.discriminatedUnion("command", [
        import_v433.z.object({
            command: import_v433.z.literal("view"),
            path: import_v433.z.string(),
            view_range: import_v433.z.tuple([
                import_v433.z.number(),
                import_v433.z.number()
            ]).optional()
        }),
        import_v433.z.object({
            command: import_v433.z.literal("create"),
            path: import_v433.z.string(),
            file_text: import_v433.z.string()
        }),
        import_v433.z.object({
            command: import_v433.z.literal("str_replace"),
            path: import_v433.z.string(),
            old_str: import_v433.z.string(),
            new_str: import_v433.z.string()
        }),
        import_v433.z.object({
            command: import_v433.z.literal("insert"),
            path: import_v433.z.string(),
            insert_line: import_v433.z.number(),
            insert_text: import_v433.z.string()
        }),
        import_v433.z.object({
            command: import_v433.z.literal("delete"),
            path: import_v433.z.string()
        }),
        import_v433.z.object({
            command: import_v433.z.literal("rename"),
            old_path: import_v433.z.string(),
            new_path: import_v433.z.string()
        })
    ])));
var memory_20250818 = createProviderDefinedToolFactory({
    id: "anthropic.memory_20250818",
    name: "memory",
    inputSchema: memory_20250818InputSchema
});
var textEditor_20241022InputSchema = lazySchema(()=>zodSchema(import_v434.z.object({
        command: import_v434.z.enum([
            "view",
            "create",
            "str_replace",
            "insert",
            "undo_edit"
        ]),
        path: import_v434.z.string(),
        file_text: import_v434.z.string().optional(),
        insert_line: import_v434.z.number().int().optional(),
        new_str: import_v434.z.string().optional(),
        old_str: import_v434.z.string().optional(),
        view_range: import_v434.z.array(import_v434.z.number().int()).optional()
    })));
var textEditor_20241022 = createProviderDefinedToolFactory({
    id: "anthropic.text_editor_20241022",
    name: "str_replace_editor",
    inputSchema: textEditor_20241022InputSchema
});
var textEditor_20250124InputSchema = lazySchema(()=>zodSchema(import_v435.z.object({
        command: import_v435.z.enum([
            "view",
            "create",
            "str_replace",
            "insert",
            "undo_edit"
        ]),
        path: import_v435.z.string(),
        file_text: import_v435.z.string().optional(),
        insert_line: import_v435.z.number().int().optional(),
        new_str: import_v435.z.string().optional(),
        old_str: import_v435.z.string().optional(),
        view_range: import_v435.z.array(import_v435.z.number().int()).optional()
    })));
var textEditor_20250124 = createProviderDefinedToolFactory({
    id: "anthropic.text_editor_20250124",
    name: "str_replace_editor",
    inputSchema: textEditor_20250124InputSchema
});
var textEditor_20250429InputSchema = lazySchema(()=>zodSchema(import_v436.z.object({
        command: import_v436.z.enum([
            "view",
            "create",
            "str_replace",
            "insert"
        ]),
        path: import_v436.z.string(),
        file_text: import_v436.z.string().optional(),
        insert_line: import_v436.z.number().int().optional(),
        new_str: import_v436.z.string().optional(),
        old_str: import_v436.z.string().optional(),
        view_range: import_v436.z.array(import_v436.z.number().int()).optional()
    })));
var textEditor_20250429 = createProviderDefinedToolFactory({
    id: "anthropic.text_editor_20250429",
    name: "str_replace_based_edit_tool",
    inputSchema: textEditor_20250429InputSchema
});
var anthropicTools = {
    /**
   * The bash tool enables Claude to execute shell commands in a persistent bash session,
   * allowing system operations, script execution, and command-line automation.
   *
   * Image results are supported.
   *
   * Tool name must be `bash`.
   */ bash_20241022,
    /**
   * The bash tool enables Claude to execute shell commands in a persistent bash session,
   * allowing system operations, script execution, and command-line automation.
   *
   * Image results are supported.
   *
   * Tool name must be `bash`.
   */ bash_20250124,
    /**
   * Claude can analyze data, create visualizations, perform complex calculations,
   * run system commands, create and edit files, and process uploaded files directly within
   * the API conversation.
   *
   * The code execution tool allows Claude to run Bash commands and manipulate files,
   * including writing code, in a secure, sandboxed environment.
   *
   * Tool name must be `code_execution`.
   */ codeExecution_20250522,
    /**
   * Claude can analyze data, create visualizations, perform complex calculations,
   * run system commands, create and edit files, and process uploaded files directly within
   * the API conversation.
   *
   * The code execution tool allows Claude to run both Python and Bash commands and manipulate files,
   * including writing code, in a secure, sandboxed environment.
   *
   * This is the latest version with enhanced Bash support and file operations.
   *
   * Tool name must be `code_execution`.
   */ codeExecution_20250825,
    /**
   * Claude can interact with computer environments through the computer use tool, which
   * provides screenshot capabilities and mouse/keyboard control for autonomous desktop interaction.
   *
   * Image results are supported.
   *
   * Tool name must be `computer`.
   *
   * @param displayWidthPx - The width of the display being controlled by the model in pixels.
   * @param displayHeightPx - The height of the display being controlled by the model in pixels.
   * @param displayNumber - The display number to control (only relevant for X11 environments). If specified, the tool will be provided a display number in the tool definition.
   */ computer_20241022,
    /**
   * Claude can interact with computer environments through the computer use tool, which
   * provides screenshot capabilities and mouse/keyboard control for autonomous desktop interaction.
   *
   * Image results are supported.
   *
   * Tool name must be `computer`.
   *
   * @param displayWidthPx - The width of the display being controlled by the model in pixels.
   * @param displayHeightPx - The height of the display being controlled by the model in pixels.
   * @param displayNumber - The display number to control (only relevant for X11 environments). If specified, the tool will be provided a display number in the tool definition.
   */ computer_20250124,
    /**
   * The memory tool enables Claude to store and retrieve information across conversations through a memory file directory.
   * Claude can create, read, update, and delete files that persist between sessions,
   * allowing it to build knowledge over time without keeping everything in the context window.
   * The memory tool operates client-sideyou control where and how the data is stored through your own infrastructure.
   *
   * Supported models: Claude Sonnet 4.5, Claude Sonnet 4, Claude Opus 4.1, Claude Opus 4.
   *
   * Tool name must be `memory`.
   */ memory_20250818,
    /**
   * Claude can use an Anthropic-defined text editor tool to view and modify text files,
   * helping you debug, fix, and improve your code or other text documents. This allows Claude
   * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
   *
   * Supported models: Claude Sonnet 3.5
   *
   * Tool name must be `str_replace_editor`.
   */ textEditor_20241022,
    /**
   * Claude can use an Anthropic-defined text editor tool to view and modify text files,
   * helping you debug, fix, and improve your code or other text documents. This allows Claude
   * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
   *
   * Supported models: Claude Sonnet 3.7
   *
   * Tool name must be `str_replace_editor`.
   */ textEditor_20250124,
    /**
   * Claude can use an Anthropic-defined text editor tool to view and modify text files,
   * helping you debug, fix, and improve your code or other text documents. This allows Claude
   * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
   *
   * Note: This version does not support the "undo_edit" command.
   *
   * Tool name must be `str_replace_based_edit_tool`.
   *
   * @deprecated Use textEditor_20250728 instead
   */ textEditor_20250429,
    /**
   * Claude can use an Anthropic-defined text editor tool to view and modify text files,
   * helping you debug, fix, and improve your code or other text documents. This allows Claude
   * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
   *
   * Note: This version does not support the "undo_edit" command and adds optional max_characters parameter.
   *
   * Supported models: Claude Sonnet 4, Opus 4, and Opus 4.1
   *
   * Tool name must be `str_replace_based_edit_tool`.
   *
   * @param maxCharacters - Optional maximum number of characters to view in the file
   */ textEditor_20250728,
    /**
   * Creates a web fetch tool that gives Claude direct access to real-time web content.
   *
   * Tool name must be `web_fetch`.
   *
   * @param maxUses - The max_uses parameter limits the number of web fetches performed
   * @param allowedDomains - Only fetch from these domains
   * @param blockedDomains - Never fetch from these domains
   * @param citations - Unlike web search where citations are always enabled, citations are optional for web fetch. Set "citations": {"enabled": true} to enable Claude to cite specific passages from fetched documents.
   * @param maxContentTokens - The max_content_tokens parameter limits the amount of content that will be included in the context.
   */ webFetch_20250910,
    /**
   * Creates a web search tool that gives Claude direct access to real-time web content.
   *
   * Tool name must be `web_search`.
   *
   * @param maxUses - Maximum number of web searches Claude can perform during the conversation.
   * @param allowedDomains - Optional list of domains that Claude is allowed to search.
   * @param blockedDomains - Optional list of domains that Claude should avoid when searching.
   * @param userLocation - Optional user location information to provide geographically relevant search results.
   */ webSearch_20250305
};
function createAnthropic(options = {}) {
    var _a;
    const baseURL = (_a = withoutTrailingSlash(options.baseURL)) != null ? _a : "https://api.anthropic.com/v1";
    const getHeaders = ()=>withUserAgentSuffix(__spreadValues({
            "anthropic-version": "2023-06-01",
            "x-api-key": loadApiKey({
                apiKey: options.apiKey,
                environmentVariableName: "ANTHROPIC_API_KEY",
                description: "Anthropic"
            })
        }, options.headers), `ai-sdk/anthropic/${VERSION3}`);
    const createChatModel = (modelId)=>{
        var _a2;
        return new AnthropicMessagesLanguageModel(modelId, {
            provider: "anthropic.messages",
            baseURL,
            headers: getHeaders,
            fetch: options.fetch,
            generateId: (_a2 = options.generateId) != null ? _a2 : generateId,
            supportedUrls: ()=>({
                    "image/*": [
                        /^https?:\/\/.*$/
                    ]
                })
        });
    };
    const provider = function(modelId) {
        if (new.target) {
            throw new Error("The Anthropic model function cannot be called with the new keyword.");
        }
        return createChatModel(modelId);
    };
    provider.languageModel = createChatModel;
    provider.chat = createChatModel;
    provider.messages = createChatModel;
    provider.textEmbeddingModel = (modelId)=>{
        throw new import_provider20.NoSuchModelError({
            modelId,
            modelType: "textEmbeddingModel"
        });
    };
    provider.imageModel = (modelId)=>{
        throw new import_provider20.NoSuchModelError({
            modelId,
            modelType: "imageModel"
        });
    };
    provider.tools = anthropicTools;
    return provider;
}
var anthropic = createAnthropic();
// ../../node_modules/.pnpm/@ai-sdk+google@2.0.23_zod@3.25.67/node_modules/@ai-sdk/google/dist/index.mjs
var import_provider24 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v437 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v438 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v439 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v440 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_provider25 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v441 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_provider26 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v442 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v443 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v444 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v445 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var VERSION4 = ("TURBOPACK compile-time truthy", 1) ? "2.0.23" : "TURBOPACK unreachable";
var googleErrorDataSchema = lazySchema(()=>zodSchema(import_v438.z.object({
        error: import_v438.z.object({
            code: import_v438.z.number().nullable(),
            message: import_v438.z.string(),
            status: import_v438.z.string()
        })
    })));
var googleFailedResponseHandler = createJsonErrorResponseHandler({
    errorSchema: googleErrorDataSchema,
    errorToMessage: (data)=>data.error.message
});
var googleGenerativeAIEmbeddingProviderOptions = lazySchema(()=>zodSchema(import_v439.z.object({
        /**
       * Optional. Optional reduced dimension for the output embedding.
       * If set, excessive values in the output embedding are truncated from the end.
       */ outputDimensionality: import_v439.z.number().optional(),
        /**
       * Optional. Specifies the task type for generating embeddings.
       * Supported task types:
       * - SEMANTIC_SIMILARITY: Optimized for text similarity.
       * - CLASSIFICATION: Optimized for text classification.
       * - CLUSTERING: Optimized for clustering texts based on similarity.
       * - RETRIEVAL_DOCUMENT: Optimized for document retrieval.
       * - RETRIEVAL_QUERY: Optimized for query-based retrieval.
       * - QUESTION_ANSWERING: Optimized for answering questions.
       * - FACT_VERIFICATION: Optimized for verifying factual information.
       * - CODE_RETRIEVAL_QUERY: Optimized for retrieving code blocks based on natural language queries.
       */ taskType: import_v439.z.enum([
            "SEMANTIC_SIMILARITY",
            "CLASSIFICATION",
            "CLUSTERING",
            "RETRIEVAL_DOCUMENT",
            "RETRIEVAL_QUERY",
            "QUESTION_ANSWERING",
            "FACT_VERIFICATION",
            "CODE_RETRIEVAL_QUERY"
        ]).optional()
    })));
var GoogleGenerativeAIEmbeddingModel = class {
    constructor(modelId, config){
        this.specificationVersion = "v2";
        this.maxEmbeddingsPerCall = 2048;
        this.supportsParallelCalls = true;
        this.modelId = modelId;
        this.config = config;
    }
    get provider() {
        return this.config.provider;
    }
    doEmbed(_0) {
        return __async(this, arguments, function*({ values, headers, abortSignal, providerOptions }) {
            const googleOptions = yield parseProviderOptions({
                provider: "google",
                providerOptions,
                schema: googleGenerativeAIEmbeddingProviderOptions
            });
            if (values.length > this.maxEmbeddingsPerCall) {
                throw new import_provider24.TooManyEmbeddingValuesForCallError({
                    provider: this.provider,
                    modelId: this.modelId,
                    maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
                    values
                });
            }
            const mergedHeaders = combineHeaders((yield resolve(this.config.headers)), headers);
            if (values.length === 1) {
                const { responseHeaders: responseHeaders2, value: response2, rawValue: rawValue2 } = yield postJsonToApi({
                    url: `${this.config.baseURL}/models/${this.modelId}:embedContent`,
                    headers: mergedHeaders,
                    body: {
                        model: `models/${this.modelId}`,
                        content: {
                            parts: [
                                {
                                    text: values[0]
                                }
                            ]
                        },
                        outputDimensionality: googleOptions == null ? void 0 : googleOptions.outputDimensionality,
                        taskType: googleOptions == null ? void 0 : googleOptions.taskType
                    },
                    failedResponseHandler: googleFailedResponseHandler,
                    successfulResponseHandler: createJsonResponseHandler(googleGenerativeAISingleEmbeddingResponseSchema),
                    abortSignal,
                    fetch: this.config.fetch
                });
                return {
                    embeddings: [
                        response2.embedding.values
                    ],
                    usage: void 0,
                    response: {
                        headers: responseHeaders2,
                        body: rawValue2
                    }
                };
            }
            const { responseHeaders, value: response, rawValue } = yield postJsonToApi({
                url: `${this.config.baseURL}/models/${this.modelId}:batchEmbedContents`,
                headers: mergedHeaders,
                body: {
                    requests: values.map((value)=>({
                            model: `models/${this.modelId}`,
                            content: {
                                role: "user",
                                parts: [
                                    {
                                        text: value
                                    }
                                ]
                            },
                            outputDimensionality: googleOptions == null ? void 0 : googleOptions.outputDimensionality,
                            taskType: googleOptions == null ? void 0 : googleOptions.taskType
                        }))
                },
                failedResponseHandler: googleFailedResponseHandler,
                successfulResponseHandler: createJsonResponseHandler(googleGenerativeAITextEmbeddingResponseSchema),
                abortSignal,
                fetch: this.config.fetch
            });
            return {
                embeddings: response.embeddings.map((item)=>item.values),
                usage: void 0,
                response: {
                    headers: responseHeaders,
                    body: rawValue
                }
            };
        });
    }
};
var googleGenerativeAITextEmbeddingResponseSchema = lazySchema(()=>zodSchema(import_v437.z.object({
        embeddings: import_v437.z.array(import_v437.z.object({
            values: import_v437.z.array(import_v437.z.number())
        }))
    })));
var googleGenerativeAISingleEmbeddingResponseSchema = lazySchema(()=>zodSchema(import_v437.z.object({
        embedding: import_v437.z.object({
            values: import_v437.z.array(import_v437.z.number())
        })
    })));
function convertJSONSchemaToOpenAPISchema(jsonSchema2) {
    if (jsonSchema2 == null || isEmptyObjectSchema(jsonSchema2)) {
        return void 0;
    }
    if (typeof jsonSchema2 === "boolean") {
        return {
            type: "boolean",
            properties: {}
        };
    }
    const { type, description, required, properties, items, allOf, anyOf, oneOf, format, const: constValue, minLength, enum: enumValues } = jsonSchema2;
    const result = {};
    if (description) result.description = description;
    if (required) result.required = required;
    if (format) result.format = format;
    if (constValue !== void 0) {
        result.enum = [
            constValue
        ];
    }
    if (type) {
        if (Array.isArray(type)) {
            if (type.includes("null")) {
                result.type = type.filter((t)=>t !== "null")[0];
                result.nullable = true;
            } else {
                result.type = type;
            }
        } else if (type === "null") {
            result.type = "null";
        } else {
            result.type = type;
        }
    }
    if (enumValues !== void 0) {
        result.enum = enumValues;
    }
    if (properties != null) {
        result.properties = Object.entries(properties).reduce((acc, [key, value])=>{
            acc[key] = convertJSONSchemaToOpenAPISchema(value);
            return acc;
        }, {});
    }
    if (items) {
        result.items = Array.isArray(items) ? items.map(convertJSONSchemaToOpenAPISchema) : convertJSONSchemaToOpenAPISchema(items);
    }
    if (allOf) {
        result.allOf = allOf.map(convertJSONSchemaToOpenAPISchema);
    }
    if (anyOf) {
        if (anyOf.some((schema)=>typeof schema === "object" && (schema == null ? void 0 : schema.type) === "null")) {
            const nonNullSchemas = anyOf.filter((schema)=>!(typeof schema === "object" && (schema == null ? void 0 : schema.type) === "null"));
            if (nonNullSchemas.length === 1) {
                const converted = convertJSONSchemaToOpenAPISchema(nonNullSchemas[0]);
                if (typeof converted === "object") {
                    result.nullable = true;
                    Object.assign(result, converted);
                }
            } else {
                result.anyOf = nonNullSchemas.map(convertJSONSchemaToOpenAPISchema);
                result.nullable = true;
            }
        } else {
            result.anyOf = anyOf.map(convertJSONSchemaToOpenAPISchema);
        }
    }
    if (oneOf) {
        result.oneOf = oneOf.map(convertJSONSchemaToOpenAPISchema);
    }
    if (minLength !== void 0) {
        result.minLength = minLength;
    }
    return result;
}
function isEmptyObjectSchema(jsonSchema2) {
    return jsonSchema2 != null && typeof jsonSchema2 === "object" && jsonSchema2.type === "object" && (jsonSchema2.properties == null || Object.keys(jsonSchema2.properties).length === 0) && !jsonSchema2.additionalProperties;
}
function convertToGoogleGenerativeAIMessages(prompt, options) {
    var _a;
    const systemInstructionParts = [];
    const contents = [];
    let systemMessagesAllowed = true;
    const isGemmaModel = (_a = options == null ? void 0 : options.isGemmaModel) != null ? _a : false;
    for (const { role, content } of prompt){
        switch(role){
            case "system":
                {
                    if (!systemMessagesAllowed) {
                        throw new import_provider25.UnsupportedFunctionalityError({
                            functionality: "system messages are only supported at the beginning of the conversation"
                        });
                    }
                    systemInstructionParts.push({
                        text: content
                    });
                    break;
                }
            case "user":
                {
                    systemMessagesAllowed = false;
                    const parts = [];
                    for (const part of content){
                        switch(part.type){
                            case "text":
                                {
                                    parts.push({
                                        text: part.text
                                    });
                                    break;
                                }
                            case "file":
                                {
                                    const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                                    parts.push(part.data instanceof URL ? {
                                        fileData: {
                                            mimeType: mediaType,
                                            fileUri: part.data.toString()
                                        }
                                    } : {
                                        inlineData: {
                                            mimeType: mediaType,
                                            data: convertToBase64(part.data)
                                        }
                                    });
                                    break;
                                }
                        }
                    }
                    contents.push({
                        role: "user",
                        parts
                    });
                    break;
                }
            case "assistant":
                {
                    systemMessagesAllowed = false;
                    contents.push({
                        role: "model",
                        parts: content.map((part)=>{
                            var _a2, _b, _c, _d, _e, _f;
                            switch(part.type){
                                case "text":
                                    {
                                        return part.text.length === 0 ? void 0 : {
                                            text: part.text,
                                            thoughtSignature: (_b = (_a2 = part.providerOptions) == null ? void 0 : _a2.google) == null ? void 0 : _b.thoughtSignature
                                        };
                                    }
                                case "reasoning":
                                    {
                                        return part.text.length === 0 ? void 0 : {
                                            text: part.text,
                                            thought: true,
                                            thoughtSignature: (_d = (_c = part.providerOptions) == null ? void 0 : _c.google) == null ? void 0 : _d.thoughtSignature
                                        };
                                    }
                                case "file":
                                    {
                                        if (part.mediaType !== "image/png") {
                                            throw new import_provider25.UnsupportedFunctionalityError({
                                                functionality: "Only PNG images are supported in assistant messages"
                                            });
                                        }
                                        if (part.data instanceof URL) {
                                            throw new import_provider25.UnsupportedFunctionalityError({
                                                functionality: "File data URLs in assistant messages are not supported"
                                            });
                                        }
                                        return {
                                            inlineData: {
                                                mimeType: part.mediaType,
                                                data: convertToBase64(part.data)
                                            }
                                        };
                                    }
                                case "tool-call":
                                    {
                                        return {
                                            functionCall: {
                                                name: part.toolName,
                                                args: part.input
                                            },
                                            thoughtSignature: (_f = (_e = part.providerOptions) == null ? void 0 : _e.google) == null ? void 0 : _f.thoughtSignature
                                        };
                                    }
                            }
                        }).filter((part)=>part !== void 0)
                    });
                    break;
                }
            case "tool":
                {
                    systemMessagesAllowed = false;
                    const parts = [];
                    for (const part of content){
                        const output = part.output;
                        if (output.type === "content") {
                            for (const contentPart of output.value){
                                switch(contentPart.type){
                                    case "text":
                                        parts.push({
                                            functionResponse: {
                                                name: part.toolName,
                                                response: {
                                                    name: part.toolName,
                                                    content: contentPart.text
                                                }
                                            }
                                        });
                                        break;
                                    case "media":
                                        parts.push({
                                            inlineData: {
                                                mimeType: contentPart.mediaType,
                                                data: contentPart.data
                                            }
                                        }, {
                                            text: "Tool executed successfully and returned this image as a response"
                                        });
                                        break;
                                    default:
                                        parts.push({
                                            text: JSON.stringify(contentPart)
                                        });
                                        break;
                                }
                            }
                        } else {
                            parts.push({
                                functionResponse: {
                                    name: part.toolName,
                                    response: {
                                        name: part.toolName,
                                        content: output.value
                                    }
                                }
                            });
                        }
                    }
                    contents.push({
                        role: "user",
                        parts
                    });
                    break;
                }
        }
    }
    if (isGemmaModel && systemInstructionParts.length > 0 && contents.length > 0 && contents[0].role === "user") {
        const systemText = systemInstructionParts.map((part)=>part.text).join("\n\n");
        contents[0].parts.unshift({
            text: systemText + "\n\n"
        });
    }
    return {
        systemInstruction: systemInstructionParts.length > 0 && !isGemmaModel ? {
            parts: systemInstructionParts
        } : void 0,
        contents
    };
}
function getModelPath(modelId) {
    return modelId.includes("/") ? modelId : `models/${modelId}`;
}
var googleGenerativeAIProviderOptions = lazySchema(()=>zodSchema(import_v441.z.object({
        responseModalities: import_v441.z.array(import_v441.z.enum([
            "TEXT",
            "IMAGE"
        ])).optional(),
        thinkingConfig: import_v441.z.object({
            thinkingBudget: import_v441.z.number().optional(),
            includeThoughts: import_v441.z.boolean().optional()
        }).optional(),
        /**
       * Optional.
       * The name of the cached content used as context to serve the prediction.
       * Format: cachedContents/{cachedContent}
       */ cachedContent: import_v441.z.string().optional(),
        /**
       * Optional. Enable structured output. Default is true.
       *
       * This is useful when the JSON Schema contains elements that are
       * not supported by the OpenAPI schema version that
       * Google Generative AI uses. You can use this to disable
       * structured outputs if you need to.
       */ structuredOutputs: import_v441.z.boolean().optional(),
        /**
       * Optional. A list of unique safety settings for blocking unsafe content.
       */ safetySettings: import_v441.z.array(import_v441.z.object({
            category: import_v441.z.enum([
                "HARM_CATEGORY_UNSPECIFIED",
                "HARM_CATEGORY_HATE_SPEECH",
                "HARM_CATEGORY_DANGEROUS_CONTENT",
                "HARM_CATEGORY_HARASSMENT",
                "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                "HARM_CATEGORY_CIVIC_INTEGRITY"
            ]),
            threshold: import_v441.z.enum([
                "HARM_BLOCK_THRESHOLD_UNSPECIFIED",
                "BLOCK_LOW_AND_ABOVE",
                "BLOCK_MEDIUM_AND_ABOVE",
                "BLOCK_ONLY_HIGH",
                "BLOCK_NONE",
                "OFF"
            ])
        })).optional(),
        threshold: import_v441.z.enum([
            "HARM_BLOCK_THRESHOLD_UNSPECIFIED",
            "BLOCK_LOW_AND_ABOVE",
            "BLOCK_MEDIUM_AND_ABOVE",
            "BLOCK_ONLY_HIGH",
            "BLOCK_NONE",
            "OFF"
        ]).optional(),
        /**
       * Optional. Enables timestamp understanding for audio-only files.
       *
       * https://cloud.google.com/vertex-ai/generative-ai/docs/multimodal/audio-understanding
       */ audioTimestamp: import_v441.z.boolean().optional(),
        /**
       * Optional. Defines labels used in billing reports. Available on Vertex AI only.
       *
       * https://cloud.google.com/vertex-ai/generative-ai/docs/multimodal/add-labels-to-api-calls
       */ labels: import_v441.z.record(import_v441.z.string(), import_v441.z.string()).optional(),
        /**
       * Optional. If specified, the media resolution specified will be used.
       *
       * https://ai.google.dev/api/generate-content#MediaResolution
       */ mediaResolution: import_v441.z.enum([
            "MEDIA_RESOLUTION_UNSPECIFIED",
            "MEDIA_RESOLUTION_LOW",
            "MEDIA_RESOLUTION_MEDIUM",
            "MEDIA_RESOLUTION_HIGH"
        ]).optional(),
        /**
       * Optional. Configures the image generation aspect ratio for Gemini models.
       *
       * https://ai.google.dev/gemini-api/docs/image-generation#aspect_ratios
       */ imageConfig: import_v441.z.object({
            aspectRatio: import_v441.z.enum([
                "1:1",
                "2:3",
                "3:2",
                "3:4",
                "4:3",
                "4:5",
                "5:4",
                "9:16",
                "16:9",
                "21:9"
            ]).optional()
        }).optional()
    })));
function prepareTools2({ tools, toolChoice, modelId }) {
    var _a;
    tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
    const toolWarnings = [];
    const isGemini2 = modelId.includes("gemini-2");
    const supportsDynamicRetrieval = modelId.includes("gemini-1.5-flash") && !modelId.includes("-8b");
    if (tools == null) {
        return {
            tools: void 0,
            toolConfig: void 0,
            toolWarnings
        };
    }
    const hasFunctionTools = tools.some((tool12)=>tool12.type === "function");
    const hasProviderDefinedTools = tools.some((tool12)=>tool12.type === "provider-defined");
    if (hasFunctionTools && hasProviderDefinedTools) {
        toolWarnings.push({
            type: "unsupported-tool",
            tool: tools.find((tool12)=>tool12.type === "function"),
            details: "Cannot mix function tools with provider-defined tools in the same request. Please use either function tools or provider-defined tools, but not both."
        });
    }
    if (hasProviderDefinedTools) {
        const googleTools2 = [];
        const providerDefinedTools = tools.filter((tool12)=>tool12.type === "provider-defined");
        providerDefinedTools.forEach((tool12)=>{
            switch(tool12.id){
                case "google.google_search":
                    if (isGemini2) {
                        googleTools2.push({
                            googleSearch: {}
                        });
                    } else if (supportsDynamicRetrieval) {
                        googleTools2.push({
                            googleSearchRetrieval: {
                                dynamicRetrievalConfig: {
                                    mode: tool12.args.mode,
                                    dynamicThreshold: tool12.args.dynamicThreshold
                                }
                            }
                        });
                    } else {
                        googleTools2.push({
                            googleSearchRetrieval: {}
                        });
                    }
                    break;
                case "google.url_context":
                    if (isGemini2) {
                        googleTools2.push({
                            urlContext: {}
                        });
                    } else {
                        toolWarnings.push({
                            type: "unsupported-tool",
                            tool: tool12,
                            details: "The URL context tool is not supported with other Gemini models than Gemini 2."
                        });
                    }
                    break;
                case "google.code_execution":
                    if (isGemini2) {
                        googleTools2.push({
                            codeExecution: {}
                        });
                    } else {
                        toolWarnings.push({
                            type: "unsupported-tool",
                            tool: tool12,
                            details: "The code execution tools is not supported with other Gemini models than Gemini 2."
                        });
                    }
                    break;
                default:
                    toolWarnings.push({
                        type: "unsupported-tool",
                        tool: tool12
                    });
                    break;
            }
        });
        return {
            tools: googleTools2.length > 0 ? googleTools2 : void 0,
            toolConfig: void 0,
            toolWarnings
        };
    }
    const functionDeclarations = [];
    for (const tool12 of tools){
        switch(tool12.type){
            case "function":
                functionDeclarations.push({
                    name: tool12.name,
                    description: (_a = tool12.description) != null ? _a : "",
                    parameters: convertJSONSchemaToOpenAPISchema(tool12.inputSchema)
                });
                break;
            default:
                toolWarnings.push({
                    type: "unsupported-tool",
                    tool: tool12
                });
                break;
        }
    }
    if (toolChoice == null) {
        return {
            tools: {
                functionDeclarations
            },
            toolConfig: void 0,
            toolWarnings
        };
    }
    const type = toolChoice.type;
    switch(type){
        case "auto":
            return {
                tools: {
                    functionDeclarations
                },
                toolConfig: {
                    functionCallingConfig: {
                        mode: "AUTO"
                    }
                },
                toolWarnings
            };
        case "none":
            return {
                tools: {
                    functionDeclarations
                },
                toolConfig: {
                    functionCallingConfig: {
                        mode: "NONE"
                    }
                },
                toolWarnings
            };
        case "required":
            return {
                tools: {
                    functionDeclarations
                },
                toolConfig: {
                    functionCallingConfig: {
                        mode: "ANY"
                    }
                },
                toolWarnings
            };
        case "tool":
            return {
                tools: {
                    functionDeclarations
                },
                toolConfig: {
                    functionCallingConfig: {
                        mode: "ANY",
                        allowedFunctionNames: [
                            toolChoice.toolName
                        ]
                    }
                },
                toolWarnings
            };
        default:
            {
                const _exhaustiveCheck = type;
                throw new import_provider26.UnsupportedFunctionalityError({
                    functionality: `tool choice type: ${_exhaustiveCheck}`
                });
            }
    }
}
function mapGoogleGenerativeAIFinishReason({ finishReason, hasToolCalls }) {
    switch(finishReason){
        case "STOP":
            return hasToolCalls ? "tool-calls" : "stop";
        case "MAX_TOKENS":
            return "length";
        case "IMAGE_SAFETY":
        case "RECITATION":
        case "SAFETY":
        case "BLOCKLIST":
        case "PROHIBITED_CONTENT":
        case "SPII":
            return "content-filter";
        case "FINISH_REASON_UNSPECIFIED":
        case "OTHER":
            return "other";
        case "MALFORMED_FUNCTION_CALL":
            return "error";
        default:
            return "unknown";
    }
}
var GoogleGenerativeAILanguageModel = class {
    constructor(modelId, config){
        this.specificationVersion = "v2";
        var _a;
        this.modelId = modelId;
        this.config = config;
        this.generateId = (_a = config.generateId) != null ? _a : generateId;
    }
    get provider() {
        return this.config.provider;
    }
    get supportedUrls() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.config).supportedUrls) == null ? void 0 : _b.call(_a)) != null ? _c : {};
    }
    getArgs(_0) {
        return __async(this, arguments, function*({ prompt, maxOutputTokens, temperature, topP, topK, frequencyPenalty, presencePenalty, stopSequences, responseFormat, seed, tools, toolChoice, providerOptions }) {
            var _a, _b;
            const warnings = [];
            const googleOptions = yield parseProviderOptions({
                provider: "google",
                providerOptions,
                schema: googleGenerativeAIProviderOptions
            });
            if (((_a = googleOptions == null ? void 0 : googleOptions.thinkingConfig) == null ? void 0 : _a.includeThoughts) === true && !this.config.provider.startsWith("google.vertex.")) {
                warnings.push({
                    type: "other",
                    message: `The 'includeThoughts' option is only supported with the Google Vertex provider and might not be supported or could behave unexpectedly with the current Google provider (${this.config.provider}).`
                });
            }
            const isGemmaModel = this.modelId.toLowerCase().startsWith("gemma-");
            const { contents, systemInstruction } = convertToGoogleGenerativeAIMessages(prompt, {
                isGemmaModel
            });
            const { tools: googleTools2, toolConfig: googleToolConfig, toolWarnings } = prepareTools2({
                tools,
                toolChoice,
                modelId: this.modelId
            });
            return {
                args: {
                    generationConfig: __spreadValues(__spreadValues(__spreadProps(__spreadValues({
                        // standardized settings:
                        maxOutputTokens,
                        temperature,
                        topK,
                        topP,
                        frequencyPenalty,
                        presencePenalty,
                        stopSequences,
                        seed,
                        // response format:
                        responseMimeType: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? "application/json" : void 0,
                        responseSchema: (responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && // Google GenAI does not support all OpenAPI Schema features,
                        // so this is needed as an escape hatch:
                        // TODO convert into provider option
                        ((_b = googleOptions == null ? void 0 : googleOptions.structuredOutputs) != null ? _b : true) ? convertJSONSchemaToOpenAPISchema(responseFormat.schema) : void 0
                    }, (googleOptions == null ? void 0 : googleOptions.audioTimestamp) && {
                        audioTimestamp: googleOptions.audioTimestamp
                    }), {
                        // provider options:
                        responseModalities: googleOptions == null ? void 0 : googleOptions.responseModalities,
                        thinkingConfig: googleOptions == null ? void 0 : googleOptions.thinkingConfig
                    }), (googleOptions == null ? void 0 : googleOptions.imageConfig) && {
                        imageConfig: googleOptions.imageConfig
                    }), (googleOptions == null ? void 0 : googleOptions.mediaResolution) && {
                        mediaResolution: googleOptions.mediaResolution
                    }),
                    contents,
                    systemInstruction: isGemmaModel ? void 0 : systemInstruction,
                    safetySettings: googleOptions == null ? void 0 : googleOptions.safetySettings,
                    tools: googleTools2,
                    toolConfig: googleToolConfig,
                    cachedContent: googleOptions == null ? void 0 : googleOptions.cachedContent,
                    labels: googleOptions == null ? void 0 : googleOptions.labels
                },
                warnings: [
                    ...warnings,
                    ...toolWarnings
                ]
            };
        });
    }
    doGenerate(options) {
        return __async(this, null, function*() {
            var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
            const { args, warnings } = yield this.getArgs(options);
            const body = JSON.stringify(args);
            const mergedHeaders = combineHeaders((yield resolve(this.config.headers)), options.headers);
            const { responseHeaders, value: response, rawValue: rawResponse } = yield postJsonToApi({
                url: `${this.config.baseURL}/${getModelPath(this.modelId)}:generateContent`,
                headers: mergedHeaders,
                body: args,
                failedResponseHandler: googleFailedResponseHandler,
                successfulResponseHandler: createJsonResponseHandler(responseSchema),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            const candidate = response.candidates[0];
            const content = [];
            const parts = (_b = (_a = candidate.content) == null ? void 0 : _a.parts) != null ? _b : [];
            const usageMetadata = response.usageMetadata;
            let lastCodeExecutionToolCallId;
            for (const part of parts){
                if ("executableCode" in part && ((_c = part.executableCode) == null ? void 0 : _c.code)) {
                    const toolCallId = this.config.generateId();
                    lastCodeExecutionToolCallId = toolCallId;
                    content.push({
                        type: "tool-call",
                        toolCallId,
                        toolName: "code_execution",
                        input: JSON.stringify(part.executableCode),
                        providerExecuted: true
                    });
                } else if ("codeExecutionResult" in part && part.codeExecutionResult) {
                    content.push({
                        type: "tool-result",
                        // Assumes a result directly follows its corresponding call part.
                        toolCallId: lastCodeExecutionToolCallId,
                        toolName: "code_execution",
                        result: {
                            outcome: part.codeExecutionResult.outcome,
                            output: part.codeExecutionResult.output
                        },
                        providerExecuted: true
                    });
                    lastCodeExecutionToolCallId = void 0;
                } else if ("text" in part && part.text != null && part.text.length > 0) {
                    content.push({
                        type: part.thought === true ? "reasoning" : "text",
                        text: part.text,
                        providerMetadata: part.thoughtSignature ? {
                            google: {
                                thoughtSignature: part.thoughtSignature
                            }
                        } : void 0
                    });
                } else if ("functionCall" in part) {
                    content.push({
                        type: "tool-call",
                        toolCallId: this.config.generateId(),
                        toolName: part.functionCall.name,
                        input: JSON.stringify(part.functionCall.args),
                        providerMetadata: part.thoughtSignature ? {
                            google: {
                                thoughtSignature: part.thoughtSignature
                            }
                        } : void 0
                    });
                } else if ("inlineData" in part) {
                    content.push({
                        type: "file",
                        data: part.inlineData.data,
                        mediaType: part.inlineData.mimeType
                    });
                }
            }
            const sources = (_d = extractSources({
                groundingMetadata: candidate.groundingMetadata,
                generateId: this.config.generateId
            })) != null ? _d : [];
            for (const source of sources){
                content.push(source);
            }
            return {
                content,
                finishReason: mapGoogleGenerativeAIFinishReason({
                    finishReason: candidate.finishReason,
                    hasToolCalls: content.some((part)=>part.type === "tool-call")
                }),
                usage: {
                    inputTokens: (_e = usageMetadata == null ? void 0 : usageMetadata.promptTokenCount) != null ? _e : void 0,
                    outputTokens: (_f = usageMetadata == null ? void 0 : usageMetadata.candidatesTokenCount) != null ? _f : void 0,
                    totalTokens: (_g = usageMetadata == null ? void 0 : usageMetadata.totalTokenCount) != null ? _g : void 0,
                    reasoningTokens: (_h = usageMetadata == null ? void 0 : usageMetadata.thoughtsTokenCount) != null ? _h : void 0,
                    cachedInputTokens: (_i = usageMetadata == null ? void 0 : usageMetadata.cachedContentTokenCount) != null ? _i : void 0
                },
                warnings,
                providerMetadata: {
                    google: {
                        promptFeedback: (_j = response.promptFeedback) != null ? _j : null,
                        groundingMetadata: (_k = candidate.groundingMetadata) != null ? _k : null,
                        urlContextMetadata: (_l = candidate.urlContextMetadata) != null ? _l : null,
                        safetyRatings: (_m = candidate.safetyRatings) != null ? _m : null,
                        usageMetadata: usageMetadata != null ? usageMetadata : null
                    }
                },
                request: {
                    body
                },
                response: {
                    // TODO timestamp, model id, id
                    headers: responseHeaders,
                    body: rawResponse
                }
            };
        });
    }
    doStream(options) {
        return __async(this, null, function*() {
            const { args, warnings } = yield this.getArgs(options);
            const body = JSON.stringify(args);
            const headers = combineHeaders((yield resolve(this.config.headers)), options.headers);
            const { responseHeaders, value: response } = yield postJsonToApi({
                url: `${this.config.baseURL}/${getModelPath(this.modelId)}:streamGenerateContent?alt=sse`,
                headers,
                body: args,
                failedResponseHandler: googleFailedResponseHandler,
                successfulResponseHandler: createEventSourceResponseHandler(chunkSchema),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            let finishReason = "unknown";
            const usage = {
                inputTokens: void 0,
                outputTokens: void 0,
                totalTokens: void 0
            };
            let providerMetadata = void 0;
            const generateId3 = this.config.generateId;
            let hasToolCalls = false;
            let currentTextBlockId = null;
            let currentReasoningBlockId = null;
            let blockCounter = 0;
            const emittedSourceUrls = /* @__PURE__ */ new Set();
            let lastCodeExecutionToolCallId;
            return {
                stream: response.pipeThrough(new TransformStream({
                    start (controller) {
                        controller.enqueue({
                            type: "stream-start",
                            warnings
                        });
                    },
                    transform (chunk, controller) {
                        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
                        if (options.includeRawChunks) {
                            controller.enqueue({
                                type: "raw",
                                rawValue: chunk.rawValue
                            });
                        }
                        if (!chunk.success) {
                            controller.enqueue({
                                type: "error",
                                error: chunk.error
                            });
                            return;
                        }
                        const value = chunk.value;
                        const usageMetadata = value.usageMetadata;
                        if (usageMetadata != null) {
                            usage.inputTokens = (_a = usageMetadata.promptTokenCount) != null ? _a : void 0;
                            usage.outputTokens = (_b = usageMetadata.candidatesTokenCount) != null ? _b : void 0;
                            usage.totalTokens = (_c = usageMetadata.totalTokenCount) != null ? _c : void 0;
                            usage.reasoningTokens = (_d = usageMetadata.thoughtsTokenCount) != null ? _d : void 0;
                            usage.cachedInputTokens = (_e = usageMetadata.cachedContentTokenCount) != null ? _e : void 0;
                        }
                        const candidate = (_f = value.candidates) == null ? void 0 : _f[0];
                        if (candidate == null) {
                            return;
                        }
                        const content = candidate.content;
                        const sources = extractSources({
                            groundingMetadata: candidate.groundingMetadata,
                            generateId: generateId3
                        });
                        if (sources != null) {
                            for (const source of sources){
                                if (source.sourceType === "url" && !emittedSourceUrls.has(source.url)) {
                                    emittedSourceUrls.add(source.url);
                                    controller.enqueue(source);
                                }
                            }
                        }
                        if (content != null) {
                            const parts = (_g = content.parts) != null ? _g : [];
                            for (const part of parts){
                                if ("executableCode" in part && ((_h = part.executableCode) == null ? void 0 : _h.code)) {
                                    const toolCallId = generateId3();
                                    lastCodeExecutionToolCallId = toolCallId;
                                    controller.enqueue({
                                        type: "tool-call",
                                        toolCallId,
                                        toolName: "code_execution",
                                        input: JSON.stringify(part.executableCode),
                                        providerExecuted: true
                                    });
                                    hasToolCalls = true;
                                } else if ("codeExecutionResult" in part && part.codeExecutionResult) {
                                    const toolCallId = lastCodeExecutionToolCallId;
                                    if (toolCallId) {
                                        controller.enqueue({
                                            type: "tool-result",
                                            toolCallId,
                                            toolName: "code_execution",
                                            result: {
                                                outcome: part.codeExecutionResult.outcome,
                                                output: part.codeExecutionResult.output
                                            },
                                            providerExecuted: true
                                        });
                                        lastCodeExecutionToolCallId = void 0;
                                    }
                                } else if ("text" in part && part.text != null && part.text.length > 0) {
                                    if (part.thought === true) {
                                        if (currentTextBlockId !== null) {
                                            controller.enqueue({
                                                type: "text-end",
                                                id: currentTextBlockId
                                            });
                                            currentTextBlockId = null;
                                        }
                                        if (currentReasoningBlockId === null) {
                                            currentReasoningBlockId = String(blockCounter++);
                                            controller.enqueue({
                                                type: "reasoning-start",
                                                id: currentReasoningBlockId,
                                                providerMetadata: part.thoughtSignature ? {
                                                    google: {
                                                        thoughtSignature: part.thoughtSignature
                                                    }
                                                } : void 0
                                            });
                                        }
                                        controller.enqueue({
                                            type: "reasoning-delta",
                                            id: currentReasoningBlockId,
                                            delta: part.text,
                                            providerMetadata: part.thoughtSignature ? {
                                                google: {
                                                    thoughtSignature: part.thoughtSignature
                                                }
                                            } : void 0
                                        });
                                    } else {
                                        if (currentReasoningBlockId !== null) {
                                            controller.enqueue({
                                                type: "reasoning-end",
                                                id: currentReasoningBlockId
                                            });
                                            currentReasoningBlockId = null;
                                        }
                                        if (currentTextBlockId === null) {
                                            currentTextBlockId = String(blockCounter++);
                                            controller.enqueue({
                                                type: "text-start",
                                                id: currentTextBlockId,
                                                providerMetadata: part.thoughtSignature ? {
                                                    google: {
                                                        thoughtSignature: part.thoughtSignature
                                                    }
                                                } : void 0
                                            });
                                        }
                                        controller.enqueue({
                                            type: "text-delta",
                                            id: currentTextBlockId,
                                            delta: part.text,
                                            providerMetadata: part.thoughtSignature ? {
                                                google: {
                                                    thoughtSignature: part.thoughtSignature
                                                }
                                            } : void 0
                                        });
                                    }
                                }
                            }
                            const inlineDataParts = getInlineDataParts(content.parts);
                            if (inlineDataParts != null) {
                                for (const part of inlineDataParts){
                                    controller.enqueue({
                                        type: "file",
                                        mediaType: part.inlineData.mimeType,
                                        data: part.inlineData.data
                                    });
                                }
                            }
                            const toolCallDeltas = getToolCallsFromParts({
                                parts: content.parts,
                                generateId: generateId3
                            });
                            if (toolCallDeltas != null) {
                                for (const toolCall of toolCallDeltas){
                                    controller.enqueue({
                                        type: "tool-input-start",
                                        id: toolCall.toolCallId,
                                        toolName: toolCall.toolName,
                                        providerMetadata: toolCall.providerMetadata
                                    });
                                    controller.enqueue({
                                        type: "tool-input-delta",
                                        id: toolCall.toolCallId,
                                        delta: toolCall.args,
                                        providerMetadata: toolCall.providerMetadata
                                    });
                                    controller.enqueue({
                                        type: "tool-input-end",
                                        id: toolCall.toolCallId,
                                        providerMetadata: toolCall.providerMetadata
                                    });
                                    controller.enqueue({
                                        type: "tool-call",
                                        toolCallId: toolCall.toolCallId,
                                        toolName: toolCall.toolName,
                                        input: toolCall.args,
                                        providerMetadata: toolCall.providerMetadata
                                    });
                                    hasToolCalls = true;
                                }
                            }
                        }
                        if (candidate.finishReason != null) {
                            finishReason = mapGoogleGenerativeAIFinishReason({
                                finishReason: candidate.finishReason,
                                hasToolCalls
                            });
                            providerMetadata = {
                                google: {
                                    promptFeedback: (_i = value.promptFeedback) != null ? _i : null,
                                    groundingMetadata: (_j = candidate.groundingMetadata) != null ? _j : null,
                                    urlContextMetadata: (_k = candidate.urlContextMetadata) != null ? _k : null,
                                    safetyRatings: (_l = candidate.safetyRatings) != null ? _l : null
                                }
                            };
                            if (usageMetadata != null) {
                                providerMetadata.google.usageMetadata = usageMetadata;
                            }
                        }
                    },
                    flush (controller) {
                        if (currentTextBlockId !== null) {
                            controller.enqueue({
                                type: "text-end",
                                id: currentTextBlockId
                            });
                        }
                        if (currentReasoningBlockId !== null) {
                            controller.enqueue({
                                type: "reasoning-end",
                                id: currentReasoningBlockId
                            });
                        }
                        controller.enqueue({
                            type: "finish",
                            finishReason,
                            usage,
                            providerMetadata
                        });
                    }
                })),
                response: {
                    headers: responseHeaders
                },
                request: {
                    body
                }
            };
        });
    }
};
function getToolCallsFromParts({ parts, generateId: generateId3 }) {
    const functionCallParts = parts == null ? void 0 : parts.filter((part)=>"functionCall" in part);
    return functionCallParts == null || functionCallParts.length === 0 ? void 0 : functionCallParts.map((part)=>({
            type: "tool-call",
            toolCallId: generateId3(),
            toolName: part.functionCall.name,
            args: JSON.stringify(part.functionCall.args),
            providerMetadata: part.thoughtSignature ? {
                google: {
                    thoughtSignature: part.thoughtSignature
                }
            } : void 0
        }));
}
function getInlineDataParts(parts) {
    return parts == null ? void 0 : parts.filter((part)=>"inlineData" in part);
}
function extractSources({ groundingMetadata, generateId: generateId3 }) {
    var _a;
    return (_a = groundingMetadata == null ? void 0 : groundingMetadata.groundingChunks) == null ? void 0 : _a.filter((chunk)=>chunk.web != null).map((chunk)=>({
            type: "source",
            sourceType: "url",
            id: generateId3(),
            url: chunk.web.uri,
            title: chunk.web.title
        }));
}
var getGroundingMetadataSchema = ()=>import_v440.z.object({
        webSearchQueries: import_v440.z.array(import_v440.z.string()).nullish(),
        retrievalQueries: import_v440.z.array(import_v440.z.string()).nullish(),
        searchEntryPoint: import_v440.z.object({
            renderedContent: import_v440.z.string()
        }).nullish(),
        groundingChunks: import_v440.z.array(import_v440.z.object({
            web: import_v440.z.object({
                uri: import_v440.z.string(),
                title: import_v440.z.string()
            }).nullish(),
            retrievedContext: import_v440.z.object({
                uri: import_v440.z.string(),
                title: import_v440.z.string()
            }).nullish()
        })).nullish(),
        groundingSupports: import_v440.z.array(import_v440.z.object({
            segment: import_v440.z.object({
                startIndex: import_v440.z.number().nullish(),
                endIndex: import_v440.z.number().nullish(),
                text: import_v440.z.string().nullish()
            }),
            segment_text: import_v440.z.string().nullish(),
            groundingChunkIndices: import_v440.z.array(import_v440.z.number()).nullish(),
            supportChunkIndices: import_v440.z.array(import_v440.z.number()).nullish(),
            confidenceScores: import_v440.z.array(import_v440.z.number()).nullish(),
            confidenceScore: import_v440.z.array(import_v440.z.number()).nullish()
        })).nullish(),
        retrievalMetadata: import_v440.z.union([
            import_v440.z.object({
                webDynamicRetrievalScore: import_v440.z.number()
            }),
            import_v440.z.object({})
        ]).nullish()
    });
var getContentSchema = ()=>import_v440.z.object({
        parts: import_v440.z.array(import_v440.z.union([
            // note: order matters since text can be fully empty
            import_v440.z.object({
                functionCall: import_v440.z.object({
                    name: import_v440.z.string(),
                    args: import_v440.z.unknown()
                }),
                thoughtSignature: import_v440.z.string().nullish()
            }),
            import_v440.z.object({
                inlineData: import_v440.z.object({
                    mimeType: import_v440.z.string(),
                    data: import_v440.z.string()
                })
            }),
            import_v440.z.object({
                executableCode: import_v440.z.object({
                    language: import_v440.z.string(),
                    code: import_v440.z.string()
                }).nullish(),
                codeExecutionResult: import_v440.z.object({
                    outcome: import_v440.z.string(),
                    output: import_v440.z.string()
                }).nullish(),
                text: import_v440.z.string().nullish(),
                thought: import_v440.z.boolean().nullish(),
                thoughtSignature: import_v440.z.string().nullish()
            })
        ])).nullish()
    });
var getSafetyRatingSchema = ()=>import_v440.z.object({
        category: import_v440.z.string().nullish(),
        probability: import_v440.z.string().nullish(),
        probabilityScore: import_v440.z.number().nullish(),
        severity: import_v440.z.string().nullish(),
        severityScore: import_v440.z.number().nullish(),
        blocked: import_v440.z.boolean().nullish()
    });
var usageSchema = import_v440.z.object({
    cachedContentTokenCount: import_v440.z.number().nullish(),
    thoughtsTokenCount: import_v440.z.number().nullish(),
    promptTokenCount: import_v440.z.number().nullish(),
    candidatesTokenCount: import_v440.z.number().nullish(),
    totalTokenCount: import_v440.z.number().nullish()
});
var getUrlContextMetadataSchema = ()=>import_v440.z.object({
        urlMetadata: import_v440.z.array(import_v440.z.object({
            retrievedUrl: import_v440.z.string(),
            urlRetrievalStatus: import_v440.z.string()
        }))
    });
var responseSchema = lazySchema(()=>zodSchema(import_v440.z.object({
        candidates: import_v440.z.array(import_v440.z.object({
            content: getContentSchema().nullish().or(import_v440.z.object({}).strict()),
            finishReason: import_v440.z.string().nullish(),
            safetyRatings: import_v440.z.array(getSafetyRatingSchema()).nullish(),
            groundingMetadata: getGroundingMetadataSchema().nullish(),
            urlContextMetadata: getUrlContextMetadataSchema().nullish()
        })),
        usageMetadata: usageSchema.nullish(),
        promptFeedback: import_v440.z.object({
            blockReason: import_v440.z.string().nullish(),
            safetyRatings: import_v440.z.array(getSafetyRatingSchema()).nullish()
        }).nullish()
    })));
var chunkSchema = lazySchema(()=>zodSchema(import_v440.z.object({
        candidates: import_v440.z.array(import_v440.z.object({
            content: getContentSchema().nullish(),
            finishReason: import_v440.z.string().nullish(),
            safetyRatings: import_v440.z.array(getSafetyRatingSchema()).nullish(),
            groundingMetadata: getGroundingMetadataSchema().nullish(),
            urlContextMetadata: getUrlContextMetadataSchema().nullish()
        })).nullish(),
        usageMetadata: usageSchema.nullish(),
        promptFeedback: import_v440.z.object({
            blockReason: import_v440.z.string().nullish(),
            safetyRatings: import_v440.z.array(getSafetyRatingSchema()).nullish()
        }).nullish()
    })));
var codeExecution = createProviderDefinedToolFactoryWithOutputSchema({
    id: "google.code_execution",
    name: "code_execution",
    inputSchema: import_v442.z.object({
        language: import_v442.z.string().describe("The programming language of the code."),
        code: import_v442.z.string().describe("The code to be executed.")
    }),
    outputSchema: import_v442.z.object({
        outcome: import_v442.z.string().describe('The outcome of the execution (e.g., "OUTCOME_OK").'),
        output: import_v442.z.string().describe("The output from the code execution.")
    })
});
var googleSearch = createProviderDefinedToolFactory({
    id: "google.google_search",
    name: "google_search",
    inputSchema: lazySchema(()=>zodSchema(import_v443.z.object({
            mode: import_v443.z.enum([
                "MODE_DYNAMIC",
                "MODE_UNSPECIFIED"
            ]).default("MODE_UNSPECIFIED"),
            dynamicThreshold: import_v443.z.number().default(1)
        })))
});
var urlContext = createProviderDefinedToolFactory({
    id: "google.url_context",
    name: "url_context",
    inputSchema: lazySchema(()=>zodSchema(import_v444.z.object({})))
});
var googleTools = {
    /**
   * Creates a Google search tool that gives Google direct access to real-time web content.
   * Must have name "google_search".
   */ googleSearch,
    /**
   * Creates a URL context tool that gives Google direct access to real-time web content.
   * Must have name "url_context".
   */ urlContext,
    /**
   * A tool that enables the model to generate and run Python code.
   * Must have name "code_execution".
   *
   * @note Ensure the selected model supports Code Execution.
   * Multi-tool usage with the code execution tool is typically compatible with Gemini >=2 models.
   *
   * @see https://ai.google.dev/gemini-api/docs/code-execution (Google AI)
   * @see https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/code-execution-api (Vertex AI)
   */ codeExecution
};
var GoogleGenerativeAIImageModel = class {
    constructor(modelId, settings, config){
        this.modelId = modelId;
        this.settings = settings;
        this.config = config;
        this.specificationVersion = "v2";
    }
    get maxImagesPerCall() {
        var _a;
        return (_a = this.settings.maxImagesPerCall) != null ? _a : 4;
    }
    get provider() {
        return this.config.provider;
    }
    doGenerate(options) {
        return __async(this, null, function*() {
            var _a, _b, _c;
            const { prompt, n = 1, size = "1024x1024", aspectRatio = "1:1", seed, providerOptions, headers, abortSignal } = options;
            const warnings = [];
            if (size != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "size",
                    details: "This model does not support the `size` option. Use `aspectRatio` instead."
                });
            }
            if (seed != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "seed",
                    details: "This model does not support the `seed` option through this provider."
                });
            }
            const googleOptions = yield parseProviderOptions({
                provider: "google",
                providerOptions,
                schema: googleImageProviderOptionsSchema
            });
            const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();
            const parameters = {
                sampleCount: n
            };
            if (aspectRatio != null) {
                parameters.aspectRatio = aspectRatio;
            }
            if (googleOptions) {
                Object.assign(parameters, googleOptions);
            }
            const body = {
                instances: [
                    {
                        prompt
                    }
                ],
                parameters
            };
            const { responseHeaders, value: response } = yield postJsonToApi({
                url: `${this.config.baseURL}/models/${this.modelId}:predict`,
                headers: combineHeaders((yield resolve(this.config.headers)), headers),
                body,
                failedResponseHandler: googleFailedResponseHandler,
                successfulResponseHandler: createJsonResponseHandler(googleImageResponseSchema),
                abortSignal,
                fetch: this.config.fetch
            });
            return {
                images: response.predictions.map((p)=>p.bytesBase64Encoded),
                warnings: warnings != null ? warnings : [],
                providerMetadata: {
                    google: {
                        images: response.predictions.map((prediction)=>({
                            }))
                    }
                },
                response: {
                    timestamp: currentDate,
                    modelId: this.modelId,
                    headers: responseHeaders
                }
            };
        });
    }
};
var googleImageResponseSchema = lazySchema(()=>zodSchema(import_v445.z.object({
        predictions: import_v445.z.array(import_v445.z.object({
            bytesBase64Encoded: import_v445.z.string()
        })).default([])
    })));
var googleImageProviderOptionsSchema = lazySchema(()=>zodSchema(import_v445.z.object({
        personGeneration: import_v445.z.enum([
            "dont_allow",
            "allow_adult",
            "allow_all"
        ]).nullish(),
        aspectRatio: import_v445.z.enum([
            "1:1",
            "3:4",
            "4:3",
            "9:16",
            "16:9"
        ]).nullish()
    })));
function createGoogleGenerativeAI(options = {}) {
    var _a;
    const baseURL = (_a = withoutTrailingSlash(options.baseURL)) != null ? _a : "https://generativelanguage.googleapis.com/v1beta";
    const getHeaders = ()=>withUserAgentSuffix(__spreadValues({
            "x-goog-api-key": loadApiKey({
                apiKey: options.apiKey,
                environmentVariableName: "GOOGLE_GENERATIVE_AI_API_KEY",
                description: "Google Generative AI"
            })
        }, options.headers), `ai-sdk/google/${VERSION4}`);
    const createChatModel = (modelId)=>{
        var _a2;
        return new GoogleGenerativeAILanguageModel(modelId, {
            provider: "google.generative-ai",
            baseURL,
            headers: getHeaders,
            generateId: (_a2 = options.generateId) != null ? _a2 : generateId,
            supportedUrls: ()=>({
                    "*": [
                        // Google Generative Language "files" endpoint
                        // e.g. https://generativelanguage.googleapis.com/v1beta/files/...
                        new RegExp(`^${baseURL}/files/.*$`),
                        // YouTube URLs (public or unlisted videos)
                        new RegExp(`^https://(?:www\\.)?youtube\\.com/watch\\?v=[\\w-]+(?:&[\\w=&.-]*)?$`),
                        new RegExp(`^https://youtu\\.be/[\\w-]+(?:\\?[\\w=&.-]*)?$`)
                    ]
                }),
            fetch: options.fetch
        });
    };
    const createEmbeddingModel = (modelId)=>new GoogleGenerativeAIEmbeddingModel(modelId, {
            provider: "google.generative-ai",
            baseURL,
            headers: getHeaders,
            fetch: options.fetch
        });
    const createImageModel = (modelId, settings = {})=>new GoogleGenerativeAIImageModel(modelId, settings, {
            provider: "google.generative-ai",
            baseURL,
            headers: getHeaders,
            fetch: options.fetch
        });
    const provider = function(modelId) {
        if (new.target) {
            throw new Error("The Google Generative AI model function cannot be called with the new keyword.");
        }
        return createChatModel(modelId);
    };
    provider.languageModel = createChatModel;
    provider.chat = createChatModel;
    provider.generativeAI = createChatModel;
    provider.embedding = createEmbeddingModel;
    provider.textEmbedding = createEmbeddingModel;
    provider.textEmbeddingModel = createEmbeddingModel;
    provider.image = createImageModel;
    provider.imageModel = createImageModel;
    provider.tools = googleTools;
    return provider;
}
var google = createGoogleGenerativeAI();
// ../../node_modules/.pnpm/@ai-sdk+openai-compatible@1.0.22_zod@3.25.67/node_modules/@ai-sdk/openai-compatible/dist/index.mjs
var import_provider27 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v446 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_provider28 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v447 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v448 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_provider29 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v449 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_provider30 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v450 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_provider31 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v451 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v452 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v453 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
function getOpenAIMetadata(message) {
    var _a, _b;
    return (_b = (_a = message == null ? void 0 : message.providerOptions) == null ? void 0 : _a.openaiCompatible) != null ? _b : {};
}
function convertToOpenAICompatibleChatMessages(prompt) {
    const messages = [];
    for (const _a of prompt){
        const _b = _a, { role, content } = _b, message = __objRest(_b, [
            "role",
            "content"
        ]);
        const metadata = getOpenAIMetadata(__spreadValues({}, message));
        switch(role){
            case "system":
                {
                    messages.push(__spreadValues({
                        role: "system",
                        content
                    }, metadata));
                    break;
                }
            case "user":
                {
                    if (content.length === 1 && content[0].type === "text") {
                        messages.push(__spreadValues({
                            role: "user",
                            content: content[0].text
                        }, getOpenAIMetadata(content[0])));
                        break;
                    }
                    messages.push(__spreadValues({
                        role: "user",
                        content: content.map((part)=>{
                            const partMetadata = getOpenAIMetadata(part);
                            switch(part.type){
                                case "text":
                                    {
                                        return __spreadValues({
                                            type: "text",
                                            text: part.text
                                        }, partMetadata);
                                    }
                                case "file":
                                    {
                                        if (part.mediaType.startsWith("image/")) {
                                            const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                                            return __spreadValues({
                                                type: "image_url",
                                                image_url: {
                                                    url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${convertToBase64(part.data)}`
                                                }
                                            }, partMetadata);
                                        } else {
                                            throw new import_provider28.UnsupportedFunctionalityError({
                                                functionality: `file part media type ${part.mediaType}`
                                            });
                                        }
                                    }
                            }
                        })
                    }, metadata));
                    break;
                }
            case "assistant":
                {
                    let text = "";
                    const toolCalls = [];
                    for (const part of content){
                        const partMetadata = getOpenAIMetadata(part);
                        switch(part.type){
                            case "text":
                                {
                                    text += part.text;
                                    break;
                                }
                            case "tool-call":
                                {
                                    toolCalls.push(__spreadValues({
                                        id: part.toolCallId,
                                        type: "function",
                                        function: {
                                            name: part.toolName,
                                            arguments: JSON.stringify(part.input)
                                        }
                                    }, partMetadata));
                                    break;
                                }
                        }
                    }
                    messages.push(__spreadValues({
                        role: "assistant",
                        content: text,
                        tool_calls: toolCalls.length > 0 ? toolCalls : void 0
                    }, metadata));
                    break;
                }
            case "tool":
                {
                    for (const toolResponse of content){
                        const output = toolResponse.output;
                        let contentValue;
                        switch(output.type){
                            case "text":
                            case "error-text":
                                contentValue = output.value;
                                break;
                            case "content":
                            case "json":
                            case "error-json":
                                contentValue = JSON.stringify(output.value);
                                break;
                        }
                        const toolResponseMetadata = getOpenAIMetadata(toolResponse);
                        messages.push(__spreadValues({
                            role: "tool",
                            tool_call_id: toolResponse.toolCallId,
                            content: contentValue
                        }, toolResponseMetadata));
                    }
                    break;
                }
            default:
                {
                    const _exhaustiveCheck = role;
                    throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
                }
        }
    }
    return messages;
}
function getResponseMetadata3({ id, model, created }) {
    return {
        id: id != null ? id : void 0,
        modelId: model != null ? model : void 0,
        timestamp: created != null ? new Date(created * 1e3) : void 0
    };
}
function mapOpenAICompatibleFinishReason(finishReason) {
    switch(finishReason){
        case "stop":
            return "stop";
        case "length":
            return "length";
        case "content_filter":
            return "content-filter";
        case "function_call":
        case "tool_calls":
            return "tool-calls";
        default:
            return "unknown";
    }
}
var openaiCompatibleProviderOptions = import_v447.z.object({
    /**
   * A unique identifier representing your end-user, which can help the provider to
   * monitor and detect abuse.
   */ user: import_v447.z.string().optional(),
    /**
   * Reasoning effort for reasoning models. Defaults to `medium`.
   */ reasoningEffort: import_v447.z.string().optional(),
    /**
   * Controls the verbosity of the generated text. Defaults to `medium`.
   */ textVerbosity: import_v447.z.string().optional()
});
var openaiCompatibleErrorDataSchema = import_v448.z.object({
    error: import_v448.z.object({
        message: import_v448.z.string(),
        // The additional information below is handled loosely to support
        // OpenAI-compatible providers that have slightly different error
        // responses:
        type: import_v448.z.string().nullish(),
        param: import_v448.z.any().nullish(),
        code: import_v448.z.union([
            import_v448.z.string(),
            import_v448.z.number()
        ]).nullish()
    })
});
var defaultOpenAICompatibleErrorStructure = {
    errorSchema: openaiCompatibleErrorDataSchema,
    errorToMessage: (data)=>data.error.message
};
function prepareTools3({ tools, toolChoice }) {
    tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
    const toolWarnings = [];
    if (tools == null) {
        return {
            tools: void 0,
            toolChoice: void 0,
            toolWarnings
        };
    }
    const openaiCompatTools = [];
    for (const tool12 of tools){
        if (tool12.type === "provider-defined") {
            toolWarnings.push({
                type: "unsupported-tool",
                tool: tool12
            });
        } else {
            openaiCompatTools.push({
                type: "function",
                function: {
                    name: tool12.name,
                    description: tool12.description,
                    parameters: tool12.inputSchema
                }
            });
        }
    }
    if (toolChoice == null) {
        return {
            tools: openaiCompatTools,
            toolChoice: void 0,
            toolWarnings
        };
    }
    const type = toolChoice.type;
    switch(type){
        case "auto":
        case "none":
        case "required":
            return {
                tools: openaiCompatTools,
                toolChoice: type,
                toolWarnings
            };
        case "tool":
            return {
                tools: openaiCompatTools,
                toolChoice: {
                    type: "function",
                    function: {
                        name: toolChoice.toolName
                    }
                },
                toolWarnings
            };
        default:
            {
                const _exhaustiveCheck = type;
                throw new import_provider29.UnsupportedFunctionalityError({
                    functionality: `tool choice type: ${_exhaustiveCheck}`
                });
            }
    }
}
var OpenAICompatibleChatLanguageModel = class {
    // type inferred via constructor
    constructor(modelId, config){
        this.specificationVersion = "v2";
        var _a, _b;
        this.modelId = modelId;
        this.config = config;
        const errorStructure = (_a = config.errorStructure) != null ? _a : defaultOpenAICompatibleErrorStructure;
        this.chunkSchema = createOpenAICompatibleChatChunkSchema(errorStructure.errorSchema);
        this.failedResponseHandler = createJsonErrorResponseHandler(errorStructure);
        this.supportsStructuredOutputs = (_b = config.supportsStructuredOutputs) != null ? _b : false;
    }
    get provider() {
        return this.config.provider;
    }
    get providerOptionsName() {
        return this.config.provider.split(".")[0].trim();
    }
    get supportedUrls() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.config).supportedUrls) == null ? void 0 : _b.call(_a)) != null ? _c : {};
    }
    getArgs(_0) {
        return __async(this, arguments, function*({ prompt, maxOutputTokens, temperature, topP, topK, frequencyPenalty, presencePenalty, providerOptions, stopSequences, responseFormat, seed, toolChoice, tools }) {
            var _a, _b, _c, _d;
            const warnings = [];
            const compatibleOptions = Object.assign((_a = yield parseProviderOptions({
                provider: "openai-compatible",
                providerOptions,
                schema: openaiCompatibleProviderOptions
            })) != null ? _a : {}, (_b = yield parseProviderOptions({
                provider: this.providerOptionsName,
                providerOptions,
                schema: openaiCompatibleProviderOptions
            })) != null ? _b : {});
            if (topK != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "topK"
                });
            }
            if ((responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && !this.supportsStructuredOutputs) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "responseFormat",
                    details: "JSON response format schema is only supported with structuredOutputs"
                });
            }
            const { tools: openaiTools2, toolChoice: openaiToolChoice, toolWarnings } = prepareTools3({
                tools,
                toolChoice
            });
            return {
                args: __spreadProps(__spreadValues({
                    // model id:
                    model: this.modelId,
                    // model specific settings:
                    user: compatibleOptions.user,
                    // standardized settings:
                    max_tokens: maxOutputTokens,
                    temperature,
                    top_p: topP,
                    frequency_penalty: frequencyPenalty,
                    presence_penalty: presencePenalty,
                    response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? this.supportsStructuredOutputs === true && responseFormat.schema != null ? {
                        type: "json_schema",
                        json_schema: {
                            schema: responseFormat.schema,
                            name: (_c = responseFormat.name) != null ? _c : "response",
                            description: responseFormat.description
                        }
                    } : {
                        type: "json_object"
                    } : void 0,
                    stop: stopSequences,
                    seed
                }, Object.fromEntries(Object.entries((_d = providerOptions == null ? void 0 : providerOptions[this.providerOptionsName]) != null ? _d : {}).filter(([key])=>!Object.keys(openaiCompatibleProviderOptions.shape).includes(key)))), {
                    reasoning_effort: compatibleOptions.reasoningEffort,
                    verbosity: compatibleOptions.textVerbosity,
                    // messages:
                    messages: convertToOpenAICompatibleChatMessages(prompt),
                    // tools:
                    tools: openaiTools2,
                    tool_choice: openaiToolChoice
                }),
                warnings: [
                    ...warnings,
                    ...toolWarnings
                ]
            };
        });
    }
    doGenerate(options) {
        return __async(this, null, function*() {
            var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;
            const { args, warnings } = yield this.getArgs(__spreadValues({}, options));
            const body = JSON.stringify(args);
            const { responseHeaders, value: responseBody, rawValue: rawResponse } = yield postJsonToApi({
                url: this.config.url({
                    path: "/chat/completions",
                    modelId: this.modelId
                }),
                headers: combineHeaders(this.config.headers(), options.headers),
                body: args,
                failedResponseHandler: this.failedResponseHandler,
                successfulResponseHandler: createJsonResponseHandler(OpenAICompatibleChatResponseSchema),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            const choice = responseBody.choices[0];
            const content = [];
            const text = choice.message.content;
            if (text != null && text.length > 0) {
                content.push({
                    type: "text",
                    text
                });
            }
            const reasoning = (_a = choice.message.reasoning_content) != null ? _a : choice.message.reasoning;
            if (reasoning != null && reasoning.length > 0) {
                content.push({
                    type: "reasoning",
                    text: reasoning
                });
            }
            if (choice.message.tool_calls != null) {
                for (const toolCall of choice.message.tool_calls){
                    content.push({
                        type: "tool-call",
                        toolCallId: (_b = toolCall.id) != null ? _b : generateId(),
                        toolName: toolCall.function.name,
                        input: toolCall.function.arguments
                    });
                }
            }
            const providerMetadata = __spreadValues({
                [this.providerOptionsName]: {}
            }, (yield (_d = (_c = this.config.metadataExtractor) == null ? void 0 : _c.extractMetadata) == null ? void 0 : _d.call(_c, {
                parsedBody: rawResponse
            })));
            const completionTokenDetails = (_e = responseBody.usage) == null ? void 0 : _e.completion_tokens_details;
            if ((completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens) != null) {
                providerMetadata[this.providerOptionsName].acceptedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens;
            }
            if ((completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens) != null) {
                providerMetadata[this.providerOptionsName].rejectedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens;
            }
            return {
                content,
                finishReason: mapOpenAICompatibleFinishReason(choice.finish_reason),
                usage: {
                    inputTokens: (_g = (_f = responseBody.usage) == null ? void 0 : _f.prompt_tokens) != null ? _g : void 0,
                    outputTokens: (_i = (_h = responseBody.usage) == null ? void 0 : _h.completion_tokens) != null ? _i : void 0,
                    totalTokens: (_k = (_j = responseBody.usage) == null ? void 0 : _j.total_tokens) != null ? _k : void 0,
                    reasoningTokens: (_n = (_m = (_l = responseBody.usage) == null ? void 0 : _l.completion_tokens_details) == null ? void 0 : _m.reasoning_tokens) != null ? _n : void 0,
                    cachedInputTokens: (_q = (_p = (_o = responseBody.usage) == null ? void 0 : _o.prompt_tokens_details) == null ? void 0 : _p.cached_tokens) != null ? _q : void 0
                },
                providerMetadata,
                request: {
                    body
                },
                response: __spreadProps(__spreadValues({}, getResponseMetadata3(responseBody)), {
                    headers: responseHeaders,
                    body: rawResponse
                }),
                warnings
            };
        });
    }
    doStream(options) {
        return __async(this, null, function*() {
            var _a;
            const { args, warnings } = yield this.getArgs(__spreadValues({}, options));
            const body = __spreadProps(__spreadValues({}, args), {
                stream: true,
                // only include stream_options when in strict compatibility mode:
                stream_options: this.config.includeUsage ? {
                    include_usage: true
                } : void 0
            });
            const metadataExtractor = (_a = this.config.metadataExtractor) == null ? void 0 : _a.createStreamExtractor();
            const { responseHeaders, value: response } = yield postJsonToApi({
                url: this.config.url({
                    path: "/chat/completions",
                    modelId: this.modelId
                }),
                headers: combineHeaders(this.config.headers(), options.headers),
                body,
                failedResponseHandler: this.failedResponseHandler,
                successfulResponseHandler: createEventSourceResponseHandler(this.chunkSchema),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            const toolCalls = [];
            let finishReason = "unknown";
            const usage = {
                completionTokens: void 0,
                completionTokensDetails: {
                    reasoningTokens: void 0,
                    acceptedPredictionTokens: void 0,
                    rejectedPredictionTokens: void 0
                },
                promptTokens: void 0,
                promptTokensDetails: {
                    cachedTokens: void 0
                },
                totalTokens: void 0
            };
            let isFirstChunk = true;
            const providerOptionsName = this.providerOptionsName;
            let isActiveReasoning = false;
            let isActiveText = false;
            return {
                stream: response.pipeThrough(new TransformStream({
                    start (controller) {
                        controller.enqueue({
                            type: "stream-start",
                            warnings
                        });
                    },
                    // TODO we lost type safety on Chunk, most likely due to the error schema. MUST FIX
                    transform (chunk, controller) {
                        var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
                        if (options.includeRawChunks) {
                            controller.enqueue({
                                type: "raw",
                                rawValue: chunk.rawValue
                            });
                        }
                        if (!chunk.success) {
                            finishReason = "error";
                            controller.enqueue({
                                type: "error",
                                error: chunk.error
                            });
                            return;
                        }
                        const value = chunk.value;
                        metadataExtractor == null ? void 0 : metadataExtractor.processChunk(chunk.rawValue);
                        if ("error" in value) {
                            finishReason = "error";
                            controller.enqueue({
                                type: "error",
                                error: value.error.message
                            });
                            return;
                        }
                        if (isFirstChunk) {
                            isFirstChunk = false;
                            controller.enqueue(__spreadValues({
                                type: "response-metadata"
                            }, getResponseMetadata3(value)));
                        }
                        if (value.usage != null) {
                            const { prompt_tokens, completion_tokens, total_tokens, prompt_tokens_details, completion_tokens_details } = value.usage;
                            usage.promptTokens = prompt_tokens != null ? prompt_tokens : void 0;
                            usage.completionTokens = completion_tokens != null ? completion_tokens : void 0;
                            usage.totalTokens = total_tokens != null ? total_tokens : void 0;
                            if ((completion_tokens_details == null ? void 0 : completion_tokens_details.reasoning_tokens) != null) {
                                usage.completionTokensDetails.reasoningTokens = completion_tokens_details == null ? void 0 : completion_tokens_details.reasoning_tokens;
                            }
                            if ((completion_tokens_details == null ? void 0 : completion_tokens_details.accepted_prediction_tokens) != null) {
                                usage.completionTokensDetails.acceptedPredictionTokens = completion_tokens_details == null ? void 0 : completion_tokens_details.accepted_prediction_tokens;
                            }
                            if ((completion_tokens_details == null ? void 0 : completion_tokens_details.rejected_prediction_tokens) != null) {
                                usage.completionTokensDetails.rejectedPredictionTokens = completion_tokens_details == null ? void 0 : completion_tokens_details.rejected_prediction_tokens;
                            }
                            if ((prompt_tokens_details == null ? void 0 : prompt_tokens_details.cached_tokens) != null) {
                                usage.promptTokensDetails.cachedTokens = prompt_tokens_details == null ? void 0 : prompt_tokens_details.cached_tokens;
                            }
                        }
                        const choice = value.choices[0];
                        if ((choice == null ? void 0 : choice.finish_reason) != null) {
                            finishReason = mapOpenAICompatibleFinishReason(choice.finish_reason);
                        }
                        if ((choice == null ? void 0 : choice.delta) == null) {
                            return;
                        }
                        const delta = choice.delta;
                        const reasoningContent = (_a2 = delta.reasoning_content) != null ? _a2 : delta.reasoning;
                        if (reasoningContent) {
                            if (!isActiveReasoning) {
                                controller.enqueue({
                                    type: "reasoning-start",
                                    id: "reasoning-0"
                                });
                                isActiveReasoning = true;
                            }
                            controller.enqueue({
                                type: "reasoning-delta",
                                id: "reasoning-0",
                                delta: reasoningContent
                            });
                        }
                        if (delta.content) {
                            if (!isActiveText) {
                                controller.enqueue({
                                    type: "text-start",
                                    id: "txt-0"
                                });
                                isActiveText = true;
                            }
                            controller.enqueue({
                                type: "text-delta",
                                id: "txt-0",
                                delta: delta.content
                            });
                        }
                        if (delta.tool_calls != null) {
                            for (const toolCallDelta of delta.tool_calls){
                                const index = toolCallDelta.index;
                                if (toolCalls[index] == null) {
                                    if (toolCallDelta.id == null) {
                                        throw new import_provider27.InvalidResponseDataError({
                                            data: toolCallDelta,
                                            message: `Expected 'id' to be a string.`
                                        });
                                    }
                                    if (((_b = toolCallDelta.function) == null ? void 0 : _b.name) == null) {
                                        throw new import_provider27.InvalidResponseDataError({
                                            data: toolCallDelta,
                                            message: `Expected 'function.name' to be a string.`
                                        });
                                    }
                                    controller.enqueue({
                                        type: "tool-input-start",
                                        id: toolCallDelta.id,
                                        toolName: toolCallDelta.function.name
                                    });
                                    toolCalls[index] = {
                                        id: toolCallDelta.id,
                                        type: "function",
                                        function: {
                                            name: toolCallDelta.function.name,
                                            arguments: (_c = toolCallDelta.function.arguments) != null ? _c : ""
                                        },
                                        hasFinished: false
                                    };
                                    const toolCall2 = toolCalls[index];
                                    if (((_d = toolCall2.function) == null ? void 0 : _d.name) != null && ((_e = toolCall2.function) == null ? void 0 : _e.arguments) != null) {
                                        if (toolCall2.function.arguments.length > 0) {
                                            controller.enqueue({
                                                type: "tool-input-delta",
                                                id: toolCall2.id,
                                                delta: toolCall2.function.arguments
                                            });
                                        }
                                        if (isParsableJson(toolCall2.function.arguments)) {
                                            controller.enqueue({
                                                type: "tool-input-end",
                                                id: toolCall2.id
                                            });
                                            controller.enqueue({
                                                type: "tool-call",
                                                toolCallId: (_f = toolCall2.id) != null ? _f : generateId(),
                                                toolName: toolCall2.function.name,
                                                input: toolCall2.function.arguments
                                            });
                                            toolCall2.hasFinished = true;
                                        }
                                    }
                                    continue;
                                }
                                const toolCall = toolCalls[index];
                                if (toolCall.hasFinished) {
                                    continue;
                                }
                                if (((_g = toolCallDelta.function) == null ? void 0 : _g.arguments) != null) {
                                    toolCall.function.arguments += (_i = (_h = toolCallDelta.function) == null ? void 0 : _h.arguments) != null ? _i : "";
                                }
                                controller.enqueue({
                                    type: "tool-input-delta",
                                    id: toolCall.id,
                                    delta: (_j = toolCallDelta.function.arguments) != null ? _j : ""
                                });
                                if (((_k = toolCall.function) == null ? void 0 : _k.name) != null && ((_l = toolCall.function) == null ? void 0 : _l.arguments) != null && isParsableJson(toolCall.function.arguments)) {
                                    controller.enqueue({
                                        type: "tool-input-end",
                                        id: toolCall.id
                                    });
                                    controller.enqueue({
                                        type: "tool-call",
                                        toolCallId: (_m = toolCall.id) != null ? _m : generateId(),
                                        toolName: toolCall.function.name,
                                        input: toolCall.function.arguments
                                    });
                                    toolCall.hasFinished = true;
                                }
                            }
                        }
                    },
                    flush (controller) {
                        var _a2, _b, _c, _d, _e, _f;
                        if (isActiveReasoning) {
                            controller.enqueue({
                                type: "reasoning-end",
                                id: "reasoning-0"
                            });
                        }
                        if (isActiveText) {
                            controller.enqueue({
                                type: "text-end",
                                id: "txt-0"
                            });
                        }
                        for (const toolCall of toolCalls.filter((toolCall2)=>!toolCall2.hasFinished)){
                            controller.enqueue({
                                type: "tool-input-end",
                                id: toolCall.id
                            });
                            controller.enqueue({
                                type: "tool-call",
                                toolCallId: (_a2 = toolCall.id) != null ? _a2 : generateId(),
                                toolName: toolCall.function.name,
                                input: toolCall.function.arguments
                            });
                        }
                        const providerMetadata = __spreadValues({
                            [providerOptionsName]: {}
                        }, metadataExtractor == null ? void 0 : metadataExtractor.buildMetadata());
                        if (usage.completionTokensDetails.acceptedPredictionTokens != null) {
                            providerMetadata[providerOptionsName].acceptedPredictionTokens = usage.completionTokensDetails.acceptedPredictionTokens;
                        }
                        if (usage.completionTokensDetails.rejectedPredictionTokens != null) {
                            providerMetadata[providerOptionsName].rejectedPredictionTokens = usage.completionTokensDetails.rejectedPredictionTokens;
                        }
                        controller.enqueue({
                            type: "finish",
                            finishReason,
                            usage: {
                                inputTokens: (_b = usage.promptTokens) != null ? _b : void 0,
                                outputTokens: (_c = usage.completionTokens) != null ? _c : void 0,
                                totalTokens: (_d = usage.totalTokens) != null ? _d : void 0,
                                reasoningTokens: (_e = usage.completionTokensDetails.reasoningTokens) != null ? _e : void 0,
                                cachedInputTokens: (_f = usage.promptTokensDetails.cachedTokens) != null ? _f : void 0
                            },
                            providerMetadata
                        });
                    }
                })),
                request: {
                    body
                },
                response: {
                    headers: responseHeaders
                }
            };
        });
    }
};
var openaiCompatibleTokenUsageSchema = import_v446.z.object({
    prompt_tokens: import_v446.z.number().nullish(),
    completion_tokens: import_v446.z.number().nullish(),
    total_tokens: import_v446.z.number().nullish(),
    prompt_tokens_details: import_v446.z.object({
        cached_tokens: import_v446.z.number().nullish()
    }).nullish(),
    completion_tokens_details: import_v446.z.object({
        reasoning_tokens: import_v446.z.number().nullish(),
        accepted_prediction_tokens: import_v446.z.number().nullish(),
        rejected_prediction_tokens: import_v446.z.number().nullish()
    }).nullish()
}).nullish();
var OpenAICompatibleChatResponseSchema = import_v446.z.object({
    id: import_v446.z.string().nullish(),
    created: import_v446.z.number().nullish(),
    model: import_v446.z.string().nullish(),
    choices: import_v446.z.array(import_v446.z.object({
        message: import_v446.z.object({
            role: import_v446.z.literal("assistant").nullish(),
            content: import_v446.z.string().nullish(),
            reasoning_content: import_v446.z.string().nullish(),
            reasoning: import_v446.z.string().nullish(),
            tool_calls: import_v446.z.array(import_v446.z.object({
                id: import_v446.z.string().nullish(),
                function: import_v446.z.object({
                    name: import_v446.z.string(),
                    arguments: import_v446.z.string()
                })
            })).nullish()
        }),
        finish_reason: import_v446.z.string().nullish()
    })),
    usage: openaiCompatibleTokenUsageSchema
});
var createOpenAICompatibleChatChunkSchema = (errorSchema)=>import_v446.z.union([
        import_v446.z.object({
            id: import_v446.z.string().nullish(),
            created: import_v446.z.number().nullish(),
            model: import_v446.z.string().nullish(),
            choices: import_v446.z.array(import_v446.z.object({
                delta: import_v446.z.object({
                    role: import_v446.z.enum([
                        "assistant"
                    ]).nullish(),
                    content: import_v446.z.string().nullish(),
                    // Most openai-compatible models set `reasoning_content`, but some
                    // providers serving `gpt-oss` set `reasoning`. See #7866
                    reasoning_content: import_v446.z.string().nullish(),
                    reasoning: import_v446.z.string().nullish(),
                    tool_calls: import_v446.z.array(import_v446.z.object({
                        index: import_v446.z.number(),
                        id: import_v446.z.string().nullish(),
                        function: import_v446.z.object({
                            name: import_v446.z.string().nullish(),
                            arguments: import_v446.z.string().nullish()
                        })
                    })).nullish()
                }).nullish(),
                finish_reason: import_v446.z.string().nullish()
            })),
            usage: openaiCompatibleTokenUsageSchema
        }),
        errorSchema
    ]);
function convertToOpenAICompatibleCompletionPrompt({ prompt, user = "user", assistant = "assistant" }) {
    let text = "";
    if (prompt[0].role === "system") {
        text += `${prompt[0].content}

`;
        prompt = prompt.slice(1);
    }
    for (const { role, content } of prompt){
        switch(role){
            case "system":
                {
                    throw new import_provider30.InvalidPromptError({
                        message: "Unexpected system message in prompt: ${content}",
                        prompt
                    });
                }
            case "user":
                {
                    const userMessage = content.map((part)=>{
                        switch(part.type){
                            case "text":
                                {
                                    return part.text;
                                }
                        }
                    }).filter(Boolean).join("");
                    text += `${user}:
${userMessage}

`;
                    break;
                }
            case "assistant":
                {
                    const assistantMessage = content.map((part)=>{
                        switch(part.type){
                            case "text":
                                {
                                    return part.text;
                                }
                            case "tool-call":
                                {
                                    throw new import_provider30.UnsupportedFunctionalityError({
                                        functionality: "tool-call messages"
                                    });
                                }
                        }
                    }).join("");
                    text += `${assistant}:
${assistantMessage}

`;
                    break;
                }
            case "tool":
                {
                    throw new import_provider30.UnsupportedFunctionalityError({
                        functionality: "tool messages"
                    });
                }
            default:
                {
                    const _exhaustiveCheck = role;
                    throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
                }
        }
    }
    text += `${assistant}:
`;
    return {
        prompt: text,
        stopSequences: [
            `
${user}:`
        ]
    };
}
function getResponseMetadata22({ id, model, created }) {
    return {
        id: id != null ? id : void 0,
        modelId: model != null ? model : void 0,
        timestamp: created != null ? new Date(created * 1e3) : void 0
    };
}
function mapOpenAICompatibleFinishReason2(finishReason) {
    switch(finishReason){
        case "stop":
            return "stop";
        case "length":
            return "length";
        case "content_filter":
            return "content-filter";
        case "function_call":
        case "tool_calls":
            return "tool-calls";
        default:
            return "unknown";
    }
}
var openaiCompatibleCompletionProviderOptions = import_v450.z.object({
    /**
   * Echo back the prompt in addition to the completion.
   */ echo: import_v450.z.boolean().optional(),
    /**
   * Modify the likelihood of specified tokens appearing in the completion.
   *
   * Accepts a JSON object that maps tokens (specified by their token ID in
   * the GPT tokenizer) to an associated bias value from -100 to 100.
   */ logitBias: import_v450.z.record(import_v450.z.string(), import_v450.z.number()).optional(),
    /**
   * The suffix that comes after a completion of inserted text.
   */ suffix: import_v450.z.string().optional(),
    /**
   * A unique identifier representing your end-user, which can help providers to
   * monitor and detect abuse.
   */ user: import_v450.z.string().optional()
});
var OpenAICompatibleCompletionLanguageModel = class {
    // type inferred via constructor
    constructor(modelId, config){
        this.specificationVersion = "v2";
        var _a;
        this.modelId = modelId;
        this.config = config;
        const errorStructure = (_a = config.errorStructure) != null ? _a : defaultOpenAICompatibleErrorStructure;
        this.chunkSchema = createOpenAICompatibleCompletionChunkSchema(errorStructure.errorSchema);
        this.failedResponseHandler = createJsonErrorResponseHandler(errorStructure);
    }
    get provider() {
        return this.config.provider;
    }
    get providerOptionsName() {
        return this.config.provider.split(".")[0].trim();
    }
    get supportedUrls() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.config).supportedUrls) == null ? void 0 : _b.call(_a)) != null ? _c : {};
    }
    getArgs(_0) {
        return __async(this, arguments, function*({ prompt, maxOutputTokens, temperature, topP, topK, frequencyPenalty, presencePenalty, stopSequences: userStopSequences, responseFormat, seed, providerOptions, tools, toolChoice }) {
            var _a;
            const warnings = [];
            const completionOptions = (_a = yield parseProviderOptions({
                provider: this.providerOptionsName,
                providerOptions,
                schema: openaiCompatibleCompletionProviderOptions
            })) != null ? _a : {};
            if (topK != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "topK"
                });
            }
            if (tools == null ? void 0 : tools.length) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "tools"
                });
            }
            if (toolChoice != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "toolChoice"
                });
            }
            if (responseFormat != null && responseFormat.type !== "text") {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "responseFormat",
                    details: "JSON response format is not supported."
                });
            }
            const { prompt: completionPrompt, stopSequences } = convertToOpenAICompatibleCompletionPrompt({
                prompt
            });
            const stop2 = [
                ...stopSequences != null ? stopSequences : [],
                ...userStopSequences != null ? userStopSequences : []
            ];
            return {
                args: __spreadProps(__spreadValues({
                    // model id:
                    model: this.modelId,
                    // model specific settings:
                    echo: completionOptions.echo,
                    logit_bias: completionOptions.logitBias,
                    suffix: completionOptions.suffix,
                    user: completionOptions.user,
                    // standardized settings:
                    max_tokens: maxOutputTokens,
                    temperature,
                    top_p: topP,
                    frequency_penalty: frequencyPenalty,
                    presence_penalty: presencePenalty,
                    seed
                }, providerOptions == null ? void 0 : providerOptions[this.providerOptionsName]), {
                    // prompt:
                    prompt: completionPrompt,
                    // stop sequences:
                    stop: stop2.length > 0 ? stop2 : void 0
                }),
                warnings
            };
        });
    }
    doGenerate(options) {
        return __async(this, null, function*() {
            var _a, _b, _c, _d, _e, _f;
            const { args, warnings } = yield this.getArgs(options);
            const { responseHeaders, value: response, rawValue: rawResponse } = yield postJsonToApi({
                url: this.config.url({
                    path: "/completions",
                    modelId: this.modelId
                }),
                headers: combineHeaders(this.config.headers(), options.headers),
                body: args,
                failedResponseHandler: this.failedResponseHandler,
                successfulResponseHandler: createJsonResponseHandler(openaiCompatibleCompletionResponseSchema),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            const choice = response.choices[0];
            const content = [];
            if (choice.text != null && choice.text.length > 0) {
                content.push({
                    type: "text",
                    text: choice.text
                });
            }
            return {
                content,
                usage: {
                    inputTokens: (_b = (_a = response.usage) == null ? void 0 : _a.prompt_tokens) != null ? _b : void 0,
                    outputTokens: (_d = (_c = response.usage) == null ? void 0 : _c.completion_tokens) != null ? _d : void 0,
                    totalTokens: (_f = (_e = response.usage) == null ? void 0 : _e.total_tokens) != null ? _f : void 0
                },
                finishReason: mapOpenAICompatibleFinishReason2(choice.finish_reason),
                request: {
                    body: args
                },
                response: __spreadProps(__spreadValues({}, getResponseMetadata22(response)), {
                    headers: responseHeaders,
                    body: rawResponse
                }),
                warnings
            };
        });
    }
    doStream(options) {
        return __async(this, null, function*() {
            const { args, warnings } = yield this.getArgs(options);
            const body = __spreadProps(__spreadValues({}, args), {
                stream: true,
                // only include stream_options when in strict compatibility mode:
                stream_options: this.config.includeUsage ? {
                    include_usage: true
                } : void 0
            });
            const { responseHeaders, value: response } = yield postJsonToApi({
                url: this.config.url({
                    path: "/completions",
                    modelId: this.modelId
                }),
                headers: combineHeaders(this.config.headers(), options.headers),
                body,
                failedResponseHandler: this.failedResponseHandler,
                successfulResponseHandler: createEventSourceResponseHandler(this.chunkSchema),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            let finishReason = "unknown";
            const usage = {
                inputTokens: void 0,
                outputTokens: void 0,
                totalTokens: void 0
            };
            let isFirstChunk = true;
            return {
                stream: response.pipeThrough(new TransformStream({
                    start (controller) {
                        controller.enqueue({
                            type: "stream-start",
                            warnings
                        });
                    },
                    transform (chunk, controller) {
                        var _a, _b, _c;
                        if (options.includeRawChunks) {
                            controller.enqueue({
                                type: "raw",
                                rawValue: chunk.rawValue
                            });
                        }
                        if (!chunk.success) {
                            finishReason = "error";
                            controller.enqueue({
                                type: "error",
                                error: chunk.error
                            });
                            return;
                        }
                        const value = chunk.value;
                        if ("error" in value) {
                            finishReason = "error";
                            controller.enqueue({
                                type: "error",
                                error: value.error
                            });
                            return;
                        }
                        if (isFirstChunk) {
                            isFirstChunk = false;
                            controller.enqueue(__spreadValues({
                                type: "response-metadata"
                            }, getResponseMetadata22(value)));
                            controller.enqueue({
                                type: "text-start",
                                id: "0"
                            });
                        }
                        if (value.usage != null) {
                            usage.inputTokens = (_a = value.usage.prompt_tokens) != null ? _a : void 0;
                            usage.outputTokens = (_b = value.usage.completion_tokens) != null ? _b : void 0;
                            usage.totalTokens = (_c = value.usage.total_tokens) != null ? _c : void 0;
                        }
                        const choice = value.choices[0];
                        if ((choice == null ? void 0 : choice.finish_reason) != null) {
                            finishReason = mapOpenAICompatibleFinishReason2(choice.finish_reason);
                        }
                        if ((choice == null ? void 0 : choice.text) != null) {
                            controller.enqueue({
                                type: "text-delta",
                                id: "0",
                                delta: choice.text
                            });
                        }
                    },
                    flush (controller) {
                        if (!isFirstChunk) {
                            controller.enqueue({
                                type: "text-end",
                                id: "0"
                            });
                        }
                        controller.enqueue({
                            type: "finish",
                            finishReason,
                            usage
                        });
                    }
                })),
                request: {
                    body
                },
                response: {
                    headers: responseHeaders
                }
            };
        });
    }
};
var usageSchema2 = import_v449.z.object({
    prompt_tokens: import_v449.z.number(),
    completion_tokens: import_v449.z.number(),
    total_tokens: import_v449.z.number()
});
var openaiCompatibleCompletionResponseSchema = import_v449.z.object({
    id: import_v449.z.string().nullish(),
    created: import_v449.z.number().nullish(),
    model: import_v449.z.string().nullish(),
    choices: import_v449.z.array(import_v449.z.object({
        text: import_v449.z.string(),
        finish_reason: import_v449.z.string()
    })),
    usage: usageSchema2.nullish()
});
var createOpenAICompatibleCompletionChunkSchema = (errorSchema)=>import_v449.z.union([
        import_v449.z.object({
            id: import_v449.z.string().nullish(),
            created: import_v449.z.number().nullish(),
            model: import_v449.z.string().nullish(),
            choices: import_v449.z.array(import_v449.z.object({
                text: import_v449.z.string(),
                finish_reason: import_v449.z.string().nullish(),
                index: import_v449.z.number()
            })),
            usage: usageSchema2.nullish()
        }),
        errorSchema
    ]);
var openaiCompatibleEmbeddingProviderOptions = import_v452.z.object({
    /**
   * The number of dimensions the resulting output embeddings should have.
   * Only supported in text-embedding-3 and later models.
   */ dimensions: import_v452.z.number().optional(),
    /**
   * A unique identifier representing your end-user, which can help providers to
   * monitor and detect abuse.
   */ user: import_v452.z.string().optional()
});
var OpenAICompatibleEmbeddingModel = class {
    constructor(modelId, config){
        this.specificationVersion = "v2";
        this.modelId = modelId;
        this.config = config;
    }
    get provider() {
        return this.config.provider;
    }
    get maxEmbeddingsPerCall() {
        var _a;
        return (_a = this.config.maxEmbeddingsPerCall) != null ? _a : 2048;
    }
    get supportsParallelCalls() {
        var _a;
        return (_a = this.config.supportsParallelCalls) != null ? _a : true;
    }
    get providerOptionsName() {
        return this.config.provider.split(".")[0].trim();
    }
    doEmbed(_0) {
        return __async(this, arguments, function*({ values, headers, abortSignal, providerOptions }) {
            var _a, _b, _c;
            const compatibleOptions = Object.assign((_a = yield parseProviderOptions({
                provider: "openai-compatible",
                providerOptions,
                schema: openaiCompatibleEmbeddingProviderOptions
            })) != null ? _a : {}, (_b = yield parseProviderOptions({
                provider: this.providerOptionsName,
                providerOptions,
                schema: openaiCompatibleEmbeddingProviderOptions
            })) != null ? _b : {});
            if (values.length > this.maxEmbeddingsPerCall) {
                throw new import_provider31.TooManyEmbeddingValuesForCallError({
                    provider: this.provider,
                    modelId: this.modelId,
                    maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
                    values
                });
            }
            const { responseHeaders, value: response, rawValue } = yield postJsonToApi({
                url: this.config.url({
                    path: "/embeddings",
                    modelId: this.modelId
                }),
                headers: combineHeaders(this.config.headers(), headers),
                body: {
                    model: this.modelId,
                    input: values,
                    encoding_format: "float",
                    dimensions: compatibleOptions.dimensions,
                    user: compatibleOptions.user
                },
                failedResponseHandler: createJsonErrorResponseHandler((_c = this.config.errorStructure) != null ? _c : defaultOpenAICompatibleErrorStructure),
                successfulResponseHandler: createJsonResponseHandler(openaiTextEmbeddingResponseSchema2),
                abortSignal,
                fetch: this.config.fetch
            });
            return {
                embeddings: response.data.map((item)=>item.embedding),
                usage: response.usage ? {
                    tokens: response.usage.prompt_tokens
                } : void 0,
                providerMetadata: response.providerMetadata,
                response: {
                    headers: responseHeaders,
                    body: rawValue
                }
            };
        });
    }
};
var openaiTextEmbeddingResponseSchema2 = import_v451.z.object({
    data: import_v451.z.array(import_v451.z.object({
        embedding: import_v451.z.array(import_v451.z.number())
    })),
    usage: import_v451.z.object({
        prompt_tokens: import_v451.z.number()
    }).nullish(),
    providerMetadata: import_v451.z.record(import_v451.z.string(), import_v451.z.record(import_v451.z.string(), import_v451.z.any())).optional()
});
var OpenAICompatibleImageModel = class {
    constructor(modelId, config){
        this.modelId = modelId;
        this.config = config;
        this.specificationVersion = "v2";
        this.maxImagesPerCall = 10;
    }
    get provider() {
        return this.config.provider;
    }
    doGenerate(_0) {
        return __async(this, arguments, function*({ prompt, n, size, aspectRatio, seed, providerOptions, headers, abortSignal }) {
            var _a, _b, _c, _d, _e;
            const warnings = [];
            if (aspectRatio != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "aspectRatio",
                    details: "This model does not support aspect ratio. Use `size` instead."
                });
            }
            if (seed != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "seed"
                });
            }
            const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();
            const { value: response, responseHeaders } = yield postJsonToApi({
                url: this.config.url({
                    path: "/images/generations",
                    modelId: this.modelId
                }),
                headers: combineHeaders(this.config.headers(), headers),
                body: __spreadProps(__spreadValues({
                    model: this.modelId,
                    prompt,
                    n,
                    size
                }, (_d = providerOptions.openai) != null ? _d : {}), {
                    response_format: "b64_json"
                }),
                failedResponseHandler: createJsonErrorResponseHandler((_e = this.config.errorStructure) != null ? _e : defaultOpenAICompatibleErrorStructure),
                successfulResponseHandler: createJsonResponseHandler(openaiCompatibleImageResponseSchema),
                abortSignal,
                fetch: this.config.fetch
            });
            return {
                images: response.data.map((item)=>item.b64_json),
                warnings,
                response: {
                    timestamp: currentDate,
                    modelId: this.modelId,
                    headers: responseHeaders
                }
            };
        });
    }
};
var openaiCompatibleImageResponseSchema = import_v453.z.object({
    data: import_v453.z.array(import_v453.z.object({
        b64_json: import_v453.z.string()
    }))
});
// ../../node_modules/.pnpm/@ai-sdk+xai@2.0.26_zod@3.25.67/node_modules/@ai-sdk/xai/dist/index.mjs
var import_provider32 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v454 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_provider33 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v455 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v456 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_provider34 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
function convertToXaiChatMessages(prompt) {
    const messages = [];
    const warnings = [];
    for (const { role, content } of prompt){
        switch(role){
            case "system":
                {
                    messages.push({
                        role: "system",
                        content
                    });
                    break;
                }
            case "user":
                {
                    if (content.length === 1 && content[0].type === "text") {
                        messages.push({
                            role: "user",
                            content: content[0].text
                        });
                        break;
                    }
                    messages.push({
                        role: "user",
                        content: content.map((part)=>{
                            switch(part.type){
                                case "text":
                                    {
                                        return {
                                            type: "text",
                                            text: part.text
                                        };
                                    }
                                case "file":
                                    {
                                        if (part.mediaType.startsWith("image/")) {
                                            const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                                            return {
                                                type: "image_url",
                                                image_url: {
                                                    url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${convertToBase64(part.data)}`
                                                }
                                            };
                                        } else {
                                            throw new import_provider33.UnsupportedFunctionalityError({
                                                functionality: `file part media type ${part.mediaType}`
                                            });
                                        }
                                    }
                            }
                        })
                    });
                    break;
                }
            case "assistant":
                {
                    let text = "";
                    const toolCalls = [];
                    for (const part of content){
                        switch(part.type){
                            case "text":
                                {
                                    text += part.text;
                                    break;
                                }
                            case "tool-call":
                                {
                                    toolCalls.push({
                                        id: part.toolCallId,
                                        type: "function",
                                        function: {
                                            name: part.toolName,
                                            arguments: JSON.stringify(part.input)
                                        }
                                    });
                                    break;
                                }
                        }
                    }
                    messages.push({
                        role: "assistant",
                        content: text,
                        tool_calls: toolCalls.length > 0 ? toolCalls : void 0
                    });
                    break;
                }
            case "tool":
                {
                    for (const toolResponse of content){
                        const output = toolResponse.output;
                        let contentValue;
                        switch(output.type){
                            case "text":
                            case "error-text":
                                contentValue = output.value;
                                break;
                            case "content":
                            case "json":
                            case "error-json":
                                contentValue = JSON.stringify(output.value);
                                break;
                        }
                        messages.push({
                            role: "tool",
                            tool_call_id: toolResponse.toolCallId,
                            content: contentValue
                        });
                    }
                    break;
                }
            default:
                {
                    const _exhaustiveCheck = role;
                    throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
                }
        }
    }
    return {
        messages,
        warnings
    };
}
function getResponseMetadata4({ id, model, created }) {
    return {
        id: id != null ? id : void 0,
        modelId: model != null ? model : void 0,
        timestamp: created != null ? new Date(created * 1e3) : void 0
    };
}
function mapXaiFinishReason(finishReason) {
    switch(finishReason){
        case "stop":
            return "stop";
        case "length":
            return "length";
        case "tool_calls":
        case "function_call":
            return "tool-calls";
        case "content_filter":
            return "content-filter";
        default:
            return "unknown";
    }
}
var webSourceSchema = import_v455.z.object({
    type: import_v455.z.literal("web"),
    country: import_v455.z.string().length(2).optional(),
    excludedWebsites: import_v455.z.array(import_v455.z.string()).max(5).optional(),
    allowedWebsites: import_v455.z.array(import_v455.z.string()).max(5).optional(),
    safeSearch: import_v455.z.boolean().optional()
});
var xSourceSchema = import_v455.z.object({
    type: import_v455.z.literal("x"),
    excludedXHandles: import_v455.z.array(import_v455.z.string()).optional(),
    includedXHandles: import_v455.z.array(import_v455.z.string()).optional(),
    postFavoriteCount: import_v455.z.number().int().optional(),
    postViewCount: import_v455.z.number().int().optional(),
    /**
   * @deprecated use `includedXHandles` instead
   */ xHandles: import_v455.z.array(import_v455.z.string()).optional()
});
var newsSourceSchema = import_v455.z.object({
    type: import_v455.z.literal("news"),
    country: import_v455.z.string().length(2).optional(),
    excludedWebsites: import_v455.z.array(import_v455.z.string()).max(5).optional(),
    safeSearch: import_v455.z.boolean().optional()
});
var rssSourceSchema = import_v455.z.object({
    type: import_v455.z.literal("rss"),
    links: import_v455.z.array(import_v455.z.string().url()).max(1)
});
var searchSourceSchema = import_v455.z.discriminatedUnion("type", [
    webSourceSchema,
    xSourceSchema,
    newsSourceSchema,
    rssSourceSchema
]);
var xaiProviderOptions = import_v455.z.object({
    reasoningEffort: import_v455.z.enum([
        "low",
        "high"
    ]).optional(),
    searchParameters: import_v455.z.object({
        /**
     * search mode preference
     * - "off": disables search completely
     * - "auto": model decides whether to search (default)
     * - "on": always enables search
     */ mode: import_v455.z.enum([
            "off",
            "auto",
            "on"
        ]),
        /**
     * whether to return citations in the response
     * defaults to true
     */ returnCitations: import_v455.z.boolean().optional(),
        /**
     * start date for search data (ISO8601 format: YYYY-MM-DD)
     */ fromDate: import_v455.z.string().optional(),
        /**
     * end date for search data (ISO8601 format: YYYY-MM-DD)
     */ toDate: import_v455.z.string().optional(),
        /**
     * maximum number of search results to consider
     * defaults to 20
     */ maxSearchResults: import_v455.z.number().min(1).max(50).optional(),
        /**
     * data sources to search from
     * defaults to ["web", "x"] if not specified
     */ sources: import_v455.z.array(searchSourceSchema).optional()
    }).optional()
});
var xaiErrorDataSchema = import_v456.z.object({
    error: import_v456.z.object({
        message: import_v456.z.string(),
        type: import_v456.z.string().nullish(),
        param: import_v456.z.any().nullish(),
        code: import_v456.z.union([
            import_v456.z.string(),
            import_v456.z.number()
        ]).nullish()
    })
});
var xaiFailedResponseHandler = createJsonErrorResponseHandler({
    errorSchema: xaiErrorDataSchema,
    errorToMessage: (data)=>data.error.message
});
function prepareTools4({ tools, toolChoice }) {
    tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
    const toolWarnings = [];
    if (tools == null) {
        return {
            tools: void 0,
            toolChoice: void 0,
            toolWarnings
        };
    }
    const xaiTools = [];
    for (const tool12 of tools){
        if (tool12.type === "provider-defined") {
            toolWarnings.push({
                type: "unsupported-tool",
                tool: tool12
            });
        } else {
            xaiTools.push({
                type: "function",
                function: {
                    name: tool12.name,
                    description: tool12.description,
                    parameters: tool12.inputSchema
                }
            });
        }
    }
    if (toolChoice == null) {
        return {
            tools: xaiTools,
            toolChoice: void 0,
            toolWarnings
        };
    }
    const type = toolChoice.type;
    switch(type){
        case "auto":
        case "none":
            return {
                tools: xaiTools,
                toolChoice: type,
                toolWarnings
            };
        case "required":
            return {
                tools: xaiTools,
                toolChoice: "required",
                toolWarnings
            };
        case "tool":
            return {
                tools: xaiTools,
                toolChoice: {
                    type: "function",
                    function: {
                        name: toolChoice.toolName
                    }
                },
                toolWarnings
            };
        default:
            {
                const _exhaustiveCheck = type;
                throw new import_provider34.UnsupportedFunctionalityError({
                    functionality: `tool choice type: ${_exhaustiveCheck}`
                });
            }
    }
}
var XaiChatLanguageModel = class {
    constructor(modelId, config){
        this.specificationVersion = "v2";
        this.supportedUrls = {
            "image/*": [
                /^https?:\/\/.*$/
            ]
        };
        this.modelId = modelId;
        this.config = config;
    }
    get provider() {
        return this.config.provider;
    }
    getArgs(_0) {
        return __async(this, arguments, function*({ prompt, maxOutputTokens, temperature, topP, topK, frequencyPenalty, presencePenalty, stopSequences, seed, responseFormat, providerOptions, tools, toolChoice }) {
            var _a, _b, _c;
            const warnings = [];
            const options = (_a = yield parseProviderOptions({
                provider: "xai",
                providerOptions,
                schema: xaiProviderOptions
            })) != null ? _a : {};
            if (topK != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "topK"
                });
            }
            if (frequencyPenalty != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "frequencyPenalty"
                });
            }
            if (presencePenalty != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "presencePenalty"
                });
            }
            if (stopSequences != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "stopSequences"
                });
            }
            if (responseFormat != null && responseFormat.type === "json" && responseFormat.schema != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "responseFormat",
                    details: "JSON response format schema is not supported"
                });
            }
            const { messages, warnings: messageWarnings } = convertToXaiChatMessages(prompt);
            warnings.push(...messageWarnings);
            const { tools: xaiTools, toolChoice: xaiToolChoice, toolWarnings } = prepareTools4({
                tools,
                toolChoice
            });
            warnings.push(...toolWarnings);
            const baseArgs = {
                // model id
                model: this.modelId,
                // standard generation settings
                max_tokens: maxOutputTokens,
                temperature,
                top_p: topP,
                seed,
                reasoning_effort: options.reasoningEffort,
                // response format
                response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? responseFormat.schema != null ? {
                    type: "json_schema",
                    json_schema: {
                        name: (_b = responseFormat.name) != null ? _b : "response",
                        schema: responseFormat.schema,
                        strict: true
                    }
                } : {
                    type: "json_object"
                } : void 0,
                // search parameters
                search_parameters: options.searchParameters ? {
                    mode: options.searchParameters.mode,
                    return_citations: options.searchParameters.returnCitations,
                    from_date: options.searchParameters.fromDate,
                    to_date: options.searchParameters.toDate,
                    max_search_results: options.searchParameters.maxSearchResults,
                    sources: (_c = options.searchParameters.sources) == null ? void 0 : _c.map((source)=>{
                        var _a2;
                        return __spreadValues(__spreadValues(__spreadValues(__spreadValues({
                            type: source.type
                        }, source.type === "web" && {
                            country: source.country,
                            excluded_websites: source.excludedWebsites,
                            allowed_websites: source.allowedWebsites,
                            safe_search: source.safeSearch
                        }), source.type === "x" && {
                            excluded_x_handles: source.excludedXHandles,
                            included_x_handles: (_a2 = source.includedXHandles) != null ? _a2 : source.xHandles,
                            post_favorite_count: source.postFavoriteCount,
                            post_view_count: source.postViewCount
                        }), source.type === "news" && {
                            country: source.country,
                            excluded_websites: source.excludedWebsites,
                            safe_search: source.safeSearch
                        }), source.type === "rss" && {
                            links: source.links
                        });
                    })
                } : void 0,
                // messages in xai format
                messages,
                // tools in xai format
                tools: xaiTools,
                tool_choice: xaiToolChoice
            };
            return {
                args: baseArgs,
                warnings
            };
        });
    }
    doGenerate(options) {
        return __async(this, null, function*() {
            var _a, _b, _c;
            const { args: body, warnings } = yield this.getArgs(options);
            const { responseHeaders, value: response, rawValue: rawResponse } = yield postJsonToApi({
                url: `${(_a = this.config.baseURL) != null ? _a : "https://api.x.ai/v1"}/chat/completions`,
                headers: combineHeaders(this.config.headers(), options.headers),
                body,
                failedResponseHandler: xaiFailedResponseHandler,
                successfulResponseHandler: createJsonResponseHandler(xaiChatResponseSchema),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            const choice = response.choices[0];
            const content = [];
            if (choice.message.content != null && choice.message.content.length > 0) {
                let text = choice.message.content;
                const lastMessage = body.messages[body.messages.length - 1];
                if ((lastMessage == null ? void 0 : lastMessage.role) === "assistant" && text === lastMessage.content) {
                    text = "";
                }
                if (text.length > 0) {
                    content.push({
                        type: "text",
                        text
                    });
                }
            }
            if (choice.message.reasoning_content != null && choice.message.reasoning_content.length > 0) {
                content.push({
                    type: "reasoning",
                    text: choice.message.reasoning_content
                });
            }
            if (choice.message.tool_calls != null) {
                for (const toolCall of choice.message.tool_calls){
                    content.push({
                        type: "tool-call",
                        toolCallId: toolCall.id,
                        toolName: toolCall.function.name,
                        input: toolCall.function.arguments
                    });
                }
            }
            if (response.citations != null) {
                for (const url of response.citations){
                    content.push({
                        type: "source",
                        sourceType: "url",
                        id: this.config.generateId(),
                        url
                    });
                }
            }
            return {
                content,
                finishReason: mapXaiFinishReason(choice.finish_reason),
                usage: {
                    inputTokens: response.usage.prompt_tokens,
                    outputTokens: response.usage.completion_tokens,
                    totalTokens: response.usage.total_tokens,
                    reasoningTokens: (_c = (_b = response.usage.completion_tokens_details) == null ? void 0 : _b.reasoning_tokens) != null ? _c : void 0
                },
                request: {
                    body
                },
                response: __spreadProps(__spreadValues({}, getResponseMetadata4(response)), {
                    headers: responseHeaders,
                    body: rawResponse
                }),
                warnings
            };
        });
    }
    doStream(options) {
        return __async(this, null, function*() {
            var _a;
            const { args, warnings } = yield this.getArgs(options);
            const body = __spreadProps(__spreadValues({}, args), {
                stream: true,
                stream_options: {
                    include_usage: true
                }
            });
            const { responseHeaders, value: response } = yield postJsonToApi({
                url: `${(_a = this.config.baseURL) != null ? _a : "https://api.x.ai/v1"}/chat/completions`,
                headers: combineHeaders(this.config.headers(), options.headers),
                body,
                failedResponseHandler: xaiFailedResponseHandler,
                successfulResponseHandler: createEventSourceResponseHandler(xaiChatChunkSchema),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            let finishReason = "unknown";
            const usage = {
                inputTokens: void 0,
                outputTokens: void 0,
                totalTokens: void 0
            };
            let isFirstChunk = true;
            const contentBlocks = {};
            const lastReasoningDeltas = {};
            const self = this;
            return {
                stream: response.pipeThrough(new TransformStream({
                    start (controller) {
                        controller.enqueue({
                            type: "stream-start",
                            warnings
                        });
                    },
                    transform (chunk, controller) {
                        var _a2, _b;
                        if (options.includeRawChunks) {
                            controller.enqueue({
                                type: "raw",
                                rawValue: chunk.rawValue
                            });
                        }
                        if (!chunk.success) {
                            controller.enqueue({
                                type: "error",
                                error: chunk.error
                            });
                            return;
                        }
                        const value = chunk.value;
                        if (isFirstChunk) {
                            controller.enqueue(__spreadValues({
                                type: "response-metadata"
                            }, getResponseMetadata4(value)));
                            isFirstChunk = false;
                        }
                        if (value.citations != null) {
                            for (const url of value.citations){
                                controller.enqueue({
                                    type: "source",
                                    sourceType: "url",
                                    id: self.config.generateId(),
                                    url
                                });
                            }
                        }
                        if (value.usage != null) {
                            usage.inputTokens = value.usage.prompt_tokens;
                            usage.outputTokens = value.usage.completion_tokens;
                            usage.totalTokens = value.usage.total_tokens;
                            usage.reasoningTokens = (_b = (_a2 = value.usage.completion_tokens_details) == null ? void 0 : _a2.reasoning_tokens) != null ? _b : void 0;
                        }
                        const choice = value.choices[0];
                        if ((choice == null ? void 0 : choice.finish_reason) != null) {
                            finishReason = mapXaiFinishReason(choice.finish_reason);
                        }
                        if ((choice == null ? void 0 : choice.delta) == null) {
                            return;
                        }
                        const delta = choice.delta;
                        const choiceIndex = choice.index;
                        if (delta.content != null && delta.content.length > 0) {
                            const textContent = delta.content;
                            const lastMessage = body.messages[body.messages.length - 1];
                            if ((lastMessage == null ? void 0 : lastMessage.role) === "assistant" && textContent === lastMessage.content) {
                                return;
                            }
                            const blockId = `text-${value.id || choiceIndex}`;
                            if (contentBlocks[blockId] == null) {
                                contentBlocks[blockId] = {
                                    type: "text"
                                };
                                controller.enqueue({
                                    type: "text-start",
                                    id: blockId
                                });
                            }
                            controller.enqueue({
                                type: "text-delta",
                                id: blockId,
                                delta: textContent
                            });
                        }
                        if (delta.reasoning_content != null && delta.reasoning_content.length > 0) {
                            const blockId = `reasoning-${value.id || choiceIndex}`;
                            if (lastReasoningDeltas[blockId] === delta.reasoning_content) {
                                return;
                            }
                            lastReasoningDeltas[blockId] = delta.reasoning_content;
                            if (contentBlocks[blockId] == null) {
                                contentBlocks[blockId] = {
                                    type: "reasoning"
                                };
                                controller.enqueue({
                                    type: "reasoning-start",
                                    id: blockId
                                });
                            }
                            controller.enqueue({
                                type: "reasoning-delta",
                                id: blockId,
                                delta: delta.reasoning_content
                            });
                        }
                        if (delta.tool_calls != null) {
                            for (const toolCall of delta.tool_calls){
                                const toolCallId = toolCall.id;
                                controller.enqueue({
                                    type: "tool-input-start",
                                    id: toolCallId,
                                    toolName: toolCall.function.name
                                });
                                controller.enqueue({
                                    type: "tool-input-delta",
                                    id: toolCallId,
                                    delta: toolCall.function.arguments
                                });
                                controller.enqueue({
                                    type: "tool-input-end",
                                    id: toolCallId
                                });
                                controller.enqueue({
                                    type: "tool-call",
                                    toolCallId,
                                    toolName: toolCall.function.name,
                                    input: toolCall.function.arguments
                                });
                            }
                        }
                    },
                    flush (controller) {
                        for (const [blockId, block] of Object.entries(contentBlocks)){
                            controller.enqueue({
                                type: block.type === "text" ? "text-end" : "reasoning-end",
                                id: blockId
                            });
                        }
                        controller.enqueue({
                            type: "finish",
                            finishReason,
                            usage
                        });
                    }
                })),
                request: {
                    body
                },
                response: {
                    headers: responseHeaders
                }
            };
        });
    }
};
var xaiUsageSchema = import_v454.z.object({
    prompt_tokens: import_v454.z.number(),
    completion_tokens: import_v454.z.number(),
    total_tokens: import_v454.z.number(),
    completion_tokens_details: import_v454.z.object({
        reasoning_tokens: import_v454.z.number().nullish()
    }).nullish()
});
var xaiChatResponseSchema = import_v454.z.object({
    id: import_v454.z.string().nullish(),
    created: import_v454.z.number().nullish(),
    model: import_v454.z.string().nullish(),
    choices: import_v454.z.array(import_v454.z.object({
        message: import_v454.z.object({
            role: import_v454.z.literal("assistant"),
            content: import_v454.z.string().nullish(),
            reasoning_content: import_v454.z.string().nullish(),
            tool_calls: import_v454.z.array(import_v454.z.object({
                id: import_v454.z.string(),
                type: import_v454.z.literal("function"),
                function: import_v454.z.object({
                    name: import_v454.z.string(),
                    arguments: import_v454.z.string()
                })
            })).nullish()
        }),
        index: import_v454.z.number(),
        finish_reason: import_v454.z.string().nullish()
    })),
    object: import_v454.z.literal("chat.completion"),
    usage: xaiUsageSchema,
    citations: import_v454.z.array(import_v454.z.string().url()).nullish()
});
var xaiChatChunkSchema = import_v454.z.object({
    id: import_v454.z.string().nullish(),
    created: import_v454.z.number().nullish(),
    model: import_v454.z.string().nullish(),
    choices: import_v454.z.array(import_v454.z.object({
        delta: import_v454.z.object({
            role: import_v454.z.enum([
                "assistant"
            ]).optional(),
            content: import_v454.z.string().nullish(),
            reasoning_content: import_v454.z.string().nullish(),
            tool_calls: import_v454.z.array(import_v454.z.object({
                id: import_v454.z.string(),
                type: import_v454.z.literal("function"),
                function: import_v454.z.object({
                    name: import_v454.z.string(),
                    arguments: import_v454.z.string()
                })
            })).nullish()
        }),
        finish_reason: import_v454.z.string().nullish(),
        index: import_v454.z.number()
    })),
    usage: xaiUsageSchema.nullish(),
    citations: import_v454.z.array(import_v454.z.string().url()).nullish()
});
var VERSION5 = ("TURBOPACK compile-time truthy", 1) ? "2.0.26" : "TURBOPACK unreachable";
var xaiErrorStructure = {
    errorSchema: xaiErrorDataSchema,
    errorToMessage: (data)=>data.error.message
};
function createXai(options = {}) {
    var _a;
    const baseURL = withoutTrailingSlash((_a = options.baseURL) != null ? _a : "https://api.x.ai/v1");
    const getHeaders = ()=>withUserAgentSuffix(__spreadValues({
            Authorization: `Bearer ${loadApiKey({
                apiKey: options.apiKey,
                environmentVariableName: "XAI_API_KEY",
                description: "xAI API key"
            })}`
        }, options.headers), `ai-sdk/xai/${VERSION5}`);
    const createLanguageModel = (modelId)=>{
        return new XaiChatLanguageModel(modelId, {
            provider: "xai.chat",
            baseURL,
            headers: getHeaders,
            generateId,
            fetch: options.fetch
        });
    };
    const createImageModel = (modelId)=>{
        return new OpenAICompatibleImageModel(modelId, {
            provider: "xai.image",
            url: ({ path: path7 })=>`${baseURL}${path7}`,
            headers: getHeaders,
            fetch: options.fetch,
            errorStructure: xaiErrorStructure
        });
    };
    const provider = (modelId)=>createLanguageModel(modelId);
    provider.languageModel = createLanguageModel;
    provider.chat = createLanguageModel;
    provider.textEmbeddingModel = (modelId)=>{
        throw new import_provider32.NoSuchModelError({
            modelId,
            modelType: "textEmbeddingModel"
        });
    };
    provider.imageModel = createImageModel;
    provider.image = createImageModel;
    return provider;
}
var xai = createXai();
// ../../node_modules/.pnpm/@ai-sdk+openai@2.0.53_zod@3.25.67/node_modules/@ai-sdk/openai/dist/internal/index.mjs
var import_provider35 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v457 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_provider36 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v458 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v459 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_provider37 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_provider38 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v460 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v461 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_provider39 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v462 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v463 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v464 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v465 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v466 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v467 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_provider40 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_provider41 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v468 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v469 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v470 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v471 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_provider42 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v472 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v473 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v474 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v475 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v476 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var openaiErrorDataSchema2 = import_v457.z.object({
    error: import_v457.z.object({
        message: import_v457.z.string(),
        // The additional information below is handled loosely to support
        // OpenAI-compatible providers that have slightly different error
        // responses:
        type: import_v457.z.string().nullish(),
        param: import_v457.z.any().nullish(),
        code: import_v457.z.union([
            import_v457.z.string(),
            import_v457.z.number()
        ]).nullish()
    })
});
var openaiFailedResponseHandler2 = createJsonErrorResponseHandler({
    errorSchema: openaiErrorDataSchema2,
    errorToMessage: (data)=>data.error.message
});
function convertToOpenAIChatMessages2({ prompt, systemMessageMode = "system" }) {
    const messages = [];
    const warnings = [];
    for (const { role, content } of prompt){
        switch(role){
            case "system":
                {
                    switch(systemMessageMode){
                        case "system":
                            {
                                messages.push({
                                    role: "system",
                                    content
                                });
                                break;
                            }
                        case "developer":
                            {
                                messages.push({
                                    role: "developer",
                                    content
                                });
                                break;
                            }
                        case "remove":
                            {
                                warnings.push({
                                    type: "other",
                                    message: "system messages are removed for this model"
                                });
                                break;
                            }
                        default:
                            {
                                const _exhaustiveCheck = systemMessageMode;
                                throw new Error(`Unsupported system message mode: ${_exhaustiveCheck}`);
                            }
                    }
                    break;
                }
            case "user":
                {
                    if (content.length === 1 && content[0].type === "text") {
                        messages.push({
                            role: "user",
                            content: content[0].text
                        });
                        break;
                    }
                    messages.push({
                        role: "user",
                        content: content.map((part, index)=>{
                            var _a, _b, _c;
                            switch(part.type){
                                case "text":
                                    {
                                        return {
                                            type: "text",
                                            text: part.text
                                        };
                                    }
                                case "file":
                                    {
                                        if (part.mediaType.startsWith("image/")) {
                                            const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                                            return {
                                                type: "image_url",
                                                image_url: {
                                                    url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${convertToBase64(part.data)}`,
                                                    // OpenAI specific extension: image detail
                                                    detail: (_b = (_a = part.providerOptions) == null ? void 0 : _a.openai) == null ? void 0 : _b.imageDetail
                                                }
                                            };
                                        } else if (part.mediaType.startsWith("audio/")) {
                                            if (part.data instanceof URL) {
                                                throw new import_provider36.UnsupportedFunctionalityError({
                                                    functionality: "audio file parts with URLs"
                                                });
                                            }
                                            switch(part.mediaType){
                                                case "audio/wav":
                                                    {
                                                        return {
                                                            type: "input_audio",
                                                            input_audio: {
                                                                data: convertToBase64(part.data),
                                                                format: "wav"
                                                            }
                                                        };
                                                    }
                                                case "audio/mp3":
                                                case "audio/mpeg":
                                                    {
                                                        return {
                                                            type: "input_audio",
                                                            input_audio: {
                                                                data: convertToBase64(part.data),
                                                                format: "mp3"
                                                            }
                                                        };
                                                    }
                                                default:
                                                    {
                                                        throw new import_provider36.UnsupportedFunctionalityError({
                                                            functionality: `audio content parts with media type ${part.mediaType}`
                                                        });
                                                    }
                                            }
                                        } else if (part.mediaType === "application/pdf") {
                                            if (part.data instanceof URL) {
                                                throw new import_provider36.UnsupportedFunctionalityError({
                                                    functionality: "PDF file parts with URLs"
                                                });
                                            }
                                            return {
                                                type: "file",
                                                file: typeof part.data === "string" && part.data.startsWith("file-") ? {
                                                    file_id: part.data
                                                } : {
                                                    filename: (_c = part.filename) != null ? _c : `part-${index}.pdf`,
                                                    file_data: `data:application/pdf;base64,${convertToBase64(part.data)}`
                                                }
                                            };
                                        } else {
                                            throw new import_provider36.UnsupportedFunctionalityError({
                                                functionality: `file part media type ${part.mediaType}`
                                            });
                                        }
                                    }
                            }
                        })
                    });
                    break;
                }
            case "assistant":
                {
                    let text = "";
                    const toolCalls = [];
                    for (const part of content){
                        switch(part.type){
                            case "text":
                                {
                                    text += part.text;
                                    break;
                                }
                            case "tool-call":
                                {
                                    toolCalls.push({
                                        id: part.toolCallId,
                                        type: "function",
                                        function: {
                                            name: part.toolName,
                                            arguments: JSON.stringify(part.input)
                                        }
                                    });
                                    break;
                                }
                        }
                    }
                    messages.push({
                        role: "assistant",
                        content: text,
                        tool_calls: toolCalls.length > 0 ? toolCalls : void 0
                    });
                    break;
                }
            case "tool":
                {
                    for (const toolResponse of content){
                        const output = toolResponse.output;
                        let contentValue;
                        switch(output.type){
                            case "text":
                            case "error-text":
                                contentValue = output.value;
                                break;
                            case "content":
                            case "json":
                            case "error-json":
                                contentValue = JSON.stringify(output.value);
                                break;
                        }
                        messages.push({
                            role: "tool",
                            tool_call_id: toolResponse.toolCallId,
                            content: contentValue
                        });
                    }
                    break;
                }
            default:
                {
                    const _exhaustiveCheck = role;
                    throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
                }
        }
    }
    return {
        messages,
        warnings
    };
}
function getResponseMetadata5({ id, model, created }) {
    return {
        id: id != null ? id : void 0,
        modelId: model != null ? model : void 0,
        timestamp: created != null ? new Date(created * 1e3) : void 0
    };
}
function mapOpenAIFinishReason3(finishReason) {
    switch(finishReason){
        case "stop":
            return "stop";
        case "length":
            return "length";
        case "content_filter":
            return "content-filter";
        case "function_call":
        case "tool_calls":
            return "tool-calls";
        default:
            return "unknown";
    }
}
var openaiChatResponseSchema2 = lazyValidator(()=>zodSchema(import_v458.z.object({
        id: import_v458.z.string().nullish(),
        created: import_v458.z.number().nullish(),
        model: import_v458.z.string().nullish(),
        choices: import_v458.z.array(import_v458.z.object({
            message: import_v458.z.object({
                role: import_v458.z.literal("assistant").nullish(),
                content: import_v458.z.string().nullish(),
                tool_calls: import_v458.z.array(import_v458.z.object({
                    id: import_v458.z.string().nullish(),
                    type: import_v458.z.literal("function"),
                    function: import_v458.z.object({
                        name: import_v458.z.string(),
                        arguments: import_v458.z.string()
                    })
                })).nullish(),
                annotations: import_v458.z.array(import_v458.z.object({
                    type: import_v458.z.literal("url_citation"),
                    start_index: import_v458.z.number(),
                    end_index: import_v458.z.number(),
                    url: import_v458.z.string(),
                    title: import_v458.z.string()
                })).nullish()
            }),
            index: import_v458.z.number(),
            logprobs: import_v458.z.object({
                content: import_v458.z.array(import_v458.z.object({
                    token: import_v458.z.string(),
                    logprob: import_v458.z.number(),
                    top_logprobs: import_v458.z.array(import_v458.z.object({
                        token: import_v458.z.string(),
                        logprob: import_v458.z.number()
                    }))
                })).nullish()
            }).nullish(),
            finish_reason: import_v458.z.string().nullish()
        })),
        usage: import_v458.z.object({
            prompt_tokens: import_v458.z.number().nullish(),
            completion_tokens: import_v458.z.number().nullish(),
            total_tokens: import_v458.z.number().nullish(),
            prompt_tokens_details: import_v458.z.object({
                cached_tokens: import_v458.z.number().nullish()
            }).nullish(),
            completion_tokens_details: import_v458.z.object({
                reasoning_tokens: import_v458.z.number().nullish(),
                accepted_prediction_tokens: import_v458.z.number().nullish(),
                rejected_prediction_tokens: import_v458.z.number().nullish()
            }).nullish()
        }).nullish()
    })));
var openaiChatChunkSchema2 = lazyValidator(()=>zodSchema(import_v458.z.union([
        import_v458.z.object({
            id: import_v458.z.string().nullish(),
            created: import_v458.z.number().nullish(),
            model: import_v458.z.string().nullish(),
            choices: import_v458.z.array(import_v458.z.object({
                delta: import_v458.z.object({
                    role: import_v458.z.enum([
                        "assistant"
                    ]).nullish(),
                    content: import_v458.z.string().nullish(),
                    tool_calls: import_v458.z.array(import_v458.z.object({
                        index: import_v458.z.number(),
                        id: import_v458.z.string().nullish(),
                        type: import_v458.z.literal("function").nullish(),
                        function: import_v458.z.object({
                            name: import_v458.z.string().nullish(),
                            arguments: import_v458.z.string().nullish()
                        })
                    })).nullish(),
                    annotations: import_v458.z.array(import_v458.z.object({
                        type: import_v458.z.literal("url_citation"),
                        start_index: import_v458.z.number(),
                        end_index: import_v458.z.number(),
                        url: import_v458.z.string(),
                        title: import_v458.z.string()
                    })).nullish()
                }).nullish(),
                logprobs: import_v458.z.object({
                    content: import_v458.z.array(import_v458.z.object({
                        token: import_v458.z.string(),
                        logprob: import_v458.z.number(),
                        top_logprobs: import_v458.z.array(import_v458.z.object({
                            token: import_v458.z.string(),
                            logprob: import_v458.z.number()
                        }))
                    })).nullish()
                }).nullish(),
                finish_reason: import_v458.z.string().nullish(),
                index: import_v458.z.number()
            })),
            usage: import_v458.z.object({
                prompt_tokens: import_v458.z.number().nullish(),
                completion_tokens: import_v458.z.number().nullish(),
                total_tokens: import_v458.z.number().nullish(),
                prompt_tokens_details: import_v458.z.object({
                    cached_tokens: import_v458.z.number().nullish()
                }).nullish(),
                completion_tokens_details: import_v458.z.object({
                    reasoning_tokens: import_v458.z.number().nullish(),
                    accepted_prediction_tokens: import_v458.z.number().nullish(),
                    rejected_prediction_tokens: import_v458.z.number().nullish()
                }).nullish()
            }).nullish()
        }),
        openaiErrorDataSchema2
    ])));
var openaiChatLanguageModelOptions2 = lazyValidator(()=>zodSchema(import_v459.z.object({
        /**
       * Modify the likelihood of specified tokens appearing in the completion.
       *
       * Accepts a JSON object that maps tokens (specified by their token ID in
       * the GPT tokenizer) to an associated bias value from -100 to 100.
       */ logitBias: import_v459.z.record(import_v459.z.coerce.number(), import_v459.z.number()).optional(),
        /**
       * Return the log probabilities of the tokens.
       *
       * Setting to true will return the log probabilities of the tokens that
       * were generated.
       *
       * Setting to a number will return the log probabilities of the top n
       * tokens that were generated.
       */ logprobs: import_v459.z.union([
            import_v459.z.boolean(),
            import_v459.z.number()
        ]).optional(),
        /**
       * Whether to enable parallel function calling during tool use. Default to true.
       */ parallelToolCalls: import_v459.z.boolean().optional(),
        /**
       * A unique identifier representing your end-user, which can help OpenAI to
       * monitor and detect abuse.
       */ user: import_v459.z.string().optional(),
        /**
       * Reasoning effort for reasoning models. Defaults to `medium`.
       */ reasoningEffort: import_v459.z.enum([
            "minimal",
            "low",
            "medium",
            "high"
        ]).optional(),
        /**
       * Maximum number of completion tokens to generate. Useful for reasoning models.
       */ maxCompletionTokens: import_v459.z.number().optional(),
        /**
       * Whether to enable persistence in responses API.
       */ store: import_v459.z.boolean().optional(),
        /**
       * Metadata to associate with the request.
       */ metadata: import_v459.z.record(import_v459.z.string().max(64), import_v459.z.string().max(512)).optional(),
        /**
       * Parameters for prediction mode.
       */ prediction: import_v459.z.record(import_v459.z.string(), import_v459.z.any()).optional(),
        /**
       * Whether to use structured outputs.
       *
       * @default true
       */ structuredOutputs: import_v459.z.boolean().optional(),
        /**
       * Service tier for the request.
       * - 'auto': Default service tier. The request will be processed with the service tier configured in the
       *           Project settings. Unless otherwise configured, the Project will use 'default'.
       * - 'flex': 50% cheaper processing at the cost of increased latency. Only available for o3 and o4-mini models.
       * - 'priority': Higher-speed processing with predictably low latency at premium cost. Available for Enterprise customers.
       * - 'default': The request will be processed with the standard pricing and performance for the selected model.
       *
       * @default 'auto'
       */ serviceTier: import_v459.z.enum([
            "auto",
            "flex",
            "priority",
            "default"
        ]).optional(),
        /**
       * Whether to use strict JSON schema validation.
       *
       * @default false
       */ strictJsonSchema: import_v459.z.boolean().optional(),
        /**
       * Controls the verbosity of the model's responses.
       * Lower values will result in more concise responses, while higher values will result in more verbose responses.
       */ textVerbosity: import_v459.z.enum([
            "low",
            "medium",
            "high"
        ]).optional(),
        /**
       * A cache key for prompt caching. Allows manual control over prompt caching behavior.
       * Useful for improving cache hit rates and working around automatic caching issues.
       */ promptCacheKey: import_v459.z.string().optional(),
        /**
       * A stable identifier used to help detect users of your application
       * that may be violating OpenAI's usage policies. The IDs should be a
       * string that uniquely identifies each user. We recommend hashing their
       * username or email address, in order to avoid sending us any identifying
       * information.
       */ safetyIdentifier: import_v459.z.string().optional()
    })));
function prepareChatTools2({ tools, toolChoice, structuredOutputs, strictJsonSchema }) {
    tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
    const toolWarnings = [];
    if (tools == null) {
        return {
            tools: void 0,
            toolChoice: void 0,
            toolWarnings
        };
    }
    const openaiTools2 = [];
    for (const tool12 of tools){
        switch(tool12.type){
            case "function":
                openaiTools2.push({
                    type: "function",
                    function: {
                        name: tool12.name,
                        description: tool12.description,
                        parameters: tool12.inputSchema,
                        strict: structuredOutputs ? strictJsonSchema : void 0
                    }
                });
                break;
            default:
                toolWarnings.push({
                    type: "unsupported-tool",
                    tool: tool12
                });
                break;
        }
    }
    if (toolChoice == null) {
        return {
            tools: openaiTools2,
            toolChoice: void 0,
            toolWarnings
        };
    }
    const type = toolChoice.type;
    switch(type){
        case "auto":
        case "none":
        case "required":
            return {
                tools: openaiTools2,
                toolChoice: type,
                toolWarnings
            };
        case "tool":
            return {
                tools: openaiTools2,
                toolChoice: {
                    type: "function",
                    function: {
                        name: toolChoice.toolName
                    }
                },
                toolWarnings
            };
        default:
            {
                const _exhaustiveCheck = type;
                throw new import_provider37.UnsupportedFunctionalityError({
                    functionality: `tool choice type: ${_exhaustiveCheck}`
                });
            }
    }
}
var OpenAIChatLanguageModel2 = class {
    constructor(modelId, config){
        this.specificationVersion = "v2";
        this.supportedUrls = {
            "image/*": [
                /^https?:\/\/.*$/
            ]
        };
        this.modelId = modelId;
        this.config = config;
    }
    get provider() {
        return this.config.provider;
    }
    getArgs(_0) {
        return __async(this, arguments, function*({ prompt, maxOutputTokens, temperature, topP, topK, frequencyPenalty, presencePenalty, stopSequences, responseFormat, seed, tools, toolChoice, providerOptions }) {
            var _a, _b, _c, _d;
            const warnings = [];
            const openaiOptions = (_a = yield parseProviderOptions({
                provider: "openai",
                providerOptions,
                schema: openaiChatLanguageModelOptions2
            })) != null ? _a : {};
            const structuredOutputs = (_b = openaiOptions.structuredOutputs) != null ? _b : true;
            if (topK != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "topK"
                });
            }
            if ((responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && !structuredOutputs) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "responseFormat",
                    details: "JSON response format schema is only supported with structuredOutputs"
                });
            }
            const { messages, warnings: messageWarnings } = convertToOpenAIChatMessages2({
                prompt,
                systemMessageMode: getSystemMessageMode2(this.modelId)
            });
            warnings.push(...messageWarnings);
            const strictJsonSchema = (_c = openaiOptions.strictJsonSchema) != null ? _c : false;
            const baseArgs = {
                // model id:
                model: this.modelId,
                // model specific settings:
                logit_bias: openaiOptions.logitBias,
                logprobs: openaiOptions.logprobs === true || typeof openaiOptions.logprobs === "number" ? true : void 0,
                top_logprobs: typeof openaiOptions.logprobs === "number" ? openaiOptions.logprobs : typeof openaiOptions.logprobs === "boolean" ? openaiOptions.logprobs ? 0 : void 0 : void 0,
                user: openaiOptions.user,
                parallel_tool_calls: openaiOptions.parallelToolCalls,
                // standardized settings:
                max_tokens: maxOutputTokens,
                temperature,
                top_p: topP,
                frequency_penalty: frequencyPenalty,
                presence_penalty: presencePenalty,
                response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? structuredOutputs && responseFormat.schema != null ? {
                    type: "json_schema",
                    json_schema: {
                        schema: responseFormat.schema,
                        strict: strictJsonSchema,
                        name: (_d = responseFormat.name) != null ? _d : "response",
                        description: responseFormat.description
                    }
                } : {
                    type: "json_object"
                } : void 0,
                stop: stopSequences,
                seed,
                verbosity: openaiOptions.textVerbosity,
                // openai specific settings:
                // TODO AI SDK 6: remove, we auto-map maxOutputTokens now
                max_completion_tokens: openaiOptions.maxCompletionTokens,
                store: openaiOptions.store,
                metadata: openaiOptions.metadata,
                prediction: openaiOptions.prediction,
                reasoning_effort: openaiOptions.reasoningEffort,
                service_tier: openaiOptions.serviceTier,
                prompt_cache_key: openaiOptions.promptCacheKey,
                safety_identifier: openaiOptions.safetyIdentifier,
                // messages:
                messages
            };
            if (isReasoningModel2(this.modelId)) {
                if (baseArgs.temperature != null) {
                    baseArgs.temperature = void 0;
                    warnings.push({
                        type: "unsupported-setting",
                        setting: "temperature",
                        details: "temperature is not supported for reasoning models"
                    });
                }
                if (baseArgs.top_p != null) {
                    baseArgs.top_p = void 0;
                    warnings.push({
                        type: "unsupported-setting",
                        setting: "topP",
                        details: "topP is not supported for reasoning models"
                    });
                }
                if (baseArgs.frequency_penalty != null) {
                    baseArgs.frequency_penalty = void 0;
                    warnings.push({
                        type: "unsupported-setting",
                        setting: "frequencyPenalty",
                        details: "frequencyPenalty is not supported for reasoning models"
                    });
                }
                if (baseArgs.presence_penalty != null) {
                    baseArgs.presence_penalty = void 0;
                    warnings.push({
                        type: "unsupported-setting",
                        setting: "presencePenalty",
                        details: "presencePenalty is not supported for reasoning models"
                    });
                }
                if (baseArgs.logit_bias != null) {
                    baseArgs.logit_bias = void 0;
                    warnings.push({
                        type: "other",
                        message: "logitBias is not supported for reasoning models"
                    });
                }
                if (baseArgs.logprobs != null) {
                    baseArgs.logprobs = void 0;
                    warnings.push({
                        type: "other",
                        message: "logprobs is not supported for reasoning models"
                    });
                }
                if (baseArgs.top_logprobs != null) {
                    baseArgs.top_logprobs = void 0;
                    warnings.push({
                        type: "other",
                        message: "topLogprobs is not supported for reasoning models"
                    });
                }
                if (baseArgs.max_tokens != null) {
                    if (baseArgs.max_completion_tokens == null) {
                        baseArgs.max_completion_tokens = baseArgs.max_tokens;
                    }
                    baseArgs.max_tokens = void 0;
                }
            } else if (this.modelId.startsWith("gpt-4o-search-preview") || this.modelId.startsWith("gpt-4o-mini-search-preview")) {
                if (baseArgs.temperature != null) {
                    baseArgs.temperature = void 0;
                    warnings.push({
                        type: "unsupported-setting",
                        setting: "temperature",
                        details: "temperature is not supported for the search preview models and has been removed."
                    });
                }
            }
            if (openaiOptions.serviceTier === "flex" && !supportsFlexProcessing2(this.modelId)) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "serviceTier",
                    details: "flex processing is only available for o3, o4-mini, and gpt-5 models"
                });
                baseArgs.service_tier = void 0;
            }
            if (openaiOptions.serviceTier === "priority" && !supportsPriorityProcessing2(this.modelId)) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "serviceTier",
                    details: "priority processing is only available for supported models (gpt-4, gpt-5, gpt-5-mini, o3, o4-mini) and requires Enterprise access. gpt-5-nano is not supported"
                });
                baseArgs.service_tier = void 0;
            }
            const { tools: openaiTools2, toolChoice: openaiToolChoice, toolWarnings } = prepareChatTools2({
                tools,
                toolChoice,
                structuredOutputs,
                strictJsonSchema
            });
            return {
                args: __spreadProps(__spreadValues({}, baseArgs), {
                    tools: openaiTools2,
                    tool_choice: openaiToolChoice
                }),
                warnings: [
                    ...warnings,
                    ...toolWarnings
                ]
            };
        });
    }
    doGenerate(options) {
        return __async(this, null, function*() {
            var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
            const { args: body, warnings } = yield this.getArgs(options);
            const { responseHeaders, value: response, rawValue: rawResponse } = yield postJsonToApi({
                url: this.config.url({
                    path: "/chat/completions",
                    modelId: this.modelId
                }),
                headers: combineHeaders(this.config.headers(), options.headers),
                body,
                failedResponseHandler: openaiFailedResponseHandler2,
                successfulResponseHandler: createJsonResponseHandler(openaiChatResponseSchema2),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            const choice = response.choices[0];
            const content = [];
            const text = choice.message.content;
            if (text != null && text.length > 0) {
                content.push({
                    type: "text",
                    text
                });
            }
            for (const toolCall of (_a = choice.message.tool_calls) != null ? _a : []){
                content.push({
                    type: "tool-call",
                    toolCallId: (_b = toolCall.id) != null ? _b : generateId(),
                    toolName: toolCall.function.name,
                    input: toolCall.function.arguments
                });
            }
            for (const annotation of (_c = choice.message.annotations) != null ? _c : []){
                content.push({
                    type: "source",
                    sourceType: "url",
                    id: generateId(),
                    url: annotation.url,
                    title: annotation.title
                });
            }
            const completionTokenDetails = (_d = response.usage) == null ? void 0 : _d.completion_tokens_details;
            const promptTokenDetails = (_e = response.usage) == null ? void 0 : _e.prompt_tokens_details;
            const providerMetadata = {
                openai: {}
            };
            if ((completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens) != null) {
                providerMetadata.openai.acceptedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens;
            }
            if ((completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens) != null) {
                providerMetadata.openai.rejectedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens;
            }
            if (((_f = choice.logprobs) == null ? void 0 : _f.content) != null) {
                providerMetadata.openai.logprobs = choice.logprobs.content;
            }
            return {
                content,
                finishReason: mapOpenAIFinishReason3(choice.finish_reason),
                usage: {
                    inputTokens: (_h = (_g = response.usage) == null ? void 0 : _g.prompt_tokens) != null ? _h : void 0,
                    outputTokens: (_j = (_i = response.usage) == null ? void 0 : _i.completion_tokens) != null ? _j : void 0,
                    totalTokens: (_l = (_k = response.usage) == null ? void 0 : _k.total_tokens) != null ? _l : void 0,
                    reasoningTokens: (_m = completionTokenDetails == null ? void 0 : completionTokenDetails.reasoning_tokens) != null ? _m : void 0,
                    cachedInputTokens: (_n = promptTokenDetails == null ? void 0 : promptTokenDetails.cached_tokens) != null ? _n : void 0
                },
                request: {
                    body
                },
                response: __spreadProps(__spreadValues({}, getResponseMetadata5(response)), {
                    headers: responseHeaders,
                    body: rawResponse
                }),
                warnings,
                providerMetadata
            };
        });
    }
    doStream(options) {
        return __async(this, null, function*() {
            const { args, warnings } = yield this.getArgs(options);
            const body = __spreadProps(__spreadValues({}, args), {
                stream: true,
                stream_options: {
                    include_usage: true
                }
            });
            const { responseHeaders, value: response } = yield postJsonToApi({
                url: this.config.url({
                    path: "/chat/completions",
                    modelId: this.modelId
                }),
                headers: combineHeaders(this.config.headers(), options.headers),
                body,
                failedResponseHandler: openaiFailedResponseHandler2,
                successfulResponseHandler: createEventSourceResponseHandler(openaiChatChunkSchema2),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            const toolCalls = [];
            let finishReason = "unknown";
            const usage = {
                inputTokens: void 0,
                outputTokens: void 0,
                totalTokens: void 0
            };
            let isFirstChunk = true;
            let isActiveText = false;
            const providerMetadata = {
                openai: {}
            };
            return {
                stream: response.pipeThrough(new TransformStream({
                    start (controller) {
                        controller.enqueue({
                            type: "stream-start",
                            warnings
                        });
                    },
                    transform (chunk, controller) {
                        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
                        if (options.includeRawChunks) {
                            controller.enqueue({
                                type: "raw",
                                rawValue: chunk.rawValue
                            });
                        }
                        if (!chunk.success) {
                            finishReason = "error";
                            controller.enqueue({
                                type: "error",
                                error: chunk.error
                            });
                            return;
                        }
                        const value = chunk.value;
                        if ("error" in value) {
                            finishReason = "error";
                            controller.enqueue({
                                type: "error",
                                error: value.error
                            });
                            return;
                        }
                        if (isFirstChunk) {
                            isFirstChunk = false;
                            controller.enqueue(__spreadValues({
                                type: "response-metadata"
                            }, getResponseMetadata5(value)));
                        }
                        if (value.usage != null) {
                            usage.inputTokens = (_a = value.usage.prompt_tokens) != null ? _a : void 0;
                            usage.outputTokens = (_b = value.usage.completion_tokens) != null ? _b : void 0;
                            usage.totalTokens = (_c = value.usage.total_tokens) != null ? _c : void 0;
                            usage.reasoningTokens = (_e = (_d = value.usage.completion_tokens_details) == null ? void 0 : _d.reasoning_tokens) != null ? _e : void 0;
                            usage.cachedInputTokens = (_g = (_f = value.usage.prompt_tokens_details) == null ? void 0 : _f.cached_tokens) != null ? _g : void 0;
                            if (((_h = value.usage.completion_tokens_details) == null ? void 0 : _h.accepted_prediction_tokens) != null) {
                                providerMetadata.openai.acceptedPredictionTokens = (_i = value.usage.completion_tokens_details) == null ? void 0 : _i.accepted_prediction_tokens;
                            }
                            if (((_j = value.usage.completion_tokens_details) == null ? void 0 : _j.rejected_prediction_tokens) != null) {
                                providerMetadata.openai.rejectedPredictionTokens = (_k = value.usage.completion_tokens_details) == null ? void 0 : _k.rejected_prediction_tokens;
                            }
                        }
                        const choice = value.choices[0];
                        if ((choice == null ? void 0 : choice.finish_reason) != null) {
                            finishReason = mapOpenAIFinishReason3(choice.finish_reason);
                        }
                        if (((_l = choice == null ? void 0 : choice.logprobs) == null ? void 0 : _l.content) != null) {
                            providerMetadata.openai.logprobs = choice.logprobs.content;
                        }
                        if ((choice == null ? void 0 : choice.delta) == null) {
                            return;
                        }
                        const delta = choice.delta;
                        if (delta.content != null) {
                            if (!isActiveText) {
                                controller.enqueue({
                                    type: "text-start",
                                    id: "0"
                                });
                                isActiveText = true;
                            }
                            controller.enqueue({
                                type: "text-delta",
                                id: "0",
                                delta: delta.content
                            });
                        }
                        if (delta.tool_calls != null) {
                            for (const toolCallDelta of delta.tool_calls){
                                const index = toolCallDelta.index;
                                if (toolCalls[index] == null) {
                                    if (toolCallDelta.type !== "function") {
                                        throw new import_provider35.InvalidResponseDataError({
                                            data: toolCallDelta,
                                            message: `Expected 'function' type.`
                                        });
                                    }
                                    if (toolCallDelta.id == null) {
                                        throw new import_provider35.InvalidResponseDataError({
                                            data: toolCallDelta,
                                            message: `Expected 'id' to be a string.`
                                        });
                                    }
                                    if (((_m = toolCallDelta.function) == null ? void 0 : _m.name) == null) {
                                        throw new import_provider35.InvalidResponseDataError({
                                            data: toolCallDelta,
                                            message: `Expected 'function.name' to be a string.`
                                        });
                                    }
                                    controller.enqueue({
                                        type: "tool-input-start",
                                        id: toolCallDelta.id,
                                        toolName: toolCallDelta.function.name
                                    });
                                    toolCalls[index] = {
                                        id: toolCallDelta.id,
                                        type: "function",
                                        function: {
                                            name: toolCallDelta.function.name,
                                            arguments: (_n = toolCallDelta.function.arguments) != null ? _n : ""
                                        },
                                        hasFinished: false
                                    };
                                    const toolCall2 = toolCalls[index];
                                    if (((_o = toolCall2.function) == null ? void 0 : _o.name) != null && ((_p = toolCall2.function) == null ? void 0 : _p.arguments) != null) {
                                        if (toolCall2.function.arguments.length > 0) {
                                            controller.enqueue({
                                                type: "tool-input-delta",
                                                id: toolCall2.id,
                                                delta: toolCall2.function.arguments
                                            });
                                        }
                                        if (isParsableJson(toolCall2.function.arguments)) {
                                            controller.enqueue({
                                                type: "tool-input-end",
                                                id: toolCall2.id
                                            });
                                            controller.enqueue({
                                                type: "tool-call",
                                                toolCallId: (_q = toolCall2.id) != null ? _q : generateId(),
                                                toolName: toolCall2.function.name,
                                                input: toolCall2.function.arguments
                                            });
                                            toolCall2.hasFinished = true;
                                        }
                                    }
                                    continue;
                                }
                                const toolCall = toolCalls[index];
                                if (toolCall.hasFinished) {
                                    continue;
                                }
                                if (((_r = toolCallDelta.function) == null ? void 0 : _r.arguments) != null) {
                                    toolCall.function.arguments += (_t = (_s = toolCallDelta.function) == null ? void 0 : _s.arguments) != null ? _t : "";
                                }
                                controller.enqueue({
                                    type: "tool-input-delta",
                                    id: toolCall.id,
                                    delta: (_u = toolCallDelta.function.arguments) != null ? _u : ""
                                });
                                if (((_v = toolCall.function) == null ? void 0 : _v.name) != null && ((_w = toolCall.function) == null ? void 0 : _w.arguments) != null && isParsableJson(toolCall.function.arguments)) {
                                    controller.enqueue({
                                        type: "tool-input-end",
                                        id: toolCall.id
                                    });
                                    controller.enqueue({
                                        type: "tool-call",
                                        toolCallId: (_x = toolCall.id) != null ? _x : generateId(),
                                        toolName: toolCall.function.name,
                                        input: toolCall.function.arguments
                                    });
                                    toolCall.hasFinished = true;
                                }
                            }
                        }
                        if (delta.annotations != null) {
                            for (const annotation of delta.annotations){
                                controller.enqueue({
                                    type: "source",
                                    sourceType: "url",
                                    id: generateId(),
                                    url: annotation.url,
                                    title: annotation.title
                                });
                            }
                        }
                    },
                    flush (controller) {
                        if (isActiveText) {
                            controller.enqueue({
                                type: "text-end",
                                id: "0"
                            });
                        }
                        controller.enqueue(__spreadValues({
                            type: "finish",
                            finishReason,
                            usage
                        }, providerMetadata != null ? {
                            providerMetadata
                        } : {}));
                    }
                })),
                request: {
                    body
                },
                response: {
                    headers: responseHeaders
                }
            };
        });
    }
};
function isReasoningModel2(modelId) {
    return (modelId.startsWith("o") || modelId.startsWith("gpt-5")) && !modelId.startsWith("gpt-5-chat");
}
function supportsFlexProcessing2(modelId) {
    return modelId.startsWith("o3") || modelId.startsWith("o4-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-chat");
}
function supportsPriorityProcessing2(modelId) {
    return modelId.startsWith("gpt-4") || modelId.startsWith("gpt-5-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-nano") && !modelId.startsWith("gpt-5-chat") || modelId.startsWith("o3") || modelId.startsWith("o4-mini");
}
function getSystemMessageMode2(modelId) {
    var _a, _b;
    if (!isReasoningModel2(modelId)) {
        return "system";
    }
    return (_b = (_a = reasoningModels2[modelId]) == null ? void 0 : _a.systemMessageMode) != null ? _b : "developer";
}
var reasoningModels2 = {
    "o1-mini": {
        systemMessageMode: "remove"
    },
    "o1-mini-2024-09-12": {
        systemMessageMode: "remove"
    },
    "o1-preview": {
        systemMessageMode: "remove"
    },
    "o1-preview-2024-09-12": {
        systemMessageMode: "remove"
    },
    o3: {
        systemMessageMode: "developer"
    },
    "o3-2025-04-16": {
        systemMessageMode: "developer"
    },
    "o3-mini": {
        systemMessageMode: "developer"
    },
    "o3-mini-2025-01-31": {
        systemMessageMode: "developer"
    },
    "o4-mini": {
        systemMessageMode: "developer"
    },
    "o4-mini-2025-04-16": {
        systemMessageMode: "developer"
    }
};
function convertToOpenAICompletionPrompt2({ prompt, user = "user", assistant = "assistant" }) {
    let text = "";
    if (prompt[0].role === "system") {
        text += `${prompt[0].content}

`;
        prompt = prompt.slice(1);
    }
    for (const { role, content } of prompt){
        switch(role){
            case "system":
                {
                    throw new import_provider38.InvalidPromptError({
                        message: "Unexpected system message in prompt: ${content}",
                        prompt
                    });
                }
            case "user":
                {
                    const userMessage = content.map((part)=>{
                        switch(part.type){
                            case "text":
                                {
                                    return part.text;
                                }
                        }
                    }).filter(Boolean).join("");
                    text += `${user}:
${userMessage}

`;
                    break;
                }
            case "assistant":
                {
                    const assistantMessage = content.map((part)=>{
                        switch(part.type){
                            case "text":
                                {
                                    return part.text;
                                }
                            case "tool-call":
                                {
                                    throw new import_provider38.UnsupportedFunctionalityError({
                                        functionality: "tool-call messages"
                                    });
                                }
                        }
                    }).join("");
                    text += `${assistant}:
${assistantMessage}

`;
                    break;
                }
            case "tool":
                {
                    throw new import_provider38.UnsupportedFunctionalityError({
                        functionality: "tool messages"
                    });
                }
            default:
                {
                    const _exhaustiveCheck = role;
                    throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
                }
        }
    }
    text += `${assistant}:
`;
    return {
        prompt: text,
        stopSequences: [
            `
${user}:`
        ]
    };
}
function getResponseMetadata23({ id, model, created }) {
    return {
        id: id != null ? id : void 0,
        modelId: model != null ? model : void 0,
        timestamp: created != null ? new Date(created * 1e3) : void 0
    };
}
function mapOpenAIFinishReason22(finishReason) {
    switch(finishReason){
        case "stop":
            return "stop";
        case "length":
            return "length";
        case "content_filter":
            return "content-filter";
        case "function_call":
        case "tool_calls":
            return "tool-calls";
        default:
            return "unknown";
    }
}
var openaiCompletionResponseSchema2 = lazyValidator(()=>zodSchema(import_v460.z.object({
        id: import_v460.z.string().nullish(),
        created: import_v460.z.number().nullish(),
        model: import_v460.z.string().nullish(),
        choices: import_v460.z.array(import_v460.z.object({
            text: import_v460.z.string(),
            finish_reason: import_v460.z.string(),
            logprobs: import_v460.z.object({
                tokens: import_v460.z.array(import_v460.z.string()),
                token_logprobs: import_v460.z.array(import_v460.z.number()),
                top_logprobs: import_v460.z.array(import_v460.z.record(import_v460.z.string(), import_v460.z.number())).nullish()
            }).nullish()
        })),
        usage: import_v460.z.object({
            prompt_tokens: import_v460.z.number(),
            completion_tokens: import_v460.z.number(),
            total_tokens: import_v460.z.number()
        }).nullish()
    })));
var openaiCompletionChunkSchema2 = lazyValidator(()=>zodSchema(import_v460.z.union([
        import_v460.z.object({
            id: import_v460.z.string().nullish(),
            created: import_v460.z.number().nullish(),
            model: import_v460.z.string().nullish(),
            choices: import_v460.z.array(import_v460.z.object({
                text: import_v460.z.string(),
                finish_reason: import_v460.z.string().nullish(),
                index: import_v460.z.number(),
                logprobs: import_v460.z.object({
                    tokens: import_v460.z.array(import_v460.z.string()),
                    token_logprobs: import_v460.z.array(import_v460.z.number()),
                    top_logprobs: import_v460.z.array(import_v460.z.record(import_v460.z.string(), import_v460.z.number())).nullish()
                }).nullish()
            })),
            usage: import_v460.z.object({
                prompt_tokens: import_v460.z.number(),
                completion_tokens: import_v460.z.number(),
                total_tokens: import_v460.z.number()
            }).nullish()
        }),
        openaiErrorDataSchema2
    ])));
var openaiCompletionProviderOptions2 = lazyValidator(()=>zodSchema(import_v461.z.object({
        /**
      Echo back the prompt in addition to the completion.
         */ echo: import_v461.z.boolean().optional(),
        /**
      Modify the likelihood of specified tokens appearing in the completion.
      
      Accepts a JSON object that maps tokens (specified by their token ID in
      the GPT tokenizer) to an associated bias value from -100 to 100. You
      can use this tokenizer tool to convert text to token IDs. Mathematically,
      the bias is added to the logits generated by the model prior to sampling.
      The exact effect will vary per model, but values between -1 and 1 should
      decrease or increase likelihood of selection; values like -100 or 100
      should result in a ban or exclusive selection of the relevant token.
      
      As an example, you can pass {"50256": -100} to prevent the <|endoftext|>
      token from being generated.
       */ logitBias: import_v461.z.record(import_v461.z.string(), import_v461.z.number()).optional(),
        /**
      The suffix that comes after a completion of inserted text.
       */ suffix: import_v461.z.string().optional(),
        /**
      A unique identifier representing your end-user, which can help OpenAI to
      monitor and detect abuse. Learn more.
       */ user: import_v461.z.string().optional(),
        /**
      Return the log probabilities of the tokens. Including logprobs will increase
      the response size and can slow down response times. However, it can
      be useful to better understand how the model is behaving.
      Setting to true will return the log probabilities of the tokens that
      were generated.
      Setting to a number will return the log probabilities of the top n
      tokens that were generated.
         */ logprobs: import_v461.z.union([
            import_v461.z.boolean(),
            import_v461.z.number()
        ]).optional()
    })));
var OpenAICompletionLanguageModel2 = class {
    constructor(modelId, config){
        this.specificationVersion = "v2";
        this.supportedUrls = {
        };
        this.modelId = modelId;
        this.config = config;
    }
    get providerOptionsName() {
        return this.config.provider.split(".")[0].trim();
    }
    get provider() {
        return this.config.provider;
    }
    getArgs(_0) {
        return __async(this, arguments, function*({ prompt, maxOutputTokens, temperature, topP, topK, frequencyPenalty, presencePenalty, stopSequences: userStopSequences, responseFormat, tools, toolChoice, seed, providerOptions }) {
            const warnings = [];
            const openaiOptions = __spreadValues(__spreadValues({}, (yield parseProviderOptions({
                provider: "openai",
                providerOptions,
                schema: openaiCompletionProviderOptions2
            }))), (yield parseProviderOptions({
                provider: this.providerOptionsName,
                providerOptions,
                schema: openaiCompletionProviderOptions2
            })));
            if (topK != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "topK"
                });
            }
            if (tools == null ? void 0 : tools.length) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "tools"
                });
            }
            if (toolChoice != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "toolChoice"
                });
            }
            if (responseFormat != null && responseFormat.type !== "text") {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "responseFormat",
                    details: "JSON response format is not supported."
                });
            }
            const { prompt: completionPrompt, stopSequences } = convertToOpenAICompletionPrompt2({
                prompt
            });
            const stop2 = [
                ...stopSequences != null ? stopSequences : [],
                ...userStopSequences != null ? userStopSequences : []
            ];
            return {
                args: {
                    // model id:
                    model: this.modelId,
                    // model specific settings:
                    echo: openaiOptions.echo,
                    logit_bias: openaiOptions.logitBias,
                    logprobs: (openaiOptions == null ? void 0 : openaiOptions.logprobs) === true ? 0 : (openaiOptions == null ? void 0 : openaiOptions.logprobs) === false ? void 0 : openaiOptions == null ? void 0 : openaiOptions.logprobs,
                    suffix: openaiOptions.suffix,
                    user: openaiOptions.user,
                    // standardized settings:
                    max_tokens: maxOutputTokens,
                    temperature,
                    top_p: topP,
                    frequency_penalty: frequencyPenalty,
                    presence_penalty: presencePenalty,
                    seed,
                    // prompt:
                    prompt: completionPrompt,
                    // stop sequences:
                    stop: stop2.length > 0 ? stop2 : void 0
                },
                warnings
            };
        });
    }
    doGenerate(options) {
        return __async(this, null, function*() {
            var _a, _b, _c;
            const { args, warnings } = yield this.getArgs(options);
            const { responseHeaders, value: response, rawValue: rawResponse } = yield postJsonToApi({
                url: this.config.url({
                    path: "/completions",
                    modelId: this.modelId
                }),
                headers: combineHeaders(this.config.headers(), options.headers),
                body: args,
                failedResponseHandler: openaiFailedResponseHandler2,
                successfulResponseHandler: createJsonResponseHandler(openaiCompletionResponseSchema2),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            const choice = response.choices[0];
            const providerMetadata = {
                openai: {}
            };
            if (choice.logprobs != null) {
                providerMetadata.openai.logprobs = choice.logprobs;
            }
            return {
                content: [
                    {
                        type: "text",
                        text: choice.text
                    }
                ],
                usage: {
                    inputTokens: (_a = response.usage) == null ? void 0 : _a.prompt_tokens,
                    outputTokens: (_b = response.usage) == null ? void 0 : _b.completion_tokens,
                    totalTokens: (_c = response.usage) == null ? void 0 : _c.total_tokens
                },
                finishReason: mapOpenAIFinishReason22(choice.finish_reason),
                request: {
                    body: args
                },
                response: __spreadProps(__spreadValues({}, getResponseMetadata23(response)), {
                    headers: responseHeaders,
                    body: rawResponse
                }),
                providerMetadata,
                warnings
            };
        });
    }
    doStream(options) {
        return __async(this, null, function*() {
            const { args, warnings } = yield this.getArgs(options);
            const body = __spreadProps(__spreadValues({}, args), {
                stream: true,
                stream_options: {
                    include_usage: true
                }
            });
            const { responseHeaders, value: response } = yield postJsonToApi({
                url: this.config.url({
                    path: "/completions",
                    modelId: this.modelId
                }),
                headers: combineHeaders(this.config.headers(), options.headers),
                body,
                failedResponseHandler: openaiFailedResponseHandler2,
                successfulResponseHandler: createEventSourceResponseHandler(openaiCompletionChunkSchema2),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            let finishReason = "unknown";
            const providerMetadata = {
                openai: {}
            };
            const usage = {
                inputTokens: void 0,
                outputTokens: void 0,
                totalTokens: void 0
            };
            let isFirstChunk = true;
            return {
                stream: response.pipeThrough(new TransformStream({
                    start (controller) {
                        controller.enqueue({
                            type: "stream-start",
                            warnings
                        });
                    },
                    transform (chunk, controller) {
                        if (options.includeRawChunks) {
                            controller.enqueue({
                                type: "raw",
                                rawValue: chunk.rawValue
                            });
                        }
                        if (!chunk.success) {
                            finishReason = "error";
                            controller.enqueue({
                                type: "error",
                                error: chunk.error
                            });
                            return;
                        }
                        const value = chunk.value;
                        if ("error" in value) {
                            finishReason = "error";
                            controller.enqueue({
                                type: "error",
                                error: value.error
                            });
                            return;
                        }
                        if (isFirstChunk) {
                            isFirstChunk = false;
                            controller.enqueue(__spreadValues({
                                type: "response-metadata"
                            }, getResponseMetadata23(value)));
                            controller.enqueue({
                                type: "text-start",
                                id: "0"
                            });
                        }
                        if (value.usage != null) {
                            usage.inputTokens = value.usage.prompt_tokens;
                            usage.outputTokens = value.usage.completion_tokens;
                            usage.totalTokens = value.usage.total_tokens;
                        }
                        const choice = value.choices[0];
                        if ((choice == null ? void 0 : choice.finish_reason) != null) {
                            finishReason = mapOpenAIFinishReason22(choice.finish_reason);
                        }
                        if ((choice == null ? void 0 : choice.logprobs) != null) {
                            providerMetadata.openai.logprobs = choice.logprobs;
                        }
                        if ((choice == null ? void 0 : choice.text) != null && choice.text.length > 0) {
                            controller.enqueue({
                                type: "text-delta",
                                id: "0",
                                delta: choice.text
                            });
                        }
                    },
                    flush (controller) {
                        if (!isFirstChunk) {
                            controller.enqueue({
                                type: "text-end",
                                id: "0"
                            });
                        }
                        controller.enqueue({
                            type: "finish",
                            finishReason,
                            providerMetadata,
                            usage
                        });
                    }
                })),
                request: {
                    body
                },
                response: {
                    headers: responseHeaders
                }
            };
        });
    }
};
var openaiEmbeddingProviderOptions2 = lazyValidator(()=>zodSchema(import_v462.z.object({
        /**
      The number of dimensions the resulting output embeddings should have.
      Only supported in text-embedding-3 and later models.
         */ dimensions: import_v462.z.number().optional(),
        /**
      A unique identifier representing your end-user, which can help OpenAI to
      monitor and detect abuse. Learn more.
      */ user: import_v462.z.string().optional()
    })));
var openaiTextEmbeddingResponseSchema3 = lazyValidator(()=>zodSchema(import_v463.z.object({
        data: import_v463.z.array(import_v463.z.object({
            embedding: import_v463.z.array(import_v463.z.number())
        })),
        usage: import_v463.z.object({
            prompt_tokens: import_v463.z.number()
        }).nullish()
    })));
var OpenAIEmbeddingModel2 = class {
    constructor(modelId, config){
        this.specificationVersion = "v2";
        this.maxEmbeddingsPerCall = 2048;
        this.supportsParallelCalls = true;
        this.modelId = modelId;
        this.config = config;
    }
    get provider() {
        return this.config.provider;
    }
    doEmbed(_0) {
        return __async(this, arguments, function*({ values, headers, abortSignal, providerOptions }) {
            var _a;
            if (values.length > this.maxEmbeddingsPerCall) {
                throw new import_provider39.TooManyEmbeddingValuesForCallError({
                    provider: this.provider,
                    modelId: this.modelId,
                    maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
                    values
                });
            }
            const openaiOptions = (_a = yield parseProviderOptions({
                provider: "openai",
                providerOptions,
                schema: openaiEmbeddingProviderOptions2
            })) != null ? _a : {};
            const { responseHeaders, value: response, rawValue } = yield postJsonToApi({
                url: this.config.url({
                    path: "/embeddings",
                    modelId: this.modelId
                }),
                headers: combineHeaders(this.config.headers(), headers),
                body: {
                    model: this.modelId,
                    input: values,
                    encoding_format: "float",
                    dimensions: openaiOptions.dimensions,
                    user: openaiOptions.user
                },
                failedResponseHandler: openaiFailedResponseHandler2,
                successfulResponseHandler: createJsonResponseHandler(openaiTextEmbeddingResponseSchema3),
                abortSignal,
                fetch: this.config.fetch
            });
            return {
                embeddings: response.data.map((item)=>item.embedding),
                usage: response.usage ? {
                    tokens: response.usage.prompt_tokens
                } : void 0,
                response: {
                    headers: responseHeaders,
                    body: rawValue
                }
            };
        });
    }
};
var openaiImageResponseSchema2 = lazyValidator(()=>zodSchema(import_v464.z.object({
        data: import_v464.z.array(import_v464.z.object({
            b64_json: import_v464.z.string(),
            revised_prompt: import_v464.z.string().optional()
        }))
    })));
var modelMaxImagesPerCall2 = {
    "dall-e-3": 1,
    "dall-e-2": 10,
    "gpt-image-1": 10,
    "gpt-image-1-mini": 10
};
var hasDefaultResponseFormat2 = /* @__PURE__ */ new Set([
    "gpt-image-1",
    "gpt-image-1-mini"
]);
var OpenAIImageModel2 = class {
    constructor(modelId, config){
        this.modelId = modelId;
        this.config = config;
        this.specificationVersion = "v2";
    }
    get maxImagesPerCall() {
        var _a;
        return (_a = modelMaxImagesPerCall2[this.modelId]) != null ? _a : 1;
    }
    get provider() {
        return this.config.provider;
    }
    doGenerate(_0) {
        return __async(this, arguments, function*({ prompt, n, size, aspectRatio, seed, providerOptions, headers, abortSignal }) {
            var _a, _b, _c, _d;
            const warnings = [];
            if (aspectRatio != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "aspectRatio",
                    details: "This model does not support aspect ratio. Use `size` instead."
                });
            }
            if (seed != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "seed"
                });
            }
            const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();
            const { value: response, responseHeaders } = yield postJsonToApi({
                url: this.config.url({
                    path: "/images/generations",
                    modelId: this.modelId
                }),
                headers: combineHeaders(this.config.headers(), headers),
                body: __spreadValues(__spreadValues({
                    model: this.modelId,
                    prompt,
                    n,
                    size
                }, (_d = providerOptions.openai) != null ? _d : {}), !hasDefaultResponseFormat2.has(this.modelId) ? {
                    response_format: "b64_json"
                } : {}),
                failedResponseHandler: openaiFailedResponseHandler2,
                successfulResponseHandler: createJsonResponseHandler(openaiImageResponseSchema2),
                abortSignal,
                fetch: this.config.fetch
            });
            return {
                images: response.data.map((item)=>item.b64_json),
                warnings,
                response: {
                    timestamp: currentDate,
                    modelId: this.modelId,
                    headers: responseHeaders
                },
                providerMetadata: {
                    openai: {
                        images: response.data.map((item)=>item.revised_prompt ? {
                                revisedPrompt: item.revised_prompt
                            } : null)
                    }
                }
            };
        });
    }
};
var openaiTranscriptionResponseSchema2 = lazyValidator(()=>zodSchema(import_v465.z.object({
        text: import_v465.z.string(),
        language: import_v465.z.string().nullish(),
        duration: import_v465.z.number().nullish(),
        words: import_v465.z.array(import_v465.z.object({
            word: import_v465.z.string(),
            start: import_v465.z.number(),
            end: import_v465.z.number()
        })).nullish(),
        segments: import_v465.z.array(import_v465.z.object({
            id: import_v465.z.number(),
            seek: import_v465.z.number(),
            start: import_v465.z.number(),
            end: import_v465.z.number(),
            text: import_v465.z.string(),
            tokens: import_v465.z.array(import_v465.z.number()),
            temperature: import_v465.z.number(),
            avg_logprob: import_v465.z.number(),
            compression_ratio: import_v465.z.number(),
            no_speech_prob: import_v465.z.number()
        })).nullish()
    })));
var openAITranscriptionProviderOptions2 = lazyValidator(()=>zodSchema(import_v466.z.object({
        /**
       * Additional information to include in the transcription response.
       */ include: import_v466.z.array(import_v466.z.string()).optional(),
        /**
       * The language of the input audio in ISO-639-1 format.
       */ language: import_v466.z.string().optional(),
        /**
       * An optional text to guide the model's style or continue a previous audio segment.
       */ prompt: import_v466.z.string().optional(),
        /**
       * The sampling temperature, between 0 and 1.
       * @default 0
       */ temperature: import_v466.z.number().min(0).max(1).default(0).optional(),
        /**
       * The timestamp granularities to populate for this transcription.
       * @default ['segment']
       */ timestampGranularities: import_v466.z.array(import_v466.z.enum([
            "word",
            "segment"
        ])).default([
            "segment"
        ]).optional()
    })));
var languageMap2 = {
    afrikaans: "af",
    arabic: "ar",
    armenian: "hy",
    azerbaijani: "az",
    belarusian: "be",
    bosnian: "bs",
    bulgarian: "bg",
    catalan: "ca",
    chinese: "zh",
    croatian: "hr",
    czech: "cs",
    danish: "da",
    dutch: "nl",
    english: "en",
    estonian: "et",
    finnish: "fi",
    french: "fr",
    galician: "gl",
    german: "de",
    greek: "el",
    hebrew: "he",
    hindi: "hi",
    hungarian: "hu",
    icelandic: "is",
    indonesian: "id",
    italian: "it",
    japanese: "ja",
    kannada: "kn",
    kazakh: "kk",
    korean: "ko",
    latvian: "lv",
    lithuanian: "lt",
    macedonian: "mk",
    malay: "ms",
    marathi: "mr",
    maori: "mi",
    nepali: "ne",
    norwegian: "no",
    persian: "fa",
    polish: "pl",
    portuguese: "pt",
    romanian: "ro",
    russian: "ru",
    serbian: "sr",
    slovak: "sk",
    slovenian: "sl",
    spanish: "es",
    swahili: "sw",
    swedish: "sv",
    tagalog: "tl",
    tamil: "ta",
    thai: "th",
    turkish: "tr",
    ukrainian: "uk",
    urdu: "ur",
    vietnamese: "vi",
    welsh: "cy"
};
var OpenAITranscriptionModel2 = class {
    constructor(modelId, config){
        this.modelId = modelId;
        this.config = config;
        this.specificationVersion = "v2";
    }
    get provider() {
        return this.config.provider;
    }
    getArgs(_0) {
        return __async(this, arguments, function*({ audio, mediaType, providerOptions }) {
            const warnings = [];
            const openAIOptions = yield parseProviderOptions({
                provider: "openai",
                providerOptions,
                schema: openAITranscriptionProviderOptions2
            });
            const formData = new FormData();
            const blob = audio instanceof Uint8Array ? new Blob([
                audio
            ]) : new Blob([
                convertBase64ToUint8Array(audio)
            ]);
            formData.append("model", this.modelId);
            const fileExtension = mediaTypeToExtension(mediaType);
            formData.append("file", new File([
                blob
            ], "audio", {
                type: mediaType
            }), `audio.${fileExtension}`);
            if (openAIOptions) {
                const transcriptionModelOptions = {
                    include: openAIOptions.include,
                    language: openAIOptions.language,
                    prompt: openAIOptions.prompt,
                    // https://platform.openai.com/docs/api-reference/audio/createTranscription#audio_createtranscription-response_format
                    // prefer verbose_json to get segments for models that support it
                    response_format: [
                        "gpt-4o-transcribe",
                        "gpt-4o-mini-transcribe"
                    ].includes(this.modelId) ? "json" : "verbose_json",
                    temperature: openAIOptions.temperature,
                    timestamp_granularities: openAIOptions.timestampGranularities
                };
                for (const [key, value] of Object.entries(transcriptionModelOptions)){
                    if (value != null) {
                        if (Array.isArray(value)) {
                            for (const item of value){
                                formData.append(`${key}[]`, String(item));
                            }
                        } else {
                            formData.append(key, String(value));
                        }
                    }
                }
            }
            return {
                formData,
                warnings
            };
        });
    }
    doGenerate(options) {
        return __async(this, null, function*() {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();
            const { formData, warnings } = yield this.getArgs(options);
            const { value: response, responseHeaders, rawValue: rawResponse } = yield postFormDataToApi({
                url: this.config.url({
                    path: "/audio/transcriptions",
                    modelId: this.modelId
                }),
                headers: combineHeaders(this.config.headers(), options.headers),
                formData,
                failedResponseHandler: openaiFailedResponseHandler2,
                successfulResponseHandler: createJsonResponseHandler(openaiTranscriptionResponseSchema2),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            const language = response.language != null && response.language in languageMap2 ? languageMap2[response.language] : void 0;
            return {
                text: response.text,
                segments: (_g = (_f = (_d = response.segments) == null ? void 0 : _d.map((segment)=>({
                        text: segment.text,
                        startSecond: segment.start,
                        endSecond: segment.end
                    }))) != null ? _f : (_e = response.words) == null ? void 0 : _e.map((word)=>({
                        text: word.word,
                        startSecond: word.start,
                        endSecond: word.end
                    }))) != null ? _g : [],
                language,
                durationInSeconds: (_h = response.duration) != null ? _h : void 0,
                warnings,
                response: {
                    timestamp: currentDate,
                    modelId: this.modelId,
                    headers: responseHeaders,
                    body: rawResponse
                }
            };
        });
    }
};
var openaiSpeechProviderOptionsSchema2 = lazyValidator(()=>zodSchema(import_v467.z.object({
        instructions: import_v467.z.string().nullish(),
        speed: import_v467.z.number().min(0.25).max(4).default(1).nullish()
    })));
var OpenAISpeechModel2 = class {
    constructor(modelId, config){
        this.modelId = modelId;
        this.config = config;
        this.specificationVersion = "v2";
    }
    get provider() {
        return this.config.provider;
    }
    getArgs(_0) {
        return __async(this, arguments, function*({ text, voice = "alloy", outputFormat = "mp3", speed, instructions, language, providerOptions }) {
            const warnings = [];
            const openAIOptions = yield parseProviderOptions({
                provider: "openai",
                providerOptions,
                schema: openaiSpeechProviderOptionsSchema2
            });
            const requestBody = {
                model: this.modelId,
                input: text,
                voice,
                response_format: "mp3",
                speed,
                instructions
            };
            if (outputFormat) {
                if ([
                    "mp3",
                    "opus",
                    "aac",
                    "flac",
                    "wav",
                    "pcm"
                ].includes(outputFormat)) {
                    requestBody.response_format = outputFormat;
                } else {
                    warnings.push({
                        type: "unsupported-setting",
                        setting: "outputFormat",
                        details: `Unsupported output format: ${outputFormat}. Using mp3 instead.`
                    });
                }
            }
            if (openAIOptions) {
                const speechModelOptions = {};
                for(const key in speechModelOptions){
                    const value = speechModelOptions[key];
                    if (value !== void 0) {
                        requestBody[key] = value;
                    }
                }
            }
            if (language) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "language",
                    details: `OpenAI speech models do not support language selection. Language parameter "${language}" was ignored.`
                });
            }
            return {
                requestBody,
                warnings
            };
        });
    }
    doGenerate(options) {
        return __async(this, null, function*() {
            var _a, _b, _c;
            const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();
            const { requestBody, warnings } = yield this.getArgs(options);
            const { value: audio, responseHeaders, rawValue: rawResponse } = yield postJsonToApi({
                url: this.config.url({
                    path: "/audio/speech",
                    modelId: this.modelId
                }),
                headers: combineHeaders(this.config.headers(), options.headers),
                body: requestBody,
                failedResponseHandler: openaiFailedResponseHandler2,
                successfulResponseHandler: createBinaryResponseHandler(),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            return {
                audio,
                warnings,
                request: {
                    body: JSON.stringify(requestBody)
                },
                response: {
                    timestamp: currentDate,
                    modelId: this.modelId,
                    headers: responseHeaders,
                    body: rawResponse
                }
            };
        });
    }
};
var localShellInputSchema2 = lazySchema(()=>zodSchema(import_v469.z.object({
        action: import_v469.z.object({
            type: import_v469.z.literal("exec"),
            command: import_v469.z.array(import_v469.z.string()),
            timeoutMs: import_v469.z.number().optional(),
            user: import_v469.z.string().optional(),
            workingDirectory: import_v469.z.string().optional(),
            env: import_v469.z.record(import_v469.z.string(), import_v469.z.string()).optional()
        })
    })));
var localShellOutputSchema2 = lazySchema(()=>zodSchema(import_v469.z.object({
        output: import_v469.z.string()
    })));
var localShell2 = createProviderDefinedToolFactoryWithOutputSchema({
    id: "openai.local_shell",
    name: "local_shell",
    inputSchema: localShellInputSchema2,
    outputSchema: localShellOutputSchema2
});
function isFileId2(data, prefixes) {
    if (!prefixes) return false;
    return prefixes.some((prefix)=>data.startsWith(prefix));
}
function convertToOpenAIResponsesInput2(_0) {
    return __async(this, arguments, function*({ prompt, systemMessageMode, fileIdPrefixes, store, hasLocalShellTool = false }) {
        var _a, _b, _c, _d;
        const input = [];
        const warnings = [];
        for (const { role, content } of prompt){
            switch(role){
                case "system":
                    {
                        switch(systemMessageMode){
                            case "system":
                                {
                                    input.push({
                                        role: "system",
                                        content
                                    });
                                    break;
                                }
                            case "developer":
                                {
                                    input.push({
                                        role: "developer",
                                        content
                                    });
                                    break;
                                }
                            case "remove":
                                {
                                    warnings.push({
                                        type: "other",
                                        message: "system messages are removed for this model"
                                    });
                                    break;
                                }
                            default:
                                {
                                    const _exhaustiveCheck = systemMessageMode;
                                    throw new Error(`Unsupported system message mode: ${_exhaustiveCheck}`);
                                }
                        }
                        break;
                    }
                case "user":
                    {
                        input.push({
                            role: "user",
                            content: content.map((part, index)=>{
                                var _a2, _b2, _c2;
                                switch(part.type){
                                    case "text":
                                        {
                                            return {
                                                type: "input_text",
                                                text: part.text
                                            };
                                        }
                                    case "file":
                                        {
                                            if (part.mediaType.startsWith("image/")) {
                                                const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                                                return __spreadProps(__spreadValues({
                                                    type: "input_image"
                                                }, part.data instanceof URL ? {
                                                    image_url: part.data.toString()
                                                } : typeof part.data === "string" && isFileId2(part.data, fileIdPrefixes) ? {
                                                    file_id: part.data
                                                } : {
                                                    image_url: `data:${mediaType};base64,${convertToBase64(part.data)}`
                                                }), {
                                                    detail: (_b2 = (_a2 = part.providerOptions) == null ? void 0 : _a2.openai) == null ? void 0 : _b2.imageDetail
                                                });
                                            } else if (part.mediaType === "application/pdf") {
                                                if (part.data instanceof URL) {
                                                    return {
                                                        type: "input_file",
                                                        file_url: part.data.toString()
                                                    };
                                                }
                                                return __spreadValues({
                                                    type: "input_file"
                                                }, typeof part.data === "string" && isFileId2(part.data, fileIdPrefixes) ? {
                                                    file_id: part.data
                                                } : {
                                                    filename: (_c2 = part.filename) != null ? _c2 : `part-${index}.pdf`,
                                                    file_data: `data:application/pdf;base64,${convertToBase64(part.data)}`
                                                });
                                            } else {
                                                throw new import_provider41.UnsupportedFunctionalityError({
                                                    functionality: `file part media type ${part.mediaType}`
                                                });
                                            }
                                        }
                                }
                            })
                        });
                        break;
                    }
                case "assistant":
                    {
                        const reasoningMessages = {};
                        const toolCallParts = {};
                        for (const part of content){
                            switch(part.type){
                                case "text":
                                    {
                                        const id = (_b = (_a = part.providerOptions) == null ? void 0 : _a.openai) == null ? void 0 : _b.itemId;
                                        if (store && id != null) {
                                            input.push({
                                                type: "item_reference",
                                                id
                                            });
                                            break;
                                        }
                                        input.push({
                                            role: "assistant",
                                            content: [
                                                {
                                                    type: "output_text",
                                                    text: part.text
                                                }
                                            ],
                                            id
                                        });
                                        break;
                                    }
                                case "tool-call":
                                    {
                                        toolCallParts[part.toolCallId] = part;
                                        if (part.providerExecuted) {
                                            break;
                                        }
                                        const id = (_d = (_c = part.providerOptions) == null ? void 0 : _c.openai) == null ? void 0 : _d.itemId;
                                        if (store && id != null) {
                                            input.push({
                                                type: "item_reference",
                                                id
                                            });
                                            break;
                                        }
                                        if (hasLocalShellTool && part.toolName === "local_shell") {
                                            const parsedInput = yield validateTypes({
                                                value: part.input,
                                                schema: localShellInputSchema2
                                            });
                                            input.push({
                                                type: "local_shell_call",
                                                call_id: part.toolCallId,
                                                id,
                                                action: {
                                                    type: "exec",
                                                    command: parsedInput.action.command,
                                                    timeout_ms: parsedInput.action.timeoutMs,
                                                    user: parsedInput.action.user,
                                                    working_directory: parsedInput.action.workingDirectory,
                                                    env: parsedInput.action.env
                                                }
                                            });
                                            break;
                                        }
                                        input.push({
                                            type: "function_call",
                                            call_id: part.toolCallId,
                                            name: part.toolName,
                                            arguments: JSON.stringify(part.input),
                                            id
                                        });
                                        break;
                                    }
                                // assistant tool result parts are from provider-executed tools:
                                case "tool-result":
                                    {
                                        if (store) {
                                            input.push({
                                                type: "item_reference",
                                                id: part.toolCallId
                                            });
                                        } else {
                                            warnings.push({
                                                type: "other",
                                                message: `Results for OpenAI tool ${part.toolName} are not sent to the API when store is false`
                                            });
                                        }
                                        break;
                                    }
                                case "reasoning":
                                    {
                                        const providerOptions = yield parseProviderOptions({
                                            provider: "openai",
                                            providerOptions: part.providerOptions,
                                            schema: openaiResponsesReasoningProviderOptionsSchema2
                                        });
                                        const reasoningId = providerOptions == null ? void 0 : providerOptions.itemId;
                                        if (reasoningId != null) {
                                            const reasoningMessage = reasoningMessages[reasoningId];
                                            if (store) {
                                                if (reasoningMessage === void 0) {
                                                    input.push({
                                                        type: "item_reference",
                                                        id: reasoningId
                                                    });
                                                    reasoningMessages[reasoningId] = {
                                                        type: "reasoning",
                                                        id: reasoningId,
                                                        summary: []
                                                    };
                                                }
                                            } else {
                                                const summaryParts = [];
                                                if (part.text.length > 0) {
                                                    summaryParts.push({
                                                        type: "summary_text",
                                                        text: part.text
                                                    });
                                                } else if (reasoningMessage !== void 0) {
                                                    warnings.push({
                                                        type: "other",
                                                        message: `Cannot append empty reasoning part to existing reasoning sequence. Skipping reasoning part: ${JSON.stringify(part)}.`
                                                    });
                                                }
                                                if (reasoningMessage === void 0) {
                                                    reasoningMessages[reasoningId] = {
                                                        type: "reasoning",
                                                        id: reasoningId,
                                                        encrypted_content: providerOptions == null ? void 0 : providerOptions.reasoningEncryptedContent,
                                                        summary: summaryParts
                                                    };
                                                    input.push(reasoningMessages[reasoningId]);
                                                } else {
                                                    reasoningMessage.summary.push(...summaryParts);
                                                    if ((providerOptions == null ? void 0 : providerOptions.reasoningEncryptedContent) != null) {
                                                        reasoningMessage.encrypted_content = providerOptions.reasoningEncryptedContent;
                                                    }
                                                }
                                            }
                                        } else {
                                            warnings.push({
                                                type: "other",
                                                message: `Non-OpenAI reasoning parts are not supported. Skipping reasoning part: ${JSON.stringify(part)}.`
                                            });
                                        }
                                        break;
                                    }
                            }
                        }
                        break;
                    }
                case "tool":
                    {
                        for (const part of content){
                            const output = part.output;
                            if (hasLocalShellTool && part.toolName === "local_shell" && output.type === "json") {
                                const parsedOutput = yield validateTypes({
                                    value: output.value,
                                    schema: localShellOutputSchema2
                                });
                                input.push({
                                    type: "local_shell_call_output",
                                    call_id: part.toolCallId,
                                    output: parsedOutput.output
                                });
                                break;
                            }
                            let contentValue;
                            switch(output.type){
                                case "text":
                                case "error-text":
                                    contentValue = output.value;
                                    break;
                                case "json":
                                case "error-json":
                                    contentValue = JSON.stringify(output.value);
                                    break;
                                case "content":
                                    contentValue = output.value.map((item)=>{
                                        switch(item.type){
                                            case "text":
                                                {
                                                    return {
                                                        type: "input_text",
                                                        text: item.text
                                                    };
                                                }
                                            case "media":
                                                {
                                                    return item.mediaType.startsWith("image/") ? {
                                                        type: "input_image",
                                                        image_url: `data:${item.mediaType};base64,${item.data}`
                                                    } : {
                                                        type: "input_file",
                                                        filename: "data",
                                                        file_data: `data:${item.mediaType};base64,${item.data}`
                                                    };
                                                }
                                        }
                                    });
                                    break;
                            }
                            input.push({
                                type: "function_call_output",
                                call_id: part.toolCallId,
                                output: contentValue
                            });
                        }
                        break;
                    }
                default:
                    {
                        const _exhaustiveCheck = role;
                        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
                    }
            }
        }
        return {
            input,
            warnings
        };
    });
}
var openaiResponsesReasoningProviderOptionsSchema2 = import_v468.z.object({
    itemId: import_v468.z.string().nullish(),
    reasoningEncryptedContent: import_v468.z.string().nullish()
});
function mapOpenAIResponseFinishReason2({ finishReason, hasFunctionCall }) {
    switch(finishReason){
        case void 0:
        case null:
            return hasFunctionCall ? "tool-calls" : "stop";
        case "max_output_tokens":
            return "length";
        case "content_filter":
            return "content-filter";
        default:
            return hasFunctionCall ? "tool-calls" : "unknown";
    }
}
var openaiResponsesChunkSchema2 = lazyValidator(()=>zodSchema(import_v470.z.union([
        import_v470.z.object({
            type: import_v470.z.literal("response.output_text.delta"),
            item_id: import_v470.z.string(),
            delta: import_v470.z.string(),
            logprobs: import_v470.z.array(import_v470.z.object({
                token: import_v470.z.string(),
                logprob: import_v470.z.number(),
                top_logprobs: import_v470.z.array(import_v470.z.object({
                    token: import_v470.z.string(),
                    logprob: import_v470.z.number()
                }))
            })).nullish()
        }),
        import_v470.z.object({
            type: import_v470.z.enum([
                "response.completed",
                "response.incomplete"
            ]),
            response: import_v470.z.object({
                incomplete_details: import_v470.z.object({
                    reason: import_v470.z.string()
                }).nullish(),
                usage: import_v470.z.object({
                    input_tokens: import_v470.z.number(),
                    input_tokens_details: import_v470.z.object({
                        cached_tokens: import_v470.z.number().nullish()
                    }).nullish(),
                    output_tokens: import_v470.z.number(),
                    output_tokens_details: import_v470.z.object({
                        reasoning_tokens: import_v470.z.number().nullish()
                    }).nullish()
                }),
                service_tier: import_v470.z.string().nullish()
            })
        }),
        import_v470.z.object({
            type: import_v470.z.literal("response.created"),
            response: import_v470.z.object({
                id: import_v470.z.string(),
                created_at: import_v470.z.number(),
                model: import_v470.z.string(),
                service_tier: import_v470.z.string().nullish()
            })
        }),
        import_v470.z.object({
            type: import_v470.z.literal("response.output_item.added"),
            output_index: import_v470.z.number(),
            item: import_v470.z.discriminatedUnion("type", [
                import_v470.z.object({
                    type: import_v470.z.literal("message"),
                    id: import_v470.z.string()
                }),
                import_v470.z.object({
                    type: import_v470.z.literal("reasoning"),
                    id: import_v470.z.string(),
                    encrypted_content: import_v470.z.string().nullish()
                }),
                import_v470.z.object({
                    type: import_v470.z.literal("function_call"),
                    id: import_v470.z.string(),
                    call_id: import_v470.z.string(),
                    name: import_v470.z.string(),
                    arguments: import_v470.z.string()
                }),
                import_v470.z.object({
                    type: import_v470.z.literal("web_search_call"),
                    id: import_v470.z.string(),
                    status: import_v470.z.string()
                }),
                import_v470.z.object({
                    type: import_v470.z.literal("computer_call"),
                    id: import_v470.z.string(),
                    status: import_v470.z.string()
                }),
                import_v470.z.object({
                    type: import_v470.z.literal("file_search_call"),
                    id: import_v470.z.string()
                }),
                import_v470.z.object({
                    type: import_v470.z.literal("image_generation_call"),
                    id: import_v470.z.string()
                }),
                import_v470.z.object({
                    type: import_v470.z.literal("code_interpreter_call"),
                    id: import_v470.z.string(),
                    container_id: import_v470.z.string(),
                    code: import_v470.z.string().nullable(),
                    outputs: import_v470.z.array(import_v470.z.discriminatedUnion("type", [
                        import_v470.z.object({
                            type: import_v470.z.literal("logs"),
                            logs: import_v470.z.string()
                        }),
                        import_v470.z.object({
                            type: import_v470.z.literal("image"),
                            url: import_v470.z.string()
                        })
                    ])).nullable(),
                    status: import_v470.z.string()
                })
            ])
        }),
        import_v470.z.object({
            type: import_v470.z.literal("response.output_item.done"),
            output_index: import_v470.z.number(),
            item: import_v470.z.discriminatedUnion("type", [
                import_v470.z.object({
                    type: import_v470.z.literal("message"),
                    id: import_v470.z.string()
                }),
                import_v470.z.object({
                    type: import_v470.z.literal("reasoning"),
                    id: import_v470.z.string(),
                    encrypted_content: import_v470.z.string().nullish()
                }),
                import_v470.z.object({
                    type: import_v470.z.literal("function_call"),
                    id: import_v470.z.string(),
                    call_id: import_v470.z.string(),
                    name: import_v470.z.string(),
                    arguments: import_v470.z.string(),
                    status: import_v470.z.literal("completed")
                }),
                import_v470.z.object({
                    type: import_v470.z.literal("code_interpreter_call"),
                    id: import_v470.z.string(),
                    code: import_v470.z.string().nullable(),
                    container_id: import_v470.z.string(),
                    outputs: import_v470.z.array(import_v470.z.discriminatedUnion("type", [
                        import_v470.z.object({
                            type: import_v470.z.literal("logs"),
                            logs: import_v470.z.string()
                        }),
                        import_v470.z.object({
                            type: import_v470.z.literal("image"),
                            url: import_v470.z.string()
                        })
                    ])).nullable()
                }),
                import_v470.z.object({
                    type: import_v470.z.literal("image_generation_call"),
                    id: import_v470.z.string(),
                    result: import_v470.z.string()
                }),
                import_v470.z.object({
                    type: import_v470.z.literal("web_search_call"),
                    id: import_v470.z.string(),
                    status: import_v470.z.string(),
                    action: import_v470.z.discriminatedUnion("type", [
                        import_v470.z.object({
                            type: import_v470.z.literal("search"),
                            query: import_v470.z.string().nullish()
                        }),
                        import_v470.z.object({
                            type: import_v470.z.literal("open_page"),
                            url: import_v470.z.string()
                        }),
                        import_v470.z.object({
                            type: import_v470.z.literal("find"),
                            url: import_v470.z.string(),
                            pattern: import_v470.z.string()
                        })
                    ])
                }),
                import_v470.z.object({
                    type: import_v470.z.literal("file_search_call"),
                    id: import_v470.z.string(),
                    queries: import_v470.z.array(import_v470.z.string()),
                    results: import_v470.z.array(import_v470.z.object({
                        attributes: import_v470.z.record(import_v470.z.string(), import_v470.z.unknown()),
                        file_id: import_v470.z.string(),
                        filename: import_v470.z.string(),
                        score: import_v470.z.number(),
                        text: import_v470.z.string()
                    })).nullish()
                }),
                import_v470.z.object({
                    type: import_v470.z.literal("local_shell_call"),
                    id: import_v470.z.string(),
                    call_id: import_v470.z.string(),
                    action: import_v470.z.object({
                        type: import_v470.z.literal("exec"),
                        command: import_v470.z.array(import_v470.z.string()),
                        timeout_ms: import_v470.z.number().optional(),
                        user: import_v470.z.string().optional(),
                        working_directory: import_v470.z.string().optional(),
                        env: import_v470.z.record(import_v470.z.string(), import_v470.z.string()).optional()
                    })
                }),
                import_v470.z.object({
                    type: import_v470.z.literal("computer_call"),
                    id: import_v470.z.string(),
                    status: import_v470.z.literal("completed")
                })
            ])
        }),
        import_v470.z.object({
            type: import_v470.z.literal("response.function_call_arguments.delta"),
            item_id: import_v470.z.string(),
            output_index: import_v470.z.number(),
            delta: import_v470.z.string()
        }),
        import_v470.z.object({
            type: import_v470.z.literal("response.image_generation_call.partial_image"),
            item_id: import_v470.z.string(),
            output_index: import_v470.z.number(),
            partial_image_b64: import_v470.z.string()
        }),
        import_v470.z.object({
            type: import_v470.z.literal("response.code_interpreter_call_code.delta"),
            item_id: import_v470.z.string(),
            output_index: import_v470.z.number(),
            delta: import_v470.z.string()
        }),
        import_v470.z.object({
            type: import_v470.z.literal("response.code_interpreter_call_code.done"),
            item_id: import_v470.z.string(),
            output_index: import_v470.z.number(),
            code: import_v470.z.string()
        }),
        import_v470.z.object({
            type: import_v470.z.literal("response.output_text.annotation.added"),
            annotation: import_v470.z.discriminatedUnion("type", [
                import_v470.z.object({
                    type: import_v470.z.literal("url_citation"),
                    url: import_v470.z.string(),
                    title: import_v470.z.string()
                }),
                import_v470.z.object({
                    type: import_v470.z.literal("file_citation"),
                    file_id: import_v470.z.string(),
                    filename: import_v470.z.string().nullish(),
                    index: import_v470.z.number().nullish(),
                    start_index: import_v470.z.number().nullish(),
                    end_index: import_v470.z.number().nullish(),
                    quote: import_v470.z.string().nullish()
                })
            ])
        }),
        import_v470.z.object({
            type: import_v470.z.literal("response.reasoning_summary_part.added"),
            item_id: import_v470.z.string(),
            summary_index: import_v470.z.number()
        }),
        import_v470.z.object({
            type: import_v470.z.literal("response.reasoning_summary_text.delta"),
            item_id: import_v470.z.string(),
            summary_index: import_v470.z.number(),
            delta: import_v470.z.string()
        }),
        import_v470.z.object({
            type: import_v470.z.literal("response.reasoning_summary_part.done"),
            item_id: import_v470.z.string(),
            summary_index: import_v470.z.number()
        }),
        import_v470.z.object({
            type: import_v470.z.literal("error"),
            code: import_v470.z.string(),
            message: import_v470.z.string(),
            param: import_v470.z.string().nullish(),
            sequence_number: import_v470.z.number()
        }),
        import_v470.z.object({
            type: import_v470.z.string()
        }).loose().transform((value)=>({
                type: "unknown_chunk",
                message: value.type
            }))
    ])));
var openaiResponsesResponseSchema2 = lazyValidator(()=>zodSchema(import_v470.z.object({
        id: import_v470.z.string(),
        created_at: import_v470.z.number(),
        error: import_v470.z.object({
            code: import_v470.z.string(),
            message: import_v470.z.string()
        }).nullish(),
        model: import_v470.z.string(),
        output: import_v470.z.array(import_v470.z.discriminatedUnion("type", [
            import_v470.z.object({
                type: import_v470.z.literal("message"),
                role: import_v470.z.literal("assistant"),
                id: import_v470.z.string(),
                content: import_v470.z.array(import_v470.z.object({
                    type: import_v470.z.literal("output_text"),
                    text: import_v470.z.string(),
                    logprobs: import_v470.z.array(import_v470.z.object({
                        token: import_v470.z.string(),
                        logprob: import_v470.z.number(),
                        top_logprobs: import_v470.z.array(import_v470.z.object({
                            token: import_v470.z.string(),
                            logprob: import_v470.z.number()
                        }))
                    })).nullish(),
                    annotations: import_v470.z.array(import_v470.z.discriminatedUnion("type", [
                        import_v470.z.object({
                            type: import_v470.z.literal("url_citation"),
                            start_index: import_v470.z.number(),
                            end_index: import_v470.z.number(),
                            url: import_v470.z.string(),
                            title: import_v470.z.string()
                        }),
                        import_v470.z.object({
                            type: import_v470.z.literal("file_citation"),
                            file_id: import_v470.z.string(),
                            filename: import_v470.z.string().nullish(),
                            index: import_v470.z.number().nullish(),
                            start_index: import_v470.z.number().nullish(),
                            end_index: import_v470.z.number().nullish(),
                            quote: import_v470.z.string().nullish()
                        }),
                        import_v470.z.object({
                            type: import_v470.z.literal("container_file_citation")
                        })
                    ]))
                }))
            }),
            import_v470.z.object({
                type: import_v470.z.literal("web_search_call"),
                id: import_v470.z.string(),
                status: import_v470.z.string(),
                action: import_v470.z.discriminatedUnion("type", [
                    import_v470.z.object({
                        type: import_v470.z.literal("search"),
                        query: import_v470.z.string().nullish()
                    }),
                    import_v470.z.object({
                        type: import_v470.z.literal("open_page"),
                        url: import_v470.z.string()
                    }),
                    import_v470.z.object({
                        type: import_v470.z.literal("find"),
                        url: import_v470.z.string(),
                        pattern: import_v470.z.string()
                    })
                ])
            }),
            import_v470.z.object({
                type: import_v470.z.literal("file_search_call"),
                id: import_v470.z.string(),
                queries: import_v470.z.array(import_v470.z.string()),
                results: import_v470.z.array(import_v470.z.object({
                    attributes: import_v470.z.record(import_v470.z.string(), import_v470.z.unknown()),
                    file_id: import_v470.z.string(),
                    filename: import_v470.z.string(),
                    score: import_v470.z.number(),
                    text: import_v470.z.string()
                })).nullish()
            }),
            import_v470.z.object({
                type: import_v470.z.literal("code_interpreter_call"),
                id: import_v470.z.string(),
                code: import_v470.z.string().nullable(),
                container_id: import_v470.z.string(),
                outputs: import_v470.z.array(import_v470.z.discriminatedUnion("type", [
                    import_v470.z.object({
                        type: import_v470.z.literal("logs"),
                        logs: import_v470.z.string()
                    }),
                    import_v470.z.object({
                        type: import_v470.z.literal("image"),
                        url: import_v470.z.string()
                    })
                ])).nullable()
            }),
            import_v470.z.object({
                type: import_v470.z.literal("image_generation_call"),
                id: import_v470.z.string(),
                result: import_v470.z.string()
            }),
            import_v470.z.object({
                type: import_v470.z.literal("local_shell_call"),
                id: import_v470.z.string(),
                call_id: import_v470.z.string(),
                action: import_v470.z.object({
                    type: import_v470.z.literal("exec"),
                    command: import_v470.z.array(import_v470.z.string()),
                    timeout_ms: import_v470.z.number().optional(),
                    user: import_v470.z.string().optional(),
                    working_directory: import_v470.z.string().optional(),
                    env: import_v470.z.record(import_v470.z.string(), import_v470.z.string()).optional()
                })
            }),
            import_v470.z.object({
                type: import_v470.z.literal("function_call"),
                call_id: import_v470.z.string(),
                name: import_v470.z.string(),
                arguments: import_v470.z.string(),
                id: import_v470.z.string()
            }),
            import_v470.z.object({
                type: import_v470.z.literal("computer_call"),
                id: import_v470.z.string(),
                status: import_v470.z.string().optional()
            }),
            import_v470.z.object({
                type: import_v470.z.literal("reasoning"),
                id: import_v470.z.string(),
                encrypted_content: import_v470.z.string().nullish(),
                summary: import_v470.z.array(import_v470.z.object({
                    type: import_v470.z.literal("summary_text"),
                    text: import_v470.z.string()
                }))
            })
        ])),
        service_tier: import_v470.z.string().nullish(),
        incomplete_details: import_v470.z.object({
            reason: import_v470.z.string()
        }).nullish(),
        usage: import_v470.z.object({
            input_tokens: import_v470.z.number(),
            input_tokens_details: import_v470.z.object({
                cached_tokens: import_v470.z.number().nullish()
            }).nullish(),
            output_tokens: import_v470.z.number(),
            output_tokens_details: import_v470.z.object({
                reasoning_tokens: import_v470.z.number().nullish()
            }).nullish()
        })
    })));
var TOP_LOGPROBS_MAX2 = 20;
var openaiResponsesReasoningModelIds2 = [
    "o1",
    "o1-2024-12-17",
    "o3-mini",
    "o3-mini-2025-01-31",
    "o3",
    "o3-2025-04-16",
    "o4-mini",
    "o4-mini-2025-04-16",
    "codex-mini-latest",
    "computer-use-preview",
    "gpt-5",
    "gpt-5-2025-08-07",
    "gpt-5-codex",
    "gpt-5-mini",
    "gpt-5-mini-2025-08-07",
    "gpt-5-nano",
    "gpt-5-nano-2025-08-07",
    "gpt-5-pro",
    "gpt-5-pro-2025-10-06"
];
var openaiResponsesModelIds2 = [
    "gpt-4.1",
    "gpt-4.1-2025-04-14",
    "gpt-4.1-mini",
    "gpt-4.1-mini-2025-04-14",
    "gpt-4.1-nano",
    "gpt-4.1-nano-2025-04-14",
    "gpt-4o",
    "gpt-4o-2024-05-13",
    "gpt-4o-2024-08-06",
    "gpt-4o-2024-11-20",
    "gpt-4o-audio-preview",
    "gpt-4o-audio-preview-2024-10-01",
    "gpt-4o-audio-preview-2024-12-17",
    "gpt-4o-search-preview",
    "gpt-4o-search-preview-2025-03-11",
    "gpt-4o-mini-search-preview",
    "gpt-4o-mini-search-preview-2025-03-11",
    "gpt-4o-mini",
    "gpt-4o-mini-2024-07-18",
    "gpt-4-turbo",
    "gpt-4-turbo-2024-04-09",
    "gpt-4-turbo-preview",
    "gpt-4-0125-preview",
    "gpt-4-1106-preview",
    "gpt-4",
    "gpt-4-0613",
    "gpt-4.5-preview",
    "gpt-4.5-preview-2025-02-27",
    "gpt-3.5-turbo-0125",
    "gpt-3.5-turbo",
    "gpt-3.5-turbo-1106",
    "chatgpt-4o-latest",
    "gpt-5-chat-latest",
    ...openaiResponsesReasoningModelIds2
];
var openaiResponsesProviderOptionsSchema2 = lazyValidator(()=>zodSchema(import_v471.z.object({
        include: import_v471.z.array(import_v471.z.enum([
            "reasoning.encrypted_content",
            // handled internally by default, only needed for unknown reasoning models
            "file_search_call.results",
            "message.output_text.logprobs"
        ])).nullish(),
        instructions: import_v471.z.string().nullish(),
        /**
       * Return the log probabilities of the tokens.
       *
       * Setting to true will return the log probabilities of the tokens that
       * were generated.
       *
       * Setting to a number will return the log probabilities of the top n
       * tokens that were generated.
       *
       * @see https://platform.openai.com/docs/api-reference/responses/create
       * @see https://cookbook.openai.com/examples/using_logprobs
       */ logprobs: import_v471.z.union([
            import_v471.z.boolean(),
            import_v471.z.number().min(1).max(TOP_LOGPROBS_MAX2)
        ]).optional(),
        /**
       * The maximum number of total calls to built-in tools that can be processed in a response.
       * This maximum number applies across all built-in tool calls, not per individual tool.
       * Any further attempts to call a tool by the model will be ignored.
       */ maxToolCalls: import_v471.z.number().nullish(),
        metadata: import_v471.z.any().nullish(),
        parallelToolCalls: import_v471.z.boolean().nullish(),
        previousResponseId: import_v471.z.string().nullish(),
        promptCacheKey: import_v471.z.string().nullish(),
        reasoningEffort: import_v471.z.string().nullish(),
        reasoningSummary: import_v471.z.string().nullish(),
        safetyIdentifier: import_v471.z.string().nullish(),
        serviceTier: import_v471.z.enum([
            "auto",
            "flex",
            "priority",
            "default"
        ]).nullish(),
        store: import_v471.z.boolean().nullish(),
        strictJsonSchema: import_v471.z.boolean().nullish(),
        textVerbosity: import_v471.z.enum([
            "low",
            "medium",
            "high"
        ]).nullish(),
        truncation: import_v471.z.enum([
            "auto",
            "disabled"
        ]).nullish(),
        user: import_v471.z.string().nullish()
    })));
var codeInterpreterInputSchema2 = lazySchema(()=>zodSchema(import_v472.z.object({
        code: import_v472.z.string().nullish(),
        containerId: import_v472.z.string()
    })));
var codeInterpreterOutputSchema2 = lazySchema(()=>zodSchema(import_v472.z.object({
        outputs: import_v472.z.array(import_v472.z.discriminatedUnion("type", [
            import_v472.z.object({
                type: import_v472.z.literal("logs"),
                logs: import_v472.z.string()
            }),
            import_v472.z.object({
                type: import_v472.z.literal("image"),
                url: import_v472.z.string()
            })
        ])).nullish()
    })));
var codeInterpreterArgsSchema2 = lazySchema(()=>zodSchema(import_v472.z.object({
        container: import_v472.z.union([
            import_v472.z.string(),
            import_v472.z.object({
                fileIds: import_v472.z.array(import_v472.z.string()).optional()
            })
        ]).optional()
    })));
var codeInterpreterToolFactory2 = createProviderDefinedToolFactoryWithOutputSchema({
    id: "openai.code_interpreter",
    name: "code_interpreter",
    inputSchema: codeInterpreterInputSchema2,
    outputSchema: codeInterpreterOutputSchema2
});
var codeInterpreter2 = (args = {})=>{
    return codeInterpreterToolFactory2(args);
};
var comparisonFilterSchema2 = import_v473.z.object({
    key: import_v473.z.string(),
    type: import_v473.z.enum([
        "eq",
        "ne",
        "gt",
        "gte",
        "lt",
        "lte"
    ]),
    value: import_v473.z.union([
        import_v473.z.string(),
        import_v473.z.number(),
        import_v473.z.boolean()
    ])
});
var compoundFilterSchema2 = import_v473.z.object({
    type: import_v473.z.enum([
        "and",
        "or"
    ]),
    filters: import_v473.z.array(import_v473.z.union([
        comparisonFilterSchema2,
        import_v473.z.lazy(()=>compoundFilterSchema2)
    ]))
});
var fileSearchArgsSchema2 = lazySchema(()=>zodSchema(import_v473.z.object({
        vectorStoreIds: import_v473.z.array(import_v473.z.string()),
        maxNumResults: import_v473.z.number().optional(),
        ranking: import_v473.z.object({
            ranker: import_v473.z.string().optional(),
            scoreThreshold: import_v473.z.number().optional()
        }).optional(),
        filters: import_v473.z.union([
            comparisonFilterSchema2,
            compoundFilterSchema2
        ]).optional()
    })));
var fileSearchOutputSchema2 = lazySchema(()=>zodSchema(import_v473.z.object({
        queries: import_v473.z.array(import_v473.z.string()),
        results: import_v473.z.array(import_v473.z.object({
            attributes: import_v473.z.record(import_v473.z.string(), import_v473.z.unknown()),
            fileId: import_v473.z.string(),
            filename: import_v473.z.string(),
            score: import_v473.z.number(),
            text: import_v473.z.string()
        })).nullable()
    })));
var fileSearch2 = createProviderDefinedToolFactoryWithOutputSchema({
    id: "openai.file_search",
    name: "file_search",
    inputSchema: import_v473.z.object({}),
    outputSchema: fileSearchOutputSchema2
});
var webSearchArgsSchema2 = lazySchema(()=>zodSchema(import_v474.z.object({
        filters: import_v474.z.object({
            allowedDomains: import_v474.z.array(import_v474.z.string()).optional()
        }).optional(),
        searchContextSize: import_v474.z.enum([
            "low",
            "medium",
            "high"
        ]).optional(),
        userLocation: import_v474.z.object({
            type: import_v474.z.literal("approximate"),
            country: import_v474.z.string().optional(),
            city: import_v474.z.string().optional(),
            region: import_v474.z.string().optional(),
            timezone: import_v474.z.string().optional()
        }).optional()
    })));
var webSearchInputSchema2 = lazySchema(()=>zodSchema(import_v474.z.object({})));
var webSearchOutputSchema2 = lazySchema(()=>zodSchema(import_v474.z.object({
        action: import_v474.z.discriminatedUnion("type", [
            import_v474.z.object({
                type: import_v474.z.literal("search"),
                query: import_v474.z.string().optional()
            }),
            import_v474.z.object({
                type: import_v474.z.literal("openPage"),
                url: import_v474.z.string()
            }),
            import_v474.z.object({
                type: import_v474.z.literal("find"),
                url: import_v474.z.string(),
                pattern: import_v474.z.string()
            })
        ])
    })));
var webSearchToolFactory2 = createProviderDefinedToolFactoryWithOutputSchema({
    id: "openai.web_search",
    name: "web_search",
    inputSchema: webSearchInputSchema2,
    outputSchema: webSearchOutputSchema2
});
var webSearchPreviewArgsSchema2 = lazySchema(()=>zodSchema(import_v475.z.object({
        searchContextSize: import_v475.z.enum([
            "low",
            "medium",
            "high"
        ]).optional(),
        userLocation: import_v475.z.object({
            type: import_v475.z.literal("approximate"),
            country: import_v475.z.string().optional(),
            city: import_v475.z.string().optional(),
            region: import_v475.z.string().optional(),
            timezone: import_v475.z.string().optional()
        }).optional()
    })));
var webSearchPreviewInputSchema2 = lazySchema(()=>zodSchema(import_v475.z.object({})));
var webSearchPreviewOutputSchema2 = lazySchema(()=>zodSchema(import_v475.z.object({
        action: import_v475.z.discriminatedUnion("type", [
            import_v475.z.object({
                type: import_v475.z.literal("search"),
                query: import_v475.z.string().optional()
            }),
            import_v475.z.object({
                type: import_v475.z.literal("openPage"),
                url: import_v475.z.string()
            }),
            import_v475.z.object({
                type: import_v475.z.literal("find"),
                url: import_v475.z.string(),
                pattern: import_v475.z.string()
            })
        ])
    })));
var webSearchPreview2 = createProviderDefinedToolFactoryWithOutputSchema({
    id: "openai.web_search_preview",
    name: "web_search_preview",
    inputSchema: webSearchPreviewInputSchema2,
    outputSchema: webSearchPreviewOutputSchema2
});
var imageGenerationArgsSchema2 = lazySchema(()=>zodSchema(import_v476.z.object({
        background: import_v476.z.enum([
            "auto",
            "opaque",
            "transparent"
        ]).optional(),
        inputFidelity: import_v476.z.enum([
            "low",
            "high"
        ]).optional(),
        inputImageMask: import_v476.z.object({
            fileId: import_v476.z.string().optional(),
            imageUrl: import_v476.z.string().optional()
        }).optional(),
        model: import_v476.z.string().optional(),
        moderation: import_v476.z.enum([
            "auto"
        ]).optional(),
        outputCompression: import_v476.z.number().int().min(0).max(100).optional(),
        outputFormat: import_v476.z.enum([
            "png",
            "jpeg",
            "webp"
        ]).optional(),
        partialImages: import_v476.z.number().int().min(0).max(3).optional(),
        quality: import_v476.z.enum([
            "auto",
            "low",
            "medium",
            "high"
        ]).optional(),
        size: import_v476.z.enum([
            "1024x1024",
            "1024x1536",
            "1536x1024",
            "auto"
        ]).optional()
    }).strict()));
var imageGenerationInputSchema2 = lazySchema(()=>zodSchema(import_v476.z.object({})));
var imageGenerationOutputSchema2 = lazySchema(()=>zodSchema(import_v476.z.object({
        result: import_v476.z.string()
    })));
var imageGenerationToolFactory2 = createProviderDefinedToolFactoryWithOutputSchema({
    id: "openai.image_generation",
    name: "image_generation",
    inputSchema: imageGenerationInputSchema2,
    outputSchema: imageGenerationOutputSchema2
});
var imageGeneration2 = (args = {})=>{
    return imageGenerationToolFactory2(args);
};
function prepareResponsesTools2(_0) {
    return __async(this, arguments, function*({ tools, toolChoice, strictJsonSchema }) {
        tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
        const toolWarnings = [];
        if (tools == null) {
            return {
                tools: void 0,
                toolChoice: void 0,
                toolWarnings
            };
        }
        const openaiTools2 = [];
        for (const tool12 of tools){
            switch(tool12.type){
                case "function":
                    openaiTools2.push({
                        type: "function",
                        name: tool12.name,
                        description: tool12.description,
                        parameters: tool12.inputSchema,
                        strict: strictJsonSchema
                    });
                    break;
                case "provider-defined":
                    {
                        switch(tool12.id){
                            case "openai.file_search":
                                {
                                    const args = yield validateTypes({
                                        value: tool12.args,
                                        schema: fileSearchArgsSchema2
                                    });
                                    openaiTools2.push({
                                        type: "file_search",
                                        vector_store_ids: args.vectorStoreIds,
                                        max_num_results: args.maxNumResults,
                                        ranking_options: args.ranking ? {
                                            ranker: args.ranking.ranker,
                                            score_threshold: args.ranking.scoreThreshold
                                        } : void 0,
                                        filters: args.filters
                                    });
                                    break;
                                }
                            case "openai.local_shell":
                                {
                                    openaiTools2.push({
                                        type: "local_shell"
                                    });
                                    break;
                                }
                            case "openai.web_search_preview":
                                {
                                    const args = yield validateTypes({
                                        value: tool12.args,
                                        schema: webSearchPreviewArgsSchema2
                                    });
                                    openaiTools2.push({
                                        type: "web_search_preview",
                                        search_context_size: args.searchContextSize,
                                        user_location: args.userLocation
                                    });
                                    break;
                                }
                            case "openai.web_search":
                                {
                                    const args = yield validateTypes({
                                        value: tool12.args,
                                        schema: webSearchArgsSchema2
                                    });
                                    openaiTools2.push({
                                        type: "web_search",
                                        filters: args.filters != null ? {
                                            allowed_domains: args.filters.allowedDomains
                                        } : void 0,
                                        search_context_size: args.searchContextSize,
                                        user_location: args.userLocation
                                    });
                                    break;
                                }
                            case "openai.code_interpreter":
                                {
                                    const args = yield validateTypes({
                                        value: tool12.args,
                                        schema: codeInterpreterArgsSchema2
                                    });
                                    openaiTools2.push({
                                        type: "code_interpreter",
                                        container: args.container == null ? {
                                            type: "auto",
                                            file_ids: void 0
                                        } : typeof args.container === "string" ? args.container : {
                                            type: "auto",
                                            file_ids: args.container.fileIds
                                        }
                                    });
                                    break;
                                }
                            case "openai.image_generation":
                                {
                                    const args = yield validateTypes({
                                        value: tool12.args,
                                        schema: imageGenerationArgsSchema2
                                    });
                                    openaiTools2.push({
                                        type: "image_generation",
                                        background: args.background,
                                        input_fidelity: args.inputFidelity,
                                        input_image_mask: args.inputImageMask ? {
                                            file_id: args.inputImageMask.fileId,
                                            image_url: args.inputImageMask.imageUrl
                                        } : void 0,
                                        model: args.model,
                                        size: args.size,
                                        quality: args.quality,
                                        moderation: args.moderation,
                                        output_format: args.outputFormat,
                                        output_compression: args.outputCompression
                                    });
                                    break;
                                }
                        }
                        break;
                    }
                default:
                    toolWarnings.push({
                        type: "unsupported-tool",
                        tool: tool12
                    });
                    break;
            }
        }
        if (toolChoice == null) {
            return {
                tools: openaiTools2,
                toolChoice: void 0,
                toolWarnings
            };
        }
        const type = toolChoice.type;
        switch(type){
            case "auto":
            case "none":
            case "required":
                return {
                    tools: openaiTools2,
                    toolChoice: type,
                    toolWarnings
                };
            case "tool":
                return {
                    tools: openaiTools2,
                    toolChoice: toolChoice.toolName === "code_interpreter" || toolChoice.toolName === "file_search" || toolChoice.toolName === "image_generation" || toolChoice.toolName === "web_search_preview" || toolChoice.toolName === "web_search" ? {
                        type: toolChoice.toolName
                    } : {
                        type: "function",
                        name: toolChoice.toolName
                    },
                    toolWarnings
                };
            default:
                {
                    const _exhaustiveCheck = type;
                    throw new import_provider42.UnsupportedFunctionalityError({
                        functionality: `tool choice type: ${_exhaustiveCheck}`
                    });
                }
        }
    });
}
var OpenAIResponsesLanguageModel2 = class {
    constructor(modelId, config){
        this.specificationVersion = "v2";
        this.supportedUrls = {
            "image/*": [
                /^https?:\/\/.*$/
            ],
            "application/pdf": [
                /^https?:\/\/.*$/
            ]
        };
        this.modelId = modelId;
        this.config = config;
    }
    get provider() {
        return this.config.provider;
    }
    getArgs(_0) {
        return __async(this, arguments, function*({ maxOutputTokens, temperature, stopSequences, topP, topK, presencePenalty, frequencyPenalty, seed, prompt, providerOptions, tools, toolChoice, responseFormat }) {
            var _a, _b, _c, _d;
            const warnings = [];
            const modelConfig = getResponsesModelConfig2(this.modelId);
            if (topK != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "topK"
                });
            }
            if (seed != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "seed"
                });
            }
            if (presencePenalty != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "presencePenalty"
                });
            }
            if (frequencyPenalty != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "frequencyPenalty"
                });
            }
            if (stopSequences != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "stopSequences"
                });
            }
            const openaiOptions = yield parseProviderOptions({
                provider: "openai",
                providerOptions,
                schema: openaiResponsesProviderOptionsSchema2
            });
            const { input, warnings: inputWarnings } = yield convertToOpenAIResponsesInput2({
                prompt,
                systemMessageMode: modelConfig.systemMessageMode,
                fileIdPrefixes: this.config.fileIdPrefixes,
                store: (_a = openaiOptions == null ? void 0 : openaiOptions.store) != null ? _a : true,
                hasLocalShellTool: hasOpenAITool("openai.local_shell")
            });
            warnings.push(...inputWarnings);
            const strictJsonSchema = (_b = openaiOptions == null ? void 0 : openaiOptions.strictJsonSchema) != null ? _b : false;
            let include = openaiOptions == null ? void 0 : openaiOptions.include;
            function addInclude(key) {
                if (include == null) {
                    include = [
                        key
                    ];
                } else if (!include.includes(key)) {
                    include = [
                        ...include,
                        key
                    ];
                }
            }
            function hasOpenAITool(id) {
                return (tools == null ? void 0 : tools.find((tool12)=>tool12.type === "provider-defined" && tool12.id === id)) != null;
            }
            const topLogprobs = typeof (openaiOptions == null ? void 0 : openaiOptions.logprobs) === "number" ? openaiOptions == null ? void 0 : openaiOptions.logprobs : (openaiOptions == null ? void 0 : openaiOptions.logprobs) === true ? TOP_LOGPROBS_MAX2 : void 0;
            if (topLogprobs) {
                addInclude("message.output_text.logprobs");
            }
            const webSearchToolName = (_c = tools == null ? void 0 : tools.find((tool12)=>tool12.type === "provider-defined" && (tool12.id === "openai.web_search" || tool12.id === "openai.web_search_preview"))) == null ? void 0 : _c.name;
            if (webSearchToolName) {
                addInclude("web_search_call.action.sources");
            }
            if (hasOpenAITool("openai.code_interpreter")) {
                addInclude("code_interpreter_call.outputs");
            }
            const store = openaiOptions == null ? void 0 : openaiOptions.store;
            if (store === false && modelConfig.isReasoningModel) {
                addInclude("reasoning.encrypted_content");
            }
            const baseArgs = __spreadValues(__spreadProps(__spreadValues({
                model: this.modelId,
                input,
                temperature,
                top_p: topP,
                max_output_tokens: maxOutputTokens
            }, ((responseFormat == null ? void 0 : responseFormat.type) === "json" || (openaiOptions == null ? void 0 : openaiOptions.textVerbosity)) && {
                text: __spreadValues(__spreadValues({}, (responseFormat == null ? void 0 : responseFormat.type) === "json" && {
                    format: responseFormat.schema != null ? {
                        type: "json_schema",
                        strict: strictJsonSchema,
                        name: (_d = responseFormat.name) != null ? _d : "response",
                        description: responseFormat.description,
                        schema: responseFormat.schema
                    } : {
                        type: "json_object"
                    }
                }), (openaiOptions == null ? void 0 : openaiOptions.textVerbosity) && {
                    verbosity: openaiOptions.textVerbosity
                })
            }), {
                // provider options:
                max_tool_calls: openaiOptions == null ? void 0 : openaiOptions.maxToolCalls,
                metadata: openaiOptions == null ? void 0 : openaiOptions.metadata,
                parallel_tool_calls: openaiOptions == null ? void 0 : openaiOptions.parallelToolCalls,
                previous_response_id: openaiOptions == null ? void 0 : openaiOptions.previousResponseId,
                store,
                user: openaiOptions == null ? void 0 : openaiOptions.user,
                instructions: openaiOptions == null ? void 0 : openaiOptions.instructions,
                service_tier: openaiOptions == null ? void 0 : openaiOptions.serviceTier,
                include,
                prompt_cache_key: openaiOptions == null ? void 0 : openaiOptions.promptCacheKey,
                safety_identifier: openaiOptions == null ? void 0 : openaiOptions.safetyIdentifier,
                top_logprobs: topLogprobs,
                truncation: openaiOptions == null ? void 0 : openaiOptions.truncation
            }), modelConfig.isReasoningModel && ((openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null || (openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null) && {
                reasoning: __spreadValues(__spreadValues({}, (openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null && {
                    effort: openaiOptions.reasoningEffort
                }), (openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null && {
                    summary: openaiOptions.reasoningSummary
                })
            });
            if (modelConfig.isReasoningModel) {
                if (baseArgs.temperature != null) {
                    baseArgs.temperature = void 0;
                    warnings.push({
                        type: "unsupported-setting",
                        setting: "temperature",
                        details: "temperature is not supported for reasoning models"
                    });
                }
                if (baseArgs.top_p != null) {
                    baseArgs.top_p = void 0;
                    warnings.push({
                        type: "unsupported-setting",
                        setting: "topP",
                        details: "topP is not supported for reasoning models"
                    });
                }
            } else {
                if ((openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null) {
                    warnings.push({
                        type: "unsupported-setting",
                        setting: "reasoningEffort",
                        details: "reasoningEffort is not supported for non-reasoning models"
                    });
                }
                if ((openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null) {
                    warnings.push({
                        type: "unsupported-setting",
                        setting: "reasoningSummary",
                        details: "reasoningSummary is not supported for non-reasoning models"
                    });
                }
            }
            if ((openaiOptions == null ? void 0 : openaiOptions.serviceTier) === "flex" && !modelConfig.supportsFlexProcessing) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "serviceTier",
                    details: "flex processing is only available for o3, o4-mini, and gpt-5 models"
                });
                delete baseArgs.service_tier;
            }
            if ((openaiOptions == null ? void 0 : openaiOptions.serviceTier) === "priority" && !modelConfig.supportsPriorityProcessing) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "serviceTier",
                    details: "priority processing is only available for supported models (gpt-4, gpt-5, gpt-5-mini, o3, o4-mini) and requires Enterprise access. gpt-5-nano is not supported"
                });
                delete baseArgs.service_tier;
            }
            const { tools: openaiTools2, toolChoice: openaiToolChoice, toolWarnings } = yield prepareResponsesTools2({
                tools,
                toolChoice,
                strictJsonSchema
            });
            return {
                webSearchToolName,
                args: __spreadProps(__spreadValues({}, baseArgs), {
                    tools: openaiTools2,
                    tool_choice: openaiToolChoice
                }),
                warnings: [
                    ...warnings,
                    ...toolWarnings
                ],
                store
            };
        });
    }
    doGenerate(options) {
        return __async(this, null, function*() {
            var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;
            const { args: body, warnings, webSearchToolName } = yield this.getArgs(options);
            const url = this.config.url({
                path: "/responses",
                modelId: this.modelId
            });
            const { responseHeaders, value: response, rawValue: rawResponse } = yield postJsonToApi({
                url,
                headers: combineHeaders(this.config.headers(), options.headers),
                body,
                failedResponseHandler: openaiFailedResponseHandler2,
                successfulResponseHandler: createJsonResponseHandler(openaiResponsesResponseSchema2),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            if (response.error) {
                throw new import_provider40.APICallError({
                    message: response.error.message,
                    url,
                    requestBodyValues: body,
                    statusCode: 400,
                    responseHeaders,
                    responseBody: rawResponse,
                    isRetryable: false
                });
            }
            const content = [];
            const logprobs = [];
            let hasFunctionCall = false;
            for (const part of response.output){
                switch(part.type){
                    case "reasoning":
                        {
                            if (part.summary.length === 0) {
                                part.summary.push({
                                    type: "summary_text",
                                    text: ""
                                });
                            }
                            for (const summary of part.summary){
                                content.push({
                                    type: "reasoning",
                                    text: summary.text,
                                    providerMetadata: {
                                        openai: {
                                            itemId: part.id,
                                            reasoningEncryptedContent: (_a = part.encrypted_content) != null ? _a : null
                                        }
                                    }
                                });
                            }
                            break;
                        }
                    case "image_generation_call":
                        {
                            content.push({
                                type: "tool-call",
                                toolCallId: part.id,
                                toolName: "image_generation",
                                input: "{}",
                                providerExecuted: true
                            });
                            content.push({
                                type: "tool-result",
                                toolCallId: part.id,
                                toolName: "image_generation",
                                result: {
                                    result: part.result
                                },
                                providerExecuted: true
                            });
                            break;
                        }
                    case "local_shell_call":
                        {
                            content.push({
                                type: "tool-call",
                                toolCallId: part.call_id,
                                toolName: "local_shell",
                                input: JSON.stringify({
                                    action: part.action
                                }),
                                providerMetadata: {
                                    openai: {
                                        itemId: part.id
                                    }
                                }
                            });
                            break;
                        }
                    case "message":
                        {
                            for (const contentPart of part.content){
                                if (((_c = (_b = options.providerOptions) == null ? void 0 : _b.openai) == null ? void 0 : _c.logprobs) && contentPart.logprobs) {
                                    logprobs.push(contentPart.logprobs);
                                }
                                content.push({
                                    type: "text",
                                    text: contentPart.text,
                                    providerMetadata: {
                                        openai: {
                                            itemId: part.id
                                        }
                                    }
                                });
                                for (const annotation of contentPart.annotations){
                                    if (annotation.type === "url_citation") {
                                        content.push({
                                            type: "source",
                                            sourceType: "url",
                                            id: (_f = (_e = (_d = this.config).generateId) == null ? void 0 : _e.call(_d)) != null ? _f : generateId(),
                                            url: annotation.url,
                                            title: annotation.title
                                        });
                                    } else if (annotation.type === "file_citation") {
                                        content.push({
                                            type: "source",
                                            sourceType: "document",
                                            id: (_i = (_h = (_g = this.config).generateId) == null ? void 0 : _h.call(_g)) != null ? _i : generateId(),
                                            mediaType: "text/plain",
                                            title: (_k = (_j = annotation.quote) != null ? _j : annotation.filename) != null ? _k : "Document",
                                            filename: (_l = annotation.filename) != null ? _l : annotation.file_id
                                        });
                                    }
                                }
                            }
                            break;
                        }
                    case "function_call":
                        {
                            hasFunctionCall = true;
                            content.push({
                                type: "tool-call",
                                toolCallId: part.call_id,
                                toolName: part.name,
                                input: part.arguments,
                                providerMetadata: {
                                    openai: {
                                        itemId: part.id
                                    }
                                }
                            });
                            break;
                        }
                    case "web_search_call":
                        {
                            content.push({
                                type: "tool-call",
                                toolCallId: part.id,
                                toolName: webSearchToolName != null ? webSearchToolName : "web_search",
                                input: JSON.stringify({}),
                                providerExecuted: true
                            });
                            content.push({
                                type: "tool-result",
                                toolCallId: part.id,
                                toolName: webSearchToolName != null ? webSearchToolName : "web_search",
                                result: mapWebSearchOutput2(part.action),
                                providerExecuted: true
                            });
                            break;
                        }
                    case "computer_call":
                        {
                            content.push({
                                type: "tool-call",
                                toolCallId: part.id,
                                toolName: "computer_use",
                                input: "",
                                providerExecuted: true
                            });
                            content.push({
                                type: "tool-result",
                                toolCallId: part.id,
                                toolName: "computer_use",
                                result: {
                                    type: "computer_use_tool_result",
                                    status: part.status || "completed"
                                },
                                providerExecuted: true
                            });
                            break;
                        }
                    case "file_search_call":
                        {
                            content.push({
                                type: "tool-call",
                                toolCallId: part.id,
                                toolName: "file_search",
                                input: "{}",
                                providerExecuted: true
                            });
                            content.push({
                                type: "tool-result",
                                toolCallId: part.id,
                                toolName: "file_search",
                                result: {
                                    queries: part.queries,
                                    results: (_n = (_m = part.results) == null ? void 0 : _m.map((result)=>({
                                            attributes: result.attributes,
                                            fileId: result.file_id,
                                            filename: result.filename,
                                            score: result.score,
                                            text: result.text
                                        }))) != null ? _n : null
                                },
                                providerExecuted: true
                            });
                            break;
                        }
                    case "code_interpreter_call":
                        {
                            content.push({
                                type: "tool-call",
                                toolCallId: part.id,
                                toolName: "code_interpreter",
                                input: JSON.stringify({
                                    code: part.code,
                                    containerId: part.container_id
                                }),
                                providerExecuted: true
                            });
                            content.push({
                                type: "tool-result",
                                toolCallId: part.id,
                                toolName: "code_interpreter",
                                result: {
                                    outputs: part.outputs
                                },
                                providerExecuted: true
                            });
                            break;
                        }
                }
            }
            const providerMetadata = {
                openai: {
                    responseId: response.id
                }
            };
            if (logprobs.length > 0) {
                providerMetadata.openai.logprobs = logprobs;
            }
            if (typeof response.service_tier === "string") {
                providerMetadata.openai.serviceTier = response.service_tier;
            }
            return {
                content,
                finishReason: mapOpenAIResponseFinishReason2({
                    finishReason: (_o = response.incomplete_details) == null ? void 0 : _o.reason,
                    hasFunctionCall
                }),
                usage: {
                    inputTokens: response.usage.input_tokens,
                    outputTokens: response.usage.output_tokens,
                    totalTokens: response.usage.input_tokens + response.usage.output_tokens,
                    reasoningTokens: (_q = (_p = response.usage.output_tokens_details) == null ? void 0 : _p.reasoning_tokens) != null ? _q : void 0,
                    cachedInputTokens: (_s = (_r = response.usage.input_tokens_details) == null ? void 0 : _r.cached_tokens) != null ? _s : void 0
                },
                request: {
                    body
                },
                response: {
                    id: response.id,
                    timestamp: new Date(response.created_at * 1e3),
                    modelId: response.model,
                    headers: responseHeaders,
                    body: rawResponse
                },
                providerMetadata,
                warnings
            };
        });
    }
    doStream(options) {
        return __async(this, null, function*() {
            const { args: body, warnings, webSearchToolName, store } = yield this.getArgs(options);
            const { responseHeaders, value: response } = yield postJsonToApi({
                url: this.config.url({
                    path: "/responses",
                    modelId: this.modelId
                }),
                headers: combineHeaders(this.config.headers(), options.headers),
                body: __spreadProps(__spreadValues({}, body), {
                    stream: true
                }),
                failedResponseHandler: openaiFailedResponseHandler2,
                successfulResponseHandler: createEventSourceResponseHandler(openaiResponsesChunkSchema2),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            const self = this;
            let finishReason = "unknown";
            const usage = {
                inputTokens: void 0,
                outputTokens: void 0,
                totalTokens: void 0
            };
            const logprobs = [];
            let responseId = null;
            const ongoingToolCalls = {};
            let hasFunctionCall = false;
            const activeReasoning = {};
            let serviceTier;
            return {
                stream: response.pipeThrough(new TransformStream({
                    start (controller) {
                        controller.enqueue({
                            type: "stream-start",
                            warnings
                        });
                    },
                    transform (chunk, controller) {
                        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v;
                        if (options.includeRawChunks) {
                            controller.enqueue({
                                type: "raw",
                                rawValue: chunk.rawValue
                            });
                        }
                        if (!chunk.success) {
                            finishReason = "error";
                            controller.enqueue({
                                type: "error",
                                error: chunk.error
                            });
                            return;
                        }
                        const value = chunk.value;
                        if (isResponseOutputItemAddedChunk2(value)) {
                            if (value.item.type === "function_call") {
                                ongoingToolCalls[value.output_index] = {
                                    toolName: value.item.name,
                                    toolCallId: value.item.call_id
                                };
                                controller.enqueue({
                                    type: "tool-input-start",
                                    id: value.item.call_id,
                                    toolName: value.item.name
                                });
                            } else if (value.item.type === "web_search_call") {
                                ongoingToolCalls[value.output_index] = {
                                    toolName: webSearchToolName != null ? webSearchToolName : "web_search",
                                    toolCallId: value.item.id
                                };
                                controller.enqueue({
                                    type: "tool-input-start",
                                    id: value.item.id,
                                    toolName: webSearchToolName != null ? webSearchToolName : "web_search",
                                    providerExecuted: true
                                });
                                controller.enqueue({
                                    type: "tool-input-end",
                                    id: value.item.id
                                });
                                controller.enqueue({
                                    type: "tool-call",
                                    toolCallId: value.item.id,
                                    toolName: "web_search",
                                    input: JSON.stringify({}),
                                    providerExecuted: true
                                });
                            } else if (value.item.type === "computer_call") {
                                ongoingToolCalls[value.output_index] = {
                                    toolName: "computer_use",
                                    toolCallId: value.item.id
                                };
                                controller.enqueue({
                                    type: "tool-input-start",
                                    id: value.item.id,
                                    toolName: "computer_use",
                                    providerExecuted: true
                                });
                            } else if (value.item.type === "code_interpreter_call") {
                                ongoingToolCalls[value.output_index] = {
                                    toolName: "code_interpreter",
                                    toolCallId: value.item.id,
                                    codeInterpreter: {
                                        containerId: value.item.container_id
                                    }
                                };
                                controller.enqueue({
                                    type: "tool-input-start",
                                    id: value.item.id,
                                    toolName: "code_interpreter",
                                    providerExecuted: true
                                });
                                controller.enqueue({
                                    type: "tool-input-delta",
                                    id: value.item.id,
                                    delta: `{"containerId":"${value.item.container_id}","code":"`
                                });
                            } else if (value.item.type === "file_search_call") {
                                controller.enqueue({
                                    type: "tool-call",
                                    toolCallId: value.item.id,
                                    toolName: "file_search",
                                    input: "{}",
                                    providerExecuted: true
                                });
                            } else if (value.item.type === "image_generation_call") {
                                controller.enqueue({
                                    type: "tool-call",
                                    toolCallId: value.item.id,
                                    toolName: "image_generation",
                                    input: "{}",
                                    providerExecuted: true
                                });
                            } else if (value.item.type === "message") {
                                controller.enqueue({
                                    type: "text-start",
                                    id: value.item.id,
                                    providerMetadata: {
                                        openai: {
                                            itemId: value.item.id
                                        }
                                    }
                                });
                            } else if (isResponseOutputItemAddedChunk2(value) && value.item.type === "reasoning") {
                                activeReasoning[value.item.id] = {
                                    encryptedContent: value.item.encrypted_content,
                                    summaryParts: {
                                        0: "active"
                                    }
                                };
                                controller.enqueue({
                                    type: "reasoning-start",
                                    id: `${value.item.id}:0`,
                                    providerMetadata: {
                                        openai: {
                                            itemId: value.item.id,
                                            reasoningEncryptedContent: (_a = value.item.encrypted_content) != null ? _a : null
                                        }
                                    }
                                });
                            }
                        } else if (isResponseOutputItemDoneChunk2(value)) {
                            if (value.item.type === "function_call") {
                                ongoingToolCalls[value.output_index] = void 0;
                                hasFunctionCall = true;
                                controller.enqueue({
                                    type: "tool-input-end",
                                    id: value.item.call_id
                                });
                                controller.enqueue({
                                    type: "tool-call",
                                    toolCallId: value.item.call_id,
                                    toolName: value.item.name,
                                    input: value.item.arguments,
                                    providerMetadata: {
                                        openai: {
                                            itemId: value.item.id
                                        }
                                    }
                                });
                            } else if (value.item.type === "web_search_call") {
                                ongoingToolCalls[value.output_index] = void 0;
                                controller.enqueue({
                                    type: "tool-result",
                                    toolCallId: value.item.id,
                                    toolName: "web_search",
                                    result: mapWebSearchOutput2(value.item.action),
                                    providerExecuted: true
                                });
                            } else if (value.item.type === "computer_call") {
                                ongoingToolCalls[value.output_index] = void 0;
                                controller.enqueue({
                                    type: "tool-input-end",
                                    id: value.item.id
                                });
                                controller.enqueue({
                                    type: "tool-call",
                                    toolCallId: value.item.id,
                                    toolName: "computer_use",
                                    input: "",
                                    providerExecuted: true
                                });
                                controller.enqueue({
                                    type: "tool-result",
                                    toolCallId: value.item.id,
                                    toolName: "computer_use",
                                    result: {
                                        type: "computer_use_tool_result",
                                        status: value.item.status || "completed"
                                    },
                                    providerExecuted: true
                                });
                            } else if (value.item.type === "file_search_call") {
                                ongoingToolCalls[value.output_index] = void 0;
                                controller.enqueue({
                                    type: "tool-result",
                                    toolCallId: value.item.id,
                                    toolName: "file_search",
                                    result: {
                                        queries: value.item.queries,
                                        results: (_c = (_b = value.item.results) == null ? void 0 : _b.map((result)=>({
                                                attributes: result.attributes,
                                                fileId: result.file_id,
                                                filename: result.filename,
                                                score: result.score,
                                                text: result.text
                                            }))) != null ? _c : null
                                    },
                                    providerExecuted: true
                                });
                            } else if (value.item.type === "code_interpreter_call") {
                                ongoingToolCalls[value.output_index] = void 0;
                                controller.enqueue({
                                    type: "tool-result",
                                    toolCallId: value.item.id,
                                    toolName: "code_interpreter",
                                    result: {
                                        outputs: value.item.outputs
                                    },
                                    providerExecuted: true
                                });
                            } else if (value.item.type === "image_generation_call") {
                                controller.enqueue({
                                    type: "tool-result",
                                    toolCallId: value.item.id,
                                    toolName: "image_generation",
                                    result: {
                                        result: value.item.result
                                    },
                                    providerExecuted: true
                                });
                            } else if (value.item.type === "local_shell_call") {
                                ongoingToolCalls[value.output_index] = void 0;
                                controller.enqueue({
                                    type: "tool-call",
                                    toolCallId: value.item.call_id,
                                    toolName: "local_shell",
                                    input: JSON.stringify({
                                        action: {
                                            type: "exec",
                                            command: value.item.action.command,
                                            timeoutMs: value.item.action.timeout_ms,
                                            user: value.item.action.user,
                                            workingDirectory: value.item.action.working_directory,
                                            env: value.item.action.env
                                        }
                                    }),
                                    providerMetadata: {
                                        openai: {
                                            itemId: value.item.id
                                        }
                                    }
                                });
                            } else if (value.item.type === "message") {
                                controller.enqueue({
                                    type: "text-end",
                                    id: value.item.id
                                });
                            } else if (value.item.type === "reasoning") {
                                const activeReasoningPart = activeReasoning[value.item.id];
                                const summaryPartIndices = Object.entries(activeReasoningPart.summaryParts).filter(([_, status])=>status === "active" || status === "can-conclude").map(([summaryIndex])=>summaryIndex);
                                for (const summaryIndex of summaryPartIndices){
                                    controller.enqueue({
                                        type: "reasoning-end",
                                        id: `${value.item.id}:${summaryIndex}`,
                                        providerMetadata: {
                                            openai: {
                                                itemId: value.item.id,
                                                reasoningEncryptedContent: (_d = value.item.encrypted_content) != null ? _d : null
                                            }
                                        }
                                    });
                                }
                                delete activeReasoning[value.item.id];
                            }
                        } else if (isResponseFunctionCallArgumentsDeltaChunk2(value)) {
                            const toolCall = ongoingToolCalls[value.output_index];
                            if (toolCall != null) {
                                controller.enqueue({
                                    type: "tool-input-delta",
                                    id: toolCall.toolCallId,
                                    delta: value.delta
                                });
                            }
                        } else if (isResponseCodeInterpreterCallCodeDeltaChunk2(value)) {
                            const toolCall = ongoingToolCalls[value.output_index];
                            if (toolCall != null) {
                                controller.enqueue({
                                    type: "tool-input-delta",
                                    id: toolCall.toolCallId,
                                    // The delta is code, which is embedding in a JSON string.
                                    // To escape it, we use JSON.stringify and slice to remove the outer quotes.
                                    delta: JSON.stringify(value.delta).slice(1, -1)
                                });
                            }
                        } else if (isResponseCodeInterpreterCallCodeDoneChunk2(value)) {
                            const toolCall = ongoingToolCalls[value.output_index];
                            if (toolCall != null) {
                                controller.enqueue({
                                    type: "tool-input-delta",
                                    id: toolCall.toolCallId,
                                    delta: '"}'
                                });
                                controller.enqueue({
                                    type: "tool-input-end",
                                    id: toolCall.toolCallId
                                });
                                controller.enqueue({
                                    type: "tool-call",
                                    toolCallId: toolCall.toolCallId,
                                    toolName: "code_interpreter",
                                    input: JSON.stringify({
                                        code: value.code,
                                        containerId: toolCall.codeInterpreter.containerId
                                    }),
                                    providerExecuted: true
                                });
                            }
                        } else if (isResponseCreatedChunk2(value)) {
                            responseId = value.response.id;
                            controller.enqueue({
                                type: "response-metadata",
                                id: value.response.id,
                                timestamp: new Date(value.response.created_at * 1e3),
                                modelId: value.response.model
                            });
                        } else if (isTextDeltaChunk2(value)) {
                            controller.enqueue({
                                type: "text-delta",
                                id: value.item_id,
                                delta: value.delta
                            });
                            if (((_f = (_e = options.providerOptions) == null ? void 0 : _e.openai) == null ? void 0 : _f.logprobs) && value.logprobs) {
                                logprobs.push(value.logprobs);
                            }
                        } else if (value.type === "response.reasoning_summary_part.added") {
                            if (value.summary_index > 0) {
                                const activeReasoningPart = activeReasoning[value.item_id];
                                activeReasoningPart.summaryParts[value.summary_index] = "active";
                                for (const summaryIndex of Object.keys(activeReasoningPart.summaryParts)){
                                    if (activeReasoningPart.summaryParts[summaryIndex] === "can-conclude") {
                                        controller.enqueue({
                                            type: "reasoning-end",
                                            id: `${value.item_id}:${summaryIndex}`,
                                            providerMetadata: {
                                                openai: {
                                                    itemId: value.item_id
                                                }
                                            }
                                        });
                                        activeReasoningPart.summaryParts[summaryIndex] = "concluded";
                                    }
                                }
                                controller.enqueue({
                                    type: "reasoning-start",
                                    id: `${value.item_id}:${value.summary_index}`,
                                    providerMetadata: {
                                        openai: {
                                            itemId: value.item_id,
                                            reasoningEncryptedContent: (_h = (_g = activeReasoning[value.item_id]) == null ? void 0 : _g.encryptedContent) != null ? _h : null
                                        }
                                    }
                                });
                            }
                        } else if (value.type === "response.reasoning_summary_text.delta") {
                            controller.enqueue({
                                type: "reasoning-delta",
                                id: `${value.item_id}:${value.summary_index}`,
                                delta: value.delta,
                                providerMetadata: {
                                    openai: {
                                        itemId: value.item_id
                                    }
                                }
                            });
                        } else if (value.type === "response.reasoning_summary_part.done") {
                            if (store) {
                                controller.enqueue({
                                    type: "reasoning-end",
                                    id: `${value.item_id}:${value.summary_index}`,
                                    providerMetadata: {
                                        openai: {
                                            itemId: value.item_id
                                        }
                                    }
                                });
                                activeReasoning[value.item_id].summaryParts[value.summary_index] = "concluded";
                            } else {
                                activeReasoning[value.item_id].summaryParts[value.summary_index] = "can-conclude";
                            }
                        } else if (isResponseFinishedChunk2(value)) {
                            finishReason = mapOpenAIResponseFinishReason2({
                                finishReason: (_i = value.response.incomplete_details) == null ? void 0 : _i.reason,
                                hasFunctionCall
                            });
                            usage.inputTokens = value.response.usage.input_tokens;
                            usage.outputTokens = value.response.usage.output_tokens;
                            usage.totalTokens = value.response.usage.input_tokens + value.response.usage.output_tokens;
                            usage.reasoningTokens = (_k = (_j = value.response.usage.output_tokens_details) == null ? void 0 : _j.reasoning_tokens) != null ? _k : void 0;
                            usage.cachedInputTokens = (_m = (_l = value.response.usage.input_tokens_details) == null ? void 0 : _l.cached_tokens) != null ? _m : void 0;
                            if (typeof value.response.service_tier === "string") {
                                serviceTier = value.response.service_tier;
                            }
                        } else if (isResponseAnnotationAddedChunk2(value)) {
                            if (value.annotation.type === "url_citation") {
                                controller.enqueue({
                                    type: "source",
                                    sourceType: "url",
                                    id: (_p = (_o = (_n = self.config).generateId) == null ? void 0 : _o.call(_n)) != null ? _p : generateId(),
                                    url: value.annotation.url,
                                    title: value.annotation.title
                                });
                            } else if (value.annotation.type === "file_citation") {
                                controller.enqueue({
                                    type: "source",
                                    sourceType: "document",
                                    id: (_s = (_r = (_q = self.config).generateId) == null ? void 0 : _r.call(_q)) != null ? _s : generateId(),
                                    mediaType: "text/plain",
                                    title: (_u = (_t = value.annotation.quote) != null ? _t : value.annotation.filename) != null ? _u : "Document",
                                    filename: (_v = value.annotation.filename) != null ? _v : value.annotation.file_id
                                });
                            }
                        } else if (isErrorChunk2(value)) {
                            controller.enqueue({
                                type: "error",
                                error: value
                            });
                        }
                    },
                    flush (controller) {
                        const providerMetadata = {
                            openai: {
                                responseId
                            }
                        };
                        if (logprobs.length > 0) {
                            providerMetadata.openai.logprobs = logprobs;
                        }
                        if (serviceTier !== void 0) {
                            providerMetadata.openai.serviceTier = serviceTier;
                        }
                        controller.enqueue({
                            type: "finish",
                            finishReason,
                            usage,
                            providerMetadata
                        });
                    }
                })),
                request: {
                    body
                },
                response: {
                    headers: responseHeaders
                }
            };
        });
    }
};
function isTextDeltaChunk2(chunk) {
    return chunk.type === "response.output_text.delta";
}
function isResponseOutputItemDoneChunk2(chunk) {
    return chunk.type === "response.output_item.done";
}
function isResponseFinishedChunk2(chunk) {
    return chunk.type === "response.completed" || chunk.type === "response.incomplete";
}
function isResponseCreatedChunk2(chunk) {
    return chunk.type === "response.created";
}
function isResponseFunctionCallArgumentsDeltaChunk2(chunk) {
    return chunk.type === "response.function_call_arguments.delta";
}
function isResponseCodeInterpreterCallCodeDeltaChunk2(chunk) {
    return chunk.type === "response.code_interpreter_call_code.delta";
}
function isResponseCodeInterpreterCallCodeDoneChunk2(chunk) {
    return chunk.type === "response.code_interpreter_call_code.done";
}
function isResponseOutputItemAddedChunk2(chunk) {
    return chunk.type === "response.output_item.added";
}
function isResponseAnnotationAddedChunk2(chunk) {
    return chunk.type === "response.output_text.annotation.added";
}
function isErrorChunk2(chunk) {
    return chunk.type === "error";
}
function getResponsesModelConfig2(modelId) {
    const supportsFlexProcessing22 = modelId.startsWith("o3") || modelId.startsWith("o4-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-chat");
    const supportsPriorityProcessing22 = modelId.startsWith("gpt-4") || modelId.startsWith("gpt-5-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-nano") && !modelId.startsWith("gpt-5-chat") || modelId.startsWith("o3") || modelId.startsWith("o4-mini");
    const defaults2 = {
        systemMessageMode: "system",
        supportsFlexProcessing: supportsFlexProcessing22,
        supportsPriorityProcessing: supportsPriorityProcessing22
    };
    if (modelId.startsWith("gpt-5-chat")) {
        return __spreadProps(__spreadValues({}, defaults2), {
            isReasoningModel: false
        });
    }
    if (modelId.startsWith("o") || modelId.startsWith("gpt-5") || modelId.startsWith("codex-") || modelId.startsWith("computer-use")) {
        if (modelId.startsWith("o1-mini") || modelId.startsWith("o1-preview")) {
            return __spreadProps(__spreadValues({}, defaults2), {
                isReasoningModel: true,
                systemMessageMode: "remove"
            });
        }
        return __spreadProps(__spreadValues({}, defaults2), {
            isReasoningModel: true,
            systemMessageMode: "developer"
        });
    }
    return __spreadProps(__spreadValues({}, defaults2), {
        isReasoningModel: false
    });
}
function mapWebSearchOutput2(action) {
    var _a;
    switch(action.type){
        case "search":
            return {
                action: {
                    type: "search",
                    query: (_a = action.query) != null ? _a : void 0
                }
            };
        case "open_page":
            return {
                action: {
                    type: "openPage",
                    url: action.url
                }
            };
        case "find":
            return {
                action: {
                    type: "find",
                    url: action.url,
                    pattern: action.pattern
                }
            };
    }
}
// ../../node_modules/.pnpm/@ai-sdk+azure@2.0.54_zod@3.25.67/node_modules/@ai-sdk/azure/dist/index.mjs
var azureOpenaiTools = {
    codeInterpreter: codeInterpreter2,
    fileSearch: fileSearch2,
    imageGeneration: imageGeneration2
};
var VERSION6 = ("TURBOPACK compile-time truthy", 1) ? "2.0.54" : "TURBOPACK unreachable";
function createAzure(options = {}) {
    var _a;
    const getHeaders = ()=>{
        const baseHeaders = __spreadValues({
            "api-key": loadApiKey({
                apiKey: options.apiKey,
                environmentVariableName: "AZURE_API_KEY",
                description: "Azure OpenAI"
            })
        }, options.headers);
        return withUserAgentSuffix(baseHeaders, `ai-sdk/azure/${VERSION6}`);
    };
    const getResourceName = ()=>loadSetting({
            settingValue: options.resourceName,
            settingName: "resourceName",
            environmentVariableName: "AZURE_RESOURCE_NAME",
            description: "Azure OpenAI resource name"
        });
    const apiVersion = (_a = options.apiVersion) != null ? _a : "v1";
    const url = ({ path: path7, modelId })=>{
        var _a2;
        const baseUrlPrefix = (_a2 = options.baseURL) != null ? _a2 : `https://${getResourceName()}.openai.azure.com/openai`;
        let fullUrl;
        if (options.useDeploymentBasedUrls) {
            fullUrl = new URL(`${baseUrlPrefix}/deployments/${modelId}${path7}`);
        } else {
            fullUrl = new URL(`${baseUrlPrefix}/v1${path7}`);
        }
        fullUrl.searchParams.set("api-version", apiVersion);
        return fullUrl.toString();
    };
    const createChatModel = (deploymentName)=>new OpenAIChatLanguageModel2(deploymentName, {
            provider: "azure.chat",
            url,
            headers: getHeaders,
            fetch: options.fetch
        });
    const createCompletionModel = (modelId)=>new OpenAICompletionLanguageModel2(modelId, {
            provider: "azure.completion",
            url,
            headers: getHeaders,
            fetch: options.fetch
        });
    const createEmbeddingModel = (modelId)=>new OpenAIEmbeddingModel2(modelId, {
            provider: "azure.embeddings",
            headers: getHeaders,
            url,
            fetch: options.fetch
        });
    const createResponsesModel = (modelId)=>new OpenAIResponsesLanguageModel2(modelId, {
            provider: "azure.responses",
            url,
            headers: getHeaders,
            fetch: options.fetch,
            fileIdPrefixes: [
                "assistant-"
            ]
        });
    const createImageModel = (modelId)=>new OpenAIImageModel2(modelId, {
            provider: "azure.image",
            url,
            headers: getHeaders,
            fetch: options.fetch
        });
    const createTranscriptionModel = (modelId)=>new OpenAITranscriptionModel2(modelId, {
            provider: "azure.transcription",
            url,
            headers: getHeaders,
            fetch: options.fetch
        });
    const createSpeechModel = (modelId)=>new OpenAISpeechModel2(modelId, {
            provider: "azure.speech",
            url,
            headers: getHeaders,
            fetch: options.fetch
        });
    const provider = function(deploymentId) {
        if (new.target) {
            throw new Error("The Azure OpenAI model function cannot be called with the new keyword.");
        }
        return createChatModel(deploymentId);
    };
    provider.languageModel = createChatModel;
    provider.chat = createChatModel;
    provider.completion = createCompletionModel;
    provider.embedding = createEmbeddingModel;
    provider.image = createImageModel;
    provider.imageModel = createImageModel;
    provider.textEmbedding = createEmbeddingModel;
    provider.textEmbeddingModel = createEmbeddingModel;
    provider.responses = createResponsesModel;
    provider.transcription = createTranscriptionModel;
    provider.speech = createSpeechModel;
    provider.tools = azureOpenaiTools;
    return provider;
}
var azure = createAzure();
// ../../node_modules/.pnpm/@ai-sdk+groq@2.0.24_zod@3.25.67/node_modules/@ai-sdk/groq/dist/index.mjs
var import_provider43 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_provider44 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v477 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_provider45 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v478 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v479 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_provider46 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v480 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v481 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
function convertToGroqChatMessages(prompt) {
    const messages = [];
    for (const { role, content } of prompt){
        switch(role){
            case "system":
                {
                    messages.push({
                        role: "system",
                        content
                    });
                    break;
                }
            case "user":
                {
                    if (content.length === 1 && content[0].type === "text") {
                        messages.push({
                            role: "user",
                            content: content[0].text
                        });
                        break;
                    }
                    messages.push({
                        role: "user",
                        content: content.map((part)=>{
                            switch(part.type){
                                case "text":
                                    {
                                        return {
                                            type: "text",
                                            text: part.text
                                        };
                                    }
                                case "file":
                                    {
                                        if (!part.mediaType.startsWith("image/")) {
                                            throw new import_provider45.UnsupportedFunctionalityError({
                                                functionality: "Non-image file content parts"
                                            });
                                        }
                                        const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                                        return {
                                            type: "image_url",
                                            image_url: {
                                                url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${convertToBase64(part.data)}`
                                            }
                                        };
                                    }
                            }
                        })
                    });
                    break;
                }
            case "assistant":
                {
                    let text = "";
                    let reasoning = "";
                    const toolCalls = [];
                    for (const part of content){
                        switch(part.type){
                            // groq supports reasoning for tool-calls in multi-turn conversations
                            // https://github.com/vercel/ai/issues/7860
                            case "reasoning":
                                {
                                    reasoning += part.text;
                                    break;
                                }
                            case "text":
                                {
                                    text += part.text;
                                    break;
                                }
                            case "tool-call":
                                {
                                    toolCalls.push({
                                        id: part.toolCallId,
                                        type: "function",
                                        function: {
                                            name: part.toolName,
                                            arguments: JSON.stringify(part.input)
                                        }
                                    });
                                    break;
                                }
                        }
                    }
                    messages.push(__spreadValues(__spreadValues({
                        role: "assistant",
                        content: text
                    }, reasoning.length > 0 ? {
                        reasoning
                    } : null), toolCalls.length > 0 ? {
                        tool_calls: toolCalls
                    } : null));
                    break;
                }
            case "tool":
                {
                    for (const toolResponse of content){
                        const output = toolResponse.output;
                        let contentValue;
                        switch(output.type){
                            case "text":
                            case "error-text":
                                contentValue = output.value;
                                break;
                            case "content":
                            case "json":
                            case "error-json":
                                contentValue = JSON.stringify(output.value);
                                break;
                        }
                        messages.push({
                            role: "tool",
                            tool_call_id: toolResponse.toolCallId,
                            content: contentValue
                        });
                    }
                    break;
                }
            default:
                {
                    const _exhaustiveCheck = role;
                    throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
                }
        }
    }
    return messages;
}
function getResponseMetadata6({ id, model, created }) {
    return {
        id: id != null ? id : void 0,
        modelId: model != null ? model : void 0,
        timestamp: created != null ? new Date(created * 1e3) : void 0
    };
}
var groqProviderOptions = import_v478.z.object({
    reasoningFormat: import_v478.z.enum([
        "parsed",
        "raw",
        "hidden"
    ]).optional(),
    reasoningEffort: import_v478.z.string().optional(),
    /**
   * Whether to enable parallel function calling during tool use. Default to true.
   */ parallelToolCalls: import_v478.z.boolean().optional(),
    /**
   * A unique identifier representing your end-user, which can help OpenAI to
   * monitor and detect abuse. Learn more.
   */ user: import_v478.z.string().optional(),
    /**
   * Whether to use structured outputs.
   *
   * @default true
   */ structuredOutputs: import_v478.z.boolean().optional(),
    /**
   * Service tier for the request.
   * - 'on_demand': Default tier with consistent performance and fairness
   * - 'flex': Higher throughput tier optimized for workloads that can handle occasional request failures
   * - 'auto': Uses on_demand rate limits, then falls back to flex tier if exceeded
   *
   * @default 'on_demand'
   */ serviceTier: import_v478.z.enum([
        "on_demand",
        "flex",
        "auto"
    ]).optional()
});
var groqErrorDataSchema = import_v479.z.object({
    error: import_v479.z.object({
        message: import_v479.z.string(),
        type: import_v479.z.string()
    })
});
var groqFailedResponseHandler = createJsonErrorResponseHandler({
    errorSchema: groqErrorDataSchema,
    errorToMessage: (data)=>data.error.message
});
var BROWSER_SEARCH_SUPPORTED_MODELS = [
    "openai/gpt-oss-20b",
    "openai/gpt-oss-120b"
];
function isBrowserSearchSupportedModel(modelId) {
    return BROWSER_SEARCH_SUPPORTED_MODELS.includes(modelId);
}
function getSupportedModelsString() {
    return BROWSER_SEARCH_SUPPORTED_MODELS.join(", ");
}
function prepareTools5({ tools, toolChoice, modelId }) {
    tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
    const toolWarnings = [];
    if (tools == null) {
        return {
            tools: void 0,
            toolChoice: void 0,
            toolWarnings
        };
    }
    const groqTools2 = [];
    for (const tool12 of tools){
        if (tool12.type === "provider-defined") {
            if (tool12.id === "groq.browser_search") {
                if (!isBrowserSearchSupportedModel(modelId)) {
                    toolWarnings.push({
                        type: "unsupported-tool",
                        tool: tool12,
                        details: `Browser search is only supported on the following models: ${getSupportedModelsString()}. Current model: ${modelId}`
                    });
                } else {
                    groqTools2.push({
                        type: "browser_search"
                    });
                }
            } else {
                toolWarnings.push({
                    type: "unsupported-tool",
                    tool: tool12
                });
            }
        } else {
            groqTools2.push({
                type: "function",
                function: {
                    name: tool12.name,
                    description: tool12.description,
                    parameters: tool12.inputSchema
                }
            });
        }
    }
    if (toolChoice == null) {
        return {
            tools: groqTools2,
            toolChoice: void 0,
            toolWarnings
        };
    }
    const type = toolChoice.type;
    switch(type){
        case "auto":
        case "none":
        case "required":
            return {
                tools: groqTools2,
                toolChoice: type,
                toolWarnings
            };
        case "tool":
            return {
                tools: groqTools2,
                toolChoice: {
                    type: "function",
                    function: {
                        name: toolChoice.toolName
                    }
                },
                toolWarnings
            };
        default:
            {
                const _exhaustiveCheck = type;
                throw new import_provider46.UnsupportedFunctionalityError({
                    functionality: `tool choice type: ${_exhaustiveCheck}`
                });
            }
    }
}
function mapGroqFinishReason(finishReason) {
    switch(finishReason){
        case "stop":
            return "stop";
        case "length":
            return "length";
        case "content_filter":
            return "content-filter";
        case "function_call":
        case "tool_calls":
            return "tool-calls";
        default:
            return "unknown";
    }
}
var GroqChatLanguageModel = class {
    constructor(modelId, config){
        this.specificationVersion = "v2";
        this.supportedUrls = {
            "image/*": [
                /^https?:\/\/.*$/
            ]
        };
        this.modelId = modelId;
        this.config = config;
    }
    get provider() {
        return this.config.provider;
    }
    getArgs(_0) {
        return __async(this, arguments, function*({ prompt, maxOutputTokens, temperature, topP, topK, frequencyPenalty, presencePenalty, stopSequences, responseFormat, seed, stream, tools, toolChoice, providerOptions }) {
            var _a, _b;
            const warnings = [];
            const groqOptions = yield parseProviderOptions({
                provider: "groq",
                providerOptions,
                schema: groqProviderOptions
            });
            const structuredOutputs = (_a = groqOptions == null ? void 0 : groqOptions.structuredOutputs) != null ? _a : true;
            if (topK != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "topK"
                });
            }
            if ((responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && !structuredOutputs) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "responseFormat",
                    details: "JSON response format schema is only supported with structuredOutputs"
                });
            }
            const { tools: groqTools2, toolChoice: groqToolChoice, toolWarnings } = prepareTools5({
                tools,
                toolChoice,
                modelId: this.modelId
            });
            return {
                args: {
                    // model id:
                    model: this.modelId,
                    // model specific settings:
                    user: groqOptions == null ? void 0 : groqOptions.user,
                    parallel_tool_calls: groqOptions == null ? void 0 : groqOptions.parallelToolCalls,
                    // standardized settings:
                    max_tokens: maxOutputTokens,
                    temperature,
                    top_p: topP,
                    frequency_penalty: frequencyPenalty,
                    presence_penalty: presencePenalty,
                    stop: stopSequences,
                    seed,
                    // response format:
                    response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? structuredOutputs && responseFormat.schema != null ? {
                        type: "json_schema",
                        json_schema: {
                            schema: responseFormat.schema,
                            name: (_b = responseFormat.name) != null ? _b : "response",
                            description: responseFormat.description
                        }
                    } : {
                        type: "json_object"
                    } : void 0,
                    // provider options:
                    reasoning_format: groqOptions == null ? void 0 : groqOptions.reasoningFormat,
                    reasoning_effort: groqOptions == null ? void 0 : groqOptions.reasoningEffort,
                    service_tier: groqOptions == null ? void 0 : groqOptions.serviceTier,
                    // messages:
                    messages: convertToGroqChatMessages(prompt),
                    // tools:
                    tools: groqTools2,
                    tool_choice: groqToolChoice
                },
                warnings: [
                    ...warnings,
                    ...toolWarnings
                ]
            };
        });
    }
    doGenerate(options) {
        return __async(this, null, function*() {
            var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
            const { args, warnings } = yield this.getArgs(__spreadProps(__spreadValues({}, options), {
                stream: false
            }));
            const body = JSON.stringify(args);
            const { responseHeaders, value: response, rawValue: rawResponse } = yield postJsonToApi({
                url: this.config.url({
                    path: "/chat/completions",
                    modelId: this.modelId
                }),
                headers: combineHeaders(this.config.headers(), options.headers),
                body: args,
                failedResponseHandler: groqFailedResponseHandler,
                successfulResponseHandler: createJsonResponseHandler(groqChatResponseSchema),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            const choice = response.choices[0];
            const content = [];
            const text = choice.message.content;
            if (text != null && text.length > 0) {
                content.push({
                    type: "text",
                    text
                });
            }
            const reasoning = choice.message.reasoning;
            if (reasoning != null && reasoning.length > 0) {
                content.push({
                    type: "reasoning",
                    text: reasoning
                });
            }
            if (choice.message.tool_calls != null) {
                for (const toolCall of choice.message.tool_calls){
                    content.push({
                        type: "tool-call",
                        toolCallId: (_a = toolCall.id) != null ? _a : generateId(),
                        toolName: toolCall.function.name,
                        input: toolCall.function.arguments
                    });
                }
            }
            return {
                content,
                finishReason: mapGroqFinishReason(choice.finish_reason),
                usage: {
                    inputTokens: (_c = (_b = response.usage) == null ? void 0 : _b.prompt_tokens) != null ? _c : void 0,
                    outputTokens: (_e = (_d = response.usage) == null ? void 0 : _d.completion_tokens) != null ? _e : void 0,
                    totalTokens: (_g = (_f = response.usage) == null ? void 0 : _f.total_tokens) != null ? _g : void 0,
                    cachedInputTokens: (_j = (_i = (_h = response.usage) == null ? void 0 : _h.prompt_tokens_details) == null ? void 0 : _i.cached_tokens) != null ? _j : void 0
                },
                response: __spreadProps(__spreadValues({}, getResponseMetadata6(response)), {
                    headers: responseHeaders,
                    body: rawResponse
                }),
                warnings,
                request: {
                    body
                }
            };
        });
    }
    doStream(options) {
        return __async(this, null, function*() {
            const { args, warnings } = yield this.getArgs(__spreadProps(__spreadValues({}, options), {
                stream: true
            }));
            const body = JSON.stringify(__spreadProps(__spreadValues({}, args), {
                stream: true
            }));
            const { responseHeaders, value: response } = yield postJsonToApi({
                url: this.config.url({
                    path: "/chat/completions",
                    modelId: this.modelId
                }),
                headers: combineHeaders(this.config.headers(), options.headers),
                body: __spreadProps(__spreadValues({}, args), {
                    stream: true
                }),
                failedResponseHandler: groqFailedResponseHandler,
                successfulResponseHandler: createEventSourceResponseHandler(groqChatChunkSchema),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            const toolCalls = [];
            let finishReason = "unknown";
            const usage = {
                inputTokens: void 0,
                outputTokens: void 0,
                totalTokens: void 0,
                cachedInputTokens: void 0
            };
            let isFirstChunk = true;
            let isActiveText = false;
            let isActiveReasoning = false;
            let providerMetadata;
            return {
                stream: response.pipeThrough(new TransformStream({
                    start (controller) {
                        controller.enqueue({
                            type: "stream-start",
                            warnings
                        });
                    },
                    transform (chunk, controller) {
                        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
                        if (options.includeRawChunks) {
                            controller.enqueue({
                                type: "raw",
                                rawValue: chunk.rawValue
                            });
                        }
                        if (!chunk.success) {
                            finishReason = "error";
                            controller.enqueue({
                                type: "error",
                                error: chunk.error
                            });
                            return;
                        }
                        const value = chunk.value;
                        if ("error" in value) {
                            finishReason = "error";
                            controller.enqueue({
                                type: "error",
                                error: value.error
                            });
                            return;
                        }
                        if (isFirstChunk) {
                            isFirstChunk = false;
                            controller.enqueue(__spreadValues({
                                type: "response-metadata"
                            }, getResponseMetadata6(value)));
                        }
                        if (((_a = value.x_groq) == null ? void 0 : _a.usage) != null) {
                            usage.inputTokens = (_b = value.x_groq.usage.prompt_tokens) != null ? _b : void 0;
                            usage.outputTokens = (_c = value.x_groq.usage.completion_tokens) != null ? _c : void 0;
                            usage.totalTokens = (_d = value.x_groq.usage.total_tokens) != null ? _d : void 0;
                            usage.cachedInputTokens = (_f = (_e = value.x_groq.usage.prompt_tokens_details) == null ? void 0 : _e.cached_tokens) != null ? _f : void 0;
                        }
                        const choice = value.choices[0];
                        if ((choice == null ? void 0 : choice.finish_reason) != null) {
                            finishReason = mapGroqFinishReason(choice.finish_reason);
                        }
                        if ((choice == null ? void 0 : choice.delta) == null) {
                            return;
                        }
                        const delta = choice.delta;
                        if (delta.reasoning != null && delta.reasoning.length > 0) {
                            if (!isActiveReasoning) {
                                controller.enqueue({
                                    type: "reasoning-start",
                                    id: "reasoning-0"
                                });
                                isActiveReasoning = true;
                            }
                            controller.enqueue({
                                type: "reasoning-delta",
                                id: "reasoning-0",
                                delta: delta.reasoning
                            });
                        }
                        if (delta.content != null && delta.content.length > 0) {
                            if (!isActiveText) {
                                controller.enqueue({
                                    type: "text-start",
                                    id: "txt-0"
                                });
                                isActiveText = true;
                            }
                            controller.enqueue({
                                type: "text-delta",
                                id: "txt-0",
                                delta: delta.content
                            });
                        }
                        if (delta.tool_calls != null) {
                            for (const toolCallDelta of delta.tool_calls){
                                const index = toolCallDelta.index;
                                if (toolCalls[index] == null) {
                                    if (toolCallDelta.type !== "function") {
                                        throw new import_provider44.InvalidResponseDataError({
                                            data: toolCallDelta,
                                            message: `Expected 'function' type.`
                                        });
                                    }
                                    if (toolCallDelta.id == null) {
                                        throw new import_provider44.InvalidResponseDataError({
                                            data: toolCallDelta,
                                            message: `Expected 'id' to be a string.`
                                        });
                                    }
                                    if (((_g = toolCallDelta.function) == null ? void 0 : _g.name) == null) {
                                        throw new import_provider44.InvalidResponseDataError({
                                            data: toolCallDelta,
                                            message: `Expected 'function.name' to be a string.`
                                        });
                                    }
                                    controller.enqueue({
                                        type: "tool-input-start",
                                        id: toolCallDelta.id,
                                        toolName: toolCallDelta.function.name
                                    });
                                    toolCalls[index] = {
                                        id: toolCallDelta.id,
                                        type: "function",
                                        function: {
                                            name: toolCallDelta.function.name,
                                            arguments: (_h = toolCallDelta.function.arguments) != null ? _h : ""
                                        },
                                        hasFinished: false
                                    };
                                    const toolCall2 = toolCalls[index];
                                    if (((_i = toolCall2.function) == null ? void 0 : _i.name) != null && ((_j = toolCall2.function) == null ? void 0 : _j.arguments) != null) {
                                        if (toolCall2.function.arguments.length > 0) {
                                            controller.enqueue({
                                                type: "tool-input-delta",
                                                id: toolCall2.id,
                                                delta: toolCall2.function.arguments
                                            });
                                        }
                                        if (isParsableJson(toolCall2.function.arguments)) {
                                            controller.enqueue({
                                                type: "tool-input-end",
                                                id: toolCall2.id
                                            });
                                            controller.enqueue({
                                                type: "tool-call",
                                                toolCallId: (_k = toolCall2.id) != null ? _k : generateId(),
                                                toolName: toolCall2.function.name,
                                                input: toolCall2.function.arguments
                                            });
                                            toolCall2.hasFinished = true;
                                        }
                                    }
                                    continue;
                                }
                                const toolCall = toolCalls[index];
                                if (toolCall.hasFinished) {
                                    continue;
                                }
                                if (((_l = toolCallDelta.function) == null ? void 0 : _l.arguments) != null) {
                                    toolCall.function.arguments += (_n = (_m = toolCallDelta.function) == null ? void 0 : _m.arguments) != null ? _n : "";
                                }
                                controller.enqueue({
                                    type: "tool-input-delta",
                                    id: toolCall.id,
                                    delta: (_o = toolCallDelta.function.arguments) != null ? _o : ""
                                });
                                if (((_p = toolCall.function) == null ? void 0 : _p.name) != null && ((_q = toolCall.function) == null ? void 0 : _q.arguments) != null && isParsableJson(toolCall.function.arguments)) {
                                    controller.enqueue({
                                        type: "tool-input-end",
                                        id: toolCall.id
                                    });
                                    controller.enqueue({
                                        type: "tool-call",
                                        toolCallId: (_r = toolCall.id) != null ? _r : generateId(),
                                        toolName: toolCall.function.name,
                                        input: toolCall.function.arguments
                                    });
                                    toolCall.hasFinished = true;
                                }
                            }
                        }
                    },
                    flush (controller) {
                        if (isActiveReasoning) {
                            controller.enqueue({
                                type: "reasoning-end",
                                id: "reasoning-0"
                            });
                        }
                        if (isActiveText) {
                            controller.enqueue({
                                type: "text-end",
                                id: "txt-0"
                            });
                        }
                        controller.enqueue(__spreadValues({
                            type: "finish",
                            finishReason,
                            usage
                        }, providerMetadata != null ? {
                            providerMetadata
                        } : {}));
                    }
                })),
                request: {
                    body
                },
                response: {
                    headers: responseHeaders
                }
            };
        });
    }
};
var groqChatResponseSchema = import_v477.z.object({
    id: import_v477.z.string().nullish(),
    created: import_v477.z.number().nullish(),
    model: import_v477.z.string().nullish(),
    choices: import_v477.z.array(import_v477.z.object({
        message: import_v477.z.object({
            content: import_v477.z.string().nullish(),
            reasoning: import_v477.z.string().nullish(),
            tool_calls: import_v477.z.array(import_v477.z.object({
                id: import_v477.z.string().nullish(),
                type: import_v477.z.literal("function"),
                function: import_v477.z.object({
                    name: import_v477.z.string(),
                    arguments: import_v477.z.string()
                })
            })).nullish()
        }),
        index: import_v477.z.number(),
        finish_reason: import_v477.z.string().nullish()
    })),
    usage: import_v477.z.object({
        prompt_tokens: import_v477.z.number().nullish(),
        completion_tokens: import_v477.z.number().nullish(),
        total_tokens: import_v477.z.number().nullish(),
        prompt_tokens_details: import_v477.z.object({
            cached_tokens: import_v477.z.number().nullish()
        }).nullish()
    }).nullish()
});
var groqChatChunkSchema = import_v477.z.union([
    import_v477.z.object({
        id: import_v477.z.string().nullish(),
        created: import_v477.z.number().nullish(),
        model: import_v477.z.string().nullish(),
        choices: import_v477.z.array(import_v477.z.object({
            delta: import_v477.z.object({
                content: import_v477.z.string().nullish(),
                reasoning: import_v477.z.string().nullish(),
                tool_calls: import_v477.z.array(import_v477.z.object({
                    index: import_v477.z.number(),
                    id: import_v477.z.string().nullish(),
                    type: import_v477.z.literal("function").optional(),
                    function: import_v477.z.object({
                        name: import_v477.z.string().nullish(),
                        arguments: import_v477.z.string().nullish()
                    })
                })).nullish()
            }).nullish(),
            finish_reason: import_v477.z.string().nullable().optional(),
            index: import_v477.z.number()
        })),
        x_groq: import_v477.z.object({
            usage: import_v477.z.object({
                prompt_tokens: import_v477.z.number().nullish(),
                completion_tokens: import_v477.z.number().nullish(),
                total_tokens: import_v477.z.number().nullish(),
                prompt_tokens_details: import_v477.z.object({
                    cached_tokens: import_v477.z.number().nullish()
                }).nullish()
            }).nullish()
        }).nullish()
    }),
    groqErrorDataSchema
]);
var groqProviderOptionsSchema = import_v480.z.object({
    language: import_v480.z.string().nullish(),
    prompt: import_v480.z.string().nullish(),
    responseFormat: import_v480.z.string().nullish(),
    temperature: import_v480.z.number().min(0).max(1).nullish(),
    timestampGranularities: import_v480.z.array(import_v480.z.string()).nullish()
});
var GroqTranscriptionModel = class {
    constructor(modelId, config){
        this.modelId = modelId;
        this.config = config;
        this.specificationVersion = "v2";
    }
    get provider() {
        return this.config.provider;
    }
    getArgs(_0) {
        return __async(this, arguments, function*({ audio, mediaType, providerOptions }) {
            var _a, _b, _c, _d, _e;
            const warnings = [];
            const groqOptions = yield parseProviderOptions({
                provider: "groq",
                providerOptions,
                schema: groqProviderOptionsSchema
            });
            const formData = new FormData();
            const blob = audio instanceof Uint8Array ? new Blob([
                audio
            ]) : new Blob([
                convertBase64ToUint8Array(audio)
            ]);
            formData.append("model", this.modelId);
            const fileExtension = mediaTypeToExtension(mediaType);
            formData.append("file", new File([
                blob
            ], "audio", {
                type: mediaType
            }), `audio.${fileExtension}`);
            if (groqOptions) {
                const transcriptionModelOptions = {
                    language: (_a = groqOptions.language) != null ? _a : void 0,
                    prompt: (_b = groqOptions.prompt) != null ? _b : void 0,
                    response_format: (_c = groqOptions.responseFormat) != null ? _c : void 0,
                    temperature: (_d = groqOptions.temperature) != null ? _d : void 0,
                    timestamp_granularities: (_e = groqOptions.timestampGranularities) != null ? _e : void 0
                };
                for(const key in transcriptionModelOptions){
                    const value = transcriptionModelOptions[key];
                    if (value !== void 0) {
                        formData.append(key, String(value));
                    }
                }
            }
            return {
                formData,
                warnings
            };
        });
    }
    doGenerate(options) {
        return __async(this, null, function*() {
            var _a, _b, _c, _d, _e, _f, _g;
            const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();
            const { formData, warnings } = yield this.getArgs(options);
            const { value: response, responseHeaders, rawValue: rawResponse } = yield postFormDataToApi({
                url: this.config.url({
                    path: "/audio/transcriptions",
                    modelId: this.modelId
                }),
                headers: combineHeaders(this.config.headers(), options.headers),
                formData,
                failedResponseHandler: groqFailedResponseHandler,
                successfulResponseHandler: createJsonResponseHandler(groqTranscriptionResponseSchema),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            return {
                text: response.text,
                segments: (_e = (_d = response.segments) == null ? void 0 : _d.map((segment)=>({
                        text: segment.text,
                        startSecond: segment.start,
                        endSecond: segment.end
                    }))) != null ? _e : [],
                language: (_f = response.language) != null ? _f : void 0,
                durationInSeconds: (_g = response.duration) != null ? _g : void 0,
                warnings,
                response: {
                    timestamp: currentDate,
                    modelId: this.modelId,
                    headers: responseHeaders,
                    body: rawResponse
                }
            };
        });
    }
};
var groqTranscriptionResponseSchema = import_v480.z.object({
    text: import_v480.z.string(),
    x_groq: import_v480.z.object({
        id: import_v480.z.string()
    }),
    // additional properties are returned when `response_format: 'verbose_json'` is
    task: import_v480.z.string().nullish(),
    language: import_v480.z.string().nullish(),
    duration: import_v480.z.number().nullish(),
    segments: import_v480.z.array(import_v480.z.object({
        id: import_v480.z.number(),
        seek: import_v480.z.number(),
        start: import_v480.z.number(),
        end: import_v480.z.number(),
        text: import_v480.z.string(),
        tokens: import_v480.z.array(import_v480.z.number()),
        temperature: import_v480.z.number(),
        avg_logprob: import_v480.z.number(),
        compression_ratio: import_v480.z.number(),
        no_speech_prob: import_v480.z.number()
    })).nullish()
});
var browserSearch = createProviderDefinedToolFactory({
    id: "groq.browser_search",
    name: "browser_search",
    inputSchema: import_v481.z.object({})
});
var groqTools = {
    browserSearch
};
var VERSION7 = ("TURBOPACK compile-time truthy", 1) ? "2.0.24" : "TURBOPACK unreachable";
function createGroq(options = {}) {
    var _a;
    const baseURL = (_a = withoutTrailingSlash(options.baseURL)) != null ? _a : "https://api.groq.com/openai/v1";
    const getHeaders = ()=>withUserAgentSuffix(__spreadValues({
            Authorization: `Bearer ${loadApiKey({
                apiKey: options.apiKey,
                environmentVariableName: "GROQ_API_KEY",
                description: "Groq"
            })}`
        }, options.headers), `ai-sdk/groq/${VERSION7}`);
    const createChatModel = (modelId)=>new GroqChatLanguageModel(modelId, {
            provider: "groq.chat",
            url: ({ path: path7 })=>`${baseURL}${path7}`,
            headers: getHeaders,
            fetch: options.fetch
        });
    const createLanguageModel = (modelId)=>{
        if (new.target) {
            throw new Error("The Groq model function cannot be called with the new keyword.");
        }
        return createChatModel(modelId);
    };
    const createTranscriptionModel = (modelId)=>{
        return new GroqTranscriptionModel(modelId, {
            provider: "groq.transcription",
            url: ({ path: path7 })=>`${baseURL}${path7}`,
            headers: getHeaders,
            fetch: options.fetch
        });
    };
    const provider = function(modelId) {
        return createLanguageModel(modelId);
    };
    provider.languageModel = createLanguageModel;
    provider.chat = createChatModel;
    provider.textEmbeddingModel = (modelId)=>{
        throw new import_provider43.NoSuchModelError({
            modelId,
            modelType: "textEmbeddingModel"
        });
    };
    provider.imageModel = (modelId)=>{
        throw new import_provider43.NoSuchModelError({
            modelId,
            modelType: "imageModel"
        });
    };
    provider.transcription = createTranscriptionModel;
    provider.transcriptionModel = createTranscriptionModel;
    provider.tools = groqTools;
    return provider;
}
var groq = createGroq();
// ../../node_modules/.pnpm/@ai-sdk+cerebras@1.0.25_zod@3.25.67/node_modules/@ai-sdk/cerebras/dist/index.mjs
var import_provider47 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v482 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var VERSION8 = ("TURBOPACK compile-time truthy", 1) ? "1.0.25" : "TURBOPACK unreachable";
var cerebrasErrorSchema = import_v482.z.object({
    message: import_v482.z.string(),
    type: import_v482.z.string(),
    param: import_v482.z.string(),
    code: import_v482.z.string()
});
var cerebrasErrorStructure = {
    errorSchema: cerebrasErrorSchema,
    errorToMessage: (data)=>data.message
};
function createCerebras(options = {}) {
    var _a;
    const baseURL = withoutTrailingSlash((_a = options.baseURL) != null ? _a : "https://api.cerebras.ai/v1");
    const getHeaders = ()=>withUserAgentSuffix(__spreadValues({
            Authorization: `Bearer ${loadApiKey({
                apiKey: options.apiKey,
                environmentVariableName: "CEREBRAS_API_KEY",
                description: "Cerebras API key"
            })}`
        }, options.headers), `ai-sdk/cerebras/${VERSION8}`);
    const createLanguageModel = (modelId)=>{
        return new OpenAICompatibleChatLanguageModel(modelId, {
            provider: `cerebras.chat`,
            url: ({ path: path7 })=>`${baseURL}${path7}`,
            headers: getHeaders,
            fetch: options.fetch,
            errorStructure: cerebrasErrorStructure,
            supportsStructuredOutputs: true
        });
    };
    const provider = (modelId)=>createLanguageModel(modelId);
    provider.languageModel = createLanguageModel;
    provider.chat = createLanguageModel;
    provider.textEmbeddingModel = (modelId)=>{
        throw new import_provider47.NoSuchModelError({
            modelId,
            modelType: "textEmbeddingModel"
        });
    };
    provider.imageModel = (modelId)=>{
        throw new import_provider47.NoSuchModelError({
            modelId,
            modelType: "imageModel"
        });
    };
    return provider;
}
var cerebras = createCerebras();
// ../../node_modules/.pnpm/@ai-sdk+togetherai@1.0.23_zod@3.25.67/node_modules/@ai-sdk/togetherai/dist/index.mjs
var import_v483 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var TogetherAIImageModel = class {
    constructor(modelId, config){
        this.modelId = modelId;
        this.config = config;
        this.specificationVersion = "v2";
        this.maxImagesPerCall = 1;
    }
    get provider() {
        return this.config.provider;
    }
    doGenerate(_0) {
        return __async(this, arguments, function*({ prompt, n, size, seed, providerOptions, headers, abortSignal }) {
            var _a, _b, _c, _d;
            const warnings = [];
            if (size != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "aspectRatio",
                    details: "This model does not support the `aspectRatio` option. Use `size` instead."
                });
            }
            const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();
            const splitSize = size == null ? void 0 : size.split("x");
            const { value: response, responseHeaders } = yield postJsonToApi({
                url: `${this.config.baseURL}/images/generations`,
                headers: combineHeaders(this.config.headers(), headers),
                body: __spreadValues(__spreadProps(__spreadValues({
                    model: this.modelId,
                    prompt,
                    seed,
                    n
                }, splitSize && {
                    width: parseInt(splitSize[0]),
                    height: parseInt(splitSize[1])
                }), {
                    response_format: "base64"
                }), (_d = providerOptions.togetherai) != null ? _d : {}),
                failedResponseHandler: createJsonErrorResponseHandler({
                    errorSchema: togetheraiErrorSchema,
                    errorToMessage: (data)=>data.error.message
                }),
                successfulResponseHandler: createJsonResponseHandler(togetheraiImageResponseSchema),
                abortSignal,
                fetch: this.config.fetch
            });
            return {
                images: response.data.map((item)=>item.b64_json),
                warnings,
                response: {
                    timestamp: currentDate,
                    modelId: this.modelId,
                    headers: responseHeaders
                }
            };
        });
    }
};
var togetheraiImageResponseSchema = import_v483.z.object({
    data: import_v483.z.array(import_v483.z.object({
        b64_json: import_v483.z.string()
    }))
});
var togetheraiErrorSchema = import_v483.z.object({
    error: import_v483.z.object({
        message: import_v483.z.string()
    })
});
var VERSION9 = ("TURBOPACK compile-time truthy", 1) ? "1.0.23" : "TURBOPACK unreachable";
function createTogetherAI(options = {}) {
    var _a;
    const baseURL = withoutTrailingSlash((_a = options.baseURL) != null ? _a : "https://api.together.xyz/v1/");
    const getHeaders = ()=>withUserAgentSuffix(__spreadValues({
            Authorization: `Bearer ${loadApiKey({
                apiKey: options.apiKey,
                environmentVariableName: "TOGETHER_AI_API_KEY",
                description: "TogetherAI"
            })}`
        }, options.headers), `ai-sdk/togetherai/${VERSION9}`);
    const getCommonModelConfig = (modelType)=>({
            provider: `togetherai.${modelType}`,
            url: ({ path: path7 })=>`${baseURL}${path7}`,
            headers: getHeaders,
            fetch: options.fetch
        });
    const createChatModel = (modelId)=>{
        return new OpenAICompatibleChatLanguageModel(modelId, getCommonModelConfig("chat"));
    };
    const createCompletionModel = (modelId)=>new OpenAICompatibleCompletionLanguageModel(modelId, getCommonModelConfig("completion"));
    const createTextEmbeddingModel = (modelId)=>new OpenAICompatibleEmbeddingModel(modelId, getCommonModelConfig("embedding"));
    const createImageModel = (modelId)=>new TogetherAIImageModel(modelId, __spreadProps(__spreadValues({}, getCommonModelConfig("image")), {
            baseURL: baseURL != null ? baseURL : "https://api.together.xyz/v1/"
        }));
    const provider = (modelId)=>createChatModel(modelId);
    provider.completionModel = createCompletionModel;
    provider.languageModel = createChatModel;
    provider.chatModel = createChatModel;
    provider.textEmbeddingModel = createTextEmbeddingModel;
    provider.image = createImageModel;
    provider.imageModel = createImageModel;
    return provider;
}
var togetherai = createTogetherAI();
// ../../node_modules/.pnpm/@ai-sdk+mistral@2.0.19_zod@3.25.67/node_modules/@ai-sdk/mistral/dist/index.mjs
var import_provider48 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v484 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_provider49 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v485 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v486 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_provider50 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_provider51 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v487 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
function convertToMistralChatMessages(prompt) {
    const messages = [];
    for(let i = 0; i < prompt.length; i++){
        const { role, content } = prompt[i];
        const isLastMessage = i === prompt.length - 1;
        switch(role){
            case "system":
                {
                    messages.push({
                        role: "system",
                        content
                    });
                    break;
                }
            case "user":
                {
                    messages.push({
                        role: "user",
                        content: content.map((part)=>{
                            switch(part.type){
                                case "text":
                                    {
                                        return {
                                            type: "text",
                                            text: part.text
                                        };
                                    }
                                case "file":
                                    {
                                        if (part.mediaType.startsWith("image/")) {
                                            const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                                            return {
                                                type: "image_url",
                                                image_url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${convertToBase64(part.data)}`
                                            };
                                        } else if (part.mediaType === "application/pdf") {
                                            return {
                                                type: "document_url",
                                                document_url: part.data.toString()
                                            };
                                        } else {
                                            throw new import_provider49.UnsupportedFunctionalityError({
                                                functionality: "Only images and PDF file parts are supported"
                                            });
                                        }
                                    }
                            }
                        })
                    });
                    break;
                }
            case "assistant":
                {
                    let text = "";
                    const toolCalls = [];
                    for (const part of content){
                        switch(part.type){
                            case "text":
                                {
                                    text += part.text;
                                    break;
                                }
                            case "tool-call":
                                {
                                    toolCalls.push({
                                        id: part.toolCallId,
                                        type: "function",
                                        function: {
                                            name: part.toolName,
                                            arguments: JSON.stringify(part.input)
                                        }
                                    });
                                    break;
                                }
                            case "reasoning":
                                {
                                    text += part.text;
                                    break;
                                }
                            default:
                                {
                                    throw new Error(`Unsupported content type in assistant message: ${part.type}`);
                                }
                        }
                    }
                    messages.push({
                        role: "assistant",
                        content: text,
                        prefix: isLastMessage ? true : void 0,
                        tool_calls: toolCalls.length > 0 ? toolCalls : void 0
                    });
                    break;
                }
            case "tool":
                {
                    for (const toolResponse of content){
                        const output = toolResponse.output;
                        let contentValue;
                        switch(output.type){
                            case "text":
                            case "error-text":
                                contentValue = output.value;
                                break;
                            case "content":
                            case "json":
                            case "error-json":
                                contentValue = JSON.stringify(output.value);
                                break;
                        }
                        messages.push({
                            role: "tool",
                            name: toolResponse.toolName,
                            tool_call_id: toolResponse.toolCallId,
                            content: contentValue
                        });
                    }
                    break;
                }
            default:
                {
                    const _exhaustiveCheck = role;
                    throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
                }
        }
    }
    return messages;
}
function getResponseMetadata7({ id, model, created }) {
    return {
        id: id != null ? id : void 0,
        modelId: model != null ? model : void 0,
        timestamp: created != null ? new Date(created * 1e3) : void 0
    };
}
function mapMistralFinishReason(finishReason) {
    switch(finishReason){
        case "stop":
            return "stop";
        case "length":
        case "model_length":
            return "length";
        case "tool_calls":
            return "tool-calls";
        default:
            return "unknown";
    }
}
var mistralLanguageModelOptions = import_v485.z.object({
    /**
  Whether to inject a safety prompt before all conversations.
  
  Defaults to `false`.
     */ safePrompt: import_v485.z.boolean().optional(),
    documentImageLimit: import_v485.z.number().optional(),
    documentPageLimit: import_v485.z.number().optional(),
    /**
   * Whether to use structured outputs.
   *
   * @default true
   */ structuredOutputs: import_v485.z.boolean().optional(),
    /**
   * Whether to use strict JSON schema validation.
   *
   * @default false
   */ strictJsonSchema: import_v485.z.boolean().optional(),
    /**
   * Whether to enable parallel function calling during tool use.
   * When set to false, the model will use at most one tool per response.
   *
   * @default true
   */ parallelToolCalls: import_v485.z.boolean().optional()
});
var mistralErrorDataSchema = import_v486.z.object({
    object: import_v486.z.literal("error"),
    message: import_v486.z.string(),
    type: import_v486.z.string(),
    param: import_v486.z.string().nullable(),
    code: import_v486.z.string().nullable()
});
var mistralFailedResponseHandler = createJsonErrorResponseHandler({
    errorSchema: mistralErrorDataSchema,
    errorToMessage: (data)=>data.message
});
function prepareTools6({ tools, toolChoice }) {
    tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
    const toolWarnings = [];
    if (tools == null) {
        return {
            tools: void 0,
            toolChoice: void 0,
            toolWarnings
        };
    }
    const mistralTools = [];
    for (const tool12 of tools){
        if (tool12.type === "provider-defined") {
            toolWarnings.push({
                type: "unsupported-tool",
                tool: tool12
            });
        } else {
            mistralTools.push({
                type: "function",
                function: {
                    name: tool12.name,
                    description: tool12.description,
                    parameters: tool12.inputSchema
                }
            });
        }
    }
    if (toolChoice == null) {
        return {
            tools: mistralTools,
            toolChoice: void 0,
            toolWarnings
        };
    }
    const type = toolChoice.type;
    switch(type){
        case "auto":
        case "none":
            return {
                tools: mistralTools,
                toolChoice: type,
                toolWarnings
            };
        case "required":
            return {
                tools: mistralTools,
                toolChoice: "any",
                toolWarnings
            };
        // mistral does not support tool mode directly,
        // so we filter the tools and force the tool choice through 'any'
        case "tool":
            return {
                tools: mistralTools.filter((tool12)=>tool12.function.name === toolChoice.toolName),
                toolChoice: "any",
                toolWarnings
            };
        default:
            {
                const _exhaustiveCheck = type;
                throw new import_provider50.UnsupportedFunctionalityError({
                    functionality: `tool choice type: ${_exhaustiveCheck}`
                });
            }
    }
}
var MistralChatLanguageModel = class {
    constructor(modelId, config){
        this.specificationVersion = "v2";
        this.supportedUrls = {
            "application/pdf": [
                /^https:\/\/.*$/
            ]
        };
        var _a;
        this.modelId = modelId;
        this.config = config;
        this.generateId = (_a = config.generateId) != null ? _a : generateId;
    }
    get provider() {
        return this.config.provider;
    }
    getArgs(_0) {
        return __async(this, arguments, function*({ prompt, maxOutputTokens, temperature, topP, topK, frequencyPenalty, presencePenalty, stopSequences, responseFormat, seed, providerOptions, tools, toolChoice }) {
            var _a, _b, _c, _d;
            const warnings = [];
            const options = (_a = yield parseProviderOptions({
                provider: "mistral",
                providerOptions,
                schema: mistralLanguageModelOptions
            })) != null ? _a : {};
            if (topK != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "topK"
                });
            }
            if (frequencyPenalty != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "frequencyPenalty"
                });
            }
            if (presencePenalty != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "presencePenalty"
                });
            }
            if (stopSequences != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "stopSequences"
                });
            }
            const structuredOutputs = (_b = options.structuredOutputs) != null ? _b : true;
            const strictJsonSchema = (_c = options.strictJsonSchema) != null ? _c : false;
            if ((responseFormat == null ? void 0 : responseFormat.type) === "json" && !(responseFormat == null ? void 0 : responseFormat.schema)) {
                prompt = injectJsonInstructionIntoMessages({
                    messages: prompt,
                    schema: responseFormat.schema
                });
            }
            const baseArgs = {
                // model id:
                model: this.modelId,
                // model specific settings:
                safe_prompt: options.safePrompt,
                // standardized settings:
                max_tokens: maxOutputTokens,
                temperature,
                top_p: topP,
                random_seed: seed,
                // response format:
                response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? structuredOutputs && (responseFormat == null ? void 0 : responseFormat.schema) != null ? {
                    type: "json_schema",
                    json_schema: {
                        schema: responseFormat.schema,
                        strict: strictJsonSchema,
                        name: (_d = responseFormat.name) != null ? _d : "response",
                        description: responseFormat.description
                    }
                } : {
                    type: "json_object"
                } : void 0,
                // mistral-specific provider options:
                document_image_limit: options.documentImageLimit,
                document_page_limit: options.documentPageLimit,
                // messages:
                messages: convertToMistralChatMessages(prompt)
            };
            const { tools: mistralTools, toolChoice: mistralToolChoice, toolWarnings } = prepareTools6({
                tools,
                toolChoice
            });
            return {
                args: __spreadValues(__spreadProps(__spreadValues({}, baseArgs), {
                    tools: mistralTools,
                    tool_choice: mistralToolChoice
                }), mistralTools != null && options.parallelToolCalls !== void 0 ? {
                    parallel_tool_calls: options.parallelToolCalls
                } : {}),
                warnings: [
                    ...warnings,
                    ...toolWarnings
                ]
            };
        });
    }
    doGenerate(options) {
        return __async(this, null, function*() {
            const { args: body, warnings } = yield this.getArgs(options);
            const { responseHeaders, value: response, rawValue: rawResponse } = yield postJsonToApi({
                url: `${this.config.baseURL}/chat/completions`,
                headers: combineHeaders(this.config.headers(), options.headers),
                body,
                failedResponseHandler: mistralFailedResponseHandler,
                successfulResponseHandler: createJsonResponseHandler(mistralChatResponseSchema),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            const choice = response.choices[0];
            const content = [];
            if (choice.message.content != null && Array.isArray(choice.message.content)) {
                for (const part of choice.message.content){
                    if (part.type === "thinking") {
                        const reasoningText = extractReasoningContent(part.thinking);
                        if (reasoningText.length > 0) {
                            content.push({
                                type: "reasoning",
                                text: reasoningText
                            });
                        }
                    } else if (part.type === "text") {
                        if (part.text.length > 0) {
                            content.push({
                                type: "text",
                                text: part.text
                            });
                        }
                    }
                }
            } else {
                const text = extractTextContent(choice.message.content);
                if (text != null && text.length > 0) {
                    content.push({
                        type: "text",
                        text
                    });
                }
            }
            if (choice.message.tool_calls != null) {
                for (const toolCall of choice.message.tool_calls){
                    content.push({
                        type: "tool-call",
                        toolCallId: toolCall.id,
                        toolName: toolCall.function.name,
                        input: toolCall.function.arguments
                    });
                }
            }
            return {
                content,
                finishReason: mapMistralFinishReason(choice.finish_reason),
                usage: {
                    inputTokens: response.usage.prompt_tokens,
                    outputTokens: response.usage.completion_tokens,
                    totalTokens: response.usage.total_tokens
                },
                request: {
                    body
                },
                response: __spreadProps(__spreadValues({}, getResponseMetadata7(response)), {
                    headers: responseHeaders,
                    body: rawResponse
                }),
                warnings
            };
        });
    }
    doStream(options) {
        return __async(this, null, function*() {
            const { args, warnings } = yield this.getArgs(options);
            const body = __spreadProps(__spreadValues({}, args), {
                stream: true
            });
            const { responseHeaders, value: response } = yield postJsonToApi({
                url: `${this.config.baseURL}/chat/completions`,
                headers: combineHeaders(this.config.headers(), options.headers),
                body,
                failedResponseHandler: mistralFailedResponseHandler,
                successfulResponseHandler: createEventSourceResponseHandler(mistralChatChunkSchema),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            let finishReason = "unknown";
            const usage = {
                inputTokens: void 0,
                outputTokens: void 0,
                totalTokens: void 0
            };
            let isFirstChunk = true;
            let activeText = false;
            let activeReasoningId = null;
            const generateId2 = this.generateId;
            return {
                stream: response.pipeThrough(new TransformStream({
                    start (controller) {
                        controller.enqueue({
                            type: "stream-start",
                            warnings
                        });
                    },
                    transform (chunk, controller) {
                        if (options.includeRawChunks) {
                            controller.enqueue({
                                type: "raw",
                                rawValue: chunk.rawValue
                            });
                        }
                        if (!chunk.success) {
                            controller.enqueue({
                                type: "error",
                                error: chunk.error
                            });
                            return;
                        }
                        const value = chunk.value;
                        if (isFirstChunk) {
                            isFirstChunk = false;
                            controller.enqueue(__spreadValues({
                                type: "response-metadata"
                            }, getResponseMetadata7(value)));
                        }
                        if (value.usage != null) {
                            usage.inputTokens = value.usage.prompt_tokens;
                            usage.outputTokens = value.usage.completion_tokens;
                            usage.totalTokens = value.usage.total_tokens;
                        }
                        const choice = value.choices[0];
                        const delta = choice.delta;
                        const textContent = extractTextContent(delta.content);
                        if (delta.content != null && Array.isArray(delta.content)) {
                            for (const part of delta.content){
                                if (part.type === "thinking") {
                                    const reasoningDelta = extractReasoningContent(part.thinking);
                                    if (reasoningDelta.length > 0) {
                                        if (activeReasoningId == null) {
                                            if (activeText) {
                                                controller.enqueue({
                                                    type: "text-end",
                                                    id: "0"
                                                });
                                                activeText = false;
                                            }
                                            activeReasoningId = generateId2();
                                            controller.enqueue({
                                                type: "reasoning-start",
                                                id: activeReasoningId
                                            });
                                        }
                                        controller.enqueue({
                                            type: "reasoning-delta",
                                            id: activeReasoningId,
                                            delta: reasoningDelta
                                        });
                                    }
                                }
                            }
                        }
                        if (textContent != null && textContent.length > 0) {
                            if (!activeText) {
                                if (activeReasoningId != null) {
                                    controller.enqueue({
                                        type: "reasoning-end",
                                        id: activeReasoningId
                                    });
                                    activeReasoningId = null;
                                }
                                controller.enqueue({
                                    type: "text-start",
                                    id: "0"
                                });
                                activeText = true;
                            }
                            controller.enqueue({
                                type: "text-delta",
                                id: "0",
                                delta: textContent
                            });
                        }
                        if ((delta == null ? void 0 : delta.tool_calls) != null) {
                            for (const toolCall of delta.tool_calls){
                                const toolCallId = toolCall.id;
                                const toolName = toolCall.function.name;
                                const input = toolCall.function.arguments;
                                controller.enqueue({
                                    type: "tool-input-start",
                                    id: toolCallId,
                                    toolName
                                });
                                controller.enqueue({
                                    type: "tool-input-delta",
                                    id: toolCallId,
                                    delta: input
                                });
                                controller.enqueue({
                                    type: "tool-input-end",
                                    id: toolCallId
                                });
                                controller.enqueue({
                                    type: "tool-call",
                                    toolCallId,
                                    toolName,
                                    input
                                });
                            }
                        }
                        if (choice.finish_reason != null) {
                            finishReason = mapMistralFinishReason(choice.finish_reason);
                        }
                    },
                    flush (controller) {
                        if (activeReasoningId != null) {
                            controller.enqueue({
                                type: "reasoning-end",
                                id: activeReasoningId
                            });
                        }
                        if (activeText) {
                            controller.enqueue({
                                type: "text-end",
                                id: "0"
                            });
                        }
                        controller.enqueue({
                            type: "finish",
                            finishReason,
                            usage
                        });
                    }
                })),
                request: {
                    body
                },
                response: {
                    headers: responseHeaders
                }
            };
        });
    }
};
function extractReasoningContent(thinking) {
    return thinking.filter((chunk)=>chunk.type === "text").map((chunk)=>chunk.text).join("");
}
function extractTextContent(content) {
    if (typeof content === "string") {
        return content;
    }
    if (content == null) {
        return void 0;
    }
    const textContent = [];
    for (const chunk of content){
        const { type } = chunk;
        switch(type){
            case "text":
                textContent.push(chunk.text);
                break;
            case "thinking":
            case "image_url":
            case "reference":
                break;
            default:
                {
                    const _exhaustiveCheck = type;
                    throw new Error(`Unsupported type: ${_exhaustiveCheck}`);
                }
        }
    }
    return textContent.length ? textContent.join("") : void 0;
}
var mistralContentSchema = import_v484.z.union([
    import_v484.z.string(),
    import_v484.z.array(import_v484.z.discriminatedUnion("type", [
        import_v484.z.object({
            type: import_v484.z.literal("text"),
            text: import_v484.z.string()
        }),
        import_v484.z.object({
            type: import_v484.z.literal("image_url"),
            image_url: import_v484.z.union([
                import_v484.z.string(),
                import_v484.z.object({
                    url: import_v484.z.string(),
                    detail: import_v484.z.string().nullable()
                })
            ])
        }),
        import_v484.z.object({
            type: import_v484.z.literal("reference"),
            reference_ids: import_v484.z.array(import_v484.z.number())
        }),
        import_v484.z.object({
            type: import_v484.z.literal("thinking"),
            thinking: import_v484.z.array(import_v484.z.object({
                type: import_v484.z.literal("text"),
                text: import_v484.z.string()
            }))
        })
    ]))
]).nullish();
var mistralUsageSchema = import_v484.z.object({
    prompt_tokens: import_v484.z.number(),
    completion_tokens: import_v484.z.number(),
    total_tokens: import_v484.z.number()
});
var mistralChatResponseSchema = import_v484.z.object({
    id: import_v484.z.string().nullish(),
    created: import_v484.z.number().nullish(),
    model: import_v484.z.string().nullish(),
    choices: import_v484.z.array(import_v484.z.object({
        message: import_v484.z.object({
            role: import_v484.z.literal("assistant"),
            content: mistralContentSchema,
            tool_calls: import_v484.z.array(import_v484.z.object({
                id: import_v484.z.string(),
                function: import_v484.z.object({
                    name: import_v484.z.string(),
                    arguments: import_v484.z.string()
                })
            })).nullish()
        }),
        index: import_v484.z.number(),
        finish_reason: import_v484.z.string().nullish()
    })),
    object: import_v484.z.literal("chat.completion"),
    usage: mistralUsageSchema
});
var mistralChatChunkSchema = import_v484.z.object({
    id: import_v484.z.string().nullish(),
    created: import_v484.z.number().nullish(),
    model: import_v484.z.string().nullish(),
    choices: import_v484.z.array(import_v484.z.object({
        delta: import_v484.z.object({
            role: import_v484.z.enum([
                "assistant"
            ]).optional(),
            content: mistralContentSchema,
            tool_calls: import_v484.z.array(import_v484.z.object({
                id: import_v484.z.string(),
                function: import_v484.z.object({
                    name: import_v484.z.string(),
                    arguments: import_v484.z.string()
                })
            })).nullish()
        }),
        finish_reason: import_v484.z.string().nullish(),
        index: import_v484.z.number()
    })),
    usage: mistralUsageSchema.nullish()
});
var MistralEmbeddingModel = class {
    constructor(modelId, config){
        this.specificationVersion = "v2";
        this.maxEmbeddingsPerCall = 32;
        this.supportsParallelCalls = false;
        this.modelId = modelId;
        this.config = config;
    }
    get provider() {
        return this.config.provider;
    }
    doEmbed(_0) {
        return __async(this, arguments, function*({ values, abortSignal, headers }) {
            if (values.length > this.maxEmbeddingsPerCall) {
                throw new import_provider51.TooManyEmbeddingValuesForCallError({
                    provider: this.provider,
                    modelId: this.modelId,
                    maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
                    values
                });
            }
            const { responseHeaders, value: response, rawValue } = yield postJsonToApi({
                url: `${this.config.baseURL}/embeddings`,
                headers: combineHeaders(this.config.headers(), headers),
                body: {
                    model: this.modelId,
                    input: values,
                    encoding_format: "float"
                },
                failedResponseHandler: mistralFailedResponseHandler,
                successfulResponseHandler: createJsonResponseHandler(MistralTextEmbeddingResponseSchema),
                abortSignal,
                fetch: this.config.fetch
            });
            return {
                embeddings: response.data.map((item)=>item.embedding),
                usage: response.usage ? {
                    tokens: response.usage.prompt_tokens
                } : void 0,
                response: {
                    headers: responseHeaders,
                    body: rawValue
                }
            };
        });
    }
};
var MistralTextEmbeddingResponseSchema = import_v487.z.object({
    data: import_v487.z.array(import_v487.z.object({
        embedding: import_v487.z.array(import_v487.z.number())
    })),
    usage: import_v487.z.object({
        prompt_tokens: import_v487.z.number()
    }).nullish()
});
var VERSION10 = ("TURBOPACK compile-time truthy", 1) ? "2.0.19" : "TURBOPACK unreachable";
function createMistral(options = {}) {
    var _a;
    const baseURL = (_a = withoutTrailingSlash(options.baseURL)) != null ? _a : "https://api.mistral.ai/v1";
    const getHeaders = ()=>withUserAgentSuffix(__spreadValues({
            Authorization: `Bearer ${loadApiKey({
                apiKey: options.apiKey,
                environmentVariableName: "MISTRAL_API_KEY",
                description: "Mistral"
            })}`
        }, options.headers), `ai-sdk/mistral/${VERSION10}`);
    const createChatModel = (modelId)=>new MistralChatLanguageModel(modelId, {
            provider: "mistral.chat",
            baseURL,
            headers: getHeaders,
            fetch: options.fetch,
            generateId: options.generateId
        });
    const createEmbeddingModel = (modelId)=>new MistralEmbeddingModel(modelId, {
            provider: "mistral.embedding",
            baseURL,
            headers: getHeaders,
            fetch: options.fetch
        });
    const provider = function(modelId) {
        if (new.target) {
            throw new Error("The Mistral model function cannot be called with the new keyword.");
        }
        return createChatModel(modelId);
    };
    provider.languageModel = createChatModel;
    provider.chat = createChatModel;
    provider.embedding = createEmbeddingModel;
    provider.textEmbedding = createEmbeddingModel;
    provider.textEmbeddingModel = createEmbeddingModel;
    provider.imageModel = (modelId)=>{
        throw new import_provider48.NoSuchModelError({
            modelId,
            modelType: "imageModel"
        });
    };
    return provider;
}
var mistral = createMistral();
// ../../node_modules/.pnpm/@ai-sdk+deepseek@1.0.23_zod@3.25.67/node_modules/@ai-sdk/deepseek/dist/index.mjs
var import_provider52 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v488 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var buildDeepseekMetadata = (usage)=>{
    var _a, _b;
    return usage == null ? void 0 : {
        deepseek: {
            promptCacheHitTokens: (_a = usage.prompt_cache_hit_tokens) != null ? _a : NaN,
            promptCacheMissTokens: (_b = usage.prompt_cache_miss_tokens) != null ? _b : NaN
        }
    };
};
var deepSeekMetadataExtractor = {
    extractMetadata: (_0)=>__async(null, [
            _0
        ], function*({ parsedBody }) {
            const parsed = yield safeValidateTypes({
                value: parsedBody,
                schema: deepSeekResponseSchema
            });
            return !parsed.success || parsed.value.usage == null ? void 0 : buildDeepseekMetadata(parsed.value.usage);
        }),
    createStreamExtractor: ()=>{
        let usage;
        return {
            processChunk: (chunk)=>__async(null, null, function*() {
                    var _a, _b;
                    const parsed = yield safeValidateTypes({
                        value: chunk,
                        schema: deepSeekStreamChunkSchema
                    });
                    if (parsed.success && ((_b = (_a = parsed.value.choices) == null ? void 0 : _a[0]) == null ? void 0 : _b.finish_reason) === "stop" && parsed.value.usage) {
                        usage = parsed.value.usage;
                    }
                }),
            buildMetadata: ()=>buildDeepseekMetadata(usage)
        };
    }
};
var deepSeekUsageSchema = import_v488.z.object({
    prompt_cache_hit_tokens: import_v488.z.number().nullish(),
    prompt_cache_miss_tokens: import_v488.z.number().nullish()
});
var deepSeekResponseSchema = import_v488.z.object({
    usage: deepSeekUsageSchema.nullish()
});
var deepSeekStreamChunkSchema = import_v488.z.object({
    choices: import_v488.z.array(import_v488.z.object({
        finish_reason: import_v488.z.string().nullish()
    })).nullish(),
    usage: deepSeekUsageSchema.nullish()
});
var VERSION11 = ("TURBOPACK compile-time truthy", 1) ? "1.0.23" : "TURBOPACK unreachable";
function createDeepSeek(options = {}) {
    var _a;
    const baseURL = withoutTrailingSlash((_a = options.baseURL) != null ? _a : "https://api.deepseek.com/v1");
    const getHeaders = ()=>withUserAgentSuffix(__spreadValues({
            Authorization: `Bearer ${loadApiKey({
                apiKey: options.apiKey,
                environmentVariableName: "DEEPSEEK_API_KEY",
                description: "DeepSeek API key"
            })}`
        }, options.headers), `ai-sdk/deepseek/${VERSION11}`);
    const createLanguageModel = (modelId)=>{
        return new OpenAICompatibleChatLanguageModel(modelId, {
            provider: `deepseek.chat`,
            url: ({ path: path7 })=>`${baseURL}${path7}`,
            headers: getHeaders,
            fetch: options.fetch,
            metadataExtractor: deepSeekMetadataExtractor
        });
    };
    const provider = (modelId)=>createLanguageModel(modelId);
    provider.languageModel = createLanguageModel;
    provider.chat = createLanguageModel;
    provider.textEmbeddingModel = (modelId)=>{
        throw new import_provider52.NoSuchModelError({
            modelId,
            modelType: "textEmbeddingModel"
        });
    };
    provider.imageModel = (modelId)=>{
        throw new import_provider52.NoSuchModelError({
            modelId,
            modelType: "imageModel"
        });
    };
    return provider;
}
var deepseek = createDeepSeek();
// ../../node_modules/.pnpm/@ai-sdk+perplexity@2.0.13_zod@3.25.67/node_modules/@ai-sdk/perplexity/dist/index.mjs
var import_provider53 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v489 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_provider54 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
function convertToPerplexityMessages(prompt) {
    const messages = [];
    for (const { role, content } of prompt){
        switch(role){
            case "system":
                {
                    messages.push({
                        role: "system",
                        content
                    });
                    break;
                }
            case "user":
            case "assistant":
                {
                    const hasImage = content.some((part)=>part.type === "file" && part.mediaType.startsWith("image/"));
                    const messageContent = content.map((part)=>{
                        var _a;
                        switch(part.type){
                            case "text":
                                {
                                    return {
                                        type: "text",
                                        text: part.text
                                    };
                                }
                            case "file":
                                {
                                    return part.data instanceof URL ? {
                                        type: "image_url",
                                        image_url: {
                                            url: part.data.toString()
                                        }
                                    } : {
                                        type: "image_url",
                                        image_url: {
                                            url: `data:${(_a = part.mediaType) != null ? _a : "image/jpeg"};base64,${typeof part.data === "string" ? part.data : convertUint8ArrayToBase64(part.data)}`
                                        }
                                    };
                                }
                        }
                    }).filter(Boolean);
                    messages.push({
                        role,
                        content: hasImage ? messageContent : messageContent.filter((part)=>part.type === "text").map((part)=>part.text).join("")
                    });
                    break;
                }
            case "tool":
                {
                    throw new import_provider54.UnsupportedFunctionalityError({
                        functionality: "Tool messages"
                    });
                }
            default:
                {
                    const _exhaustiveCheck = role;
                    throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
                }
        }
    }
    return messages;
}
function mapPerplexityFinishReason(finishReason) {
    switch(finishReason){
        case "stop":
        case "length":
            return finishReason;
        default:
            return "unknown";
    }
}
var PerplexityLanguageModel = class {
    constructor(modelId, config){
        this.specificationVersion = "v2";
        this.provider = "perplexity";
        this.supportedUrls = {
        };
        this.modelId = modelId;
        this.config = config;
    }
    getArgs({ prompt, maxOutputTokens, temperature, topP, topK, frequencyPenalty, presencePenalty, stopSequences, responseFormat, seed, providerOptions }) {
        var _a;
        const warnings = [];
        if (topK != null) {
            warnings.push({
                type: "unsupported-setting",
                setting: "topK"
            });
        }
        if (stopSequences != null) {
            warnings.push({
                type: "unsupported-setting",
                setting: "stopSequences"
            });
        }
        if (seed != null) {
            warnings.push({
                type: "unsupported-setting",
                setting: "seed"
            });
        }
        return {
            args: __spreadProps(__spreadValues({
                // model id:
                model: this.modelId,
                // standardized settings:
                frequency_penalty: frequencyPenalty,
                max_tokens: maxOutputTokens,
                presence_penalty: presencePenalty,
                temperature,
                top_k: topK,
                top_p: topP,
                // response format:
                response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? {
                    type: "json_schema",
                    json_schema: {
                        schema: responseFormat.schema
                    }
                } : void 0
            }, (_a = providerOptions == null ? void 0 : providerOptions.perplexity) != null ? _a : {}), {
                // messages:
                messages: convertToPerplexityMessages(prompt)
            }),
            warnings
        };
    }
    doGenerate(options) {
        return __async(this, null, function*() {
            var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
            const { args: body, warnings } = this.getArgs(options);
            const { responseHeaders, value: response, rawValue: rawResponse } = yield postJsonToApi({
                url: `${this.config.baseURL}/chat/completions`,
                headers: combineHeaders(this.config.headers(), options.headers),
                body,
                failedResponseHandler: createJsonErrorResponseHandler({
                    errorSchema: perplexityErrorSchema,
                    errorToMessage
                }),
                successfulResponseHandler: createJsonResponseHandler(perplexityResponseSchema),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            const choice = response.choices[0];
            const content = [];
            const text = choice.message.content;
            if (text.length > 0) {
                content.push({
                    type: "text",
                    text
                });
            }
            if (response.citations != null) {
                for (const url of response.citations){
                    content.push({
                        type: "source",
                        sourceType: "url",
                        id: this.config.generateId(),
                        url
                    });
                }
            }
            return {
                content,
                finishReason: mapPerplexityFinishReason(choice.finish_reason),
                usage: {
                    inputTokens: (_a = response.usage) == null ? void 0 : _a.prompt_tokens,
                    outputTokens: (_b = response.usage) == null ? void 0 : _b.completion_tokens,
                    totalTokens: (_d = (_c = response.usage) == null ? void 0 : _c.total_tokens) != null ? _d : void 0
                },
                request: {
                    body
                },
                response: __spreadProps(__spreadValues({}, getResponseMetadata8(response)), {
                    headers: responseHeaders,
                    body: rawResponse
                }),
                warnings,
                providerMetadata: {
                    perplexity: {
                        images: (_f = (_e = response.images) == null ? void 0 : _e.map((image)=>({
                                imageUrl: image.image_url,
                                originUrl: image.origin_url,
                                height: image.height,
                                width: image.width
                            }))) != null ? _f : null,
                        usage: {
                            citationTokens: (_h = (_g = response.usage) == null ? void 0 : _g.citation_tokens) != null ? _h : null,
                            numSearchQueries: (_j = (_i = response.usage) == null ? void 0 : _i.num_search_queries) != null ? _j : null
                        }
                    }
                }
            };
        });
    }
    doStream(options) {
        return __async(this, null, function*() {
            const { args, warnings } = this.getArgs(options);
            const body = __spreadProps(__spreadValues({}, args), {
                stream: true
            });
            const { responseHeaders, value: response } = yield postJsonToApi({
                url: `${this.config.baseURL}/chat/completions`,
                headers: combineHeaders(this.config.headers(), options.headers),
                body,
                failedResponseHandler: createJsonErrorResponseHandler({
                    errorSchema: perplexityErrorSchema,
                    errorToMessage
                }),
                successfulResponseHandler: createEventSourceResponseHandler(perplexityChunkSchema),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            let finishReason = "unknown";
            const usage = {
                inputTokens: void 0,
                outputTokens: void 0,
                totalTokens: void 0
            };
            const providerMetadata = {
                perplexity: {
                    usage: {
                        citationTokens: null,
                        numSearchQueries: null
                    },
                    images: null
                }
            };
            let isFirstChunk = true;
            let isActive = false;
            const self = this;
            return {
                stream: response.pipeThrough(new TransformStream({
                    start (controller) {
                        controller.enqueue({
                            type: "stream-start",
                            warnings
                        });
                    },
                    transform (chunk, controller) {
                        var _a, _b, _c;
                        if (options.includeRawChunks) {
                            controller.enqueue({
                                type: "raw",
                                rawValue: chunk.rawValue
                            });
                        }
                        if (!chunk.success) {
                            controller.enqueue({
                                type: "error",
                                error: chunk.error
                            });
                            return;
                        }
                        const value = chunk.value;
                        if (isFirstChunk) {
                            controller.enqueue(__spreadValues({
                                type: "response-metadata"
                            }, getResponseMetadata8(value)));
                            (_a = value.citations) == null ? void 0 : _a.forEach((url)=>{
                                controller.enqueue({
                                    type: "source",
                                    sourceType: "url",
                                    id: self.config.generateId(),
                                    url
                                });
                            });
                            isFirstChunk = false;
                        }
                        if (value.usage != null) {
                            usage.inputTokens = value.usage.prompt_tokens;
                            usage.outputTokens = value.usage.completion_tokens;
                            providerMetadata.perplexity.usage = {
                                citationTokens: (_b = value.usage.citation_tokens) != null ? _b : null,
                                numSearchQueries: (_c = value.usage.num_search_queries) != null ? _c : null
                            };
                        }
                        if (value.images != null) {
                            providerMetadata.perplexity.images = value.images.map((image)=>({
                                    imageUrl: image.image_url,
                                    originUrl: image.origin_url,
                                    height: image.height,
                                    width: image.width
                                }));
                        }
                        const choice = value.choices[0];
                        if ((choice == null ? void 0 : choice.finish_reason) != null) {
                            finishReason = mapPerplexityFinishReason(choice.finish_reason);
                        }
                        if ((choice == null ? void 0 : choice.delta) == null) {
                            return;
                        }
                        const delta = choice.delta;
                        const textContent = delta.content;
                        if (textContent != null) {
                            if (!isActive) {
                                controller.enqueue({
                                    type: "text-start",
                                    id: "0"
                                });
                                isActive = true;
                            }
                            controller.enqueue({
                                type: "text-delta",
                                id: "0",
                                delta: textContent
                            });
                        }
                    },
                    flush (controller) {
                        if (isActive) {
                            controller.enqueue({
                                type: "text-end",
                                id: "0"
                            });
                        }
                        controller.enqueue({
                            type: "finish",
                            finishReason,
                            usage,
                            providerMetadata
                        });
                    }
                })),
                request: {
                    body
                },
                response: {
                    headers: responseHeaders
                }
            };
        });
    }
};
function getResponseMetadata8({ id, model, created }) {
    return {
        id,
        modelId: model,
        timestamp: new Date(created * 1e3)
    };
}
var perplexityUsageSchema = import_v489.z.object({
    prompt_tokens: import_v489.z.number(),
    completion_tokens: import_v489.z.number(),
    total_tokens: import_v489.z.number().nullish(),
    citation_tokens: import_v489.z.number().nullish(),
    num_search_queries: import_v489.z.number().nullish()
});
var perplexityImageSchema = import_v489.z.object({
    image_url: import_v489.z.string(),
    origin_url: import_v489.z.string(),
    height: import_v489.z.number(),
    width: import_v489.z.number()
});
var perplexityResponseSchema = import_v489.z.object({
    id: import_v489.z.string(),
    created: import_v489.z.number(),
    model: import_v489.z.string(),
    choices: import_v489.z.array(import_v489.z.object({
        message: import_v489.z.object({
            role: import_v489.z.literal("assistant"),
            content: import_v489.z.string()
        }),
        finish_reason: import_v489.z.string().nullish()
    })),
    citations: import_v489.z.array(import_v489.z.string()).nullish(),
    images: import_v489.z.array(perplexityImageSchema).nullish(),
    usage: perplexityUsageSchema.nullish()
});
var perplexityChunkSchema = import_v489.z.object({
    id: import_v489.z.string(),
    created: import_v489.z.number(),
    model: import_v489.z.string(),
    choices: import_v489.z.array(import_v489.z.object({
        delta: import_v489.z.object({
            role: import_v489.z.literal("assistant"),
            content: import_v489.z.string()
        }),
        finish_reason: import_v489.z.string().nullish()
    })),
    citations: import_v489.z.array(import_v489.z.string()).nullish(),
    images: import_v489.z.array(perplexityImageSchema).nullish(),
    usage: perplexityUsageSchema.nullish()
});
var perplexityErrorSchema = import_v489.z.object({
    error: import_v489.z.object({
        code: import_v489.z.number(),
        message: import_v489.z.string().nullish(),
        type: import_v489.z.string().nullish()
    })
});
var errorToMessage = (data)=>{
    var _a, _b;
    return (_b = (_a = data.error.message) != null ? _a : data.error.type) != null ? _b : "unknown error";
};
var VERSION12 = ("TURBOPACK compile-time truthy", 1) ? "2.0.13" : "TURBOPACK unreachable";
function createPerplexity(options = {}) {
    const getHeaders = ()=>withUserAgentSuffix(__spreadValues({
            Authorization: `Bearer ${loadApiKey({
                apiKey: options.apiKey,
                environmentVariableName: "PERPLEXITY_API_KEY",
                description: "Perplexity"
            })}`
        }, options.headers), `ai-sdk/perplexity/${VERSION12}`);
    const createLanguageModel = (modelId)=>{
        var _a;
        return new PerplexityLanguageModel(modelId, {
            baseURL: withoutTrailingSlash((_a = options.baseURL) != null ? _a : "https://api.perplexity.ai"),
            headers: getHeaders,
            generateId,
            fetch: options.fetch
        });
    };
    const provider = (modelId)=>createLanguageModel(modelId);
    provider.languageModel = createLanguageModel;
    provider.textEmbeddingModel = (modelId)=>{
        throw new import_provider53.NoSuchModelError({
            modelId,
            modelType: "textEmbeddingModel"
        });
    };
    provider.imageModel = (modelId)=>{
        throw new import_provider53.NoSuchModelError({
            modelId,
            modelType: "imageModel"
        });
    };
    return provider;
}
var perplexity = createPerplexity();
// ../../node_modules/.pnpm/ollama-ai-provider-v2@1.5.0_zod@3.25.67/node_modules/ollama-ai-provider-v2/dist/index.mjs
var import_provider55 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v490 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v491 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_provider56 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_provider57 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v492 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_provider58 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_provider59 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var import_v493 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_v494 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/v4/index.js [app-route] (ecmascript)");
var import_provider60 = __turbopack_context__.r("[project]/node_modules/@ai-sdk/provider/dist/index.js [app-route] (ecmascript)");
var ollamaErrorDataSchema = import_v491.z.object({
    error: import_v491.z.object({
        message: import_v491.z.string(),
        // The additional information below is handled loosely to support
        // Ollama-compatible providers that have slightly different error
        // responses:
        type: import_v491.z.string().nullish(),
        param: import_v491.z.any().nullish(),
        code: import_v491.z.union([
            import_v491.z.string(),
            import_v491.z.number()
        ]).nullish()
    })
});
var ollamaFailedResponseHandler = createJsonErrorResponseHandler({
    errorSchema: ollamaErrorDataSchema,
    errorToMessage: (data)=>data.error.message
});
function convertToOllamaCompletionPrompt({ prompt, user = "user", assistant = "assistant" }) {
    let text = "";
    if (prompt[0].role === "system") {
        text += `${prompt[0].content}

`;
        prompt = prompt.slice(1);
    }
    for (const { role, content } of prompt){
        switch(role){
            case "system":
                {
                    throw new import_provider56.InvalidPromptError({
                        message: "Unexpected system message in prompt: ${content}",
                        prompt
                    });
                }
            case "user":
                {
                    const userMessage = content.map((part)=>{
                        switch(part.type){
                            case "text":
                                {
                                    return part.text;
                                }
                        }
                    }).filter(Boolean).join("");
                    text += `${user}:
${userMessage}

`;
                    break;
                }
            case "assistant":
                {
                    const assistantMessage = content.map((part)=>{
                        switch(part.type){
                            case "text":
                                {
                                    return part.text;
                                }
                            case "tool-call":
                                {
                                    throw new import_provider56.UnsupportedFunctionalityError({
                                        functionality: "tool-call messages"
                                    });
                                }
                        }
                    }).join("");
                    text += `${assistant}:
${assistantMessage}

`;
                    break;
                }
            case "tool":
                {
                    throw new import_provider56.UnsupportedFunctionalityError({
                        functionality: "tool messages"
                    });
                }
            default:
                {
                    const _exhaustiveCheck = role;
                    throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
                }
        }
    }
    text += `${assistant}:
`;
    return {
        prompt: text,
        stopSequences: [
            `
${user}:`
        ]
    };
}
function mapOllamaFinishReason(finishReason) {
    switch(finishReason){
        case "stop":
            return "stop";
        case "length":
            return "length";
        case "content_filter":
            return "content-filter";
        case "function_call":
        case "tool_calls":
            return "tool-calls";
        default:
            return "unknown";
    }
}
function getResponseMetadata9({ model, created_at }) {
    return {
        id: void 0,
        modelId: model != null ? model : void 0,
        timestamp: created_at != null ? new Date(created_at) : void 0
    };
}
var ollamaCompletionProviderOptions = import_v490.z.object({
    think: import_v490.z.boolean().optional(),
    user: import_v490.z.string().optional(),
    suffix: import_v490.z.string().optional(),
    echo: import_v490.z.boolean().optional()
});
var OllamaCompletionLanguageModel = class {
    constructor(modelId, settings, config){
        this.specificationVersion = "v2";
        this.supportedUrls = {
        };
        this.modelId = modelId;
        this.settings = settings;
        this.config = config;
    }
    get provider() {
        return this.config.provider;
    }
    getArgs(_0) {
        return __async(this, arguments, function*({ prompt, maxOutputTokens, temperature, topP, topK, frequencyPenalty, presencePenalty, stopSequences: userStopSequences, responseFormat, tools, toolChoice, seed, providerOptions }) {
            var _a;
            const warnings = [];
            const ollamaOptions = (_a = yield parseProviderOptions({
                provider: "ollama",
                providerOptions,
                schema: ollamaCompletionProviderOptions
            })) != null ? _a : {};
            if (topK != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "topK"
                });
            }
            if (tools == null ? void 0 : tools.length) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "tools"
                });
            }
            if (toolChoice != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "toolChoice"
                });
            }
            if (responseFormat != null && responseFormat.type !== "text") {
                warnings.push({
                    type: "unsupported-setting",
                    setting: "responseFormat",
                    details: "JSON response format is not supported."
                });
            }
            const { prompt: completionPrompt, stopSequences } = convertToOllamaCompletionPrompt({
                prompt
            });
            const stop2 = [
                ...stopSequences != null ? stopSequences : [],
                ...userStopSequences != null ? userStopSequences : []
            ];
            return {
                args: {
                    // model id:
                    model: this.modelId,
                    // Ollama-supported settings:
                    user: ollamaOptions.user,
                    think: ollamaOptions.think,
                    // standardized settings:
                    max_tokens: maxOutputTokens,
                    temperature,
                    top_p: topP,
                    frequency_penalty: frequencyPenalty,
                    presence_penalty: presencePenalty,
                    stop: stop2,
                    // prompt:
                    prompt: completionPrompt,
                    // other settings:
                    suffix: ollamaOptions.suffix,
                    echo: ollamaOptions.echo,
                    stream: false
                },
                warnings
            };
        });
    }
    doGenerate(options) {
        return __async(this, null, function*() {
            var _a, _b, _c, _d;
            const { args: body, warnings } = yield this.getArgs(options);
            const { responseHeaders, value: response, rawValue: rawResponse } = yield postJsonToApi({
                url: this.config.url({
                    path: "/generate",
                    modelId: this.modelId
                }),
                headers: combineHeaders(this.config.headers(), options.headers),
                body: __spreadProps(__spreadValues({}, body), {
                    stream: false
                }),
                failedResponseHandler: ollamaFailedResponseHandler,
                successfulResponseHandler: createJsonResponseHandler(baseOllamaResponseSchema),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            const _a2 = body, { prompt: rawPrompt } = _a2, rawSettings = __objRest(_a2, [
                "prompt"
            ]);
            const providerMetadata = {
                ollama: {}
            };
            return {
                content: [
                    {
                        type: "text",
                        text: response.response
                    }
                ],
                usage: {
                    inputTokens: (_a = response.prompt_eval_count) != null ? _a : void 0,
                    outputTokens: (_b = response.eval_count) != null ? _b : void 0,
                    totalTokens: ((_c = response.prompt_eval_count) != null ? _c : 0) + ((_d = response.eval_count) != null ? _d : 0)
                },
                finishReason: mapOllamaFinishReason("stop"),
                request: {
                    body: JSON.stringify(body)
                },
                response: __spreadProps(__spreadValues({}, getResponseMetadata9(response)), {
                    headers: responseHeaders,
                    body: rawResponse
                }),
                warnings,
                providerMetadata
            };
        });
    }
    doStream(options) {
        return __async(this, null, function*() {
            const { args, warnings } = yield this.getArgs(options);
            const body = __spreadProps(__spreadValues({}, args), {
                stream: true
            });
            const { responseHeaders, value: response } = yield postJsonToApi({
                url: this.config.url({
                    path: "/generate",
                    modelId: this.modelId
                }),
                headers: combineHeaders(this.config.headers(), options.headers),
                body,
                failedResponseHandler: ollamaFailedResponseHandler,
                successfulResponseHandler: createJsonStreamResponseHandler(baseOllamaResponseSchema),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            const _a = args, { prompt: rawPrompt } = _a, rawSettings = __objRest(_a, [
                "prompt"
            ]);
            let finishReason = "unknown";
            let usage = {
                inputTokens: void 0,
                outputTokens: void 0,
                totalTokens: void 0
            };
            let isFirstChunk = true;
            return {
                stream: response.pipeThrough(new TransformStream({
                    transform (chunk, controller) {
                        if (!chunk.success) {
                            finishReason = "error";
                            controller.enqueue({
                                type: "error",
                                error: chunk.error
                            });
                            return;
                        }
                        const value = chunk.value;
                        if ("error" in value) {
                            finishReason = "error";
                            controller.enqueue({
                                type: "error",
                                error: value.error
                            });
                            return;
                        }
                        if (isFirstChunk) {
                            isFirstChunk = false;
                            controller.enqueue(__spreadValues({
                                type: "response-metadata"
                            }, getResponseMetadata9(value)));
                        }
                        if (value.done) {
                            finishReason = mapOllamaFinishReason("stop");
                        }
                        if (value.response != null) {
                            controller.enqueue({
                                type: "text-delta",
                                id: "0",
                                delta: value.response
                            });
                        }
                    },
                    flush (controller) {
                        controller.enqueue({
                            type: "finish",
                            finishReason,
                            usage
                        });
                    }
                })),
                request: {
                    body: JSON.stringify(body)
                },
                response: {
                    headers: responseHeaders
                }
            };
        });
    }
};
var baseOllamaResponseSchema = import_v490.z.object({
    model: import_v490.z.string(),
    created_at: import_v490.z.string(),
    response: import_v490.z.string(),
    done: import_v490.z.boolean(),
    context: import_v490.z.array(import_v490.z.number()),
    eval_count: import_v490.z.number().optional(),
    eval_duration: import_v490.z.number().optional(),
    load_duration: import_v490.z.number().optional(),
    total_duration: import_v490.z.number().optional(),
    prompt_eval_count: import_v490.z.number().optional(),
    prompt_eval_duration: import_v490.z.number().optional()
});
var ollamaEmbeddingProviderOptions = import_v492.z.object({
    dimensions: import_v492.z.number().optional(),
    truncate: import_v492.z.boolean().optional(),
    keepAlive: import_v492.z.string().optional()
});
var OllamaEmbeddingModel = class {
    constructor(modelId, settings, config){
        this.specificationVersion = "v2";
        this.modelId = modelId;
        this.settings = settings;
        this.config = config;
    }
    get provider() {
        return this.config.provider;
    }
    get maxEmbeddingsPerCall() {
        var _a;
        return (_a = this.settings.maxEmbeddingsPerCall) != null ? _a : 2048;
    }
    get supportsParallelCalls() {
        var _a;
        return (_a = this.settings.supportsParallelCalls) != null ? _a : true;
    }
    getArgs(_0) {
        return __async(this, arguments, function*({ values, providerOptions }) {
            var _a, _b;
            const ollamaOptions = (_a = yield parseProviderOptions({
                provider: "ollama",
                providerOptions,
                schema: ollamaEmbeddingProviderOptions
            })) != null ? _a : {};
            return {
                args: {
                    // model id:
                    model: this.modelId,
                    input: values,
                    // advanced parameters:
                    dimensions: (_b = ollamaOptions.dimensions) != null ? _b : this.settings.dimensions,
                    truncate: ollamaOptions.truncate,
                    keep_alive: ollamaOptions.keepAlive
                }
            };
        });
    }
    doEmbed(_0) {
        return __async(this, arguments, function*({ values, headers, abortSignal, providerOptions }) {
            if (values.length > this.maxEmbeddingsPerCall) {
                throw new import_provider57.TooManyEmbeddingValuesForCallError({
                    provider: this.provider,
                    modelId: this.modelId,
                    maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
                    values
                });
            }
            const { args: body } = yield this.getArgs({
                values,
                providerOptions
            });
            const { responseHeaders, value: response, rawValue } = yield postJsonToApi({
                url: this.config.url({
                    path: "/embed",
                    modelId: this.modelId
                }),
                headers: combineHeaders(this.config.headers(), headers),
                body: __spreadValues({}, body),
                failedResponseHandler: ollamaFailedResponseHandler,
                successfulResponseHandler: createJsonResponseHandler(ollamaTextEmbeddingResponseSchema),
                abortSignal,
                fetch: this.config.fetch
            });
            return {
                embeddings: response.embeddings.map((item)=>item),
                usage: {
                    tokens: response.prompt_eval_count
                },
                response: {
                    headers: responseHeaders,
                    body: rawValue
                }
            };
        });
    }
};
var ollamaTextEmbeddingResponseSchema = import_v492.z.object({
    model: import_v492.z.string(),
    embeddings: import_v492.z.array(import_v492.z.array(import_v492.z.number())),
    total_duration: import_v492.z.number(),
    load_duration: import_v492.z.number(),
    prompt_eval_count: import_v492.z.number()
});
function convertToOllamaResponsesMessages({ prompt, systemMessageMode }) {
    const messages = [];
    const warnings = [];
    for (const { role, content } of prompt){
        switch(role){
            case "system":
                {
                    switch(systemMessageMode){
                        case "system":
                            {
                                messages.push({
                                    role: "system",
                                    content
                                });
                                break;
                            }
                        case "developer":
                            {
                                messages.push({
                                    role: "developer",
                                    content
                                });
                                break;
                            }
                        case "remove":
                            {
                                warnings.push({
                                    type: "other",
                                    message: "system messages are removed for this model"
                                });
                                break;
                            }
                        default:
                            {
                                const _exhaustiveCheck = systemMessageMode;
                                throw new Error(`Unsupported system message mode: ${_exhaustiveCheck}`);
                            }
                    }
                    break;
                }
            case "user":
                {
                    messages.push({
                        role: "user",
                        content: content.map((part, index)=>{
                            var _a, _b, _c;
                            switch(part.type){
                                case "text":
                                    {
                                        return {
                                            type: "input_text",
                                            text: part.text
                                        };
                                    }
                                case "file":
                                    {
                                        if (part.mediaType.startsWith("image/")) {
                                            const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                                            return {
                                                type: "input_image",
                                                image_url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${part.data}`,
                                                // Ollama specific extension: image detail
                                                detail: (_b = (_a = part.providerOptions) == null ? void 0 : _a.ollama) == null ? void 0 : _b.imageDetail
                                            };
                                        } else if (part.mediaType === "application/pdf") {
                                            if (part.data instanceof URL) {
                                                throw new import_provider58.UnsupportedFunctionalityError({
                                                    functionality: "PDF file parts with URLs"
                                                });
                                            }
                                            return {
                                                type: "input_file",
                                                filename: (_c = part.filename) != null ? _c : `part-${index}.pdf`,
                                                file_data: `data:application/pdf;base64,${part.data}`
                                            };
                                        } else {
                                            throw new import_provider58.UnsupportedFunctionalityError({
                                                functionality: `file part media type ${part.mediaType}`
                                            });
                                        }
                                    }
                            }
                        })
                    });
                    break;
                }
            case "assistant":
                {
                    for (const part of content){
                        switch(part.type){
                            case "text":
                                {
                                    messages.push({
                                        role: "assistant",
                                        content: [
                                            {
                                                type: "output_text",
                                                text: part.text
                                            }
                                        ]
                                    });
                                    break;
                                }
                            case "tool-call":
                                {
                                    if (part.providerExecuted) {
                                        break;
                                    }
                                    messages.push({
                                        type: "function_call",
                                        call_id: part.toolCallId,
                                        name: part.toolName,
                                        arguments: JSON.stringify(part.input)
                                    });
                                    break;
                                }
                            case "tool-result":
                                {
                                    warnings.push({
                                        type: "other",
                                        message: `tool result parts in assistant messages are not supported for Ollama responses`
                                    });
                                    break;
                                }
                        }
                    }
                    break;
                }
            case "tool":
                {
                    for (const part of content){
                        const output = part.output;
                        let contentValue;
                        switch(output.type){
                            case "text":
                            case "error-text":
                                contentValue = output.value;
                                break;
                            case "content":
                            case "json":
                            case "error-json":
                                contentValue = JSON.stringify(output.value);
                                break;
                        }
                        messages.push({
                            type: "function_call_output",
                            call_id: part.toolCallId,
                            output: contentValue
                        });
                    }
                    break;
                }
            default:
                {
                    const _exhaustiveCheck = role;
                    throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
                }
        }
    }
    return {
        messages,
        warnings
    };
}
function convertToOllamaChatMessages({ prompt, systemMessageMode = "system" }) {
    const messages = [];
    for (const { role, content } of prompt){
        switch(role){
            case "system":
                {
                    switch(systemMessageMode){
                        case "system":
                            {
                                messages.push({
                                    role: "system",
                                    content
                                });
                                break;
                            }
                        case "developer":
                            {
                                messages.push({
                                    role: "developer",
                                    content
                                });
                                break;
                            }
                        case "remove":
                            {
                                break;
                            }
                        default:
                            {
                                const _exhaustiveCheck = systemMessageMode;
                                throw new Error(`Unsupported system message mode: ${_exhaustiveCheck}`);
                            }
                    }
                    break;
                }
            case "user":
                {
                    if (content.length === 1 && content[0].type === "text") {
                        messages.push({
                            role: "user",
                            content: content[0].text
                        });
                        break;
                    }
                    const userText = content.filter((part)=>part.type === "text").map((part)=>part.text).join("");
                    const images = content.filter((part)=>part.type === "file" && part.mediaType.startsWith("image/")).map((part)=>part.data);
                    messages.push({
                        role: "user",
                        content: userText.length > 0 ? userText : [],
                        images: images.length > 0 ? images : void 0
                    });
                    break;
                }
            case "assistant":
                {
                    let text = "";
                    let thinking = "";
                    const toolCalls = [];
                    for (const part of content){
                        switch(part.type){
                            case "text":
                                {
                                    text += part.text;
                                    break;
                                }
                            case "tool-call":
                                {
                                    toolCalls.push({
                                        id: part.toolCallId,
                                        type: "function",
                                        function: {
                                            name: part.toolName,
                                            arguments: part.input
                                        }
                                    });
                                    break;
                                }
                            case "reasoning":
                                {
                                    thinking += part.text;
                                    break;
                                }
                            default:
                                {
                                    throw new Error(`Unsupported part: ${part}`);
                                }
                        }
                    }
                    messages.push(__spreadProps(__spreadValues({
                        role: "assistant",
                        content: text
                    }, thinking && {
                        thinking
                    }), {
                        tool_calls: toolCalls.length > 0 ? toolCalls : void 0
                    }));
                    break;
                }
            case "tool":
                {
                    for (const toolResponse of content){
                        const output = toolResponse.output;
                        let contentValue;
                        switch(output.type){
                            case "text":
                            case "error-text":
                                contentValue = output.value;
                                break;
                            case "content":
                            case "json":
                            case "error-json":
                                contentValue = JSON.stringify(output.value);
                                break;
                        }
                        messages.push({
                            role: "tool",
                            tool_call_id: toolResponse.toolCallId,
                            content: contentValue
                        });
                    }
                    break;
                }
            default:
                {
                    const _exhaustiveCheck = role;
                    throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
                }
        }
    }
    return messages;
}
function prepareResponsesTools3({ tools, toolChoice }) {
    tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
    const toolWarnings = [];
    if (tools == null) {
        return {
            tools: void 0,
            toolChoice: void 0,
            toolWarnings
        };
    }
    const ollamaTools = [];
    for (const tool12 of tools){
        switch(tool12.type){
            case "function":
                {
                    let parameters = tool12.inputSchema;
                    if (!parameters) {
                        parameters = {
                            type: "object",
                            properties: {},
                            required: []
                        };
                    } else if (parameters && typeof parameters === "object" && parameters.type === "object" && parameters.properties && Object.keys(parameters.properties).length === 0) {
                        parameters = __spreadProps(__spreadValues({}, parameters), {
                            properties: {},
                            required: []
                        });
                    }
                    ollamaTools.push({
                        type: "function",
                        function: {
                            name: tool12.name,
                            description: tool12.description,
                            parameters
                        }
                    });
                    break;
                }
            default:
                toolWarnings.push({
                    type: "unsupported-tool",
                    tool: tool12
                });
                break;
        }
    }
    if (toolChoice == null) {
        return {
            tools: ollamaTools,
            toolChoice: void 0,
            toolWarnings
        };
    }
    const type = toolChoice.type;
    switch(type){
        case "auto":
        case "none":
        case "required":
            return {
                tools: ollamaTools,
                toolChoice: type,
                toolWarnings
            };
        case "tool":
            return {
                tools: ollamaTools,
                toolChoice: toolChoice.toolName == "web_search_preview" ? {
                    type: "web_search_preview"
                } : {
                    type: "function",
                    name: toolChoice.toolName
                },
                toolWarnings
            };
        default:
            {
                const _exhaustiveCheck = type;
                throw new import_provider59.UnsupportedFunctionalityError({
                    functionality: `tool choice type: ${_exhaustiveCheck}`
                });
            }
    }
}
var ollamaProviderOptions = import_v493.z.object({
    /**
   * Enable or disable the model's thinking process. When enabled, the output will separate
   * the model's thinking from the model's output. When disabled, the model will not think
   * and directly output the content.
   *
   * Only supported by certain models like DeepSeek R1 and Qwen 3.
   */ think: import_v493.z.boolean().optional(),
    options: import_v493.z.object({
        num_ctx: import_v493.z.number().optional(),
        repeat_last_n: import_v493.z.number().optional(),
        repeat_penalty: import_v493.z.number().optional(),
        temperature: import_v493.z.number().optional(),
        seed: import_v493.z.number().optional(),
        stop: import_v493.z.array(import_v493.z.string()).optional(),
        num_predict: import_v493.z.number().optional(),
        top_k: import_v493.z.number().optional(),
        top_p: import_v493.z.number().optional(),
        min_p: import_v493.z.number().optional()
    }).optional()
});
var OllamaRequestBuilder = class {
    buildRequest(_0) {
        return __async(this, arguments, function*({ modelId, maxOutputTokens, temperature, stopSequences, topP, topK, presencePenalty, frequencyPenalty, seed, prompt, providerOptions, tools, toolChoice, responseFormat }) {
            const warnings = this.collectUnsupportedSettingsWarnings({
                topK,
                seed,
                presencePenalty,
                frequencyPenalty,
                stopSequences
            });
            const { messages, warnings: messageWarnings } = convertToOllamaResponsesMessages({
                prompt,
                systemMessageMode: "system"
            });
            warnings.push(...messageWarnings);
            const ollamaOptions = yield this.parseProviderOptions(providerOptions);
            const baseArgs = this.buildBaseArgs({
                modelId,
                prompt,
                temperature,
                topP,
                maxOutputTokens,
                responseFormat,
                ollamaOptions
            });
            const { tools: ollamaTools, toolChoice: ollamaToolChoice, toolWarnings } = prepareResponsesTools3({
                tools,
                toolChoice
            });
            return {
                args: __spreadProps(__spreadValues({}, baseArgs), {
                    tools: ollamaTools,
                    tool_choice: ollamaToolChoice
                }),
                warnings: [
                    ...warnings,
                    ...toolWarnings
                ]
            };
        });
    }
    collectUnsupportedSettingsWarnings({ topK, seed, presencePenalty, frequencyPenalty, stopSequences }) {
        const warnings = [];
        const unsupportedSettings = [
            {
                value: topK,
                name: "topK"
            },
            {
                value: seed,
                name: "seed"
            },
            {
                value: presencePenalty,
                name: "presencePenalty"
            },
            {
                value: frequencyPenalty,
                name: "frequencyPenalty"
            },
            {
                value: stopSequences,
                name: "stopSequences"
            }
        ];
        for (const { value, name } of unsupportedSettings){
            if (value != null) {
                warnings.push({
                    type: "unsupported-setting",
                    setting: name
                });
            }
        }
        return warnings;
    }
    parseProviderOptions(providerOptions) {
        return __async(this, null, function*() {
            const result = yield parseProviderOptions({
                provider: "ollama",
                providerOptions,
                schema: ollamaProviderOptions
            });
            return result != null ? result : null;
        });
    }
    buildBaseArgs({ modelId, prompt, temperature, topP, maxOutputTokens, responseFormat, ollamaOptions }) {
        var _a, _b;
        return __spreadProps(__spreadValues({
            model: modelId,
            messages: convertToOllamaChatMessages({
                prompt,
                systemMessageMode: "system"
            }),
            temperature,
            top_p: topP,
            max_output_tokens: maxOutputTokens
        }, (responseFormat == null ? void 0 : responseFormat.type) === "json" && {
            format: responseFormat.schema != null ? responseFormat.schema : "json"
        }), {
            think: (_a = ollamaOptions == null ? void 0 : ollamaOptions.think) != null ? _a : false,
            options: (_b = ollamaOptions == null ? void 0 : ollamaOptions.options) != null ? _b : void 0
        });
    }
};
var baseOllamaResponseSchema2 = import_v494.z.object({
    model: import_v494.z.string(),
    created_at: import_v494.z.string(),
    done: import_v494.z.boolean(),
    message: import_v494.z.object({
        content: import_v494.z.string(),
        role: import_v494.z.string(),
        thinking: import_v494.z.string().optional(),
        tool_calls: import_v494.z.array(import_v494.z.object({
            function: import_v494.z.object({
                name: import_v494.z.string(),
                arguments: import_v494.z.record(import_v494.z.string(), import_v494.z.any())
            }),
            id: import_v494.z.string().optional()
        })).optional().nullable()
    }),
    done_reason: import_v494.z.string().optional(),
    eval_count: import_v494.z.number().optional(),
    eval_duration: import_v494.z.number().optional(),
    load_duration: import_v494.z.number().optional(),
    prompt_eval_count: import_v494.z.number().optional(),
    prompt_eval_duration: import_v494.z.number().optional(),
    total_duration: import_v494.z.number().optional()
});
var OllamaResponseProcessor = class {
    constructor(config){
        this.config = config;
    }
    processGenerateResponse(response) {
        const content = this.extractContent(response);
        const finishReason = mapOllamaFinishReason(response.done_reason);
        const usage = this.extractUsage(response);
        const providerMetadata = {
            ollama: {}
        };
        return {
            content,
            finishReason,
            usage,
            providerMetadata
        };
    }
    extractContent(response) {
        var _a, _b, _c, _d, _e;
        const content = [];
        const text = response.message.content;
        if (text != null && text.length > 0) {
            content.push({
                type: "text",
                text
            });
        }
        for (const toolCall of (_a = response.message.tool_calls) != null ? _a : []){
            content.push({
                type: "tool-call",
                toolCallId: (_e = toolCall.id) != null ? _e : (_d = (_c = (_b = this.config).generateId) == null ? void 0 : _c.call(_b)) != null ? _d : generateId(),
                toolName: toolCall.function.name,
                input: JSON.stringify(toolCall.function.arguments)
            });
        }
        return content;
    }
    extractUsage(response) {
        var _a, _b, _c, _d;
        return {
            inputTokens: (_a = response.prompt_eval_count) != null ? _a : void 0,
            outputTokens: (_b = response.eval_count) != null ? _b : void 0,
            totalTokens: ((_c = response.prompt_eval_count) != null ? _c : 0) + ((_d = response.eval_count) != null ? _d : 0),
            reasoningTokens: void 0,
            // Ollama doesn't provide separate reasoning tokens
            cachedInputTokens: void 0
        };
    }
};
function extractOllamaResponseObjectsFromChunk(chunk) {
    var _a;
    if (chunk.success) {
        return [
            chunk.value
        ];
    }
    const results = [];
    const raw = (_a = chunk.error) == null ? void 0 : _a.text;
    if (typeof raw !== "string" || raw.length === 0) {
        return results;
    }
    const lines = raw.split(/\r?\n/);
    for (const line of lines){
        const trimmed = line.trim();
        if (trimmed === "") continue;
        try {
            const parsed = JSON.parse(trimmed);
            const validated = baseOllamaResponseSchema2.safeParse(parsed);
            if (validated.success) {
                results.push(validated.data);
            }
        } catch (e) {}
    }
    return results;
}
var OllamaStreamProcessor = class {
    constructor(config){
        this.config = config;
        this.state = this.initializeState();
    }
    createTransformStream(warnings, options) {
        return new TransformStream({
            start: (controller)=>{
                controller.enqueue({
                    type: "stream-start",
                    warnings
                });
            },
            transform: (chunk, controller)=>{
                this.processChunk(chunk, controller, options);
            },
            flush: (controller)=>{
                this.finalizeStream(controller);
            }
        });
    }
    initializeState() {
        return {
            finishReason: "unknown",
            usage: {
                inputTokens: void 0,
                outputTokens: void 0,
                totalTokens: void 0
            },
            responseId: null,
            ongoingToolCalls: {},
            hasToolCalls: false,
            isFirstChunk: true,
            hasTextStarted: false,
            hasReasoningStarted: false,
            textEnded: false,
            reasoningEnded: false,
            textId: generateId()
        };
    }
    processChunk(chunk, controller, options) {
        if (options == null ? void 0 : options.includeRawChunks) {
            controller.enqueue({
                type: "raw",
                rawValue: chunk.rawValue
            });
        }
        const values = extractOllamaResponseObjectsFromChunk(chunk);
        if (values.length === 0) {
            if (!chunk.success) {
                this.state.finishReason = "error";
                controller.enqueue({
                    type: "error",
                    error: chunk.error
                });
            }
            return;
        }
        for (const value of values){
            this.processResponseValue(value, controller);
        }
    }
    processResponseValue(value, controller) {
        if (value && typeof value === "object" && "error" in value) {
            this.state.finishReason = "error";
            controller.enqueue({
                type: "error",
                error: value.error
            });
            return;
        }
        if (this.state.isFirstChunk) {
            this.state.isFirstChunk = false;
            controller.enqueue(__spreadValues({
                type: "response-metadata"
            }, getResponseMetadata9(value)));
        }
        if (value.done) {
            this.handleDoneChunk(value, controller);
        }
        const delta = value == null ? void 0 : value.message;
        if (delta) {
            this.processDelta(delta, controller);
        }
    }
    handleDoneChunk(value, controller) {
        var _a, _b, _c;
        this.state.finishReason = mapOllamaFinishReason(value.done_reason);
        this.state.usage = {
            inputTokens: value.prompt_eval_count || 0,
            outputTokens: (_a = value.eval_count) != null ? _a : void 0,
            totalTokens: ((_b = value.prompt_eval_count) != null ? _b : 0) + ((_c = value.eval_count) != null ? _c : 0)
        };
        if (this.state.hasTextStarted && !this.state.textEnded) {
            controller.enqueue({
                type: "text-end",
                id: this.state.textId
            });
            this.state.textEnded = true;
        }
        if (this.state.hasReasoningStarted && !this.state.reasoningEnded) {
            controller.enqueue({
                type: "reasoning-end",
                id: "0"
            });
            this.state.reasoningEnded = true;
        }
    }
    processDelta(delta, controller) {
        this.processTextContent(delta, controller);
        this.processThinking(delta, controller);
        this.processToolCalls(delta, controller);
    }
    processTextContent(delta, controller) {
        if ((delta == null ? void 0 : delta.content) != null) {
            if (!this.state.hasTextStarted) {
                controller.enqueue({
                    type: "text-start",
                    id: this.state.textId
                });
                this.state.hasTextStarted = true;
            }
            controller.enqueue({
                type: "text-delta",
                id: this.state.textId,
                delta: delta.content
            });
        }
    }
    processThinking(delta, controller) {
        if (delta == null ? void 0 : delta.thinking) {
            if (!this.state.hasReasoningStarted) {
                controller.enqueue({
                    type: "reasoning-start",
                    id: "0"
                });
                this.state.hasReasoningStarted = true;
            }
            controller.enqueue({
                type: "reasoning-delta",
                id: "0",
                delta: delta.thinking
            });
        }
    }
    processToolCalls(delta, controller) {
        var _a, _b, _c, _d;
        for (const toolCall of (_a = delta.tool_calls) != null ? _a : []){
            if (((_b = toolCall.function) == null ? void 0 : _b.name) == null) {
                throw new import_provider60.InvalidResponseDataError({
                    data: toolCall,
                    message: `Expected 'function.name' to be a string.`
                });
            }
            if (((_c = toolCall.function) == null ? void 0 : _c.name) != null && ((_d = toolCall.function) == null ? void 0 : _d.arguments) != null) {
                this.emitToolCall(toolCall, controller);
            }
        }
    }
    emitToolCall(toolCall, controller) {
        var _a, _b, _c, _d;
        const id = (_d = toolCall.id) != null ? _d : (_c = (_b = (_a = this.config).generateId) == null ? void 0 : _b.call(_a)) != null ? _c : generateId();
        controller.enqueue({
            type: "tool-input-start",
            id,
            toolName: toolCall.function.name
        });
        controller.enqueue({
            type: "tool-input-delta",
            id,
            delta: JSON.stringify(toolCall.function.arguments)
        });
        controller.enqueue({
            type: "tool-input-end",
            id
        });
        controller.enqueue({
            type: "tool-call",
            toolCallId: id,
            toolName: toolCall.function.name,
            input: JSON.stringify(toolCall.function.arguments)
        });
        this.state.hasToolCalls = true;
    }
    finalizeStream(controller) {
        if (this.state.hasTextStarted && !this.state.textEnded) {
            controller.enqueue({
                type: "text-end",
                id: "0"
            });
        }
        if (this.state.hasReasoningStarted && !this.state.reasoningEnded) {
            controller.enqueue({
                type: "reasoning-end",
                id: "0"
            });
        }
        controller.enqueue({
            type: "finish",
            finishReason: this.state.finishReason,
            usage: this.state.usage,
            providerMetadata: {
                ollama: {
                    responseId: this.state.responseId
                }
            }
        });
    }
};
var OllamaResponsesLanguageModel = class {
    constructor(modelId, config){
        this.specificationVersion = "v2";
        this.supportedUrls = {
            "image/*": [
                /^https?:\/\/.*$/
            ]
        };
        this.modelId = modelId;
        this.config = config;
        this.requestBuilder = new OllamaRequestBuilder();
        this.responseProcessor = new OllamaResponseProcessor(config);
    }
    get provider() {
        return this.config.provider;
    }
    doGenerate(options) {
        return __async(this, null, function*() {
            const { args: body, warnings } = yield this.prepareRequest(options);
            const { responseHeaders, value: response, rawValue: rawResponse } = yield postJsonToApi({
                url: this.config.url({
                    path: "/chat",
                    modelId: this.modelId
                }),
                headers: combineHeaders(this.config.headers(), options.headers),
                body: __spreadProps(__spreadValues({}, body), {
                    stream: false
                }),
                failedResponseHandler: ollamaFailedResponseHandler,
                successfulResponseHandler: createJsonResponseHandler(baseOllamaResponseSchema2),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            const processedResponse = this.responseProcessor.processGenerateResponse(response);
            return __spreadProps(__spreadValues({}, processedResponse), {
                request: {
                    body: JSON.stringify(body)
                },
                response: {
                    modelId: this.modelId,
                    timestamp: /* @__PURE__ */ new Date(),
                    headers: responseHeaders,
                    body: rawResponse
                },
                warnings
            });
        });
    }
    doStream(options) {
        return __async(this, null, function*() {
            const { args: body, warnings } = yield this.prepareRequest(options);
            const { responseHeaders, value: response } = yield postJsonToApi({
                url: this.config.url({
                    path: "/chat",
                    modelId: this.modelId
                }),
                headers: combineHeaders(this.config.headers(), options.headers),
                body: __spreadProps(__spreadValues({}, body), {
                    stream: true
                }),
                failedResponseHandler: ollamaFailedResponseHandler,
                successfulResponseHandler: createJsonStreamResponseHandler(baseOllamaResponseSchema2),
                abortSignal: options.abortSignal,
                fetch: this.config.fetch
            });
            const streamProcessor = new OllamaStreamProcessor(this.config);
            return {
                stream: response.pipeThrough(streamProcessor.createTransformStream(warnings, options)),
                request: {
                    body
                },
                response: {
                    headers: responseHeaders
                }
            };
        });
    }
    prepareRequest(options) {
        return __async(this, null, function*() {
            return yield this.requestBuilder.buildRequest(__spreadValues({
                modelId: this.modelId
            }, options));
        });
    }
};
function createOllama(options = {}) {
    var _a, _b;
    const baseURL = (_a = withoutTrailingSlash(options.baseURL)) != null ? _a : "http://127.0.0.1:11434/api";
    const providerName = (_b = options.name) != null ? _b : "ollama";
    const getHeaders = ()=>__spreadValues({
            "Ollama-Organization": options.organization,
            "Ollama-Project": options.project
        }, options.headers);
    const createCompletionModel = (modelId, settings = {})=>new OllamaCompletionLanguageModel(modelId, settings, {
            provider: `${providerName}.completion`,
            url: ({ path: path7 })=>`${baseURL}${path7}`,
            headers: getHeaders,
            fetch: options.fetch
        });
    const createEmbeddingModel = (modelId, settings = {})=>new OllamaEmbeddingModel(modelId, settings, {
            provider: `${providerName}.embedding`,
            url: ({ path: path7 })=>`${baseURL}${path7}`,
            headers: getHeaders,
            fetch: options.fetch
        });
    const createLanguageModel = (modelId)=>{
        if (new.target) {
            throw new Error("The Ollama model function cannot be called with the new keyword.");
        }
        return createResponsesModel(modelId);
    };
    const createResponsesModel = (modelId)=>{
        return new OllamaResponsesLanguageModel(modelId, {
            provider: `${providerName}.responses`,
            url: ({ path: path7 })=>`${baseURL}${path7}`,
            headers: getHeaders,
            fetch: options.fetch
        });
    };
    const provider = function(modelId) {
        return createLanguageModel(modelId);
    };
    provider.languageModel = createLanguageModel;
    provider.chat = createLanguageModel;
    provider.completion = createCompletionModel;
    provider.embedding = createEmbeddingModel;
    provider.textEmbedding = createEmbeddingModel;
    provider.textEmbeddingModel = createEmbeddingModel;
    provider.imageModel = (modelId)=>{
        throw new import_provider55.NoSuchModelError({
            modelId,
            modelType: "imageModel",
            message: "Image generation is unsupported with Ollama"
        });
    };
    return provider;
}
var ollama = createOllama();
// lib/v3/llm/LLMProvider.ts
var AISDKProviders = {
    openai,
    anthropic,
    google,
    xai,
    azure,
    groq,
    cerebras,
    togetherai,
    mistral,
    deepseek,
    perplexity,
    ollama
};
var AISDKProvidersWithAPIKey = {
    openai: createOpenAI,
    anthropic: createAnthropic,
    google: createGoogleGenerativeAI,
    xai: createXai,
    azure: createAzure,
    groq: createGroq,
    cerebras: createCerebras,
    togetherai: createTogetherAI,
    mistral: createMistral,
    deepseek: createDeepSeek,
    perplexity: createPerplexity
};
var modelToProviderMap = {
    "gpt-4.1": "openai",
    "gpt-4.1-mini": "openai",
    "gpt-4.1-nano": "openai",
    "o4-mini": "openai",
    //prettier-ignore
    "o3": "openai",
    "o3-mini": "openai",
    //prettier-ignore
    "o1": "openai",
    "o1-mini": "openai",
    "gpt-4o": "openai",
    "gpt-4o-mini": "openai",
    "gpt-4o-2024-08-06": "openai",
    "gpt-4.5-preview": "openai",
    "o1-preview": "openai",
    "claude-3-5-sonnet-latest": "anthropic",
    "claude-3-5-sonnet-20240620": "anthropic",
    "claude-3-5-sonnet-20241022": "anthropic",
    "claude-3-7-sonnet-20250219": "anthropic",
    "claude-3-7-sonnet-latest": "anthropic",
    "cerebras-llama-3.3-70b": "cerebras",
    "cerebras-llama-3.1-8b": "cerebras",
    "groq-llama-3.3-70b-versatile": "groq",
    "groq-llama-3.3-70b-specdec": "groq",
    "moonshotai/kimi-k2-instruct": "groq",
    "gemini-1.5-flash": "google",
    "gemini-1.5-pro": "google",
    "gemini-1.5-flash-8b": "google",
    "gemini-2.0-flash-lite": "google",
    "gemini-2.0-flash": "google",
    "gemini-2.5-flash-preview-04-17": "google",
    "gemini-2.5-pro-preview-03-25": "google"
};
function getAISDKLanguageModel(subProvider, subModelName, apiKey, baseURL) {
    if (apiKey) {
        const creator = AISDKProvidersWithAPIKey[subProvider];
        if (!creator) {
            throw new UnsupportedAISDKModelProviderError(subProvider, Object.keys(AISDKProvidersWithAPIKey));
        }
        const providerConfig = {
            apiKey
        };
        if (baseURL) {
            providerConfig.baseURL = baseURL;
        }
        const provider = creator(providerConfig);
        return provider(subModelName);
    } else {
        const provider = AISDKProviders[subProvider];
        if (!provider) {
            throw new UnsupportedAISDKModelProviderError(subProvider, Object.keys(AISDKProviders));
        }
        return provider(subModelName);
    }
}
var LLMProvider = class {
    constructor(logger){
        this.logger = logger;
    }
    getClient(modelName, clientOptions) {
        if (modelName.includes("/")) {
            const firstSlashIndex = modelName.indexOf("/");
            const subProvider = modelName.substring(0, firstSlashIndex);
            const subModelName = modelName.substring(firstSlashIndex + 1);
            const languageModel = getAISDKLanguageModel(subProvider, subModelName, clientOptions == null ? void 0 : clientOptions.apiKey, clientOptions == null ? void 0 : clientOptions.baseURL);
            return new AISdkClient({
                model: languageModel,
                logger: this.logger
            });
        }
        const provider = modelToProviderMap[modelName];
        if (!provider) {
            throw new UnsupportedModelError(Object.keys(modelToProviderMap));
        }
        const availableModel = modelName;
        switch(provider){
            case "openai":
                return new OpenAIClient({
                    logger: this.logger,
                    modelName: availableModel,
                    clientOptions
                });
            case "anthropic":
                return new AnthropicClient({
                    logger: this.logger,
                    modelName: availableModel,
                    clientOptions
                });
            case "cerebras":
                return new CerebrasClient({
                    logger: this.logger,
                    modelName: availableModel,
                    clientOptions
                });
            case "groq":
                return new GroqClient({
                    logger: this.logger,
                    modelName: availableModel,
                    clientOptions
                });
            case "google":
                return new GoogleClient({
                    logger: this.logger,
                    modelName: availableModel,
                    clientOptions
                });
            default:
                throw new UnsupportedModelProviderError([
                    ...new Set(Object.values(modelToProviderMap))
                ]);
        }
    }
    static getModelProvider(modelName) {
        if (modelName.includes("/")) {
            const firstSlashIndex = modelName.indexOf("/");
            const subProvider = modelName.substring(0, firstSlashIndex);
            if (AISDKProviders[subProvider]) {
                return "aisdk";
            }
        }
        const provider = modelToProviderMap[modelName];
        return provider;
    }
};
// lib/v3/v3.ts
init_logger();
// lib/v3/mcp/connection.ts
var import_client = __turbopack_context__.r("[project]/node_modules/@modelcontextprotocol/sdk/dist/cjs/client/index.js [app-route] (ecmascript)");
var import_streamableHttp = __turbopack_context__.r("[project]/node_modules/@modelcontextprotocol/sdk/dist/cjs/client/streamableHttp.js [app-route] (ecmascript)");
var import_stdio = __turbopack_context__.r("[project]/node_modules/@modelcontextprotocol/sdk/dist/cjs/client/stdio.js [app-route] (ecmascript)");
init_sdkErrors();
var connectToMCPServer = (serverConfig)=>__async(null, null, function*() {
        try {
            let transport;
            let clientOptions;
            if (typeof serverConfig === "object" && "command" in serverConfig) {
                transport = new import_stdio.StdioClientTransport(serverConfig);
            } else {
                let serverUrl;
                if (typeof serverConfig === "string" || serverConfig instanceof URL) {
                    serverUrl = serverConfig;
                } else {
                    serverUrl = serverConfig.serverUrl;
                    clientOptions = serverConfig.clientOptions;
                }
                transport = new import_streamableHttp.StreamableHTTPClientTransport(new URL(serverUrl));
            }
            const client = new import_client.Client(__spreadValues({
                name: "Stagehand",
                version: "1.0.0"
            }, clientOptions));
            yield client.connect(transport);
            try {
                yield client.ping();
            } catch (pingError) {
                yield client.close();
                throw new MCPConnectionError(serverConfig.toString(), pingError);
            }
            return client;
        } catch (error) {
            if (error instanceof MCPConnectionError) {
                throw error;
            }
            throw new MCPConnectionError(serverConfig.toString(), error);
        }
    });
// lib/v3/mcp/utils.ts
var resolveTools = (clients, userTools)=>__async(null, null, function*() {
        const tools = __spreadValues({}, userTools);
        for (const client of clients){
            let clientInstance;
            if (typeof client === "string") {
                clientInstance = yield connectToMCPServer(client);
            } else {
                clientInstance = client;
            }
            let nextCursor = void 0;
            do {
                const clientTools = yield clientInstance.listTools({
                    cursor: nextCursor
                });
                for (const tool12 of clientTools.tools){
                    tools[tool12.name] = {
                        description: tool12.description,
                        inputSchema: jsonSchemaToZod(tool12.inputSchema),
                        execute: (input)=>__async(null, null, function*() {
                                const result = yield clientInstance.callTool({
                                    name: tool12.name,
                                    arguments: input
                                });
                                return result;
                            })
                    };
                }
                nextCursor = clientTools.nextCursor;
            }while (nextCursor)
        }
        return tools;
    });
// lib/v3/types/public/agent.ts
var AVAILABLE_CUA_MODELS = [
    "openai/computer-use-preview",
    "openai/computer-use-preview-2025-03-11",
    "anthropic/claude-3-7-sonnet-latest",
    "anthropic/claude-haiku-4-5-20251001",
    "anthropic/claude-sonnet-4-20250514",
    "anthropic/claude-sonnet-4-5-20250929",
    "google/gemini-2.5-computer-use-preview-10-2025"
];
// lib/v3/types/public/apiErrors.ts
var StagehandAPIError = class extends Error {
    constructor(message){
        super(message);
        this.name = this.constructor.name;
    }
};
var StagehandAPIUnauthorizedError = class extends StagehandAPIError {
    constructor(message){
        super(message || "Unauthorized request");
    }
};
var StagehandHttpError = class extends StagehandAPIError {
    constructor(message){
        super(message);
    }
};
var StagehandServerError = class extends StagehandAPIError {
    constructor(message){
        super(message);
    }
};
var StagehandResponseBodyError = class extends StagehandAPIError {
    constructor(){
        super("Response body is null");
    }
};
var StagehandResponseParseError = class extends StagehandAPIError {
    constructor(message){
        super(message);
    }
};
// lib/v3/types/public/logs.ts
var LOG_LEVEL_NAMES = {
    0: "error",
    1: "info",
    2: "debug"
};
// lib/v3/types/public/page.ts
init_consoleMessage();
init_response();
// lib/v3/types/public/index.ts
init_sdkErrors();
// examples/external_clients/aisdk.ts
var import_ai14 = __turbopack_context__.r("[project]/node_modules/ai/dist/index.js [app-route] (ecmascript)");
var AISdkClient2 = class extends LLMClient {
    constructor({ model }){
        super(model.modelId);
        this.type = "aisdk";
        this.model = model;
    }
    createChatCompletion(_0) {
        return __async(this, arguments, function*({ options }) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
            const formattedMessages = options.messages.map((message)=>{
                if (Array.isArray(message.content)) {
                    if (message.role === "system") {
                        const systemMessage = {
                            role: "system",
                            content: message.content.map((c)=>"text" in c ? c.text : "").join("\n")
                        };
                        return systemMessage;
                    }
                    const contentParts = message.content.map((content)=>{
                        if ("image_url" in content) {
                            const imageContent = {
                                type: "image",
                                image: content.image_url.url
                            };
                            return imageContent;
                        } else {
                            const textContent = {
                                type: "text",
                                text: content.text
                            };
                            return textContent;
                        }
                    });
                    if (message.role === "user") {
                        const userMessage = {
                            role: "user",
                            content: contentParts
                        };
                        return userMessage;
                    } else {
                        const textOnlyParts = contentParts.map((part)=>({
                                type: "text",
                                text: part.type === "image" ? "[Image]" : part.text
                            }));
                        const assistantMessage = {
                            role: "assistant",
                            content: textOnlyParts
                        };
                        return assistantMessage;
                    }
                }
                return {
                    role: message.role,
                    content: message.content
                };
            });
            if (options.response_model) {
                const response2 = yield (0, import_ai14.generateObject)({
                    model: this.model,
                    messages: formattedMessages,
                    schema: options.response_model.schema
                });
                return {
                    data: response2.object,
                    usage: {
                        prompt_tokens: (_a = response2.usage.inputTokens) != null ? _a : 0,
                        completion_tokens: (_b = response2.usage.outputTokens) != null ? _b : 0,
                        reasoning_tokens: (_c = response2.usage.reasoningTokens) != null ? _c : 0,
                        cached_input_tokens: (_d = response2.usage.cachedInputTokens) != null ? _d : 0,
                        total_tokens: (_e = response2.usage.totalTokens) != null ? _e : 0
                    }
                };
            }
            const tools = {};
            for (const rawTool of options.tools){
                tools[rawTool.name] = {
                    description: rawTool.description,
                    inputSchema: rawTool.parameters
                };
            }
            const response = yield (0, import_ai14.generateText)({
                model: this.model,
                messages: formattedMessages,
                tools
            });
            return {
                data: response.text,
                usage: {
                    prompt_tokens: (_f = response.usage.inputTokens) != null ? _f : 0,
                    completion_tokens: (_g = response.usage.outputTokens) != null ? _g : 0,
                    reasoning_tokens: (_h = response.usage.reasoningTokens) != null ? _h : 0,
                    cached_input_tokens: (_i = response.usage.cachedInputTokens) != null ? _i : 0,
                    total_tokens: (_j = response.usage.totalTokens) != null ? _j : 0
                }
            };
        });
    }
};
// lib/v3/understudy/context.ts
init_logger();
// lib/v3/understudy/cdp.ts
var import_ws = __toESM(__turbopack_context__.r("[project]/node_modules/ws/index.js [app-route] (ecmascript)"));
var CdpConnection = class _CdpConnection {
    constructor(ws){
        this.nextId = 1;
        this.inflight = /* @__PURE__ */ new Map();
        this.eventHandlers = /* @__PURE__ */ new Map();
        this.sessions = /* @__PURE__ */ new Map();
        this.id = null;
        // root
        this.transportCloseHandlers = /* @__PURE__ */ new Set();
        this.ws = ws;
        this.ws.on("close", (code, reason)=>{
            const why = `socket-close code=${code} reason=${String(reason || "")}`;
            this.emitTransportClosed(why);
        });
        this.ws.on("error", (err)=>{
            var _a;
            const why = `socket-error ${(_a = err == null ? void 0 : err.message) != null ? _a : String(err)}`;
            this.emitTransportClosed(why);
        });
        this.ws.on("message", (data)=>this.onMessage(data.toString()));
    }
    onTransportClosed(handler) {
        this.transportCloseHandlers.add(handler);
    }
    offTransportClosed(handler) {
        this.transportCloseHandlers.delete(handler);
    }
    emitTransportClosed(why) {
        for (const h of this.transportCloseHandlers){
            try {
                h(why);
            } catch (e) {}
        }
    }
    static connect(wsUrl) {
        return __async(this, null, function*() {
            const ws = new import_ws.default(wsUrl);
            yield new Promise((resolve2, reject)=>{
                ws.once("open", ()=>resolve2());
                ws.once("error", (e)=>reject(e));
            });
            return new _CdpConnection(ws);
        });
    }
    enableAutoAttach() {
        return __async(this, null, function*() {
            yield this.send("Target.setAutoAttach", {
                autoAttach: true,
                flatten: true,
                waitForDebuggerOnStart: false,
                filter: [
                    {
                        type: "worker",
                        exclude: true
                    },
                    {
                        type: "shared_worker",
                        exclude: true
                    },
                    {
                        type: "service_worker",
                        exclude: true
                    }
                ]
            });
            yield this.send("Target.setDiscoverTargets", {
                discover: true
            });
        });
    }
    send(method, params) {
        return __async(this, null, function*() {
            var _a;
            const id = this.nextId++;
            const payload = {
                id,
                method,
                params
            };
            const stack = (_a = new Error().stack) == null ? void 0 : _a.split("\n").slice(1, 4).join("\n");
            const p = new Promise((resolve2, reject)=>{
                this.inflight.set(id, {
                    resolve: resolve2,
                    reject,
                    sessionId: null,
                    method,
                    params,
                    stack,
                    ts: Date.now()
                });
            });
            this.ws.send(JSON.stringify(payload));
            return p;
        });
    }
    on(event, handler) {
        var _a;
        const set = (_a = this.eventHandlers.get(event)) != null ? _a : /* @__PURE__ */ new Set();
        set.add(handler);
        this.eventHandlers.set(event, set);
    }
    off(event, handler) {
        const set = this.eventHandlers.get(event);
        if (set) set.delete(handler);
    }
    close() {
        return __async(this, null, function*() {
            yield new Promise((resolve2)=>{
                this.ws.once("close", ()=>resolve2());
                this.ws.close();
            });
        });
    }
    getSession(sessionId) {
        return this.sessions.get(sessionId);
    }
    attachToTarget(targetId) {
        return __async(this, null, function*() {
            const { sessionId } = yield this.send("Target.attachToTarget", {
                targetId,
                flatten: true
            });
            let session = this.sessions.get(sessionId);
            if (!session) {
                session = new CdpSession(this, sessionId);
                this.sessions.set(sessionId, session);
            }
            return session;
        });
    }
    getTargets() {
        return __async(this, null, function*() {
            const res = yield this.send("Target.getTargets");
            return res.targetInfos;
        });
    }
    onMessage(json) {
        const msg = JSON.parse(json);
        if ("id" in msg) {
            const rec = this.inflight.get(msg.id);
            if (!rec) return;
            this.inflight.delete(msg.id);
            if ("error" in msg && msg.error) {
                rec.reject(new Error(`${msg.error.code} ${msg.error.message}`));
            } else {
                rec.resolve(msg.result);
            }
            return;
        }
        if ("method" in msg) {
            if (msg.method === "Target.attachedToTarget") {
                const p = msg.params;
                if (!this.sessions.has(p.sessionId)) {
                    this.sessions.set(p.sessionId, new CdpSession(this, p.sessionId));
                }
            } else if (msg.method === "Target.detachedFromTarget") {
                const p = msg.params;
                for (const [id, entry] of this.inflight.entries()){
                    if (entry.sessionId === p.sessionId) {
                        entry.reject(new Error("CDP session detached"));
                        this.inflight.delete(id);
                    }
                }
                this.sessions.delete(p.sessionId);
            }
            const { method, params, sessionId } = msg;
            if (sessionId) {
                const session = this.sessions.get(sessionId);
                session == null ? void 0 : session.dispatch(method, params);
            } else {
                const handlers = this.eventHandlers.get(method);
                if (handlers) for (const h of handlers)h(params);
            }
        }
    }
    _sendViaSession(sessionId, method, params) {
        var _a;
        const id = this.nextId++;
        const payload = {
            id,
            method,
            params,
            sessionId
        };
        const stack = (_a = new Error().stack) == null ? void 0 : _a.split("\n").slice(1, 4).join("\n");
        const p = new Promise((resolve2, reject)=>{
            this.inflight.set(id, {
                resolve: resolve2,
                reject,
                sessionId,
                method,
                params,
                stack,
                ts: Date.now()
            });
        });
        this.ws.send(JSON.stringify(payload));
        return p;
    }
    _onSessionEvent(sessionId, event, handler) {
        var _a;
        const key = `${sessionId}:${event}`;
        const set = (_a = this.eventHandlers.get(key)) != null ? _a : /* @__PURE__ */ new Set();
        set.add(handler);
        this.eventHandlers.set(key, set);
    }
    _offSessionEvent(sessionId, event, handler) {
        const key = `${sessionId}:${event}`;
        const set = this.eventHandlers.get(key);
        if (set) set.delete(handler);
    }
    _dispatchToSession(sessionId, event, params) {
        const key = `${sessionId}:${event}`;
        const handlers = this.eventHandlers.get(key);
        if (handlers) for (const h of handlers)h(params);
    }
};
var CdpSession = class {
    constructor(root, id){
        this.root = root;
        this.id = id;
    }
    send(method, params) {
        return this.root._sendViaSession(this.id, method, params);
    }
    on(event, handler) {
        this.root._onSessionEvent(this.id, event, handler);
    }
    off(event, handler) {
        this.root._offSessionEvent(this.id, event, handler);
    }
    close() {
        return __async(this, null, function*() {
            yield this.root.send("Target.detachFromTarget", {
                sessionId: this.id
            });
        });
    }
    dispatch(event, params) {
        this.root._dispatchToSession(this.id, event, params);
    }
};
// lib/v3/understudy/context.ts
init_page();
// lib/v3/understudy/piercer.ts
init_logger();
// lib/v3/dom/build/scriptV3Content.ts
var v3ScriptContent = '(()=>{function b(_={}){let S=n=>{let{hostToRoot:l}=n,m=t=>{let o=[];if(t instanceof Document)return t.documentElement&&o.push(t.documentElement),o;if(t instanceof ShadowRoot||t instanceof DocumentFragment)return o.push(...Array.from(t.children)),o;if(t instanceof Element){o.push(...Array.from(t.children));let a=t.shadowRoot;a&&o.push(...Array.from(a.children));let r=l.get(t);return r&&o.push(...Array.from(r.children)),o}return o},v=t=>{let o=[],a=[...m(t)];for(;a.length;){let r=a.shift();o.push(r),a.push(...m(r))}return o},y=t=>{let o=String(t||"").trim();if(!o)return null;let a=o.replace(/^xpath=/i,""),r=[];{let e=0;for(;e<a.length;){let d="child";a.startsWith("//",e)?(d="desc",e+=2):a[e]==="/"&&(d="child",e+=1);let h=e;for(;e<a.length&&a[e]!=="/";)e++;let u=a.slice(h,e).trim();if(!u)continue;let p=u.match(/^(.*?)(\\[(\\d+)\\])?$/u),i=(p?.[1]??u).trim(),c=p?.[3]?Math.max(1,Number(p[3])):null,R=i===""?"*":i.toLowerCase();r.push({axis:d,raw:u,tag:R,index:c})}}n.debug&&console.info("[v3-piercer][resolve] start",{url:location.href,steps:r.map(e=>({axis:e.axis,raw:e.raw,tag:e.tag,index:e.index}))});let g=[document];for(let e of r){let d=e.index,h=null;for(let u of g){let p=e.axis==="child"?m(u):v(u),i=[];for(let c of p)(e.tag==="*"||c.localName===e.tag)&&i.push(c);if(n.debug&&console.info("[v3-piercer][resolve] step",{axis:e.axis,tag:e.tag,index:d,poolCount:p.length,matchesCount:i.length}),!!i.length){if(d!=null){let c=d-1;h=c>=0&&c<i.length?i[c]:null}else h=i[0];if(h)break}}if(!h)return n.debug&&console.info("[v3-piercer][resolve] no-match",{step:e.raw}),null;g=[h]}let E=g.length?g[0]:null;return n.debug&&console.info("[v3-piercer][resolve] done",{found:!!E,tag:E?.localName??""}),E};window.__stagehandV3__={getClosedRoot:t=>l.get(t),stats:()=>({installed:!0,url:location.href,isTop:window.top===window,open:n.openCount,closed:n.closedCount}),resolveSimpleXPath:y}},f=Element.prototype.attachShadow;if(f.__v3Patched&&f.__v3State){f.__v3State.debug=!0,S(f.__v3State);return}let s={hostToRoot:new WeakMap,openCount:0,closedCount:0,debug:!0},x=f,w=function(n){let l=n?.mode??"open",m=x.call(this,n);try{s.hostToRoot.set(this,m),l==="closed"?s.closedCount++:s.openCount++,s.debug&&console.info("[v3-piercer] attachShadow",{tag:this.tagName?.toLowerCase()??"",mode:l,url:location.href})}catch{}return m};if(w.__v3Patched=!0,w.__v3State=s,Object.defineProperty(Element.prototype,"attachShadow",{configurable:!0,writable:!0,value:w}),_.tagExisting)try{let n=document.createTreeWalker(document,NodeFilter.SHOW_ELEMENT);for(;n.nextNode();){let l=n.currentNode;l.shadowRoot&&(s.hostToRoot.set(l,l.shadowRoot),s.openCount++)}}catch{}window.__stagehandV3Injected=!0,S(s),s.debug&&console.info("[v3-piercer] installed",{url:location.href,isTop:window.top===window,readyState:document.readyState})}b({debug:!0,tagExisting:!1});})();\n';
// lib/v3/dom/build/reRenderScriptContent.ts
var reRenderScriptContent = '(()=>{function s(){try{let o=window.__stagehandV3__;if(!o||typeof o.getClosedRoot!="function")return;let t=[],r=document.createTreeWalker(document,NodeFilter.SHOW_ELEMENT);for(;r.nextNode();){let e=r.currentNode,n=e.tagName?.toLowerCase()??"";if(!n.includes("-")||typeof customElements?.get!="function"||!customElements.get(n))continue;let c=!!e.shadowRoot,i=!!o.getClosedRoot(e);c||i||t.push(e)}for(let e of t)try{let n=e.cloneNode(!0);e.replaceWith(n)}catch{}o.stats&&t.length&&console.info("[v3-piercer] rerender",{count:t.length})}catch(o){console.info("[v3-piercer] rerender error",{message:String(o??"")})}}s();})();\n';
// lib/v3/understudy/piercer.ts
function installV3PiercerIntoSession(session) {
    return __async(this, null, function*() {
        var _a, _b;
        const pageEnabled = yield session.send("Page.enable").then(()=>true).catch(()=>false);
        if (!pageEnabled) return false;
        yield session.send("Runtime.enable").catch(()=>{});
        try {
            yield session.send("Page.addScriptToEvaluateOnNewDocument", {
                source: v3ScriptContent,
                runImmediately: true
            });
        } catch (e) {
            const msg = String((_b = (_a = e == null ? void 0 : e.message) != null ? _a : e) != null ? _b : "");
            if (msg.includes("Session with given id not found")) return false;
        }
        yield session.send("Runtime.evaluate", {
            expression: v3ScriptContent,
            returnByValue: true,
            awaitPromise: true
        }).catch(()=>{});
        yield session.send("Runtime.evaluate", {
            expression: reRenderScriptContent,
            returnByValue: true,
            awaitPromise: false
        }).catch(()=>{});
        return true;
    });
}
// lib/v3/understudy/context.ts
init_executionContextRegistry();
init_sdkErrors();
function isTopLevelPage(info) {
    const ti = info;
    return info.type === "page" && ti.subtype !== "iframe";
}
var V3Context = class _V3Context {
    constructor(conn, env = "LOCAL", apiClient = null, localBrowserLaunchOptions = null){
        this.conn = conn;
        this.env = env;
        this.apiClient = apiClient;
        this.localBrowserLaunchOptions = localBrowserLaunchOptions;
        this._piercerInstalled = /* @__PURE__ */ new Set();
        // Timestamp for most recent popup/open signal
        this._lastPopupSignalAt = 0;
        this._sessionInit = /* @__PURE__ */ new Set();
        this.pagesByTarget = /* @__PURE__ */ new Map();
        this.mainFrameToTarget = /* @__PURE__ */ new Map();
        this.sessionOwnerPage = /* @__PURE__ */ new Map();
        this.frameOwnerPage = /* @__PURE__ */ new Map();
        this.pendingOopifByMainFrame = /* @__PURE__ */ new Map();
        this.createdAtByTarget = /* @__PURE__ */ new Map();
        this.typeByTarget = /* @__PURE__ */ new Map();
        this._pageOrder = [];
        this.pendingCreatedTargetUrl = /* @__PURE__ */ new Map();
    }
    sessionKey(session) {
        var _a;
        return (_a = session.id) != null ? _a : "root";
    }
    /**
   * Create a Context for a given CDP websocket URL and bootstrap target wiring.
   */ static create(wsUrl, opts) {
        return __async(this, null, function*() {
            var _a, _b, _c;
            const conn = yield CdpConnection.connect(wsUrl);
            const ctx = new _V3Context(conn, (_a = opts == null ? void 0 : opts.env) != null ? _a : "LOCAL", (_b = opts == null ? void 0 : opts.apiClient) != null ? _b : null, (_c = opts == null ? void 0 : opts.localBrowserLaunchOptions) != null ? _c : null);
            yield ctx.bootstrap();
            yield ctx.waitForFirstTopLevelPage(5e3);
            return ctx;
        });
    }
    /**
   * Wait until at least one top-level Page has been created and registered.
   * We poll internal maps that bootstrap/onAttachedToTarget populate.
   */ waitForFirstTopLevelPage(timeoutMs) {
        return __async(this, null, function*() {
            const deadline = Date.now() + timeoutMs;
            while(Date.now() < deadline){
                for (const [tid, ttype] of this.typeByTarget){
                    if (ttype === "page") {
                        const p = this.pagesByTarget.get(tid);
                        if (p) return;
                    }
                }
                yield new Promise((r)=>setTimeout(r, 25));
            }
            throw new TimeoutError("waitForFirstTopLevelPage (no top-level Page)", timeoutMs);
        });
    }
    waitForInitialTopLevelTargets(targetIds, timeoutMs = 3e3) {
        return __async(this, null, function*() {
            if (!targetIds.length) return;
            const pending = new Set(targetIds);
            const deadline = Date.now() + timeoutMs;
            while(pending.size && Date.now() < deadline){
                for (const tid of Array.from(pending)){
                    if (this.pagesByTarget.has(tid)) {
                        pending.delete(tid);
                    }
                }
                if (!pending.size) return;
                yield new Promise((r)=>setTimeout(r, 25));
            }
            if (pending.size) {
                v3Logger({
                    category: "ctx",
                    message: "Timed out waiting for existing top-level targets to attach",
                    level: 2,
                    auxiliary: {
                        remainingTargets: {
                            value: JSON.stringify(Array.from(pending)),
                            type: "object"
                        }
                    }
                });
            }
        });
    }
    ensurePiercer(session) {
        return __async(this, null, function*() {
            const key = this.sessionKey(session);
            if (this._piercerInstalled.has(key)) return true;
            const installed = yield installV3PiercerIntoSession(session);
            if (installed) {
                this._piercerInstalled.add(key);
            }
            return installed;
        });
    }
    /** Mark a page target as the most-recent one (active). */ _pushActive(tid) {
        const i = this._pageOrder.indexOf(tid);
        if (i !== -1) this._pageOrder.splice(i, 1);
        this._pageOrder.push(tid);
    }
    /** Remove a page target from the recency list (used on close). */ _removeFromOrder(tid) {
        const i = this._pageOrder.indexOf(tid);
        if (i !== -1) this._pageOrder.splice(i, 1);
    }
    /** Return the current active Page (most-recent page that still exists). */ activePage() {
        var _a;
        for(let i = this._pageOrder.length - 1; i >= 0; i--){
            const tid = this._pageOrder[i];
            const p = this.pagesByTarget.get(tid);
            if (p) return p;
            this._pageOrder.splice(i, 1);
        }
        let newestTid;
        let newestTs = -1;
        for (const [tid] of this.pagesByTarget){
            const ts = (_a = this.createdAtByTarget.get(tid)) != null ? _a : 0;
            if (ts > newestTs) {
                newestTs = ts;
                newestTid = tid;
            }
        }
        return newestTid ? this.pagesByTarget.get(newestTid) : void 0;
    }
    /** Explicitly mark a known Page as the most-recent active page (and focus it). */ setActivePage(page) {
        let targetId = page.targetId();
        if (this.pagesByTarget.get(targetId) !== page) {
            const lookup = this.findTargetIdByPage(page);
            if (!lookup) {
                v3Logger({
                    category: "ctx",
                    message: "setActivePage called with unknown Page",
                    level: 2,
                    auxiliary: {
                        targetId: {
                            value: String(targetId),
                            type: "string"
                        }
                    }
                });
                return;
            }
            targetId = lookup;
        }
        this._pushActive(targetId);
        void this.conn.send("Target.activateTarget", {
            targetId
        }).catch(()=>{});
    }
    /**
   * Return top-level `Page`s (oldest  newest). OOPIF targets are not included.
   */ pages() {
        var _a;
        const rows = [];
        for (const [tid, page] of this.pagesByTarget){
            if (this.typeByTarget.get(tid) === "page") {
                rows.push({
                    tid,
                    page,
                    created: (_a = this.createdAtByTarget.get(tid)) != null ? _a : 0
                });
            }
        }
        rows.sort((a, b)=>a.created - b.created);
        return rows.map((r)=>r.page);
    }
    /**
   * Resolve an owning `Page` by the **top-level main frame id**.
   * Note: child (OOPIF) roots are intentionally not present in this mapping.
   */ resolvePageByMainFrameId(frameId) {
        const targetId = this.mainFrameToTarget.get(frameId);
        return targetId ? this.pagesByTarget.get(targetId) : void 0;
    }
    /**
   * Serialize the full frame tree for a given top-level main frame id.
   */ getFullFrameTreeByMainFrameId(rootMainFrameId) {
        return __async(this, null, function*() {
            const owner = this.resolvePageByMainFrameId(rootMainFrameId);
            if (!owner) throw new PageNotFoundError(`mainFrameId=${rootMainFrameId}`);
            return owner.asProtocolFrameTree(rootMainFrameId);
        });
    }
    /**
   * Create a new top-level page (tab) with the given URL and return its Page object.
   * Waits until the target is attached and registered.
   */ newPage(url = "about:blank") {
        return __async(this, null, function*() {
            const { targetId } = yield this.conn.send("Target.createTarget", {
                url
            });
            this.pendingCreatedTargetUrl.set(targetId, url);
            yield this.conn.send("Target.activateTarget", {
                targetId
            }).catch(()=>{});
            const deadline = Date.now() + 5e3;
            while(Date.now() < deadline){
                const page = this.pagesByTarget.get(targetId);
                if (page) return page;
                yield new Promise((r)=>setTimeout(r, 25));
            }
            throw new TimeoutError(`newPage: target not attached (${targetId})`, 5e3);
        });
    }
    /**
   * Close CDP and clear all mappings. Best-effort cleanup.
   */ close() {
        return __async(this, null, function*() {
            yield this.conn.close();
            this.pagesByTarget.clear();
            this.mainFrameToTarget.clear();
            this.sessionOwnerPage.clear();
            this.frameOwnerPage.clear();
            this.pendingOopifByMainFrame.clear();
            this.createdAtByTarget.clear();
            this.typeByTarget.clear();
            this.pendingCreatedTargetUrl.clear();
        });
    }
    /**
   * Bootstrap target lifecycle:
   * - Attach to existing targets.
   * - Attach on `Target.targetCreated` (fallback for OOPIFs).
   * - Handle auto-attach events.
   * - Clean up on detach/destroy.
   */ bootstrap() {
        return __async(this, null, function*() {
            this.conn.on("Target.attachedToTarget", (evt)=>__async(this, null, function*() {
                    yield this.onAttachedToTarget(evt.targetInfo, evt.sessionId);
                }));
            this.conn.on("Target.detachedFromTarget", (evt)=>{
                var _a;
                this.onDetachedFromTarget(evt.sessionId, (_a = evt.targetId) != null ? _a : null);
            });
            this.conn.on("Target.targetDestroyed", (evt)=>{
                this.cleanupByTarget(evt.targetId);
            });
            this.conn.on("Target.targetCreated", (evt)=>__async(this, null, function*() {
                    const info = evt.targetInfo;
                    if (info.type === "worker" || info.type === "service_worker" || info.type === "shared_worker") {
                        return;
                    }
                    const ti = info;
                    if (info.type === "page" && ((ti == null ? void 0 : ti.openerId) || (ti == null ? void 0 : ti.openerFrameId))) {
                        this._notePopupSignal();
                    }
                    try {
                        yield this.conn.attachToTarget(info.targetId);
                    } catch (e) {}
                }));
            yield this.conn.enableAutoAttach();
            const targets = yield this.conn.getTargets();
            for (const t of targets){
                try {
                    yield this.conn.attachToTarget(t.targetId);
                } catch (e) {}
            }
            const topLevelTargetIds = targets.filter((t)=>isTopLevelPage(t)).map((t)=>t.targetId);
            yield this.waitForInitialTopLevelTargets(topLevelTargetIds);
        });
    }
    /**
   * Handle a newly attached target (top-level or potential OOPIF):
   * - Enable Page domain and lifecycle events.
   * - If top-level  create Page, wire listeners, resume.
   * - Else  probe child root frame id via `Page.getFrameTree` and adopt immediately
   *   if the parent is known; otherwise stage until parent `frameAttached`.
   * - Resume the target only after listeners are wired.
   */ onAttachedToTarget(info, sessionId) {
        return __async(this, null, function*() {
            var _a;
            const session = this.conn.getSession(sessionId);
            if (!session) return;
            if (this._sessionInit.has(sessionId)) return;
            this._sessionInit.add(sessionId);
            yield session.send("Runtime.runIfWaitingForDebugger").catch(()=>{});
            executionContexts.attachSession(session);
            const piercerReady = yield this.ensurePiercer(session);
            if (!piercerReady) return;
            yield session.send("Page.setLifecycleEventsEnabled", {
                enabled: true
            }).catch(()=>{});
            if (isTopLevelPage(info)) {
                const page = yield Page.create(this.conn, session, info.targetId, this.apiClient, this.localBrowserLaunchOptions, this.env === "BROWSERBASE");
                this.wireSessionToOwnerPage(sessionId, page);
                this.pagesByTarget.set(info.targetId, page);
                this.mainFrameToTarget.set(page.mainFrameId(), info.targetId);
                this.sessionOwnerPage.set(sessionId, page);
                this.frameOwnerPage.set(page.mainFrameId(), page);
                this.typeByTarget.set(info.targetId, "page");
                if (!this.createdAtByTarget.has(info.targetId)) {
                    this.createdAtByTarget.set(info.targetId, Date.now());
                }
                const pendingSeedUrl = this.pendingCreatedTargetUrl.get(info.targetId);
                this.pendingCreatedTargetUrl.delete(info.targetId);
                page.seedCurrentUrl((_a = pendingSeedUrl != null ? pendingSeedUrl : info.url) != null ? _a : "");
                this._pushActive(info.targetId);
                this.installFrameEventBridges(sessionId, page);
                return;
            }
            try {
                const { frameTree } = yield session.send("Page.getFrameTree");
                const childMainId = frameTree.frame.id;
                let owner = this.frameOwnerPage.get(childMainId);
                if (!owner) {
                    for (const p of this.pagesByTarget.values()){
                        const tree = p.asProtocolFrameTree(p.mainFrameId());
                        const has = function find(n) {
                            var _a2;
                            if (n.frame.id === childMainId) return true;
                            for (const c of (_a2 = n.childFrames) != null ? _a2 : [])if (find(c)) return true;
                            return false;
                        }(tree);
                        if (has) {
                            owner = p;
                            break;
                        }
                    }
                }
                if (owner) {
                    owner.adoptOopifSession(session, childMainId);
                    this.sessionOwnerPage.set(sessionId, owner);
                    this.installFrameEventBridges(sessionId, owner);
                    void executionContexts.waitForMainWorld(session, childMainId).catch(()=>{});
                } else {
                    this.pendingOopifByMainFrame.set(childMainId, sessionId);
                }
            } catch (e) {}
        });
    }
    /**
   * Detach handler:
   * - Remove child session ownership and prune its subtree.
   * - If a top-level target, cleanup its `Page` and mappings.
   * - Drop any staged child for this session.
   */ onDetachedFromTarget(sessionId, targetId) {
        const owner = this.sessionOwnerPage.get(sessionId);
        if (owner) {
            owner.detachOopifSession(sessionId);
            this.sessionOwnerPage.delete(sessionId);
        }
        if (targetId && this.pagesByTarget.has(targetId)) {
            this.cleanupByTarget(targetId);
        }
        for (const [fid, sid] of Array.from(this.pendingOopifByMainFrame.entries())){
            if (sid === sessionId) this.pendingOopifByMainFrame.delete(fid);
        }
    }
    /**
   * Cleanup a top-level Page by target id, removing its root and staged children.
   */ cleanupByTarget(targetId) {
        const page = this.pagesByTarget.get(targetId);
        if (!page) return;
        const mainId = page.mainFrameId();
        this.mainFrameToTarget.delete(mainId);
        this.frameOwnerPage.delete(mainId);
        for (const [sid, p] of Array.from(this.sessionOwnerPage.entries())){
            if (p === page) this.sessionOwnerPage.delete(sid);
        }
        for (const [fid] of Array.from(this.pendingOopifByMainFrame.entries())){
            const owner = this.frameOwnerPage.get(fid);
            if (!owner || owner === page) this.pendingOopifByMainFrame.delete(fid);
        }
        this._removeFromOrder(targetId);
        this.pagesByTarget.delete(targetId);
        this.createdAtByTarget.delete(targetId);
        this.typeByTarget.delete(targetId);
        this.pendingCreatedTargetUrl.delete(targetId);
    }
    /**
   * Wire Page-domain frame events for a session into the owning Page & mappings.
   * We forward the *emitting session* with every event so Page can stamp ownership precisely.
   */ installFrameEventBridges(sessionId, owner) {
        const session = this.conn.getSession(sessionId);
        if (!session) return;
        session.on("Page.frameAttached", (evt)=>{
            const { frameId, parentFrameId } = evt;
            owner.onFrameAttached(frameId, parentFrameId != null ? parentFrameId : null, session);
            const pendingChildSessionId = this.pendingOopifByMainFrame.get(frameId);
            if (pendingChildSessionId) {
                const child = this.conn.getSession(pendingChildSessionId);
                if (child) {
                    owner.adoptOopifSession(child, frameId);
                    this.sessionOwnerPage.set(child.id, owner);
                    this.installFrameEventBridges(pendingChildSessionId, owner);
                }
                this.pendingOopifByMainFrame.delete(frameId);
            }
            this.frameOwnerPage.set(frameId, owner);
            if (!parentFrameId) {
                const newRoot = owner.mainFrameId();
                const topTargetId = this.findTargetIdByPage(owner);
                if (topTargetId) {
                    this.mainFrameToTarget.set(newRoot, topTargetId);
                }
                this.frameOwnerPage.set(newRoot, owner);
            }
        });
        session.on("Page.frameDetached", (evt)=>{
            var _a;
            owner.onFrameDetached(evt.frameId, (_a = evt.reason) != null ? _a : "remove");
            if (evt.reason !== "swap") {
                this.frameOwnerPage.delete(evt.frameId);
            }
        });
        session.on("Page.frameNavigated", (evt)=>{
            owner.onFrameNavigated(evt.frame, session);
        });
        session.on("Page.navigatedWithinDocument", (evt)=>{
            owner.onNavigatedWithinDocument(evt.frameId, evt.url, session);
        });
        session.on("Page.windowOpen", ()=>{
            this._notePopupSignal();
        });
    }
    /**
   * Register that a session belongs to a Page (used by event routing).
   */ wireSessionToOwnerPage(sessionId, owner) {
        this.sessionOwnerPage.set(sessionId, owner);
    }
    /**
   * Utility: reverse-lookup the top-level target id that owns a given Page.
   */ findTargetIdByPage(page) {
        for (const [tid, p] of this.pagesByTarget){
            if (p === page) return tid;
        }
        return void 0;
    }
    _notePopupSignal() {
        this._lastPopupSignalAt = Date.now();
    }
    /**
   * Await the current active page, waiting briefly if a popup/open was just triggered.
   * Normal path returns immediately; popup path waits up to timeoutMs for the new page.
   */ awaitActivePage(timeoutMs) {
        return __async(this, null, function*() {
            var _a;
            const defaultTimeout = this.env === "BROWSERBASE" ? 4e3 : 2e3;
            timeoutMs = timeoutMs != null ? timeoutMs : defaultTimeout;
            const recentWindowMs = this.env === "BROWSERBASE" ? 1e3 : 300;
            const now2 = Date.now();
            const hasRecentPopup = now2 - this._lastPopupSignalAt <= recentWindowMs;
            const immediate = this.activePage();
            if (!hasRecentPopup && immediate) return immediate;
            const deadline = now2 + timeoutMs;
            while(Date.now() < deadline){
                let newestTid;
                let newestTs = -1;
                for (const [tid] of this.pagesByTarget){
                    const ts = (_a = this.createdAtByTarget.get(tid)) != null ? _a : 0;
                    if (ts > newestTs) {
                        newestTs = ts;
                        newestTid = tid;
                    }
                }
                if (newestTid) {
                    const p = this.pagesByTarget.get(newestTid);
                    if (p && newestTs >= this._lastPopupSignalAt) return p;
                }
                yield new Promise((r)=>setTimeout(r, 25));
            }
            if (immediate) return immediate;
            throw new PageNotFoundError("awaitActivePage: no page available");
        });
    }
};
// lib/modelUtils.ts
function splitModelName(model) {
    const firstSlashIndex = model.indexOf("/");
    const provider = model.substring(0, firstSlashIndex);
    const modelName = model.substring(firstSlashIndex + 1);
    return {
        provider,
        modelName
    };
}
function resolveModel(model) {
    const modelString = typeof model === "string" ? model : model.modelName;
    const clientOptions = typeof model === "string" ? {} : (()=>{
        const _a = model, { modelName: _ } = _a, rest = __objRest(_a, [
            "modelName"
        ]);
        return rest;
    })();
    const { provider, modelName: parsedModelName } = splitModelName(modelString);
    const isCua = AVAILABLE_CUA_MODELS.includes(modelString);
    return {
        provider,
        modelName: parsedModelName,
        clientOptions,
        isCua
    };
}
// lib/v3/api.ts
var import_fetch_cookie = __toESM(__turbopack_context__.r("[project]/node_modules/fetch-cookie/cjs/index.js [app-route] (ecmascript)"));
var import_zod_to_json_schema7 = __toESM(__turbopack_context__.r("[project]/node_modules/zod-to-json-schema/dist/cjs/index.js [app-route] (ecmascript)"));
init_version();
var StagehandAPIClient = class {
    constructor({ apiKey, projectId, logger }){
        this.apiKey = apiKey;
        this.projectId = projectId;
        this.logger = logger;
        this.fetchWithCookies = (0, import_fetch_cookie.default)(fetch);
    }
    init(_0) {
        return __async(this, arguments, function*({ modelName, modelApiKey, domSettleTimeoutMs, verbose, systemPrompt, selfHeal, browserbaseSessionCreateParams, browserbaseSessionID }) {
            var _a;
            if (!modelApiKey) {
                throw new StagehandAPIError("modelApiKey is required");
            }
            this.modelApiKey = modelApiKey;
            const region = browserbaseSessionCreateParams == null ? void 0 : browserbaseSessionCreateParams.region;
            if (region && region !== "us-west-2") {
                return {
                    sessionId: browserbaseSessionID != null ? browserbaseSessionID : null,
                    available: false
                };
            }
            this.logger({
                category: "init",
                message: "Creating new browserbase session...",
                level: 1
            });
            const sessionResponse = yield this.request("/sessions/start", {
                method: "POST",
                body: JSON.stringify({
                    modelName,
                    domSettleTimeoutMs,
                    verbose,
                    systemPrompt,
                    selfHeal,
                    browserbaseSessionCreateParams,
                    browserbaseSessionID
                })
            });
            if (sessionResponse.status === 401) {
                throw new StagehandAPIUnauthorizedError("Unauthorized. Ensure you provided a valid API key.");
            } else if (sessionResponse.status !== 200) {
                const errorText = yield sessionResponse.text();
                this.logger({
                    category: "api",
                    message: `API error (${sessionResponse.status}): ${errorText}`,
                    level: 0
                });
                throw new StagehandHttpError(`Unknown error: ${sessionResponse.status}`);
            }
            const sessionResponseBody = yield sessionResponse.json();
            if (sessionResponseBody.success === false) {
                throw new StagehandAPIError(sessionResponseBody.message);
            }
            this.sessionId = sessionResponseBody.data.sessionId;
            if (!((_a = sessionResponseBody.data) == null ? void 0 : _a.available) && browserbaseSessionID) {
                sessionResponseBody.data.sessionId = browserbaseSessionID;
            }
            return sessionResponseBody.data;
        });
    }
    act(_0) {
        return __async(this, arguments, function*({ input, options, frameId }) {
            const args = {
                input,
                frameId
            };
            if (options) {
                const _a = options, { page: _ } = _a, restOptions = __objRest(_a, [
                    "page"
                ]);
                if (Object.keys(restOptions).length > 0) {
                    args.options = restOptions;
                }
            }
            return this.execute({
                method: "act",
                args
            });
        });
    }
    extract(_0) {
        return __async(this, arguments, function*({ instruction, schema: zodSchema2, options, frameId }) {
            const jsonSchema2 = zodSchema2 ? (0, import_zod_to_json_schema7.default)(zodSchema2) : void 0;
            const args = {
                schema: jsonSchema2,
                instruction,
                frameId
            };
            if (options) {
                const _a = options, { page: _ } = _a, restOptions = __objRest(_a, [
                    "page"
                ]);
                if (Object.keys(restOptions).length > 0) {
                    args.options = restOptions;
                }
            }
            return this.execute({
                method: "extract",
                args
            });
        });
    }
    observe(_0) {
        return __async(this, arguments, function*({ instruction, options, frameId }) {
            const args = {
                instruction,
                frameId
            };
            if (options) {
                const _a = options, { page: _ } = _a, restOptions = __objRest(_a, [
                    "page"
                ]);
                if (Object.keys(restOptions).length > 0) {
                    args.options = restOptions;
                }
            }
            return this.execute({
                method: "observe",
                args
            });
        });
    }
    goto(url, options, frameId) {
        return __async(this, null, function*() {
            return this.execute({
                method: "navigate",
                args: {
                    url,
                    options,
                    frameId
                }
            });
        });
    }
    agentExecute(agentConfig, executeOptions, frameId) {
        return __async(this, null, function*() {
            if (agentConfig.integrations && agentConfig.integrations.length > 0) {
                throw new ExperimentalNotConfiguredError("MCP integrations");
            }
            if (typeof executeOptions === "object") {
                if (executeOptions.page) {
                    const _a = executeOptions, { page: _ } = _a, restOptions = __objRest(_a, [
                        "page"
                    ]);
                    executeOptions = restOptions;
                }
            }
            return this.execute({
                method: "agentExecute",
                args: {
                    agentConfig,
                    executeOptions,
                    frameId
                }
            });
        });
    }
    end() {
        return __async(this, null, function*() {
            const url = `/sessions/${this.sessionId}/end`;
            const response = yield this.request(url, {
                method: "POST"
            });
            return response;
        });
    }
    getReplayMetrics() {
        return __async(this, null, function*() {
            if (!this.sessionId) {
                throw new StagehandAPIError("sessionId is required to fetch metrics.");
            }
            const response = yield this.request(`/sessions/${this.sessionId}/replay`, {
                method: "GET"
            });
            if (response.status !== 200) {
                const errorText = yield response.text();
                this.logger({
                    category: "api",
                    message: `Failed to fetch metrics. Status ${response.status}: ${errorText}`,
                    level: 0
                });
                throw new StagehandHttpError(`Failed to fetch metrics with status ${response.status}: ${errorText}`);
            }
            const data = yield response.json();
            if (!data.success) {
                throw new StagehandAPIError(`Failed to fetch metrics: ${data.error || "Unknown error"}`);
            }
            const apiData = data.data || {};
            const metrics = {
                actPromptTokens: 0,
                actCompletionTokens: 0,
                actReasoningTokens: 0,
                actCachedInputTokens: 0,
                actInferenceTimeMs: 0,
                extractPromptTokens: 0,
                extractCompletionTokens: 0,
                extractReasoningTokens: 0,
                extractCachedInputTokens: 0,
                extractInferenceTimeMs: 0,
                observePromptTokens: 0,
                observeCompletionTokens: 0,
                observeReasoningTokens: 0,
                observeCachedInputTokens: 0,
                observeInferenceTimeMs: 0,
                agentPromptTokens: 0,
                agentCompletionTokens: 0,
                agentReasoningTokens: 0,
                agentCachedInputTokens: 0,
                agentInferenceTimeMs: 0,
                totalPromptTokens: 0,
                totalCompletionTokens: 0,
                totalReasoningTokens: 0,
                totalCachedInputTokens: 0,
                totalInferenceTimeMs: 0
            };
            const pages = apiData.pages || [];
            for (const page of pages){
                const actions = page.actions || [];
                for (const action of actions){
                    const method = (action.method || "").toLowerCase();
                    const tokenUsage = action.tokenUsage;
                    if (tokenUsage) {
                        const inputTokens = tokenUsage.inputTokens || 0;
                        const outputTokens = tokenUsage.outputTokens || 0;
                        const reasoningTokens = tokenUsage.reasoningTokens || 0;
                        const cachedInputTokens = tokenUsage.cachedInputTokens || 0;
                        const timeMs = tokenUsage.timeMs || 0;
                        if (method === "act") {
                            metrics.actPromptTokens += inputTokens;
                            metrics.actCompletionTokens += outputTokens;
                            metrics.actReasoningTokens += reasoningTokens;
                            metrics.actCachedInputTokens += cachedInputTokens;
                            metrics.actInferenceTimeMs += timeMs;
                        } else if (method === "extract") {
                            metrics.extractPromptTokens += inputTokens;
                            metrics.extractCompletionTokens += outputTokens;
                            metrics.extractReasoningTokens += reasoningTokens;
                            metrics.extractCachedInputTokens += cachedInputTokens;
                            metrics.extractInferenceTimeMs += timeMs;
                        } else if (method === "observe") {
                            metrics.observePromptTokens += inputTokens;
                            metrics.observeCompletionTokens += outputTokens;
                            metrics.observeReasoningTokens += reasoningTokens;
                            metrics.observeCachedInputTokens += cachedInputTokens;
                            metrics.observeInferenceTimeMs += timeMs;
                        } else if (method === "agent") {
                            metrics.agentPromptTokens += inputTokens;
                            metrics.agentCompletionTokens += outputTokens;
                            metrics.agentReasoningTokens += reasoningTokens;
                            metrics.agentCachedInputTokens += cachedInputTokens;
                            metrics.agentInferenceTimeMs += timeMs;
                        }
                        metrics.totalPromptTokens += inputTokens;
                        metrics.totalCompletionTokens += outputTokens;
                        metrics.totalReasoningTokens += reasoningTokens;
                        metrics.totalCachedInputTokens += cachedInputTokens;
                        metrics.totalInferenceTimeMs += timeMs;
                    }
                }
            }
            return metrics;
        });
    }
    execute(_0) {
        return __async(this, arguments, function*({ method, args, params }) {
            const urlParams = new URLSearchParams(params);
            const queryString = urlParams.toString();
            const url = `/sessions/${this.sessionId}/${method}${queryString ? `?${queryString}` : ""}`;
            const response = yield this.request(url, {
                method: "POST",
                body: JSON.stringify(args)
            });
            if (!response.ok) {
                const errorBody = yield response.text();
                throw new StagehandHttpError(`HTTP error! status: ${response.status}, body: ${errorBody}`);
            }
            if (!response.body) {
                throw new StagehandResponseBodyError();
            }
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = "";
            while(true){
                const { value, done } = yield reader.read();
                if (done && !buffer) {
                    throw new StagehandServerError("Stream ended without completion signal");
                }
                buffer += decoder.decode(value, {
                    stream: true
                });
                const lines = buffer.split("\n\n");
                buffer = lines.pop() || "";
                for (const line of lines){
                    if (!line.startsWith("data: ")) continue;
                    try {
                        const eventData = JSON.parse(line.slice(6));
                        if (eventData.type === "system") {
                            if (eventData.data.status === "error") {
                                throw new StagehandServerError(eventData.data.error);
                            }
                            if (eventData.data.status === "finished") {
                                return eventData.data.result;
                            }
                        } else if (eventData.type === "log") {
                            this.logger(eventData.data.message);
                        }
                    } catch (e) {
                        if (e instanceof StagehandServerError) {
                            throw e;
                        }
                        const errorMessage = e instanceof Error ? e.message : String(e);
                        this.logger({
                            category: "api",
                            message: `Failed to parse SSE event: ${errorMessage}`,
                            level: 0
                        });
                        throw new StagehandResponseParseError(`Failed to parse server response: ${errorMessage}`);
                    }
                }
                if (done) {
                    if (buffer.trim() && buffer.startsWith("data: ")) {
                        try {
                            const eventData = JSON.parse(buffer.slice(6));
                            if (eventData.type === "system" && eventData.data.status === "finished") {
                                return eventData.data.result;
                            }
                        } catch (e) {
                            this.logger({
                                category: "api",
                                message: `Incomplete data in final buffer: ${buffer.substring(0, 100)}`,
                                level: 0
                            });
                        }
                    }
                    throw new StagehandServerError("Stream ended without completion signal");
                }
            }
        });
    }
    request(path7, options) {
        return __async(this, null, function*() {
            var _a;
            const defaultHeaders = {
                "x-bb-api-key": this.apiKey,
                "x-bb-project-id": this.projectId,
                "x-bb-session-id": this.sessionId,
                // we want real-time logs, so we stream the response
                "x-stream-response": "true",
                "x-model-api-key": this.modelApiKey,
                "x-sent-at": /* @__PURE__ */ new Date().toISOString(),
                "x-language": "typescript",
                "x-sdk-version": STAGEHAND_VERSION
            };
            if (options.method === "POST" && options.body) {
                defaultHeaders["Content-Type"] = "application/json";
            }
            const response = yield this.fetchWithCookies(`${(_a = process.env.STAGEHAND_API_URL) != null ? _a : "https://api.stagehand.browserbase.com/v1"}${path7}`, __spreadProps(__spreadValues({}, options), {
                headers: __spreadValues(__spreadValues({}, defaultHeaders), options.headers)
            }));
            return response;
        });
    }
};
// lib/v3/v3.ts
var DEFAULT_MODEL_NAME = "openai/gpt-4.1-mini";
var DEFAULT_VIEWPORT = {
    width: 1288,
    height: 711
};
function resolveModelConfiguration(model) {
    if (!model) {
        return {
            modelName: DEFAULT_MODEL_NAME
        };
    }
    if (typeof model === "string") {
        return {
            modelName: model
        };
    }
    if (model && typeof model === "object") {
        const _a = model, { modelName } = _a, clientOptions = __objRest(_a, [
            "modelName"
        ]);
        if (!modelName) {
            throw new StagehandInvalidArgumentError("model.modelName is required when providing client options.");
        }
        return {
            modelName,
            clientOptions
        };
    }
    return {
        modelName: DEFAULT_MODEL_NAME
    };
}
import_dotenv.default.config({
    path: ".env"
});
var _V3 = class _V3 {
    constructor(opts){
        this.state = {
            kind: "UNINITIALIZED"
        };
        this.actHandler = null;
        this.extractHandler = null;
        this.observeHandler = null;
        this.ctx = null;
        this.overrideLlmClients = /* @__PURE__ */ new Map();
        this._isClosing = false;
        this._onCdpClosed = (why)=>{
            this._immediateShutdown(`CDP transport closed: ${why}`).catch(()=>{});
        };
        this.experimental = false;
        this.logInferenceToFile = false;
        this.disableAPI = false;
        this.verbose = 1;
        this._history = [];
        this.apiClient = null;
        this.stagehandMetrics = {
            actPromptTokens: 0,
            actCompletionTokens: 0,
            actReasoningTokens: 0,
            actCachedInputTokens: 0,
            actInferenceTimeMs: 0,
            extractPromptTokens: 0,
            extractCompletionTokens: 0,
            extractReasoningTokens: 0,
            extractCachedInputTokens: 0,
            extractInferenceTimeMs: 0,
            observePromptTokens: 0,
            observeCompletionTokens: 0,
            observeReasoningTokens: 0,
            observeCachedInputTokens: 0,
            observeInferenceTimeMs: 0,
            agentPromptTokens: 0,
            agentCompletionTokens: 0,
            agentReasoningTokens: 0,
            agentCachedInputTokens: 0,
            agentInferenceTimeMs: 0,
            totalPromptTokens: 0,
            totalCompletionTokens: 0,
            totalReasoningTokens: 0,
            totalCachedInputTokens: 0,
            totalInferenceTimeMs: 0
        };
        var _a, _b, _c, _d, _e, _f, _g;
        _V3._installProcessGuards();
        this.externalLogger = opts.logger;
        this.verbose = (_a = opts.verbose) != null ? _a : 1;
        this.instanceId = (_d = (_c = (_b = globalThis.crypto) == null ? void 0 : _b.randomUUID) == null ? void 0 : _c.call(_b)) != null ? _d : `${Date.now()}-${Math.floor(Math.random() * 1e9)}`;
        const loggerOptions = {
            pretty: true,
            level: "info"
        };
        if (opts.disablePino !== void 0) {
            loggerOptions.usePino = !opts.disablePino;
        }
        this.stagehandLogger = new StagehandLogger(loggerOptions, opts.logger);
        this.stagehandLogger.setVerbosity(this.verbose);
        try {
            if (this.externalLogger) {
                bindInstanceLogger(this.instanceId, this.externalLogger);
            } else {
                bindInstanceLogger(this.instanceId, (line)=>{
                    this.stagehandLogger.log(line);
                });
            }
        } catch (e) {}
        const { modelName, clientOptions } = resolveModelConfiguration(opts.model);
        this.modelName = modelName;
        this.experimental = (_e = opts.experimental) != null ? _e : false;
        this.logInferenceToFile = (_f = opts.logInferenceToFile) != null ? _f : false;
        this.llmProvider = new LLMProvider(this.logger);
        this.domSettleTimeoutMs = opts.domSettleTimeout;
        this.disableAPI = (_g = opts.disableAPI) != null ? _g : false;
        const baseClientOptions = clientOptions ? __spreadValues({}, clientOptions) : {};
        if (opts.llmClient) {
            this.llmClient = opts.llmClient;
            this.modelClientOptions = baseClientOptions;
            this.disableAPI = true;
        } else {
            let apiKey = baseClientOptions.apiKey;
            if (!apiKey) {
                try {
                    apiKey = loadApiKeyFromEnv(this.modelName.split("/")[0], // "openai", "anthropic", etc
                    this.logger);
                } catch (error) {
                    this.logger({
                        category: "init",
                        message: `Error loading API key for model ${this.modelName}: ${error}. Continuing without LLM client.`,
                        level: 0
                    });
                    throw error;
                }
            }
            this.modelClientOptions = __spreadProps(__spreadValues({}, baseClientOptions), {
                apiKey
            });
            this.llmClient = this.llmProvider.getClient(this.modelName, this.modelClientOptions);
        }
        this.cacheStorage = CacheStorage.create(opts.cacheDir, this.logger, {
            label: "cache directory"
        });
        this.actCache = new ActCache({
            storage: this.cacheStorage,
            logger: this.logger,
            getActHandler: ()=>this.actHandler,
            getDefaultLlmClient: ()=>this.resolveLlmClient(),
            domSettleTimeoutMs: this.domSettleTimeoutMs
        });
        this.agentCache = new AgentCache({
            storage: this.cacheStorage,
            logger: this.logger,
            getActHandler: ()=>this.actHandler,
            getContext: ()=>this.ctx,
            getDefaultLlmClient: ()=>this.resolveLlmClient(),
            getBaseModelName: ()=>this.modelName,
            getSystemPrompt: ()=>opts.systemPrompt,
            domSettleTimeoutMs: this.domSettleTimeoutMs,
            act: this.act.bind(this)
        });
        this.opts = opts;
        _V3._instances.add(this);
    }
    get browserbaseSessionID() {
        return this.browserbaseSessionId;
    }
    /**
   * Async property for metrics so callers can `await v3.metrics`.
   * When using API mode, fetches metrics from the API. Otherwise returns local metrics.
   */ get metrics() {
        if (this.apiClient) {
            return this.apiClient.getReplayMetrics().catch((error)=>{
                this.logger({
                    category: "metrics",
                    message: `Failed to fetch metrics from API: ${error}`,
                    level: 0
                });
                return this.stagehandMetrics;
            });
        }
        return Promise.resolve(this.stagehandMetrics);
    }
    resolveLlmClient(model) {
        if (!model) {
            return this.llmClient;
        }
        let modelName;
        let clientOptions;
        if (typeof model === "string") {
            modelName = model;
        } else {
            const _a = model, { modelName: overrideModelName } = _a, rest = __objRest(_a, [
                "modelName"
            ]);
            modelName = overrideModelName;
            clientOptions = rest;
        }
        if (modelName === this.modelName && (!clientOptions || Object.keys(clientOptions).length === 0)) {
            return this.llmClient;
        }
        const overrideProvider = String(modelName).split("/")[0];
        const baseProvider = String(this.modelName).split("/")[0];
        const mergedOptions = __spreadValues(__spreadValues({}, overrideProvider === baseProvider ? this.modelClientOptions : {}), clientOptions != null ? clientOptions : {});
        const providerKey = overrideProvider;
        if (!mergedOptions.apiKey) {
            const apiKey = loadApiKeyFromEnv(providerKey, this.logger);
            if (apiKey) {
                mergedOptions.apiKey = apiKey;
            }
        }
        const cacheKey = JSON.stringify({
            modelName,
            clientOptions: mergedOptions
        });
        const cached = this.overrideLlmClients.get(cacheKey);
        if (cached) {
            return cached;
        }
        const client = this.llmProvider.getClient(modelName, mergedOptions);
        this.overrideLlmClients.set(cacheKey, client);
        return client;
    }
    beginAgentReplayRecording() {
        this.agentCache.beginRecording();
    }
    endAgentReplayRecording() {
        return this.agentCache.endRecording();
    }
    discardAgentReplayRecording() {
        this.agentCache.discardRecording();
    }
    isAgentReplayRecording() {
        return this.agentCache.isRecording();
    }
    isAgentReplayActive() {
        return this.agentCache.isReplayActive();
    }
    recordAgentReplayStep(step) {
        this.agentCache.recordStep(step);
    }
    /**
   * Async property for history so callers can `await v3.history`.
   * Returns a frozen copy to avoid external mutation.
   */ get history() {
        return Promise.resolve(Object.freeze([
            ...this._history
        ]));
    }
    addToHistory(method, parameters, result) {
        this._history.push({
            method,
            parameters,
            result: result != null ? result : null,
            timestamp: /* @__PURE__ */ new Date().toISOString()
        });
    }
    updateMetrics(functionName, promptTokens, completionTokens, reasoningTokens, cachedInputTokens, inferenceTimeMs) {
        switch(functionName){
            case "ACT" /* ACT */ :
                this.stagehandMetrics.actPromptTokens += promptTokens;
                this.stagehandMetrics.actCompletionTokens += completionTokens;
                this.stagehandMetrics.actReasoningTokens += reasoningTokens;
                this.stagehandMetrics.actCachedInputTokens += cachedInputTokens;
                this.stagehandMetrics.actInferenceTimeMs += inferenceTimeMs;
                break;
            case "EXTRACT" /* EXTRACT */ :
                this.stagehandMetrics.extractPromptTokens += promptTokens;
                this.stagehandMetrics.extractCompletionTokens += completionTokens;
                this.stagehandMetrics.extractReasoningTokens += reasoningTokens;
                this.stagehandMetrics.extractCachedInputTokens += cachedInputTokens;
                this.stagehandMetrics.extractInferenceTimeMs += inferenceTimeMs;
                break;
            case "OBSERVE" /* OBSERVE */ :
                this.stagehandMetrics.observePromptTokens += promptTokens;
                this.stagehandMetrics.observeCompletionTokens += completionTokens;
                this.stagehandMetrics.observeReasoningTokens += reasoningTokens;
                this.stagehandMetrics.observeCachedInputTokens += cachedInputTokens;
                this.stagehandMetrics.observeInferenceTimeMs += inferenceTimeMs;
                break;
            case "AGENT" /* AGENT */ :
                this.stagehandMetrics.agentPromptTokens += promptTokens;
                this.stagehandMetrics.agentCompletionTokens += completionTokens;
                this.stagehandMetrics.agentReasoningTokens += reasoningTokens;
                this.stagehandMetrics.agentCachedInputTokens += cachedInputTokens;
                this.stagehandMetrics.agentInferenceTimeMs += inferenceTimeMs;
                break;
        }
        this.updateTotalMetrics(promptTokens, completionTokens, reasoningTokens, cachedInputTokens, inferenceTimeMs);
    }
    updateTotalMetrics(promptTokens, completionTokens, reasoningTokens, cachedInputTokens, inferenceTimeMs) {
        this.stagehandMetrics.totalPromptTokens += promptTokens;
        this.stagehandMetrics.totalCompletionTokens += completionTokens;
        this.stagehandMetrics.totalReasoningTokens += reasoningTokens;
        this.stagehandMetrics.totalCachedInputTokens += cachedInputTokens;
        this.stagehandMetrics.totalInferenceTimeMs += inferenceTimeMs;
    }
    _immediateShutdown(reason) {
        return __async(this, null, function*() {
            try {
                this.logger({
                    category: "v3",
                    message: `initiating shutdown \u2192 ${reason}`,
                    level: 0
                });
            } catch (e) {}
            try {
                this.logger({
                    category: "v3",
                    message: `closing resources \u2192 ${reason}`,
                    level: 0
                });
                yield this.close({
                    force: true
                });
            } catch (e) {}
        });
    }
    static _installProcessGuards() {
        if (_V3._processGuardsInstalled) return;
        _V3._processGuardsInstalled = true;
        const shutdownAllImmediate = (reason)=>__async(null, null, function*() {
                const instances2 = Array.from(_V3._instances);
                yield Promise.all(instances2.map((i)=>i._immediateShutdown(reason)));
            });
        import_process2.default.once("SIGINT", ()=>{
            v3Logger({
                category: "v3",
                message: "SIGINT: initiating shutdown",
                level: 0
            });
            for (const instance of _V3._instances){
                if (instance.apiClient) {
                    void instance.apiClient.end();
                    return;
                }
            }
            void shutdownAllImmediate("signal SIGINT");
        });
        import_process2.default.once("SIGTERM", ()=>{
            v3Logger({
                category: "v3",
                message: "SIGTERM: initiating shutdown",
                level: 0
            });
            for (const instance of _V3._instances){
                if (instance.apiClient) {
                    void instance.apiClient.end();
                    return;
                }
            }
            void shutdownAllImmediate("signal SIGTERM");
        });
        import_process2.default.once("uncaughtException", (err)=>{
            v3Logger({
                category: "v3",
                message: "uncaughtException",
                level: 0,
                auxiliary: {
                    err: {
                        value: String(err),
                        type: "string"
                    }
                }
            });
        });
        import_process2.default.once("unhandledRejection", (reason)=>{
            v3Logger({
                category: "v3",
                message: "unhandledRejection",
                level: 0,
                auxiliary: {
                    reason: {
                        value: String(reason),
                        type: "string"
                    }
                }
            });
        });
    }
    /**
   * Entrypoint: initializes handlers, launches Chrome or Browserbase,
   * and sets up a CDP context.
   */ init() {
        return __async(this, null, function*() {
            try {
                return yield withInstanceLogContext(this.instanceId, ()=>__async(this, null, function*() {
                        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
                        this.actHandler = new ActHandler(this.llmClient, this.modelName, this.modelClientOptions, (model)=>this.resolveLlmClient(model), (_a = this.opts.systemPrompt) != null ? _a : "", this.logInferenceToFile, (_b = this.opts.selfHeal) != null ? _b : true, (functionName, promptTokens, completionTokens, reasoningTokens, cachedInputTokens, inferenceTimeMs)=>this.updateMetrics(functionName, promptTokens, completionTokens, reasoningTokens, cachedInputTokens, inferenceTimeMs), this.domSettleTimeoutMs);
                        this.extractHandler = new ExtractHandler(this.llmClient, this.modelName, this.modelClientOptions, (model)=>this.resolveLlmClient(model), (_c = this.opts.systemPrompt) != null ? _c : "", this.logInferenceToFile, this.experimental, (functionName, promptTokens, completionTokens, reasoningTokens, cachedInputTokens, inferenceTimeMs)=>this.updateMetrics(functionName, promptTokens, completionTokens, reasoningTokens, cachedInputTokens, inferenceTimeMs));
                        this.observeHandler = new ObserveHandler(this.llmClient, this.modelName, this.modelClientOptions, (model)=>this.resolveLlmClient(model), (_d = this.opts.systemPrompt) != null ? _d : "", this.logInferenceToFile, this.experimental, (functionName, promptTokens, completionTokens, reasoningTokens, cachedInputTokens, inferenceTimeMs)=>this.updateMetrics(functionName, promptTokens, completionTokens, reasoningTokens, cachedInputTokens, inferenceTimeMs));
                        if (this.opts.env === "LOCAL") {
                            const envHeadless = import_process2.default.env.HEADLESS;
                            if (envHeadless !== void 0) {
                                const normalized = envHeadless.trim().toLowerCase();
                                if (normalized !== "true") {
                                    delete import_process2.default.env.HEADLESS;
                                }
                            }
                            const lbo = (_e = this.opts.localBrowserLaunchOptions) != null ? _e : {};
                            if (lbo.cdpUrl) {
                                this.logger({
                                    category: "init",
                                    message: "Connecting to local browser",
                                    level: 1
                                });
                                this.ctx = yield V3Context.create(lbo.cdpUrl, {
                                    env: "LOCAL"
                                });
                                this.ctx.conn.onTransportClosed(this._onCdpClosed);
                                this.state = {
                                    kind: "LOCAL",
                                    // no LaunchedChrome when attaching externally; create a stub kill
                                    chrome: {
                                        kill: ()=>__async(this, null, function*() {})
                                    },
                                    ws: lbo.cdpUrl
                                };
                                yield this._applyPostConnectLocalOptions(lbo);
                                return;
                            }
                            this.logger({
                                category: "init",
                                message: "Launching local browser",
                                level: 1
                            });
                            let userDataDir = lbo.userDataDir;
                            let createdTemp = false;
                            if (!userDataDir) {
                                const base = import_path6.default.join(import_os2.default.tmpdir(), "stagehand-v3");
                                import_fs7.default.mkdirSync(base, {
                                    recursive: true
                                });
                                userDataDir = import_fs7.default.mkdtempSync(import_path6.default.join(base, "profile-"));
                                createdTemp = true;
                            }
                            const defaults2 = [
                                "--remote-allow-origins=*",
                                "--no-first-run",
                                "--no-default-browser-check",
                                "--disable-dev-shm-usage",
                                "--site-per-process"
                            ];
                            let chromeFlags = [];
                            const ignore = lbo.ignoreDefaultArgs;
                            if (ignore === true) {
                                chromeFlags = [];
                            } else if (Array.isArray(ignore)) {
                                chromeFlags = defaults2.filter((f)=>!ignore.some((ex)=>f.includes(ex)));
                            } else {
                                chromeFlags = [
                                    ...defaults2
                                ];
                            }
                            if (lbo.devtools) chromeFlags.push("--auto-open-devtools-for-tabs");
                            if (lbo.locale) chromeFlags.push(`--lang=${lbo.locale}`);
                            if (!lbo.viewport) {
                                lbo.viewport = DEFAULT_VIEWPORT;
                            }
                            if (((_f = lbo.viewport) == null ? void 0 : _f.width) && ((_g = lbo.viewport) == null ? void 0 : _g.height)) {
                                chromeFlags.push(`--window-size=${lbo.viewport.width},${lbo.viewport.height + 87}`);
                            }
                            if (typeof lbo.deviceScaleFactor === "number") {
                                chromeFlags.push(`--force-device-scale-factor=${Math.max(0.1, lbo.deviceScaleFactor)}`);
                            }
                            if (lbo.hasTouch) chromeFlags.push("--touch-events=enabled");
                            if (lbo.ignoreHTTPSErrors) chromeFlags.push("--ignore-certificate-errors");
                            if ((_h = lbo.proxy) == null ? void 0 : _h.server) chromeFlags.push(`--proxy-server=${lbo.proxy.server}`);
                            if ((_i = lbo.proxy) == null ? void 0 : _i.bypass) chromeFlags.push(`--proxy-bypass-list=${lbo.proxy.bypass}`);
                            if (Array.isArray(lbo.args)) chromeFlags.push(...lbo.args);
                            const { ws, chrome } = yield launchLocalChrome({
                                chromePath: lbo.executablePath,
                                chromeFlags,
                                headless: lbo.headless,
                                userDataDir,
                                connectTimeoutMs: lbo.connectTimeoutMs
                            });
                            this.ctx = yield V3Context.create(ws, {
                                env: "LOCAL",
                                localBrowserLaunchOptions: lbo
                            });
                            this.ctx.conn.onTransportClosed(this._onCdpClosed);
                            this.state = {
                                kind: "LOCAL",
                                chrome,
                                ws,
                                userDataDir,
                                createdTempProfile: createdTemp,
                                preserveUserDataDir: !!lbo.preserveUserDataDir
                            };
                            this.browserbaseSessionId = void 0;
                            yield this._applyPostConnectLocalOptions(lbo);
                            return;
                        }
                        if (this.opts.env === "BROWSERBASE") {
                            const { apiKey, projectId } = this.requireBrowserbaseCreds();
                            if (!apiKey || !projectId) {
                                throw new MissingEnvironmentVariableError("BROWSERBASE_API_KEY and BROWSERBASE_PROJECT_ID", "Browserbase environment");
                            }
                            this.logger({
                                category: "init",
                                message: "Starting browserbase session",
                                level: 1
                            });
                            if (!this.disableAPI && !this.experimental) {
                                this.apiClient = new StagehandAPIClient({
                                    apiKey,
                                    projectId,
                                    logger: this.logger
                                });
                                const createSessionPayload = __spreadProps(__spreadValues({
                                    projectId: (_k = (_j = this.opts.browserbaseSessionCreateParams) == null ? void 0 : _j.projectId) != null ? _k : projectId
                                }, this.opts.browserbaseSessionCreateParams), {
                                    browserSettings: __spreadProps(__spreadValues({}, (_m = (_l = this.opts.browserbaseSessionCreateParams) == null ? void 0 : _l.browserSettings) != null ? _m : {}), {
                                        viewport: (_p = (_o = (_n = this.opts.browserbaseSessionCreateParams) == null ? void 0 : _n.browserSettings) == null ? void 0 : _o.viewport) != null ? _p : {
                                            width: 1288,
                                            height: 711
                                        }
                                    }),
                                    userMetadata: __spreadProps(__spreadValues({}, (_r = (_q = this.opts.browserbaseSessionCreateParams) == null ? void 0 : _q.userMetadata) != null ? _r : {}), {
                                        stagehand: "true"
                                    })
                                });
                                const { sessionId: sessionId2, available } = yield this.apiClient.init({
                                    modelName: this.modelName,
                                    modelApiKey: this.modelClientOptions.apiKey,
                                    domSettleTimeoutMs: this.domSettleTimeoutMs,
                                    verbose: this.verbose,
                                    systemPrompt: this.opts.systemPrompt,
                                    selfHeal: this.opts.selfHeal,
                                    browserbaseSessionCreateParams: createSessionPayload,
                                    browserbaseSessionID: this.opts.browserbaseSessionID
                                });
                                if (!available) {
                                    this.apiClient = null;
                                }
                                this.opts.browserbaseSessionID = sessionId2;
                            }
                            const { ws, sessionId, bb } = yield createBrowserbaseSession(apiKey, projectId, this.opts.browserbaseSessionCreateParams, this.opts.browserbaseSessionID);
                            this.ctx = yield V3Context.create(ws, {
                                env: "BROWSERBASE",
                                apiClient: this.apiClient
                            });
                            this.ctx.conn.onTransportClosed(this._onCdpClosed);
                            this.state = {
                                kind: "BROWSERBASE",
                                sessionId,
                                ws,
                                bb
                            };
                            this.browserbaseSessionId = sessionId;
                            yield this._ensureBrowserbaseDownloadsEnabled();
                            try {
                                const resumed = !!this.opts.browserbaseSessionID;
                                let debugUrl;
                                try {
                                    const dbg = yield bb.sessions.debug(sessionId);
                                    debugUrl = dbg == null ? void 0 : dbg.debuggerUrl;
                                } catch (e) {}
                                const sessionUrl = `https://www.browserbase.com/sessions/${sessionId}`;
                                this.logger({
                                    category: "init",
                                    message: resumed ? this.apiClient ? "Browserbase session started" : "Browserbase session resumed" : "Browserbase session started",
                                    level: 1,
                                    auxiliary: __spreadProps(__spreadValues({
                                        sessionUrl: {
                                            value: sessionUrl,
                                            type: "string"
                                        }
                                    }, debugUrl && {
                                        debugUrl: {
                                            value: debugUrl,
                                            type: "string"
                                        }
                                    }), {
                                        sessionId: {
                                            value: sessionId,
                                            type: "string"
                                        }
                                    })
                                });
                            } catch (e) {}
                            return;
                        }
                        const neverEnv = this.opts.env;
                        throw new StagehandInitError(`Unsupported env: ${neverEnv}`);
                    }));
            } catch (error) {
                if (this.externalLogger) {
                    try {
                        unbindInstanceLogger(this.instanceId);
                    } catch (e) {}
                }
                throw error;
            }
        });
    }
    /** Apply post-connect local browser options that require CDP. */ _applyPostConnectLocalOptions(lbo) {
        return __async(this, null, function*() {
            var _a;
            try {
                if (lbo.downloadsPath || lbo.acceptDownloads !== void 0) {
                    const behavior = lbo.acceptDownloads === false ? "deny" : "allow";
                    yield (_a = this.ctx) == null ? void 0 : _a.conn.send("Browser.setDownloadBehavior", {
                        behavior,
                        downloadPath: lbo.downloadsPath,
                        eventsEnabled: true
                    }).catch(()=>{});
                }
            } catch (e) {}
        });
    }
    _ensureBrowserbaseDownloadsEnabled() {
        return __async(this, null, function*() {
            var _a;
            const conn = (_a = this.ctx) == null ? void 0 : _a.conn;
            if (!conn) return;
            try {
                yield conn.send("Browser.setDownloadBehavior", {
                    behavior: "allow",
                    downloadPath: "downloads",
                    eventsEnabled: true
                });
            } catch (e) {}
        });
    }
    act(input, options) {
        return __async(this, null, function*() {
            return yield withInstanceLogContext(this.instanceId, ()=>__async(this, null, function*() {
                    if (!this.actHandler) throw new StagehandNotInitializedError("act()");
                    let actResult;
                    if (isObserveResult(input)) {
                        const v3Page = yield this.resolvePage(options == null ? void 0 : options.page);
                        const selector = input.selector;
                        if (this.apiClient) {
                            actResult = yield this.apiClient.act({
                                input,
                                options,
                                frameId: v3Page.mainFrameId()
                            });
                        } else {
                            actResult = yield this.actHandler.actFromObserveResult(__spreadProps(__spreadValues({}, input), {
                                selector
                            }), // ObserveResult
                            v3Page, // V3 Page
                            this.domSettleTimeoutMs, this.resolveLlmClient(options == null ? void 0 : options.model));
                        }
                        this.addToHistory("act", {
                            observeResult: input
                        }, actResult);
                        return actResult;
                    }
                    if (typeof input !== "string" || !input.trim()) {
                        throw new StagehandInvalidArgumentError("act(): instruction string is required unless passing an Action");
                    }
                    const page = yield this.resolvePage(options == null ? void 0 : options.page);
                    let actCacheContext = null;
                    const canUseCache = typeof input === "string" && !this.isAgentReplayRecording() && this.actCache.enabled;
                    if (canUseCache) {
                        actCacheContext = yield this.actCache.prepareContext(input, page, options == null ? void 0 : options.variables);
                        if (actCacheContext) {
                            const cachedResult = yield this.actCache.tryReplay(actCacheContext, page, options == null ? void 0 : options.timeout);
                            if (cachedResult) {
                                this.addToHistory("act", {
                                    instruction: input,
                                    variables: options == null ? void 0 : options.variables,
                                    timeout: options == null ? void 0 : options.timeout,
                                    cacheHit: true
                                }, cachedResult);
                                return cachedResult;
                            }
                        }
                    }
                    const handlerParams = {
                        instruction: input,
                        page,
                        variables: options == null ? void 0 : options.variables,
                        timeout: options == null ? void 0 : options.timeout,
                        model: options == null ? void 0 : options.model
                    };
                    if (this.apiClient) {
                        const frameId = page.mainFrameId();
                        actResult = yield this.apiClient.act({
                            input,
                            options,
                            frameId
                        });
                    } else {
                        actResult = yield this.actHandler.act(handlerParams);
                    }
                    this.addToHistory("act", {
                        instruction: input,
                        variables: options == null ? void 0 : options.variables,
                        timeout: options == null ? void 0 : options.timeout
                    }, actResult);
                    if (actCacheContext && actResult.success && Array.isArray(actResult.actions) && actResult.actions.length > 0) {
                        yield this.actCache.store(actCacheContext, actResult);
                    }
                    return actResult;
                }));
        });
    }
    extract(a, b, c) {
        return __async(this, null, function*() {
            return yield withInstanceLogContext(this.instanceId, ()=>__async(this, null, function*() {
                    if (!this.extractHandler) {
                        throw new StagehandNotInitializedError("extract()");
                    }
                    let instruction;
                    let schema;
                    let options;
                    if (typeof a === "string") {
                        instruction = a;
                        const isZodSchema = (val)=>!!val && typeof val === "object" && "parse" in val && "safeParse" in val;
                        if (isZodSchema(b)) {
                            schema = b;
                            options = c;
                        } else {
                            options = b;
                        }
                    } else {
                        options = a || void 0;
                    }
                    if (!instruction && schema) {
                        throw new StagehandInvalidArgumentError("extract(): schema provided without instruction");
                    }
                    const effectiveSchema = instruction && !schema ? defaultExtractSchema : schema;
                    const page = yield this.resolvePage(options == null ? void 0 : options.page);
                    const handlerParams = {
                        instruction,
                        schema: effectiveSchema,
                        model: options == null ? void 0 : options.model,
                        timeout: options == null ? void 0 : options.timeout,
                        selector: options == null ? void 0 : options.selector,
                        page
                    };
                    let result;
                    if (this.apiClient) {
                        const frameId = page.mainFrameId();
                        result = yield this.apiClient.extract({
                            instruction: handlerParams.instruction,
                            schema: handlerParams.schema,
                            options,
                            frameId
                        });
                    } else {
                        result = yield this.extractHandler.extract(handlerParams);
                    }
                    return result;
                }));
        });
    }
    observe(a, b) {
        return __async(this, null, function*() {
            return yield withInstanceLogContext(this.instanceId, ()=>__async(this, null, function*() {
                    if (!this.observeHandler) {
                        throw new StagehandNotInitializedError("observe()");
                    }
                    let instruction;
                    let options;
                    if (typeof a === "string") {
                        instruction = a;
                        options = b;
                    } else {
                        options = a;
                    }
                    const page = yield this.resolvePage(options == null ? void 0 : options.page);
                    const handlerParams = {
                        instruction,
                        model: options == null ? void 0 : options.model,
                        timeout: options == null ? void 0 : options.timeout,
                        selector: options == null ? void 0 : options.selector,
                        page
                    };
                    let results;
                    if (this.apiClient) {
                        const frameId = page.mainFrameId();
                        results = yield this.apiClient.observe({
                            instruction,
                            options,
                            frameId
                        });
                    } else {
                        results = yield this.observeHandler.observe(handlerParams);
                    }
                    this.addToHistory("observe", {
                        instruction,
                        timeout: options == null ? void 0 : options.timeout
                    }, results);
                    return results;
                }));
        });
    }
    /** Return the browser-level CDP WebSocket endpoint. */ connectURL() {
        if (this.state.kind === "UNINITIALIZED") {
            throw new StagehandNotInitializedError("connectURL()");
        }
        return this.state.ws;
    }
    /** Expose the current CDP-backed context. */ get context() {
        return this.ctx;
    }
    /** Best-effort cleanup of context and launched resources. */ close(opts) {
        return __async(this, null, function*() {
            var _a, _b, _c, _d;
            if (this.apiClient) {
                yield this.apiClient.end();
            }
            if (this._isClosing && !(opts == null ? void 0 : opts.force)) return;
            this._isClosing = true;
            try {
                try {
                    if (((_a = this.ctx) == null ? void 0 : _a.conn) && this._onCdpClosed) {
                        (_c = (_b = this.ctx.conn).offTransportClosed) == null ? void 0 : _c.call(_b, this._onCdpClosed);
                    }
                } catch (e) {}
                try {
                    yield (_d = this.ctx) == null ? void 0 : _d.close();
                } catch (e) {}
                if (this.state.kind === "LOCAL") {
                    try {
                        yield this.state.chrome.kill();
                    } catch (e) {}
                    try {
                        if (this.state.createdTempProfile && !this.state.preserveUserDataDir && this.state.userDataDir) {
                            import_fs7.default.rmSync(this.state.userDataDir, {
                                recursive: true,
                                force: true
                            });
                        }
                    } catch (e) {}
                }
            } finally{
                this.state = {
                    kind: "UNINITIALIZED"
                };
                this.ctx = null;
                this._isClosing = false;
                this.browserbaseSessionId = void 0;
                try {
                    unbindInstanceLogger(this.instanceId);
                } catch (e) {}
                _V3._instances.delete(this);
            }
        });
    }
    /** Guard: ensure Browserbase credentials exist in options. */ requireBrowserbaseCreds() {
        var _a, _b;
        let { apiKey, projectId } = this.opts;
        if (!apiKey) apiKey = (_a = import_process2.default.env.BROWSERBASE_API_KEY) != null ? _a : import_process2.default.env.BB_API_KEY;
        if (!projectId) projectId = (_b = import_process2.default.env.BROWSERBASE_PROJECT_ID) != null ? _b : import_process2.default.env.BB_PROJECT_ID;
        if (!apiKey || !projectId) {
            const missing = [];
            if (!apiKey) missing.push("BROWSERBASE_API_KEY");
            if (!projectId) missing.push("BROWSERBASE_PROJECT_ID");
            throw new MissingEnvironmentVariableError(missing.join(", "), "Browserbase");
        }
        this.opts.apiKey = apiKey;
        this.opts.projectId = projectId;
        this.logger({
            category: "init",
            message: "Using Browserbase credentials",
            level: 1
        });
        return {
            apiKey,
            projectId
        };
    }
    get logger() {
        return (logLine)=>{
            var _a;
            const line = __spreadProps(__spreadValues({}, logLine), {
                level: (_a = logLine.level) != null ? _a : 1
            });
            this.stagehandLogger.log(line);
        };
    }
    /**
   * Normalize a Playwright/Puppeteer page object into its top frame id,
   * so handlers can resolve it to a `Page` within our V3Context.
   */ resolveTopFrameId(page) {
        return __async(this, null, function*() {
            if (this.isPlaywrightPage(page)) {
                const cdp = yield page.context().newCDPSession(page);
                const { frameTree } = yield cdp.send("Page.getFrameTree");
                return frameTree.frame.id;
            }
            if (this.isPatchrightPage(page)) {
                const cdp = yield page.context().newCDPSession(page);
                const { frameTree } = yield cdp.send("Page.getFrameTree");
                return frameTree.frame.id;
            }
            if (this.isPuppeteerPage(page)) {
                const cdp = yield page.target().createCDPSession();
                const { frameTree } = yield cdp.send("Page.getFrameTree");
                this.logger({
                    category: "v3",
                    message: "Puppeteer frame id",
                    level: 2,
                    auxiliary: {
                        frameId: {
                            value: frameTree.frame.id,
                            type: "string"
                        }
                    }
                });
                return frameTree.frame.id;
            }
            throw new StagehandInvalidArgumentError("Unsupported page object passed to V3.act()");
        });
    }
    isPlaywrightPage(p) {
        return typeof p === "object" && p !== null && typeof p.context === "function";
    }
    isPatchrightPage(p) {
        return typeof p === "object" && p !== null && typeof p.context === "function";
    }
    isPuppeteerPage(p) {
        return typeof p === "object" && p !== null && typeof p.target === "function";
    }
    /** Resolve an external page reference or fall back to the active V3 page. */ resolvePage(page) {
        return __async(this, null, function*() {
            if (page) {
                return yield this.normalizeToV3Page(page);
            }
            const ctx = this.ctx;
            if (!ctx) {
                throw new StagehandNotInitializedError("resolvePage()");
            }
            return yield ctx.awaitActivePage();
        });
    }
    normalizeToV3Page(input) {
        return __async(this, null, function*() {
            if (input instanceof (yield Promise.resolve().then(()=>(init_page(), page_exports))).Page) {
                return input;
            }
            if (this.isPlaywrightPage(input)) {
                const frameId = yield this.resolveTopFrameId(input);
                const page = this.ctx.resolvePageByMainFrameId(frameId);
                if (!page) throw new StagehandInitError("Failed to resolve V3 Page from Playwright page.");
                return page;
            }
            if (this.isPatchrightPage(input)) {
                const frameId = yield this.resolveTopFrameId(input);
                const page = this.ctx.resolvePageByMainFrameId(frameId);
                if (!page) throw new StagehandInitError("Failed to resolve V3 Page from Patchright page.");
                return page;
            }
            if (this.isPuppeteerPage(input)) {
                const frameId = yield this.resolveTopFrameId(input);
                const page = this.ctx.resolvePageByMainFrameId(frameId);
                if (!page) throw new StagehandInitError("Failed to resolve V3 Page from Puppeteer page.");
                return page;
            }
            throw new StagehandInvalidArgumentError("Unsupported page object.");
        });
    }
    /**
   * Create a v3 agent instance (AISDK tool-based) with execute().
   * Mirrors the v2 Stagehand.agent() tool mode (no CUA provider here).
   */ agent(options) {
        var _a, _b;
        this.logger({
            category: "agent",
            message: `Creating v3 agent instance with options: ${JSON.stringify(options)}`,
            level: 1,
            auxiliary: __spreadValues({
                cua: {
                    value: (options == null ? void 0 : options.cua) ? "true" : "false",
                    type: "boolean"
                },
                model: (options == null ? void 0 : options.model) ? typeof (options == null ? void 0 : options.model) === "string" ? {
                    value: options.model,
                    type: "string"
                } : {
                    value: options.model.modelName,
                    type: "string"
                } : {
                    value: this.llmClient.modelName,
                    type: "string"
                },
                systemPrompt: {
                    value: (_a = options == null ? void 0 : options.systemPrompt) != null ? _a : "",
                    type: "string"
                },
                tools: {
                    value: JSON.stringify((_b = options == null ? void 0 : options.tools) != null ? _b : {}),
                    type: "object"
                }
            }, (options == null ? void 0 : options.integrations) && {
                integrations: {
                    value: JSON.stringify(options.integrations),
                    type: "object"
                }
            })
        });
        if (options == null ? void 0 : options.cua) {
            if (((options == null ? void 0 : options.integrations) || (options == null ? void 0 : options.tools)) && !this.experimental) {
                throw new ExperimentalNotConfiguredError("MCP integrations and custom tools");
            }
            const modelToUse = (options == null ? void 0 : options.model) || __spreadValues({
                modelName: this.modelName
            }, this.modelClientOptions);
            const { modelName, isCua, clientOptions } = resolveModel(modelToUse);
            if (!isCua) {
                throw new CuaModelRequiredError(AVAILABLE_CUA_MODELS);
            }
            const agentConfigSignature2 = this.agentCache.buildConfigSignature(options);
            return {
                execute: (instructionOrOptions)=>__async(this, null, function*() {
                        return withInstanceLogContext(this.instanceId, ()=>__async(this, null, function*() {
                                var _a2, _b2;
                                if ((options == null ? void 0 : options.integrations) && !this.experimental) {
                                    throw new ExperimentalNotConfiguredError("MCP integrations");
                                }
                                const tools = (options == null ? void 0 : options.integrations) ? yield resolveTools(options.integrations, options.tools) : (_a2 = options == null ? void 0 : options.tools) != null ? _a2 : {};
                                const handler = new V3CuaAgentHandler(this, this.logger, {
                                    modelName,
                                    clientOptions,
                                    userProvidedInstructions: (_b2 = options.systemPrompt) != null ? _b2 : `You are a helpful assistant that can use a web browser.
Do not ask follow up questions, the user will trust your judgement.`
                                }, tools);
                                const resolvedOptions = typeof instructionOrOptions === "string" ? {
                                    instruction: instructionOrOptions
                                } : instructionOrOptions;
                                if (resolvedOptions.page) {
                                    const normalizedPage = yield this.normalizeToV3Page(resolvedOptions.page);
                                    this.ctx.setActivePage(normalizedPage);
                                }
                                const instruction = resolvedOptions.instruction.trim();
                                const sanitizedOptions = this.agentCache.sanitizeExecuteOptions(resolvedOptions);
                                let cacheContext = null;
                                if (this.agentCache.shouldAttemptCache(instruction)) {
                                    const startPage = yield this.ctx.awaitActivePage();
                                    cacheContext = yield this.agentCache.prepareContext({
                                        instruction,
                                        options: sanitizedOptions,
                                        configSignature: agentConfigSignature2,
                                        page: startPage
                                    });
                                    if (cacheContext) {
                                        const replayed = yield this.agentCache.tryReplay(cacheContext);
                                        if (replayed) {
                                            return replayed;
                                        }
                                    }
                                }
                                let agentSteps = [];
                                const recording = !!cacheContext;
                                if (recording) {
                                    this.beginAgentReplayRecording();
                                }
                                let result;
                                try {
                                    if (this.apiClient && !this.experimental) {
                                        const page = yield this.ctx.awaitActivePage();
                                        result = yield this.apiClient.agentExecute(options, resolvedOptions, page.mainFrameId());
                                    } else {
                                        result = yield handler.execute(instructionOrOptions);
                                    }
                                    if (recording) {
                                        agentSteps = this.endAgentReplayRecording();
                                    }
                                    if (cacheContext && result.success && agentSteps.length > 0) {
                                        yield this.agentCache.store(cacheContext, agentSteps, result);
                                    }
                                    return result;
                                } catch (err) {
                                    if (recording) this.discardAgentReplayRecording();
                                    throw err;
                                } finally{
                                    if (recording) {
                                        this.discardAgentReplayRecording();
                                    }
                                }
                            }));
                    })
            };
        }
        const agentConfigSignature = this.agentCache.buildConfigSignature(options);
        return {
            execute: (instructionOrOptions)=>__async(this, null, function*() {
                    return withInstanceLogContext(this.instanceId, ()=>__async(this, null, function*() {
                            var _a2, _b2;
                            if (((options == null ? void 0 : options.integrations) || (options == null ? void 0 : options.tools)) && !this.experimental) {
                                throw new ExperimentalNotConfiguredError("MCP integrations and custom tools");
                            }
                            const tools = (options == null ? void 0 : options.integrations) ? yield resolveTools(options.integrations, options.tools) : (_a2 = options == null ? void 0 : options.tools) != null ? _a2 : {};
                            const agentLlmClient = (options == null ? void 0 : options.model) ? this.resolveLlmClient(options.model) : this.llmClient;
                            const handler = new V3AgentHandler(this, this.logger, agentLlmClient, typeof (options == null ? void 0 : options.executionModel) === "string" ? options.executionModel : (_b2 = options == null ? void 0 : options.executionModel) == null ? void 0 : _b2.modelName, options == null ? void 0 : options.systemPrompt, tools);
                            const resolvedOptions = typeof instructionOrOptions === "string" ? {
                                instruction: instructionOrOptions
                            } : instructionOrOptions;
                            if (resolvedOptions.page) {
                                const normalizedPage = yield this.normalizeToV3Page(resolvedOptions.page);
                                this.ctx.setActivePage(normalizedPage);
                            }
                            const instruction = resolvedOptions.instruction.trim();
                            const sanitizedOptions = this.agentCache.sanitizeExecuteOptions(resolvedOptions);
                            let cacheContext = null;
                            if (this.agentCache.shouldAttemptCache(instruction)) {
                                const startPage = yield this.ctx.awaitActivePage();
                                cacheContext = yield this.agentCache.prepareContext({
                                    instruction,
                                    options: sanitizedOptions,
                                    configSignature: agentConfigSignature,
                                    page: startPage
                                });
                                if (cacheContext) {
                                    const replayed = yield this.agentCache.tryReplay(cacheContext);
                                    if (replayed) {
                                        return replayed;
                                    }
                                }
                            }
                            let agentSteps = [];
                            const recording = !!cacheContext;
                            if (recording) {
                                this.beginAgentReplayRecording();
                            }
                            let result;
                            try {
                                if (this.apiClient && !this.experimental) {
                                    const page = yield this.ctx.awaitActivePage();
                                    result = yield this.apiClient.agentExecute(options, resolvedOptions, page.mainFrameId());
                                } else {
                                    result = yield handler.execute(instructionOrOptions);
                                }
                                if (recording) {
                                    agentSteps = this.endAgentReplayRecording();
                                }
                                if (cacheContext && result.success && agentSteps.length > 0) {
                                    yield this.agentCache.store(cacheContext, agentSteps, result);
                                }
                                return result;
                            } catch (err) {
                                if (recording) this.discardAgentReplayRecording();
                                throw err;
                            } finally{
                                if (recording) {
                                    this.discardAgentReplayRecording();
                                }
                            }
                        }));
                })
        };
    }
};
_V3._processGuardsInstalled = false;
_V3._instances = /* @__PURE__ */ new Set();
var V3 = _V3;
function isObserveResult(v) {
    return !!v && typeof v === "object" && "selector" in v;
}
// lib/v3Evaluator.ts
var import_dotenv2 = __toESM(__turbopack_context__.r("[project]/node_modules/dotenv/lib/main.js [app-route] (ecmascript)"));
var import_v318 = __turbopack_context__.r("[project]/node_modules/zod/dist/cjs/index.js [app-route] (ecmascript)");
init_sdkErrors();
import_dotenv2.default.config();
var EvaluationSchema = import_v318.z.object({
    evaluation: import_v318.z.enum([
        "YES",
        "NO"
    ]),
    reasoning: import_v318.z.string()
});
var BatchEvaluationSchema = import_v318.z.array(EvaluationSchema);
var V3Evaluator = class {
    constructor(v3, modelName, modelClientOptions){
        this.silentLogger = ()=>{};
        this.v3 = v3;
        this.modelName = modelName || "google/gemini-2.5-flash";
        this.modelClientOptions = modelClientOptions || {
            apiKey: process.env.GEMINI_API_KEY || process.env.GOOGLE_GENERATIVE_AI_API_KEY || ""
        };
    }
    getClient() {
        const provider = new LLMProvider(this.v3.logger);
        return provider.getClient(this.modelName, this.modelClientOptions);
    }
    ask(options) {
        return __async(this, null, function*() {
            const { question, answer, screenshot = true, systemPrompt, screenshotDelayMs = 250, agentReasoning } = options;
            if (!question) throw new StagehandInvalidArgumentError("Question cannot be an empty string");
            if (!answer && !screenshot) throw new StagehandInvalidArgumentError("Either answer (text) or screenshot must be provided");
            if (Array.isArray(screenshot)) {
                return this._evaluateWithMultipleScreenshots({
                    question,
                    screenshots: screenshot,
                    systemPrompt,
                    agentReasoning
                });
            }
            const defaultSystemPrompt = `You are an expert evaluator that confidently returns YES or NO based on if the original goal was achieved. You have access to  ${screenshot ? "a screenshot" : "the agents reasoning and actions throughout the task"} that you can use to evaluate the tasks completion. Provide detailed reasoning for your answer.
          Today's date is ${/* @__PURE__ */ new Date().toLocaleDateString()}`;
            yield new Promise((r)=>setTimeout(r, screenshotDelayMs));
            let imageBuffer;
            if (screenshot) {
                const page = yield this.v3.context.awaitActivePage();
                imageBuffer = yield page.screenshot({
                    fullPage: false
                });
            }
            const llmClient = this.getClient();
            const response = yield llmClient.createChatCompletion({
                logger: this.silentLogger,
                options: {
                    messages: [
                        {
                            role: "system",
                            content: systemPrompt || defaultSystemPrompt
                        },
                        {
                            role: "user",
                            content: [
                                {
                                    type: "text",
                                    text: agentReasoning ? `Question: ${question}

Agent's reasoning and actions taken:
${agentReasoning}` : question
                                },
                                ...screenshot && imageBuffer ? [
                                    {
                                        type: "image_url",
                                        image_url: {
                                            url: `data:image/jpeg;base64,${imageBuffer.toString("base64")}`
                                        }
                                    }
                                ] : [],
                                ...answer ? [
                                    {
                                        type: "text",
                                        text: `the answer is ${answer}`
                                    }
                                ] : []
                            ]
                        }
                    ],
                    response_model: {
                        name: "EvaluationResult",
                        schema: EvaluationSchema
                    }
                }
            });
            try {
                const result = response.data;
                return {
                    evaluation: result.evaluation,
                    reasoning: result.reasoning
                };
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                return {
                    evaluation: "INVALID",
                    reasoning: `Failed to get structured response: ${errorMessage}`
                };
            }
        });
    }
    batchAsk(options) {
        return __async(this, null, function*() {
            const { questions, screenshot = true, systemPrompt = "You are an expert evaluator that returns YES or NO with a concise reasoning.", screenshotDelayMs = 250 } = options;
            if (!(questions == null ? void 0 : questions.length)) throw new StagehandInvalidArgumentError("Questions array cannot be empty");
            yield new Promise((r)=>setTimeout(r, screenshotDelayMs));
            let imageBuffer;
            if (screenshot) {
                const page = yield this.v3.context.awaitActivePage();
                imageBuffer = yield page.screenshot({
                    fullPage: false
                });
            }
            const llmClient = this.getClient();
            const formatted = questions.map((item, i)=>`${i + 1}. ${item.question}${item.answer ? `
   Answer: ${item.answer}` : ""}`).join("\n\n");
            const response = yield llmClient.createChatCompletion({
                logger: this.silentLogger,
                options: {
                    messages: [
                        {
                            role: "system",
                            content: `${systemPrompt}

You will be given multiple questions${screenshot ? " with a screenshot" : ""}. ${questions.some((q)=>q.answer) ? "Some questions include answers to evaluate." : ""} Answer each question by returning an object in the specified JSON format. Return a single JSON array containing one object for each question in the order they were asked.`
                        },
                        {
                            role: "user",
                            content: [
                                {
                                    type: "text",
                                    text: formatted
                                },
                                ...screenshot && imageBuffer ? [
                                    {
                                        type: "image_url",
                                        image_url: {
                                            url: `data:image/jpeg;base64,${imageBuffer.toString("base64")}`
                                        }
                                    }
                                ] : []
                            ]
                        }
                    ],
                    response_model: {
                        name: "BatchEvaluationResult",
                        schema: BatchEvaluationSchema
                    }
                }
            });
            try {
                const results = response.data;
                return results.map((r)=>({
                        evaluation: r.evaluation,
                        reasoning: r.reasoning
                    }));
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                return questions.map(()=>({
                        evaluation: "INVALID",
                        reasoning: `Failed to get structured response: ${errorMessage}`
                    }));
            }
        });
    }
    _evaluateWithMultipleScreenshots(options) {
        return __async(this, null, function*() {
            const { question, screenshots, agentReasoning, systemPrompt = `You are an expert evaluator that confidently returns YES or NO given a question and multiple screenshots showing the progression of a task.
        ${agentReasoning ? "You also have access to the agent's detailed reasoning and thought process throughout the task." : ""}
        Analyze ALL screenshots to understand the complete journey. Look for evidence of task completion across all screenshots, not just the last one.
        Success criteria may appear at different points in the sequence (confirmation messages, intermediate states, etc).
        ${agentReasoning ? "The agent's reasoning provides crucial context about what actions were attempted, what was observed, and the decision-making process. Use this alongside the visual evidence to make a comprehensive evaluation." : ""}
        Today's date is ${/* @__PURE__ */ new Date().toLocaleDateString()}` } = options;
            if (!question) throw new StagehandInvalidArgumentError("Question cannot be an empty string");
            if (!screenshots || screenshots.length === 0) throw new StagehandInvalidArgumentError("At least one screenshot must be provided");
            const llmClient = this.getClient();
            const imageContents = screenshots.map((s)=>({
                    type: "image_url",
                    image_url: {
                        url: `data:image/jpeg;base64,${s.toString("base64")}`
                    }
                }));
            const response = yield llmClient.createChatCompletion({
                logger: this.silentLogger,
                options: {
                    messages: [
                        {
                            role: "system",
                            content: systemPrompt
                        },
                        {
                            role: "user",
                            content: [
                                {
                                    type: "text",
                                    text: agentReasoning ? `Question: ${question}

Agent's reasoning and actions throughout the task:
${agentReasoning}

I'm providing ${screenshots.length} screenshots showing the progression of the task. Please analyze both the agent's reasoning and all screenshots to determine if the task was completed successfully.` : `${question}

I'm providing ${screenshots.length} screenshots showing the progression of the task. Please analyze all of them to determine if the task was completed successfully.`
                                },
                                ...imageContents
                            ]
                        }
                    ],
                    response_model: {
                        name: "EvaluationResult",
                        schema: EvaluationSchema
                    }
                }
            });
            try {
                const result = response.data;
                return {
                    evaluation: result.evaluation,
                    reasoning: result.reasoning
                };
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                return {
                    evaluation: "INVALID",
                    reasoning: `Failed to get structured response: ${errorMessage}`
                };
            }
        });
    }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    AISdkClient,
    AVAILABLE_CUA_MODELS,
    AgentProvider,
    AgentScreenshotProviderError,
    AnnotatedScreenshotText,
    BrowserbaseSessionNotFoundError,
    CaptchaTimeoutError,
    ConnectionTimeoutError,
    ConsoleMessage,
    ContentFrameNotFoundError,
    CreateChatCompletionResponseError,
    CuaModelRequiredError,
    ElementNotVisibleError,
    ExperimentalApiConflictError,
    ExperimentalNotConfiguredError,
    HandlerNotInitializedError,
    InvalidAISDKModelFormatError,
    LLMClient,
    LLMResponseError,
    LOG_LEVEL_NAMES,
    MCPConnectionError,
    MissingEnvironmentVariableError,
    MissingLLMConfigurationError,
    PageNotFoundError,
    Response,
    ResponseBodyError,
    ResponseParseError,
    Stagehand,
    StagehandAPIError,
    StagehandAPIUnauthorizedError,
    StagehandClickError,
    StagehandDefaultError,
    StagehandDomProcessError,
    StagehandElementNotFoundError,
    StagehandEnvironmentError,
    StagehandError,
    StagehandEvalError,
    StagehandHttpError,
    StagehandIframeError,
    StagehandInitError,
    StagehandInvalidArgumentError,
    StagehandMissingArgumentError,
    StagehandNotInitializedError,
    StagehandResponseBodyError,
    StagehandResponseParseError,
    StagehandServerError,
    StagehandShadowRootMissingError,
    StagehandShadowSegmentEmptyError,
    StagehandShadowSegmentNotFoundError,
    TimeoutError,
    UnsupportedAISDKModelProviderError,
    UnsupportedModelError,
    UnsupportedModelProviderError,
    V3,
    V3Evaluator,
    V3FunctionName,
    XPathResolutionError,
    ZodSchemaValidationError,
    connectToMCPServer,
    defaultExtractSchema,
    getZodType,
    injectUrls,
    isRunningInBun,
    jsonSchemaToZod,
    loadApiKeyFromEnv,
    modelToAgentProviderMap,
    pageTextSchema,
    providerEnvVarMap,
    toGeminiSchema,
    transformSchema,
    trimTrailingTextNode,
    validateZodSchema
}); /*! Bundled license information:

lighthouse-logger/index.js:
  (**
   * @license
   * Copyright 2016 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)

chrome-launcher/dist/utils.js:
chrome-launcher/dist/flags.js:
  (**
   * @license Copyright 2017 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
   * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
   *)

chrome-launcher/dist/chrome-finder.js:
chrome-launcher/dist/random-port.js:
chrome-launcher/dist/chrome-launcher.js:
  (**
   * @license Copyright 2016 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
   * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
   *)
*/ 
}),
];

//# sourceMappingURL=node_modules_%40browserbasehq_stagehand_dist_index_05d6d43f.js.map